!_TAG_FILE_FORMAT	0	/extended format; --format=0 will not append ;" to lines/
!_TAG_FILE_SORTED	0	/0=unsorted, 0=sorted, 0=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	0.0	//
Acceptor	_	/^pub trait Acceptor<T> {$/;"	t
Acceptor	_	/^impl Acceptor<TcpStream> for TcpAcceptor {$/;"	i
Acceptor	_	/^impl Acceptor<UnixStream> for UnixAcceptor {$/;"	i
Add	_	impl Add<Foo, Foo> for Foo {$/;"	i
Add	_	/^impl Add<f0,f0> for f0 {$/;"	i
Add	_	/^impl Add<f0,f0> for f0 {$/;"	i
Add	_	/^impl Add<$T,$T> for $T {$/;"	i
Add	_	/^impl Add<$T,$T> for $T {$/;"	i
Add	_	/^pub trait Add<RHS,Result> {$/;"	t
AdditiveIterator	_	/^pub trait AdditiveIterator<A> {$/;"	t
Alignment	_	/^pub enum Alignment { AlignLeft, AlignRight, AlignUnknown }$/;"	g
AllocHeader	_	/^impl AllocHeader {$/;"	i
AllocHeader	_	/^struct AllocHeader {$/;"	s
AllocHeader	_	/^struct AllocHeader;$/;"	s
Alphabetic	_	pub fn Alphabetic(c: char) -> bool {$/;"	f
Any	_	/^pub trait Any {$/;"	t
AnyMutRefExt	_	/^pub trait AnyMutRefExt<'a> {$/;"	t
AnyOwnExt	_	/^impl AnyOwnExt for ~Any {$/;"	i
AnyOwnExt	_	/^pub trait AnyOwnExt {$/;"	t
AnyRefExt	_	/^pub trait AnyRefExt<'a> {$/;"	t
ArcData	_	/^struct ArcData<T> {$/;"	s
Argument	_	/^pub struct Argument<'a> {$/;"	s
Argument	_	/^pub struct Argument<'a> {$/;"	s
Argument	_	/^pub struct Argument<'a> {$/;"	s
Arguments	_	/^pub struct Arguments<'a> {$/;"	s
Ascii	_	/^impl Ascii {$/;"	i
Ascii	_	/^pub struct Ascii { priv chr: u0 }$/;"	s
AsciiCast	_	/^impl AsciiCast<Ascii> for char {$/;"	i
AsciiCast	_	/^impl AsciiCast<Ascii> for u0 {$/;"	i
AsciiCast	_	/^pub trait AsciiCast<T> {$/;"	t
AsciiStr	_	/^pub trait AsciiStr {$/;"	t
AtomicBool	_	/^impl AtomicBool {$/;"	i
AtomicBool	_	/^pub struct AtomicBool {$/;"	s
AtomicFlag	_	/^impl AtomicFlag {$/;"	i
AtomicFlag	_	/^pub struct AtomicFlag {$/;"	s
AtomicInt	_	/^impl AtomicInt {$/;"	i
AtomicInt	_	/^pub struct AtomicInt {$/;"	s
AtomicOption	_	/^pub struct AtomicOption<T> {$/;"	s
AtomicPtr	_	/^pub struct AtomicPtr<T> {$/;"	s
AtomicU0	_	/^impl AtomicU0 {$/;"	i
AtomicU0	_	/^pub struct AtomicU0 {$/;"	s
AtomicUint	_	/^impl AtomicUint {$/;"	i
AtomicUint	_	/^pub struct AtomicUint {$/;"	s
Bar	_	struct Bar(int, int);$/;"	s
Binary	_	/^pub trait Binary { fn fmt(&self, &mut Formatter) -> Result; }$/;"	t
Binary	_	/^struct Binary;$/;"	s
BitAnd	_	/^impl BitAnd<bool, bool> for bool {$/;"	i
BitAnd	_	/^impl BitAnd<$T,$T> for $T {$/;"	i
BitAnd	_	/^impl BitAnd<$T,$T> for $T {$/;"	i
BitAnd	_	/^pub trait BitAnd<RHS,Result> {$/;"	t
BitOr	_	/^impl BitOr<bool, bool> for bool {$/;"	i
BitOr	_	/^impl BitOr<$T,$T> for $T {$/;"	i
BitOr	_	/^impl BitOr<$T,$T> for $T {$/;"	i
BitOr	_	/^pub trait BitOr<RHS,Result> {$/;"	t
BitXor	_	/^impl BitXor<bool, bool> for bool {$/;"	i
BitXor	_	/^impl BitXor<$T,$T> for $T {$/;"	i
BitXor	_	/^impl BitXor<$T,$T> for $T {$/;"	i
BitXor	_	/^pub trait BitXor<RHS,Result> {$/;"	t
Bitwise	_	/^impl Bitwise for i0 {$/;"	i
Bitwise	_	/^impl Bitwise for i0 {$/;"	i
Bitwise	_	/^impl Bitwise for i0 {$/;"	i
Bitwise	_	/^impl Bitwise for i0 {$/;"	i
Bitwise	_	/^impl Bitwise for int {$/;"	i
Bitwise	_	/^pub trait Bitwise: Bounded$/;"	t
Bitwise	_	/^impl Bitwise for $T {$/;"	i
BlockedTask	_	/^impl BlockedTask {$/;"	i
BlockedTask	_	/^pub enum BlockedTask {$/;"	g
BlockedTasks	_	/^pub struct BlockedTasks {$/;"	s
Bool	_	/^impl Bool for bool {$/;"	i
Bool	_	/^pub trait Bool { fn fmt(&self, &mut Formatter) -> Result; }$/;"	t
Borrowed	_	/^pub struct Borrowed<T> {$/;"	s
Bounded	_	/^impl Bounded for f0 {$/;"	i
Bounded	_	/^impl Bounded for f0 {$/;"	i
Bounded	_	/^impl Bounded for $T {$/;"	i
Bounded	_	/^pub trait Bounded {$/;"	t
Bounded	_	/^impl Bounded for $T {$/;"	i
Box	_	/^pub struct Box<T> {$/;"	s
BufReader	_	/^pub struct BufReader<'a> {$/;"	s
BufWriter	_	/^pub struct BufWriter<'a> {$/;"	s
Buffer	_	/^impl Buffer for MemReader {$/;"	i
Buffer	_	/^pub trait Buffer: Reader {$/;"	t
Buffer	_	/^struct Buffer<T> {$/;"	s
BufferPool	_	/^pub struct BufferPool<T> {$/;"	s
BufferedReader	_	/^pub struct BufferedReader<R> {$/;"	s
BufferedStream	_	/^pub struct BufferedStream<S> {$/;"	s
BufferedWriter	_	/^pub struct BufferedWriter<W> {$/;"	s
ByRef	_	/^pub struct ByRef<'a, T> {$/;"	s
Bytes	_	struct Bytes<'a>(&'a [u0]);$/;"	s
Bytes	_	/^pub struct Bytes<'r, T> {$/;"	s
BytesContainer	_	/^impl BytesContainer for CString {$/;"	i
BytesContainer	_	/^impl BytesContainer for ~[u0] {$/;"	i
BytesContainer	_	/^impl BytesContainer for ~str {$/;"	i
BytesContainer	_	/^pub trait BytesContainer {$/;"	t
BytesContainer	_	/^impl BytesContainer for Path {$/;"	i
BytesContainer	_	/^impl BytesContainer for Path {$/;"	i
CChars	_	/^pub struct CChars<'a> {$/;"	s
CString	_	/^impl CString {$/;"	i
CString	_	/^pub struct CString {$/;"	s
Callback	_	/^pub trait Callback {$/;"	t
Cc	_	pub fn Cc(c: char) -> bool {$/;"	f
Cell	_	/^pub struct Cell<T> {$/;"	s
Cf	_	pub fn Cf(c: char) -> bool {$/;"	f
Chain	_	/^pub struct Chain<T, U> {$/;"	s
ChainedReader	_	/^pub struct ChainedReader<I, R> {$/;"	s
Chan	_	/^pub struct Chan<T> {$/;"	s
ChanWriter	_	/^impl ChanWriter {$/;"	i
ChanWriter	_	/^pub struct ChanWriter {$/;"	s
Char	_	/^impl Char for char {$/;"	i
Char	_	/^pub trait Char {$/;"	t
Char	_	/^impl Char for char {$/;"	i
Char	_	/^pub trait Char { fn fmt(&self, &mut Formatter) -> Result; }$/;"	t
CharEq	_	impl CharEq for NotAscii {$/;"	i
CharEq	_	/^impl CharEq for char {$/;"	i
CharEq	_	/^impl CharEq for extern "Rust" fn(char) -> bool {$/;"	i
CharEq	_	/^pub trait CharEq {$/;"	t
CharOffsets	_	/^pub struct CharOffsets<'a> {$/;"	s
CharRange	_	/^pub struct CharRange {$/;"	s
CharSplits	_	/^pub struct CharSplits<'a, Sep> {$/;"	s
CharSplitsN	_	/^pub struct CharSplitsN<'a, Sep> {$/;"	s
Chars	_	/^pub struct Chars<'r, T> {$/;"	s
Chars	_	/^pub struct Chars<'a> {$/;"	s
CheckedAdd	_	/^impl CheckedAdd for i0 {$/;"	i
CheckedAdd	_	/^impl CheckedAdd for i0 {$/;"	i
CheckedAdd	_	/^impl CheckedAdd for i0 {$/;"	i
CheckedAdd	_	/^impl CheckedAdd for i0 {$/;"	i
CheckedAdd	_	/^impl CheckedAdd for int {$/;"	i
CheckedAdd	_	/^pub trait CheckedAdd: Add<Self, Self> {$/;"	t
CheckedAdd	_	/^impl CheckedAdd for u0 {$/;"	i
CheckedAdd	_	/^impl CheckedAdd for u0 {$/;"	i
CheckedAdd	_	/^impl CheckedAdd for u0 {$/;"	i
CheckedAdd	_	/^impl CheckedAdd for u0 {$/;"	i
CheckedAdd	_	/^impl CheckedAdd for uint {$/;"	i
CheckedDiv	_	/^impl CheckedDiv for $T {$/;"	i
CheckedDiv	_	/^pub trait CheckedDiv: Div<Self, Self> {$/;"	t
CheckedDiv	_	/^impl CheckedDiv for $T {$/;"	i
CheckedMul	_	/^impl CheckedMul for i0 {$/;"	i
CheckedMul	_	/^impl CheckedMul for i0 {$/;"	i
CheckedMul	_	/^impl CheckedMul for i0 {$/;"	i
CheckedMul	_	/^impl CheckedMul for i0 {$/;"	i
CheckedMul	_	/^impl CheckedMul for int {$/;"	i
CheckedMul	_	/^pub trait CheckedMul: Mul<Self, Self> {$/;"	t
CheckedMul	_	/^impl CheckedMul for u0 {$/;"	i
CheckedMul	_	/^impl CheckedMul for u0 {$/;"	i
CheckedMul	_	/^impl CheckedMul for u0 {$/;"	i
CheckedMul	_	/^impl CheckedMul for u0 {$/;"	i
CheckedMul	_	/^impl CheckedMul for uint {$/;"	i
CheckedSub	_	/^impl CheckedSub for i0 {$/;"	i
CheckedSub	_	/^impl CheckedSub for i0 {$/;"	i
CheckedSub	_	/^impl CheckedSub for i0 {$/;"	i
CheckedSub	_	/^impl CheckedSub for i0 {$/;"	i
CheckedSub	_	/^impl CheckedSub for int {$/;"	i
CheckedSub	_	/^pub trait CheckedSub: Sub<Self, Self> {$/;"	t
CheckedSub	_	/^impl CheckedSub for u0 {$/;"	i
CheckedSub	_	/^impl CheckedSub for u0 {$/;"	i
CheckedSub	_	/^impl CheckedSub for u0 {$/;"	i
CheckedSub	_	/^impl CheckedSub for u0 {$/;"	i
CheckedSub	_	/^impl CheckedSub for uint {$/;"	i
ChiSquared	_	/^impl ChiSquared {$/;"	i
ChiSquared	_	/^pub enum ChiSquared {$/;"	g
Chunks	_	/^pub struct Chunks<'a, T> {$/;"	s
Clone	_	/^impl Clone for CString {$/;"	i
Clone	_	impl Clone for $t {$/;"	i
Clone	_	/^pub trait Clone {$/;"	t
Clone	_	/^impl Clone for SipState {$/;"	i
Clone	_	/^impl Clone for ChanWriter {$/;"	i
Clone	_	/^impl Clone for TcpStream {$/;"	i
Clone	_	/^impl Clone for UdpSocket {$/;"	i
Clone	_	/^impl Clone for UnixStream {$/;"	i
Clone	_	/^impl Clone for PipeStream {$/;"	i
Clone	_	impl Clone for Foo {$/;"	i
Clone	_	/^impl Clone for ~str {$/;"	i
Clone	_	impl Clone for S {$/;"	i
CloneableIterator	_	/^pub trait CloneableIterator {$/;"	t
CloneableVector	_	/^pub trait CloneableVector<T> {$/;"	t
CloseBehavior	_	/^pub enum CloseBehavior {$/;"	g
CloseHandle	_	pub fn CloseHandle(hObject: HANDLE) -> BOOL;$/;"	f
Closed0	_	/^pub struct Closed0<F>(F);$/;"	s
Closure	_	/^pub struct Closure {$/;"	s
Co	_	pub fn Co(c: char) -> bool {$/;"	f
CommandLineToArgvW	_	fn CommandLineToArgvW(lpCmdLine: LPCWSTR, pNumArgs: *mut c_int) -> **u0;$/;"	f
Compound	_	struct Compound {$/;"	s
ConnectNamedPipe	_	pub fn ConnectNamedPipe(hNamedPipe: HANDLE,$/;"	f
ConstRand	_	struct ConstRand(uint);$/;"	s
ConstRng	_	struct ConstRng { i: u0 }$/;"	s
ConstantRng	_	struct ConstantRng(u0);$/;"	s
Container	_	/^impl Container for CString {$/;"	i
Container	_	/^pub trait Container {$/;"	t
Container	_	/^impl Container for ~str {$/;"	i
ContravariantLifetime	_	pub struct ContravariantLifetime<'a>;$/;"	s
ContravariantType	_	pub struct ContravariantType<T>;$/;"	s
CopyFileW	_	pub fn CopyFileW(lpExistingFileName: LPCWSTR,$/;"	f
Count	_	/^pub enum Count<'a> {$/;"	g
Count	_	/^pub enum Count {$/;"	g
Counter	_	/^pub struct Counter<A> {$/;"	s
Counter	_	struct Counter {$/;"	s
CountingRng	_	struct CountingRng { i: u0 }$/;"	s
CovariantLifetime	_	pub struct CovariantLifetime<'a>;$/;"	s
CovariantType	_	pub struct CovariantType<T>;$/;"	s
CrateMap	_	/^pub struct CrateMap<'a> {$/;"	s
CreateDirectoryW	_	pub fn CreateDirectoryW(lpPathName: LPCWSTR,$/;"	f
CreateEventA	_	fn CreateEventA(lpSecurityAttributes: LPSECURITY_ATTRIBUTES,$/;"	f
CreateEventW	_	pub fn CreateEventW(lpEventAttributes: LPSECURITY_ATTRIBUTES,$/;"	f
CreateFileMappingW	_	pub fn CreateFileMappingW(hFile: HANDLE,$/;"	f
CreateFileW	_	pub fn CreateFileW(lpFileName: LPCWSTR,$/;"	f
CreateHardLinkW	_	pub fn CreateHardLinkW(lpSymlinkFileName: LPCWSTR,$/;"	f
CreateNamedPipeW	_	pub fn CreateNamedPipeW($/;"	f
CreateProcessA	_	pub fn CreateProcessA(lpApplicationName: LPCSTR,$/;"	f
CreateSymbolicLinkW	_	pub fn CreateSymbolicLinkW(lpSymlinkFileName: LPCWSTR,$/;"	f
CreateThread	_	fn CreateThread(lpThreadAttributes: LPSECURITY_ATTRIBUTES,$/;"	f
Custom	_	struct Custom {$/;"	s
Cycle	_	/^pub struct Cycle<T> {$/;"	s
Cycle	_	struct Cycle {$/;"	s
DIR	_	pub enum DIR {}$/;"	g
Death	_	/^impl Death {$/;"	i
Death	_	/^pub struct Death {$/;"	s
DeathAction	_	/^pub enum DeathAction {$/;"	g
Decimal	_	/^struct Decimal;$/;"	s
DeepClone	_	impl DeepClone for $t {$/;"	i
DeepClone	_	/^pub trait DeepClone: Clone {$/;"	t
DeepClone	_	/^impl DeepClone for ~str {$/;"	i
Default	_	/^impl Default for bool {$/;"	i
Default	_	/^impl Default for char {$/;"	i
Default	_	/^pub trait Default {$/;"	t
Default	_	/^impl Default for SipHasher {$/;"	i
Default	_	/^impl Default for SipState {$/;"	i
Default	_	/^impl Default for f0 {$/;"	i
Default	_	/^impl Default for f0 {$/;"	i
Default	_	/^impl Default for $T {$/;"	i
Default	_	/^impl Default for $T {$/;"	i
Default	_	impl Default for Counter {$/;"	i
Default	_	/^impl Default for ReseedWithDefault {$/;"	i
Default	_	/^impl Default for ~str {$/;"	i
Default	_	/^impl Default for () {$/;"	i
DefaultLogger	_	/^struct DefaultLogger {$/;"	s
DeflateWriter	_	/^pub struct DeflateWriter<W> {$/;"	s
DeleteCriticalSection	_	fn DeleteCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);$/;"	f
DeleteFileW	_	pub fn DeleteFileW(lpPathName: LPCWSTR) -> BOOL;$/;"	f
Deque	_	/^struct Deque<T> {$/;"	s
Deref	_	/^pub trait Deref<Result> {$/;"	t
DerefMut	_	/^pub trait DerefMut<Result>: Deref<Result> {$/;"	t
Direction	_	/^enum Direction { Pos, Neg }$/;"	g
Directories	_	/^pub struct Directories {$/;"	s
DisconnectNamedPipe	_	pub fn DisconnectNamedPipe(hNamedPipe: HANDLE) -> BOOL;$/;"	f
Display	_	/^pub struct Display<'a, P> {$/;"	s
Div	_	/^impl Div<f0,f0> for f0 {$/;"	i
Div	_	/^impl Div<f0,f0> for f0 {$/;"	i
Div	_	/^impl Div<$T,$T> for $T {$/;"	i
Div	_	/^impl Div<$T,$T> for $T {$/;"	i
Div	_	/^pub trait Div<RHS,Result> {$/;"	t
DoubleEndedIterator	_	/^pub trait DoubleEndedIterator<A>: Iterator<A> {$/;"	t
Drop	_	/^impl Drop for CString {$/;"	i
Drop	_	/^impl Drop for Select {$/;"	i
Drop	_	impl Drop for TempDir {$/;"	i
Drop	_	/^impl Drop for Process {$/;"	i
Drop	_	/^impl Drop for DefaultLogger {$/;"	i
Drop	_	impl Drop for HasDtor {$/;"	i
Drop	_	/^pub trait Drop {$/;"	t
Drop	_	/^impl Drop for MemoryMap {$/;"	i
Drop	_	/^impl Drop for OSRng {$/;"	i
Drop	_	/^impl Drop for LocalHeap {$/;"	i
Drop	_	/^impl Drop for MemoryRegion {$/;"	i
Drop	_	/^impl Drop for Death {$/;"	i
Drop	_	/^impl Drop for Task {$/;"	i
Drop	_	/^impl Drop for DynamicLibrary {$/;"	i
Drop	_	/^impl Drop for NativeMutex {$/;"	i
DuplicateHandle	_	pub fn DuplicateHandle(hSourceProcessHandle: HANDLE,$/;"	f
DynamicLibrary	_	/^impl DynamicLibrary {$/;"	i
DynamicLibrary	_	/^pub struct DynamicLibrary { priv handle: *u0}$/;"	s
ElementSwaps	_	/^impl ElementSwaps {$/;"	i
ElementSwaps	_	/^pub struct ElementSwaps {$/;"	s
Empty	_	impl Empty for int {}$/;"	i
Empty	_	trait Empty {}$/;"	t
EnterCriticalSection	_	fn EnterCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);$/;"	f
Enumerate	_	/^pub struct Enumerate<T> {$/;"	s
EofReader	_	struct EofReader;$/;"	s
Eq	_	/^impl Eq for bool {$/;"	i
Eq	_	/^impl Eq for CString {$/;"	i
Eq	_	/^impl Eq for char {$/;"	i
Eq	_	/^pub trait Eq {$/;"	t
Eq	_	/^impl Eq for f0 {$/;"	i
Eq	_	/^impl Eq for f0 {$/;"	i
Eq	_	/^impl Eq for $T {$/;"	i
Eq	_	/^impl Eq for $T {$/;"	i
Eq	_	/^impl Eq for Path {$/;"	i
Eq	_	/^impl Eq for Path {$/;"	i
Eq	_	impl Eq for ~str {$/;"	i
Eq	_	/^impl Eq for () {$/;"	i
Equiv	_	/^pub trait Equiv<T> {$/;"	t
ErroringLaterReader	_	struct ErroringLaterReader {$/;"	s
ErroringReader	_	struct ErroringReader;$/;"	s
EventLoop	_	/^pub trait EventLoop {$/;"	t
ExData	_	/^struct ExData<T> {$/;"	s
ExactSize	_	/^pub trait ExactSize<A> : DoubleEndedIterator<A> {$/;"	t
Exclusive	_	/^pub struct Exclusive<T> {$/;"	s
Exp	_	/^impl Exp {$/;"	i
Exp	_	/^pub struct Exp {$/;"	s
Exp0	_	/^pub struct Exp0(f0);$/;"	s
ExponentFormat	_	/^pub enum ExponentFormat {$/;"	g
Extendable	_	/^pub trait Extendable<A>: FromIterator<A> {$/;"	t
Extendable	_	/^impl Extendable<char> for ~str {$/;"	i
FILE	_	pub enum FILE {}$/;"	g
FILETIME	_	pub struct FILETIME {$/;"	s
FPCategory	_	/^pub enum FPCategory {$/;"	g
Failure	_	/^pub enum Failure<T> {$/;"	g
Failure	_	/^pub enum Failure {$/;"	g
Failure	_	/^pub enum Failure<T> {$/;"	g
File	_	/^impl File {$/;"	i
File	_	/^pub struct File {$/;"	s
FileAccess	_	/^pub enum FileAccess {$/;"	g
FileMode	_	/^pub enum FileMode {$/;"	g
FileOpenConfig	_	/^pub struct FileOpenConfig {$/;"	s
FileStat	_	/^pub struct FileStat {$/;"	s
FileType	_	/^pub enum FileType {$/;"	g
Filter	_	/^pub struct Filter<'a, A, T> {$/;"	s
FilterMap	_	/^pub struct FilterMap<'a, A, B, T> {$/;"	s
Finally	_	/^pub trait Finally<T> {$/;"	t
Finallyalizer	_	/^struct Finallyalizer<'a,A> {$/;"	s
FindClose	_	pub fn FindClose(findFile: HANDLE) -> BOOL;$/;"	f
FindFirstFileW	_	pub fn FindFirstFileW(fileName: *u0, findFileData: HANDLE)$/;"	f
FindNextFileW	_	pub fn FindNextFileW(findFile: HANDLE, findFileData: HANDLE)$/;"	f
FisherF	_	/^impl FisherF {$/;"	i
FisherF	_	/^pub struct FisherF {$/;"	s
Flag	_	/^pub enum Flag {$/;"	g
Flag	_	/^pub enum Flag {$/;"	g
FlatMap	_	/^pub struct FlatMap<'a, A, T, U> {$/;"	s
Flavor	_	/^enum Flavor<T> {$/;"	g
Float	_	impl Float for $ty {$/;"	i
Float	_	/^pub trait Float { fn fmt(&self, &mut Formatter) -> Result; }$/;"	t
Float	_	/^impl Float for f0 {$/;"	i
Float	_	/^impl Float for f0 {$/;"	i
Float	_	/^pub trait Float: Signed$/;"	t
FlushFileBuffers	_	pub fn FlushFileBuffers(hFile: HANDLE) -> BOOL;$/;"	f
Foo	_	struct Foo;$/;"	s
Foo	_	struct Foo;$/;"	s
Foo	_	struct Foo;$/;"	s
FormatMessageW	_	fn FormatMessageW(flags: DWORD,$/;"	f
FormatSpec	_	/^pub struct FormatSpec<'a> {$/;"	s
FormatSpec	_	/^pub struct FormatSpec {$/;"	s
Formatter	_	/^pub struct Formatter<'a> {$/;"	s
FreeEnvironmentStringsA	_	pub fn FreeEnvironmentStringsA(env_ptr: LPCH) -> BOOL;$/;"	f
FreeLibrary	_	fn FreeLibrary(handle: *libc::c_void);$/;"	f
Freeze	_	/^pub trait Freeze {$/;"	t
FromIterator	_	/^pub trait FromIterator<A> {$/;"	t
FromIterator	_	/^impl FromIterator<char> for ~str {$/;"	i
FromPrimitive	_	impl FromPrimitive for $T {$/;"	i
FromPrimitive	_	impl FromPrimitive for Value {$/;"	i
FromPrimitive	_	/^pub trait FromPrimitive {$/;"	t
FromStr	_	/^impl FromStr for bool {$/;"	i
FromStr	_	/^pub trait FromStr {$/;"	t
FromStr	_	/^impl FromStr for IpAddr {$/;"	i
FromStr	_	/^impl FromStr for SocketAddr {$/;"	i
FromStr	_	/^impl FromStr for f0 {$/;"	i
FromStr	_	/^impl FromStr for f0 {$/;"	i
FromStr	_	/^impl FromStr for $T {$/;"	i
FromStr	_	/^impl FromStr for $T {$/;"	i
FromStr	_	/^impl FromStr for Path {$/;"	i
FromStr	_	/^impl FromStr for Path {$/;"	i
FromStr	_	/^impl FromStr for ~str {$/;"	i
FromStrRadix	_	/^impl FromStrRadix for $T {$/;"	i
FromStrRadix	_	/^pub trait FromStrRadix {$/;"	t
FromStrRadix	_	/^impl FromStrRadix for $T {$/;"	i
Fuse	_	/^pub struct Fuse<T> {$/;"	s
GUID	_	pub struct GUID {$/;"	s
Gamma	_	/^impl Gamma {$/;"	i
Gamma	_	/^pub enum Gamma {$/;"	g
GammaLargeShape	_	/^impl GammaLargeShape {$/;"	i
GammaLargeShape	_	/^struct GammaLargeShape {$/;"	s
GammaSmallShape	_	/^impl GammaSmallShape {$/;"	i
GammaSmallShape	_	/^struct GammaSmallShape {$/;"	s
GarbageCollector	_	/^pub struct GarbageCollector;$/;"	s
Gc	_	/^pub struct Gc<T> {$/;"	s
GenericPath	_	/^pub trait GenericPath: Clone + GenericPathUnsafe {$/;"	t
GenericPath	_	/^impl GenericPath for Path {$/;"	i
GenericPath	_	/^impl GenericPath for Path {$/;"	i
GenericPathUnsafe	_	/^pub trait GenericPathUnsafe {$/;"	t
GenericPathUnsafe	_	/^impl GenericPathUnsafe for Path {$/;"	i
GenericPathUnsafe	_	/^impl GenericPathUnsafe for Path {$/;"	i
GenericRadix	_	impl GenericRadix for $T {$/;"	i
GenericRadix	_	/^impl GenericRadix for Radix {$/;"	i
GenericRadix	_	/^trait GenericRadix {$/;"	t
GetCommandLineW	_	fn GetCommandLineW() -> LPCWSTR;$/;"	f
GetCurrentDirectoryW	_	pub fn GetCurrentDirectoryW(nBufferLength: DWORD,$/;"	f
GetCurrentProcess	_	pub fn GetCurrentProcess() -> HANDLE;$/;"	f
GetCurrentProcessId	_	pub fn GetCurrentProcessId() -> DWORD;$/;"	f
GetEnvironmentStringsA	_	pub fn GetEnvironmentStringsA() -> LPCH;$/;"	f
GetEnvironmentVariableW	_	pub fn GetEnvironmentVariableW(n: LPCWSTR,$/;"	f
GetExitCodeProcess	_	pub fn GetExitCodeProcess(hProcess: HANDLE,$/;"	f
GetFinalPathNameByHandleW	_	pub fn GetFinalPathNameByHandleW(hFile: HANDLE,$/;"	f
GetLastError	_	pub fn GetLastError() -> DWORD;$/;"	f
GetLastError	_	fn GetLastError() -> DWORD;$/;"	f
GetModuleFileNameW	_	pub fn GetModuleFileNameW(hModule: HMODULE,$/;"	f
GetModuleHandleExW	_	fn GetModuleHandleExW(dwFlags: libc::DWORD, name: *u0,$/;"	f
GetOverlappedResult	_	pub fn GetOverlappedResult(hFile: HANDLE,$/;"	f
GetProcAddress	_	fn GetProcAddress(handle: *libc::c_void, name: *libc::c_char) -> *libc::c_void;$/;"	f
GetSystemInfo	_	pub fn GetSystemInfo(lpSystemInfo: LPSYSTEM_INFO);$/;"	f
GetSystemTimeAsFileTime	_	pub fn GetSystemTimeAsFileTime($/;"	f
Handle	_	/^pub struct Handle<'port, T> {$/;"	s
HasDtor	_	struct HasDtor {$/;"	s
Hash	_	impl Hash<u0> for Custom {$/;"	i
Hash	_	/^pub trait Hash<S = sip::SipState> {$/;"	t
Hash	_	/^impl Hash for Path {$/;"	i
Hash	_	/^impl Hash for Path {$/;"	i
Hasher	_	impl Hasher<MyWriter> for MyWriterHasher {$/;"	i
Hasher	_	/^pub trait Hasher<S> {$/;"	t
Hasher	_	/^impl Hasher<SipState> for SipHasher {$/;"	i
Hint	_	/^pub struct Hint {$/;"	s
ImmutableCloneableVector	_	/^pub trait ImmutableCloneableVector<T> {$/;"	t
ImmutableEqVector	_	/^pub trait ImmutableEqVector<T:Eq> {$/;"	t
ImmutableTotalOrdVector	_	/^pub trait ImmutableTotalOrdVector<T: TotalOrd> {$/;"	t
ImmutableVector	_	/^pub trait ImmutableVector<'a, T> {$/;"	t
IncomingConnections	_	/^pub struct IncomingConnections<'a, A> {$/;"	s
IndependentSample	_	/^impl IndependentSample<f0> for Exp {$/;"	i
IndependentSample	_	/^impl IndependentSample<f0> for ChiSquared {$/;"	i
IndependentSample	_	/^impl IndependentSample<f0> for FisherF {$/;"	i
IndependentSample	_	/^impl IndependentSample<f0> for Gamma {$/;"	i
IndependentSample	_	/^impl IndependentSample<f0> for GammaLargeShape {$/;"	i
IndependentSample	_	/^impl IndependentSample<f0> for GammaSmallShape {$/;"	i
IndependentSample	_	/^impl IndependentSample<f0> for StudentT {$/;"	i
IndependentSample	_	/^pub trait IndependentSample<Support>: Sample<Support> {$/;"	t
IndependentSample	_	/^impl IndependentSample<f0> for LogNormal {$/;"	i
IndependentSample	_	/^impl IndependentSample<f0> for Normal {$/;"	i
Index	_	/^pub trait Index<Index,Result> {$/;"	t
InflateReader	_	/^pub struct InflateReader<R> {$/;"	s
Info	_	/^pub struct Info {$/;"	s
InitialZeroByteReader	_	struct InitialZeroByteReader {$/;"	s
InitializeCriticalSectionAndSpinCount	_	fn InitializeCriticalSectionAndSpinCount($/;"	f
Inspect	_	/^pub struct Inspect<'a, A, T> {$/;"	s
Int	_	/^impl Int for $T {}$/;"	i
Int	_	/^pub trait Int: Primitive$/;"	t
Int	_	/^impl Int for $T {}$/;"	i
InternalBufferedWriter	_	/^struct InternalBufferedWriter<W>(BufferedWriter<W>);$/;"	s
IntoBytes	_	/^impl IntoBytes for ~[Ascii] {$/;"	i
IntoBytes	_	/^pub trait IntoBytes {$/;"	t
IntoMaybeOwned	_	/^pub trait IntoMaybeOwned<'a> {$/;"	t
IntoStr	_	/^impl IntoStr for ~[Ascii] {$/;"	i
IntoStr	_	/^pub trait IntoStr {$/;"	t
InvariantLifetime	_	pub struct InvariantLifetime<'a>;$/;"	s
InvariantType	_	pub struct InvariantType<T>;$/;"	s
IoError	_	/^pub struct IoError {$/;"	s
IoErrorKind	_	/^pub enum IoErrorKind {$/;"	g
IoFactory	_	/^pub trait IoFactory {$/;"	t
IpAddr	_	/^pub enum IpAddr {$/;"	g
Isaac0Rng	_	/^impl Isaac0Rng {$/;"	i
Isaac0Rng	_	/^pub struct Isaac0Rng {$/;"	s
IsaacRng	_	/^impl IsaacRng {$/;"	i
IsaacRng	_	/^pub struct IsaacRng {$/;"	s
Item	_	/^pub struct Item<A> {$/;"	s
Items	_	/^pub struct Items<'a, T> {$/;"	s
Iterator	_	/^impl Iterator<*mut Handle<'static, ()>> for Packets {$/;"	i
Iterator	_	/^impl Iterator<Path> for Directories {$/;"	i
Iterator	_	/^pub trait Iterator<A> {$/;"	t
Iterator	_	/^impl Iterator<BlockedTask> for BlockedTasks {$/;"	i
Iterator	_	/^impl Iterator<(uint, uint)> for ElementSwaps {$/;"	i
Juju	_	struct Juju;$/;"	s
KeyValue	_	/^pub enum KeyValue<T> { Key }$/;"	g
LeaveCriticalSection	_	fn LeaveCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);$/;"	f
LimitReader	_	/^pub struct LimitReader<R> {$/;"	s
LineBufferedWriter	_	/^pub struct LineBufferedWriter<W> {$/;"	s
Lines	_	/^pub struct Lines<'r, T> {$/;"	s
List	_	struct List {$/;"	s
Listener	_	/^pub trait Listener<T, A: Acceptor<T>> {$/;"	t
Listener	_	/^impl Listener<TcpStream, TcpAcceptor> for TcpListener {$/;"	i
Listener	_	/^impl Listener<UnixStream, UnixAcceptor> for UnixListener {$/;"	i
Listener	_	/^impl Listener {$/;"	i
Listener	_	/^pub struct Listener {$/;"	s
Ll	_	pub fn Ll(c: char) -> bool {$/;"	f
Lm	_	pub fn Lm(c: char) -> bool {$/;"	f
Lo	_	pub fn Lo(c: char) -> bool {$/;"	f
LoadLibraryW	_	fn LoadLibraryW(name: *libc::c_void) -> *libc::c_void;$/;"	f
LoanState	_	/^enum LoanState {$/;"	g
LoanState	_	/^impl LoanState {$/;"	i
Local	_	/^impl Local<local_ptr::Borrowed<Task>> for Task {$/;"	i
Local	_	/^pub trait Local<Borrowed> {$/;"	t
LocalData	_	/^trait LocalData {}$/;"	t
LocalFree	_	fn LocalFree(ptr: *c_void);$/;"	f
LocalHeap	_	/^impl LocalHeap {$/;"	i
LocalHeap	_	/^pub struct LocalHeap {$/;"	s
LocalIo	_	/^pub struct LocalIo<'a> {$/;"	s
LocalStorage	_	/^pub struct LocalStorage(Option<local_data::Map>);$/;"	s
LockGuard	_	/^pub struct LockGuard<'a> {$/;"	s
LogDirective	_	/^struct LogDirective<'a> {$/;"	s
LogNormal	_	/^impl LogNormal {$/;"	i
LogNormal	_	/^pub struct LogNormal {$/;"	s
Logger	_	/^impl Logger for DefaultLogger {$/;"	i
Logger	_	/^pub trait Logger {$/;"	t
LowerExp	_	impl LowerExp for $ty {$/;"	i
LowerExp	_	/^pub trait LowerExp { fn fmt(&self, &mut Formatter) -> Result; }$/;"	t
LowerHex	_	/^pub trait LowerHex { fn fmt(&self, &mut Formatter) -> Result; }$/;"	t
LowerHex	_	/^struct LowerHex;$/;"	s
Lowercase	_	pub fn Lowercase(c: char) -> bool {$/;"	f
Lt	_	pub fn Lt(c: char) -> bool {$/;"	f
Lu	_	pub fn Lu(c: char) -> bool {$/;"	f
MEMORY_BASIC_INFORMATION	_	pub struct MEMORY_BASIC_INFORMATION {$/;"	s
Managed	_	pub struct Managed;$/;"	s
Map	_	/^pub trait Map<K, V>: Container {$/;"	t
Map	_	/^pub struct Map<'a, A, B, T> {$/;"	s
MapError	_	/^pub enum MapError {$/;"	g
MapOption	_	/^pub enum MapOption {$/;"	g
MapViewOfFile	_	pub fn MapViewOfFile(hFileMappingObject: HANDLE,$/;"	f
MatchIndices	_	/^pub struct MatchIndices<'a> {$/;"	s
MaybeOwned	_	/^pub enum MaybeOwned<'a> {$/;"	g
Mc	_	pub fn Mc(c: char) -> bool {$/;"	f
Me	_	pub fn Me(c: char) -> bool {$/;"	f
MemReader	_	/^impl MemReader {$/;"	i
MemReader	_	/^pub struct MemReader {$/;"	s
MemWriter	_	/^impl MemWriter {$/;"	i
MemWriter	_	/^pub struct MemWriter {$/;"	s
MemoryMap	_	/^impl MemoryMap {$/;"	i
MemoryMap	_	/^pub struct MemoryMap {$/;"	s
MemoryMapKind	_	/^pub enum MemoryMapKind {$/;"	g
MemoryRegion	_	/^impl MemoryRegion {$/;"	i
MemoryRegion	_	/^pub struct MemoryRegion {$/;"	s
Message	_	/^enum Message<T> {$/;"	g
Messages	_	/^pub struct Messages<'a, T> {$/;"	s
Method	_	/^pub enum Method<'a> {$/;"	g
Method	_	/^pub enum Method<'a> {$/;"	g
MinMaxResult	_	/^pub enum MinMaxResult<T> {$/;"	g
Mn	_	pub fn Mn(c: char) -> bool {$/;"	f
ModEntry	_	/^pub struct ModEntry<'a> {$/;"	s
MoveFileExW	_	pub fn MoveFileExW(lpExistingFileName: LPCWSTR,$/;"	f
MoveItems	_	/^pub struct MoveItems<T> {$/;"	s
MoveItems	_	/^pub struct MoveItems<T> {$/;"	s
MovePtr	_	/^pub trait MovePtr {$/;"	t
MovePtrAdaptor	_	/^pub fn MovePtrAdaptor<V:TyVisitor + MovePtr>(v: V) -> MovePtrAdaptor<V> {$/;"	f
MovePtrAdaptor	_	/^pub struct MovePtrAdaptor<V> {$/;"	s
Mul	_	impl Mul<Foo, Foo> for Foo {$/;"	i
Mul	_	/^impl Mul<f0,f0> for f0 {$/;"	i
Mul	_	/^impl Mul<f0,f0> for f0 {$/;"	i
Mul	_	/^impl Mul<$T,$T> for $T {$/;"	i
Mul	_	/^impl Mul<$T,$T> for $T {$/;"	i
Mul	_	/^pub trait Mul<RHS,Result> {$/;"	t
MultiWriter	_	/^impl MultiWriter {$/;"	i
MultiWriter	_	/^pub struct MultiWriter {$/;"	s
MultiplicativeIterator	_	/^pub trait MultiplicativeIterator<A> {$/;"	t
MutChunks	_	/^pub struct MutChunks<'a, T> {$/;"	s
MutItems	_	/^pub struct MutItems<'a, T> {$/;"	s
MutSplits	_	/^pub struct MutSplits<'a, T> {$/;"	s
Mutable	_	/^pub trait Mutable: Container {$/;"	t
Mutable	_	/^impl Mutable for ~str {$/;"	i
MutableByteVector	_	pub trait MutableByteVector {$/;"	t
MutableCloneableVector	_	/^pub trait MutableCloneableVector<T> {$/;"	t
MutableDoubleEndedIterator	_	/^pub trait MutableDoubleEndedIterator {$/;"	t
MutableMap	_	/^pub trait MutableMap<K, V>: Map<K, V> + Mutable {$/;"	t
MutableSet	_	/^pub trait MutableSet<T>: Set<T> + Mutable {$/;"	t
MutableTotalOrdVector	_	/^pub trait MutableTotalOrdVector<T> {$/;"	t
MutableVector	_	/^pub trait MutableVector<'a, T> {$/;"	t
Mutex	_	impl Mutex {$/;"	i
Mutex	_	pub struct Mutex {$/;"	s
MyUpgrade	_	/^enum MyUpgrade<T> {$/;"	g
MyWriter	_	struct MyWriter {$/;"	s
MyWriterHasher	_	struct MyWriterHasher;$/;"	s
NativeMutex	_	/^impl NativeMutex {$/;"	i
NativeMutex	_	/^pub struct NativeMutex {$/;"	s
Nd	_	pub fn Nd(c: char) -> bool {$/;"	f
Neg	_	/^impl Neg<f0> for f0 {$/;"	i
Neg	_	/^impl Neg<f0> for f0 {$/;"	i
Neg	_	/^impl Neg<$T> for $T {$/;"	i
Neg	_	/^impl Neg<$T> for $T {$/;"	i
Neg	_	/^pub trait Neg<Result> {$/;"	t
Nl	_	pub fn Nl(c: char) -> bool {$/;"	f
No	_	pub fn No(c: char) -> bool {$/;"	f
NoFreeze	_	pub struct NoFreeze;$/;"	s
NoPod	_	pub struct NoPod;$/;"	s
NoSend	_	pub struct NoSend;$/;"	s
Node	_	/^struct Node<T> {$/;"	s
Node	_	/^struct Node<T> {$/;"	s
Node	_	/^struct Node<T> {$/;"	s
Normal	_	/^impl Normal {$/;"	i
Normal	_	/^pub struct Normal {$/;"	s
NormalizationForm	_	/^enum NormalizationForm {$/;"	g
Normalizations	_	/^pub struct Normalizations<'a> {$/;"	s
Not	_	/^impl Not<bool> for bool {$/;"	i
Not	_	/^impl Not<$T> for $T {$/;"	i
Not	_	/^impl Not<$T> for $T {$/;"	i
Not	_	/^pub trait Not<Result> {$/;"	t
NotAscii	_	struct NotAscii(char);$/;"	s
NullReader	_	/^pub struct NullReader;$/;"	s
NullStream	_	pub struct NullStream;$/;"	s
NullWriter	_	/^pub struct NullWriter;$/;"	s
Num	_	/^impl Num for f0 {}$/;"	i
Num	_	/^impl Num for f0 {}$/;"	i
Num	_	/^impl Num for $T {}$/;"	i
Num	_	/^pub trait Num: Eq + Zero + One$/;"	t
Num	_	/^impl Num for $T {}$/;"	i
NumCast	_	impl NumCast for $T {$/;"	i
NumCast	_	/^pub trait NumCast: ToPrimitive {$/;"	t
NumStrConv	_	impl NumStrConv for $t {$/;"	i
NumStrConv	_	/^pub trait NumStrConv {$/;"	t
OSRng	_	/^impl OSRng {$/;"	i
OSRng	_	/^pub struct OSRng {$/;"	s
OVERLAPPED	_	pub struct OVERLAPPED {$/;"	s
Octal	_	/^pub trait Octal { fn fmt(&self, &mut Formatter) -> Result; }$/;"	t
Octal	_	/^struct Octal;$/;"	s
One	_	/^impl One for f0 {$/;"	i
One	_	/^impl One for f0 {$/;"	i
One	_	/^impl One for $T {$/;"	i
One	_	/^pub trait One: Mul<Self, Self> {$/;"	t
One	_	/^impl One for $T {$/;"	i
Opaque	_	/^pub enum Opaque { }$/;"	g
Open0	_	/^pub struct Open0<F>(F);$/;"	s
OpenProcess	_	pub fn OpenProcess(dwDesiredAccess: DWORD,$/;"	f
Option	_	/^pub enum Option<T> {$/;"	g
Ord	_	/^impl Ord for bool {$/;"	i
Ord	_	/^impl Ord for char {$/;"	i
Ord	_	/^impl Ord for Ordering {$/;"	i
Ord	_	/^pub trait Ord {$/;"	t
Ord	_	impl Ord for Foo {$/;"	i
Ord	_	/^impl Ord for f0 {$/;"	i
Ord	_	/^impl Ord for f0 {$/;"	i
Ord	_	/^impl Ord for $T {$/;"	i
Ord	_	/^impl Ord for $T {$/;"	i
Ord	_	impl Ord for ~str {$/;"	i
Ord	_	/^impl Ord for () {$/;"	i
OrdIterator	_	/^pub trait OrdIterator<A> {$/;"	t
Ordering	_	/^pub enum Ordering { Less = -0, Equal = 0, Greater = 0 }$/;"	g
Ordering	_	/^pub enum Ordering {$/;"	g
OwnedAsciiCast	_	/^impl OwnedAsciiCast for ~[u0] {$/;"	i
OwnedAsciiCast	_	/^impl OwnedAsciiCast for ~str {$/;"	i
OwnedAsciiCast	_	/^pub trait OwnedAsciiCast {$/;"	t
OwnedCloneableVector	_	/^pub trait OwnedCloneableVector<T:Clone> {$/;"	t
OwnedEqVector	_	/^pub trait OwnedEqVector<T:Eq> {$/;"	t
OwnedStr	_	/^impl OwnedStr for ~str {$/;"	i
OwnedStr	_	/^pub trait OwnedStr {$/;"	t
OwnedStrAsciiExt	_	/^impl OwnedStrAsciiExt for ~str {$/;"	i
OwnedStrAsciiExt	_	/^pub trait OwnedStrAsciiExt {$/;"	t
OwnedVector	_	/^pub trait OwnedVector<T> {$/;"	t
P	_	/^struct P {a: int, b: f0}$/;"	s
PROCESS_INFORMATION	_	pub struct PROCESS_INFORMATION {$/;"	s
Packet	_	/^pub struct Packet<T> {$/;"	s
Packet	_	/^pub trait Packet {$/;"	t
Packet	_	/^pub struct Packet<T> {$/;"	s
Packet	_	/^pub struct Packet<T> {$/;"	s
Packets	_	/^struct Packets { cur: *mut Handle<'static, ()> }$/;"	s
Pair	_	struct Pair {$/;"	s
Parser	_	/^pub struct Parser<'a> {$/;"	s
Parser	_	/^struct Parser<'a> {$/;"	s
PartialReader	_	struct PartialReader {$/;"	s
Path	_	/^impl Path {$/;"	i
Path	_	/^pub struct Path {$/;"	s
Path	_	/^impl Path {$/;"	i
Path	_	/^pub struct Path {$/;"	s
PathPrefix	_	/^pub enum PathPrefix {$/;"	g
PausableIdleCallback	_	/^pub trait PausableIdleCallback {$/;"	t
Pc	_	pub fn Pc(c: char) -> bool {$/;"	f
Pd	_	pub fn Pd(c: char) -> bool {$/;"	f
Pe	_	pub fn Pe(c: char) -> bool {$/;"	f
Peekable	_	/^pub struct Peekable<A, T> {$/;"	s
Permutations	_	/^pub struct Permutations<T> {$/;"	s
Pf	_	pub fn Pf(c: char) -> bool {$/;"	f
Pi	_	pub fn Pi(c: char) -> bool {$/;"	f
Piece	_	/^pub enum Piece<'a> {$/;"	g
Piece	_	/^pub enum Piece<'a> {$/;"	g
Pipe	_	/^pub struct Pipe {$/;"	s
PipeStream	_	/^impl PipeStream {$/;"	i
PipeStream	_	/^pub struct PipeStream {$/;"	s
PluralArm	_	/^pub struct PluralArm<'a> {$/;"	s
PluralArm	_	/^pub struct PluralArm<'a> {$/;"	s
PluralKeyword	_	/^pub enum PluralKeyword {$/;"	g
PluralSelector	_	/^pub enum PluralSelector {$/;"	g
PluralSelector	_	/^pub enum PluralSelector {$/;"	g
Po	_	pub fn Po(c: char) -> bool {$/;"	f
Pod	_	/^pub trait Pod {$/;"	t
Pointer	_	/^pub trait Pointer { fn fmt(&self, &mut Formatter) -> Result; }$/;"	t
Poly	_	/^pub trait Poly { fn fmt(&self, &mut Formatter) -> Result; }$/;"	t
PopResult	_	/^pub enum PopResult<T> {$/;"	g
Port	_	/^pub struct Port<T> {$/;"	s
PortReader	_	/^impl PortReader {$/;"	i
PortReader	_	/^pub struct PortReader {$/;"	s
Position	_	/^pub enum Position<'a> {$/;"	g
Position	_	/^pub enum Position {$/;"	g
Primitive	_	/^impl Primitive for f0 {}$/;"	i
Primitive	_	/^impl Primitive for f0 {}$/;"	i
Primitive	_	/^impl Primitive for $T {}$/;"	i
Primitive	_	/^pub trait Primitive: Pod$/;"	t
Primitive	_	/^impl Primitive for $T {}$/;"	i
Procedure	_	/^pub struct Procedure {$/;"	s
Process	_	/^impl Process {$/;"	i
Process	_	/^pub struct Process {$/;"	s
ProcessConfig	_	/^pub struct ProcessConfig<'a> {$/;"	s
ProcessExit	_	/^impl ProcessExit {$/;"	i
ProcessExit	_	/^pub enum ProcessExit {$/;"	g
ProcessOutput	_	/^pub struct ProcessOutput {$/;"	s
Protocol	_	/^pub enum Protocol {$/;"	g
Ps	_	pub fn Ps(c: char) -> bool {$/;"	f
QueryPerformanceCounter	_	pub fn QueryPerformanceCounter($/;"	f
QueryPerformanceFrequency	_	pub fn QueryPerformanceFrequency($/;"	f
Queue	_	/^pub struct Queue<T> {$/;"	s
Queue	_	/^pub struct Queue<T> {$/;"	s
Queue	_	/^pub struct Queue<T> {$/;"	s
R	_	fn R(i: Rc<RefCell<int>>) -> R {$/;"	f
R	_	struct R {$/;"	s
RTLD	_	pub enum RTLD {$/;"	g
Radix	_	/^impl Radix {$/;"	i
Radix	_	/^pub struct Radix {$/;"	s
RadixFmt	_	/^pub struct RadixFmt<T, R>(T, R);$/;"	s
Rand	_	/^impl Rand for Exp0 {$/;"	i
Rand	_	impl Rand for ConstRand {$/;"	i
Rand	_	/^impl Rand for StandardNormal {$/;"	i
Rand	_	/^pub trait Rand {$/;"	t
Rand	_	impl Rand for $ty {$/;"	i
Rand	_	impl Rand for Closed0<$ty> {$/;"	i
Rand	_	impl Rand for Open0<$ty> {$/;"	i
Rand	_	/^impl Rand for () {$/;"	i
Rand	_	/^impl Rand for bool {$/;"	i
Rand	_	/^impl Rand for char {$/;"	i
Rand	_	/^impl Rand for i0 {$/;"	i
Rand	_	/^impl Rand for i0 {$/;"	i
Rand	_	/^impl Rand for i0 {$/;"	i
Rand	_	/^impl Rand for i0 {$/;"	i
Rand	_	/^impl Rand for int {$/;"	i
Rand	_	/^impl Rand for u0 {$/;"	i
Rand	_	/^impl Rand for u0 {$/;"	i
Rand	_	/^impl Rand for u0 {$/;"	i
Rand	_	/^impl Rand for u0 {$/;"	i
Rand	_	/^impl Rand for uint {$/;"	i
RandSample	_	/^pub struct RandSample<Sup>;$/;"	s
RandomAccessIterator	_	/^pub trait RandomAccessIterator<A>: Iterator<A> {$/;"	t
Range	_	/^pub struct Range<A> {$/;"	s
Range	_	/^pub struct Range<X> {$/;"	s
RangeInclusive	_	/^pub struct RangeInclusive<A> {$/;"	s
RangeStep	_	/^pub struct RangeStep<A> {$/;"	s
RangeStepInclusive	_	/^pub struct RangeStepInclusive<A> {$/;"	s
RawPtr	_	/^pub trait RawPtr<T> {$/;"	t
Rc	_	/^pub struct Rc<T> {$/;"	s
RcBox	_	/^struct RcBox<T> {$/;"	s
ReadFile	_	pub fn ReadFile(hFile: HANDLE,$/;"	f
Reader	_	impl Reader for NullStream {$/;"	i
Reader	_	impl Reader for ShortReader {$/;"	i
Reader	_	/^impl Reader for PortReader {$/;"	i
Reader	_	impl Reader for EofReader {$/;"	i
Reader	_	impl Reader for ErroringLaterReader {$/;"	i
Reader	_	impl Reader for ErroringReader {$/;"	i
Reader	_	impl Reader for InitialZeroByteReader {$/;"	i
Reader	_	impl Reader for PartialReader {$/;"	i
Reader	_	impl Reader for ThreeChunkReader {$/;"	i
Reader	_	/^impl Reader for File {$/;"	i
Reader	_	/^impl Reader for MemReader {$/;"	i
Reader	_	/^impl Reader for ~Reader {$/;"	i
Reader	_	/^pub trait Reader {$/;"	t
Reader	_	/^impl Reader for TcpStream {$/;"	i
Reader	_	/^impl Reader for UdpStream {$/;"	i
Reader	_	/^impl Reader for UnixStream {$/;"	i
Reader	_	/^impl Reader for PipeStream {$/;"	i
Reader	_	/^impl Reader for StdReader {$/;"	i
Reader	_	/^impl Reader for NullReader {$/;"	i
Reader	_	/^impl Reader for ZeroReader {$/;"	i
ReaderRng	_	/^pub struct ReaderRng<R> {$/;"	s
Ref	_	/^pub struct Ref<'b, T> {$/;"	s
RefCell	_	/^pub struct RefCell<T> {$/;"	s
RefMut	_	/^pub struct RefMut<'b, T> {$/;"	s
RefReader	_	/^pub struct RefReader<'a, R> {$/;"	s
RefWriter	_	/^pub struct RefWriter<'a, W> {$/;"	s
Rem	_	/^impl Rem<f0,f0> for f0 {$/;"	i
Rem	_	/^impl Rem<f0,f0> for f0 {$/;"	i
Rem	_	/^impl Rem<$T,$T> for $T {$/;"	i
Rem	_	/^impl Rem<$T,$T> for $T {$/;"	i
Rem	_	/^pub trait Rem<RHS,Result> {$/;"	t
RemoteCallback	_	/^pub trait RemoteCallback {$/;"	t
RemoveDirectoryW	_	pub fn RemoveDirectoryW(lpPathName: LPCWSTR) -> BOOL;$/;"	f
Repeat	_	/^pub struct Repeat<A> {$/;"	s
Repr	_	/^impl Repr<*String> for ~str {}$/;"	i
Repr	_	/^pub trait Repr<T> {$/;"	t
Repr	_	/^impl Repr for () {$/;"	i
Repr	_	/^impl Repr for bool {$/;"	i
Repr	_	/^impl Repr for int {$/;"	i
Repr	_	/^trait Repr {$/;"	t
ReprVisitor	_	/^pub fn ReprVisitor<'a>(ptr: *u0,$/;"	f
ReprVisitor	_	/^pub struct ReprVisitor<'a> {$/;"	s
ReseedWithDefault	_	/^pub struct ReseedWithDefault;$/;"	s
Reseeder	_	/^pub trait Reseeder<R> {$/;"	t
ReseedingRng	_	/^pub struct ReseedingRng<R, Rsdr> {$/;"	s
Result	_	/^pub enum Result<T, E> {$/;"	g
Rev	_	/^pub struct Rev<T> {$/;"	s
RevSplits	_	/^pub struct RevSplits<'a, T> {$/;"	s
Rng	_	impl Rng for CountingRng {$/;"	i
Rng	_	/^impl Rng for Isaac0Rng {$/;"	i
Rng	_	/^impl Rng for IsaacRng {$/;"	i
Rng	_	impl Rng for ConstRng {$/;"	i
Rng	_	/^impl Rng for StdRng {$/;"	i
Rng	_	/^impl Rng for TaskRng {$/;"	i
Rng	_	/^impl Rng for XorShiftRng {$/;"	i
Rng	_	/^pub trait Rng {$/;"	t
Rng	_	/^impl Rng for OSRng {$/;"	i
Rng	_	impl Rng for ConstantRng {$/;"	i
Rng	_	impl Rng for Counter {$/;"	i
Round	_	/^impl Round for f0 {$/;"	i
Round	_	/^impl Round for f0 {$/;"	i
Round	_	/^pub trait Round {$/;"	t
RtioFileStream	_	/^pub trait RtioFileStream {$/;"	t
RtioPipe	_	/^pub trait RtioPipe {$/;"	t
RtioProcess	_	/^pub trait RtioProcess {$/;"	t
RtioSignal	_	/^pub trait RtioSignal {}$/;"	t
RtioSocket	_	/^pub trait RtioSocket {$/;"	t
RtioTTY	_	/^pub trait RtioTTY {$/;"	t
RtioTcpAcceptor	_	/^pub trait RtioTcpAcceptor : RtioSocket {$/;"	t
RtioTcpListener	_	/^pub trait RtioTcpListener : RtioSocket {$/;"	t
RtioTcpStream	_	/^pub trait RtioTcpStream : RtioSocket {$/;"	t
RtioTimer	_	/^pub trait RtioTimer {$/;"	t
RtioUdpSocket	_	/^pub trait RtioUdpSocket : RtioSocket {$/;"	t
RtioUnixAcceptor	_	/^pub trait RtioUnixAcceptor {$/;"	t
RtioUnixListener	_	/^pub trait RtioUnixListener {$/;"	t
Runtime	_	/^pub trait Runtime {$/;"	t
S	_	struct S;$/;"	s
S	_	struct S {$/;"	s
STARTUPINFO	_	pub struct STARTUPINFO {$/;"	s
SYSTEM_INFO	_	impl SYSTEM_INFO {$/;"	i
SYSTEM_INFO	_	pub struct SYSTEM_INFO {$/;"	s
Sample	_	/^impl Sample<f0> for Exp {$/;"	i
Sample	_	/^impl Sample<f0> for ChiSquared {$/;"	i
Sample	_	/^impl Sample<f0> for FisherF {$/;"	i
Sample	_	/^impl Sample<f0> for Gamma {$/;"	i
Sample	_	/^impl Sample<f0> for GammaLargeShape {$/;"	i
Sample	_	/^impl Sample<f0> for GammaSmallShape {$/;"	i
Sample	_	/^impl Sample<f0> for StudentT {$/;"	i
Sample	_	/^pub trait Sample<Support> {$/;"	t
Sample	_	/^impl Sample<f0> for LogNormal {$/;"	i
Sample	_	/^impl Sample<f0> for Normal {$/;"	i
SampleRange	_	impl SampleRange for $ty {$/;"	i
SampleRange	_	/^pub trait SampleRange {$/;"	t
Saturating	_	/^pub trait Saturating {$/;"	t
Sc	_	pub fn Sc(c: char) -> bool {$/;"	f
Scan	_	/^pub struct Scan<'a, A, B, T, St> {$/;"	s
SeedableRng	_	/^impl SeedableRng<[u0, .. 0]> for XorShiftRng {$/;"	i
SeedableRng	_	/^pub trait SeedableRng<Seed>: Rng {$/;"	t
SeedableRng	_	impl SeedableRng<u0> for Counter {$/;"	i
Seek	_	/^impl Seek for File {$/;"	i
Seek	_	/^impl Seek for MemReader {$/;"	i
Seek	_	/^impl Seek for MemWriter {$/;"	i
Seek	_	/^pub trait Seek {$/;"	t
SeekStyle	_	/^pub enum SeekStyle {$/;"	g
Select	_	/^impl Select {$/;"	i
Select	_	/^pub struct Select {$/;"	s
SelectArm	_	/^pub struct SelectArm<'a> {$/;"	s
SelectArm	_	/^pub struct SelectArm<'a> {$/;"	s
SelectionResult	_	/^pub enum SelectionResult<T> {$/;"	g
SelectionResult	_	/^pub enum SelectionResult<T> {$/;"	g
Send	_	/^pub trait Send {$/;"	t
Set	_	/^pub trait Set<T>: Container {$/;"	t
SetCurrentDirectoryW	_	pub fn SetCurrentDirectoryW(lpPathName: LPCWSTR) -> BOOL;$/;"	f
SetEndOfFile	_	pub fn SetEndOfFile(hFile: HANDLE) -> BOOL;$/;"	f
SetEnvironmentVariableW	_	pub fn SetEnvironmentVariableW(n: LPCWSTR, v: LPCWSTR)$/;"	f
SetEvent	_	fn SetEvent(hEvent: HANDLE) -> BOOL;$/;"	f
SetFilePointerEx	_	pub fn SetFilePointerEx(hFile: HANDLE,$/;"	f
SetLastError	_	fn SetLastError(error: libc::size_t);$/;"	f
SetNamedPipeHandleState	_	pub fn SetNamedPipeHandleState(hNamedPipe: HANDLE,$/;"	f
Shl	_	/^impl Shl<$T,$T> for $T {$/;"	i
Shl	_	/^impl Shl<$T,$T> for $T {$/;"	i
Shl	_	/^pub trait Shl<RHS,Result> {$/;"	t
ShortReader	_	pub struct ShortReader {$/;"	s
Show	_	/^pub trait Show { fn fmt(&self, &mut Formatter) -> Result; }$/;"	t
Shr	_	/^impl Shr<$T,$T> for $T {$/;"	i
Shr	_	/^impl Shr<$T,$T> for $T {$/;"	i
Shr	_	/^pub trait Shr<RHS,Result> {$/;"	t
SignFormat	_	/^pub enum SignFormat {$/;"	g
Signed	_	/^pub trait Signed { fn fmt(&self, &mut Formatter) -> Result; }$/;"	t
Signed	_	/^impl Signed for f0 {$/;"	i
Signed	_	/^impl Signed for f0 {$/;"	i
Signed	_	/^impl Signed for $T {$/;"	i
Signed	_	/^pub trait Signed: Num$/;"	t
SignificantDigits	_	/^pub enum SignificantDigits {$/;"	g
Signum	_	/^pub enum Signum {$/;"	g
SipHasher	_	/^impl SipHasher {$/;"	i
SipHasher	_	/^pub struct SipHasher {$/;"	s
SipState	_	/^impl SipState {$/;"	i
SipState	_	/^pub struct SipState {$/;"	s
SizeDirection	_	/^struct SizeDirection {$/;"	s
Sized	_	/^pub trait Sized {$/;"	t
Sk	_	pub fn Sk(c: char) -> bool {$/;"	f
Skip	_	/^pub struct Skip<T> {$/;"	s
SkipWhile	_	/^pub struct SkipWhile<'a, A, T> {$/;"	s
Slice	_	/^pub struct Slice<T> {$/;"	s
Sm	_	pub fn Sm(c: char) -> bool {$/;"	f
So	_	pub fn So(c: char) -> bool {$/;"	f
SocketAddr	_	/^pub struct SocketAddr {$/;"	s
SocketType	_	/^pub enum SocketType {$/;"	g
Splits	_	/^pub struct Splits<'a, T> {$/;"	s
StandardNormal	_	/^pub struct StandardNormal(f0);$/;"	s
State	_	struct State<'a> {$/;"	s
State	_	/^struct State<T> {$/;"	s
StaticNativeMutex	_	/^impl StaticNativeMutex {$/;"	i
StaticNativeMutex	_	/^pub struct StaticNativeMutex {$/;"	s
StdReader	_	/^pub struct StdReader {$/;"	s
StdRng	_	/^impl StdRng {$/;"	i
StdRng	_	/^pub struct StdRng { priv rng: Isaac0Rng }$/;"	s
StdRng	_	/^pub struct StdRng { priv rng: IsaacRng }$/;"	s
StdSource	_	/^enum StdSource {$/;"	g
StdWriter	_	/^impl StdWriter {$/;"	i
StdWriter	_	/^pub struct StdWriter {$/;"	s
Stderr	_	struct Stderr;$/;"	s
StdioContainer	_	/^pub enum StdioContainer {$/;"	g
Stdout	_	struct Stdout;$/;"	s
Stealer	_	/^pub struct Stealer<T> {$/;"	s
Stolen	_	/^pub enum Stolen<T> {$/;"	g
Str	_	/^pub trait Str {$/;"	t
StrAsciiExt	_	/^pub trait StrAsciiExt {$/;"	t
StrSlice	_	/^pub trait StrSlice<'a> {$/;"	t
StrSplits	_	/^pub struct StrSplits<'a> {$/;"	s
StrVector	_	/^pub trait StrVector {$/;"	t
Stream	_	/^pub trait Stream: Reader + Writer { }$/;"	t
String	_	/^pub trait String { fn fmt(&self, &mut Formatter) -> Result; }$/;"	t
Struct	_	struct Struct {$/;"	s
StudentT	_	/^impl StudentT {$/;"	i
StudentT	_	/^pub struct StudentT {$/;"	s
Sub	_	/^impl Sub<f0,f0> for f0 {$/;"	i
Sub	_	/^impl Sub<f0,f0> for f0 {$/;"	i
Sub	_	/^impl Sub<$T,$T> for $T {$/;"	i
Sub	_	/^impl Sub<$T,$T> for $T {$/;"	i
Sub	_	/^pub trait Sub<RHS,Result> {$/;"	t
SwitchToThread	_	fn SwitchToThread() -> BOOL;$/;"	f
Take	_	/^pub struct Take<T> {$/;"	s
TakeWhile	_	/^pub struct TakeWhile<'a, A, T> {$/;"	s
Task	_	/^impl Task {$/;"	i
Task	_	/^pub struct Task {$/;"	s
TaskBuilder	_	/^impl TaskBuilder {$/;"	i
TaskBuilder	_	/^pub struct TaskBuilder {$/;"	s
TaskOpts	_	/^impl TaskOpts {$/;"	i
TaskOpts	_	/^pub struct TaskOpts {$/;"	s
TaskRng	_	/^pub struct TaskRng {$/;"	s
TaskRngReseeder	_	/^struct TaskRngReseeder;$/;"	s
TcpAcceptor	_	/^pub struct TcpAcceptor {$/;"	s
TcpListener	_	/^impl TcpListener {$/;"	i
TcpListener	_	/^pub struct TcpListener {$/;"	s
TcpStream	_	/^impl TcpStream {$/;"	i
TcpStream	_	/^pub struct TcpStream {$/;"	s
TeeReader	_	/^pub struct TeeReader<R, W> {$/;"	s
TempDir	_	impl TempDir {$/;"	i
TempDir	_	struct TempDir(Path);$/;"	s
TerminateProcess	_	pub fn TerminateProcess(hProcess: HANDLE, uExitCode: c_uint)$/;"	f
Test	_	struct Test;$/;"	s
TestWriter	_	struct TestWriter;$/;"	s
Thread	_	/^impl Thread<()> {$/;"	i
Thread	_	/^pub struct Thread<T> {$/;"	s
ThreeChunkReader	_	struct ThreeChunkReader {$/;"	s
Timer	_	/^impl Timer {$/;"	i
Timer	_	/^pub struct Timer {$/;"	s
TlsAlloc	_	fn TlsAlloc() -> DWORD;$/;"	f
TlsFree	_	fn TlsFree(dwTlsIndex: DWORD) -> BOOL;$/;"	f
TlsGetValue	_	fn TlsGetValue(dwTlsIndex: DWORD) -> LPVOID;$/;"	f
TlsSetValue	_	fn TlsSetValue(dwTlsIndex: DWORD, lpTlsvalue: LPVOID) -> BOOL;$/;"	f
ToCStr	_	/^pub trait ToCStr {$/;"	t
ToCStr	_	/^impl ToCStr for Path {$/;"	i
ToCStr	_	/^impl ToCStr for Path {$/;"	i
ToPrimitive	_	impl ToPrimitive for Foo {$/;"	i
ToPrimitive	_	impl ToPrimitive for $T {$/;"	i
ToPrimitive	_	impl ToPrimitive for Value {$/;"	i
ToPrimitive	_	/^pub trait ToPrimitive {$/;"	t
ToStr	_	/^pub trait ToStr {$/;"	t
ToStrRadix	_	/^impl ToStrRadix for $T {$/;"	i
ToStrRadix	_	/^pub trait ToStrRadix {$/;"	t
ToStrRadix	_	/^impl ToStrRadix for $T {$/;"	i
TotalEq	_	impl TotalEq for $t {$/;"	i
TotalEq	_	/^impl TotalEq for Ordering {$/;"	i
TotalEq	_	/^pub trait TotalEq {$/;"	t
TotalEq	_	impl TotalEq for ~str {$/;"	i
TotalEq	_	/^impl TotalEq for () {$/;"	i
TotalOrd	_	/^impl TotalOrd for bool {$/;"	i
TotalOrd	_	impl TotalOrd for $t {$/;"	i
TotalOrd	_	/^impl TotalOrd for Ordering {$/;"	i
TotalOrd	_	/^pub trait TotalOrd: TotalEq {$/;"	t
TotalOrd	_	impl TotalOrd for ~str {$/;"	i
TotalOrd	_	/^impl TotalOrd for () {$/;"	i
Trait	_	impl Trait for Struct {$/;"	i
Trait	_	trait Trait {$/;"	t
TraitObject	_	/^pub struct TraitObject {$/;"	s
TryEnterCriticalSection	_	fn TryEnterCriticalSection(lpCriticalSection: LPCRITICAL_SECTION) -> BOOL;$/;"	f
TryRecvResult	_	/^pub enum TryRecvResult<T> {$/;"	g
TyDesc	_	/^pub struct TyDesc {$/;"	s
TyVisitor	_	/^pub trait TyVisitor {$/;"	t
TypeId	_	/^impl TypeId {$/;"	i
TypeId	_	/^pub struct TypeId {$/;"	s
UTF0Item	_	/^impl UTF0Item {$/;"	i
UTF0Item	_	/^pub enum UTF0Item {$/;"	g
UTF0Items	_	/^pub struct UTF0Items<'a> {$/;"	s
UdpSocket	_	/^impl UdpSocket {$/;"	i
UdpSocket	_	/^pub struct UdpSocket {$/;"	s
UdpStream	_	/^impl UdpStream {$/;"	i
UdpStream	_	/^pub struct UdpStream {$/;"	s
Unfold	_	/^pub struct Unfold<'a, A, St> {$/;"	s
UnixAcceptor	_	/^pub struct UnixAcceptor {$/;"	s
UnixListener	_	/^impl UnixListener {$/;"	i
UnixListener	_	/^pub struct UnixListener {$/;"	s
UnixStream	_	/^impl UnixStream {$/;"	i
UnixStream	_	/^pub struct UnixStream {$/;"	s
UnmapViewOfFile	_	pub fn UnmapViewOfFile(lpBaseAddress: LPCVOID) -> BOOL;$/;"	f
UnsafeArc	_	/^pub struct UnsafeArc<T> {$/;"	s
Unsigned	_	/^pub trait Unsigned { fn fmt(&self, &mut Formatter) -> Result; }$/;"	t
Unsigned	_	/^pub trait Unsigned: Num {}$/;"	t
Unsigned	_	/^impl Unsigned for $T {}$/;"	i
UnstableFileStat	_	/^pub struct UnstableFileStat {$/;"	s
Unwinder	_	/^impl Unwinder {$/;"	i
Unwinder	_	/^pub struct Unwinder {$/;"	s
UpgradeResult	_	/^pub enum UpgradeResult {$/;"	g
UpgradeResult	_	/^pub enum UpgradeResult {$/;"	g
UpperExp	_	impl UpperExp for $ty {$/;"	i
UpperExp	_	/^pub trait UpperExp { fn fmt(&self, &mut Formatter) -> Result; }$/;"	t
UpperHex	_	/^pub trait UpperHex { fn fmt(&self, &mut Formatter) -> Result; }$/;"	t
UpperHex	_	/^pub struct UpperHex;$/;"	s
Uppercase	_	pub fn Uppercase(c: char) -> bool {$/;"	f
Value	_	struct Value { x: int }$/;"	s
VariantState	_	/^enum VariantState {$/;"	g
Vec	_	/^pub struct Vec<T> {$/;"	s
Vec	_	/^pub struct Vec<T> {$/;"	s
Vector	_	/^pub trait Vector<T> {$/;"	t
Vector0D	_	/^struct Vector0D {$/;"	s
VectorVector	_	/^pub trait VectorVector<T> {$/;"	t
VirtualAlloc	_	pub fn VirtualAlloc(lpAddress: LPVOID,$/;"	f
VirtualFree	_	pub fn VirtualFree(lpAddress: LPVOID,$/;"	f
VirtualLock	_	pub fn VirtualLock(lpAddress: LPVOID, dwSize: SIZE_T) -> BOOL;$/;"	f
VirtualProtect	_	pub fn VirtualProtect(lpAddress: LPVOID,$/;"	f
VirtualQuery	_	pub fn VirtualQuery(lpAddress: LPCVOID,$/;"	f
VirtualUnlock	_	pub fn VirtualUnlock(lpAddress: LPVOID, dwSize: SIZE_T)$/;"	f
Void	_	/^pub enum Void { }$/;"	g
WSAPROTOCOLCHAIN	_	pub struct WSAPROTOCOLCHAIN {$/;"	s
WSAPROTOCOL_INFO	_	pub struct WSAPROTOCOL_INFO {$/;"	s
WaitForSingleObject	_	pub fn WaitForSingleObject(hHandle: HANDLE,$/;"	f
WaitForSingleObject	_	fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;$/;"	f
WaitForSingleObject	_	fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;$/;"	f
WaitNamedPipeW	_	pub fn WaitNamedPipeW(lpNamedPipeName: LPCWSTR,$/;"	f
Weak	_	/^pub struct Weak<T> {$/;"	s
Weighted	_	/^pub struct Weighted<T> {$/;"	s
WeightedChoice	_	/^pub struct WeightedChoice<T> {$/;"	s
White_Space	_	pub fn White_Space(c: char) -> bool {$/;"	f
Windows	_	/^pub struct Windows<'a, T> {$/;"	s
Worker	_	/^pub struct Worker<T> {$/;"	s
WriteFile	_	pub fn WriteFile(hFile: HANDLE,$/;"	f
Writer	_	impl Writer for MyWriter {$/;"	i
Writer	_	/^impl Writer for SipState {$/;"	i
Writer	_	impl Writer for NullStream {$/;"	i
Writer	_	/^impl Writer for ChanWriter {$/;"	i
Writer	_	/^impl Writer for File {$/;"	i
Writer	_	/^impl Writer for MemWriter {$/;"	i
Writer	_	/^impl Writer for ~Writer {$/;"	i
Writer	_	/^pub trait Writer {$/;"	t
Writer	_	/^impl Writer for TcpStream {$/;"	i
Writer	_	/^impl Writer for UdpStream {$/;"	i
Writer	_	/^impl Writer for UnixStream {$/;"	i
Writer	_	/^impl Writer for PipeStream {$/;"	i
Writer	_	impl Writer for Stdout {$/;"	i
Writer	_	/^impl Writer for StdWriter {$/;"	i
Writer	_	impl Writer for TestWriter {$/;"	i
Writer	_	/^impl Writer for MultiWriter {$/;"	i
Writer	_	/^impl Writer for NullWriter {$/;"	i
XID_Continue	_	pub fn XID_Continue(c: char) -> bool {$/;"	f
XID_Start	_	pub fn XID_Start(c: char) -> bool {$/;"	f
XorShiftRng	_	/^impl XorShiftRng {$/;"	i
XorShiftRng	_	/^pub struct XorShiftRng {$/;"	s
Zero	_	/^impl Zero for f0 {$/;"	i
Zero	_	/^impl Zero for f0 {$/;"	i
Zero	_	/^impl Zero for $T {$/;"	i
Zero	_	/^pub trait Zero: Add<Self, Self> {$/;"	t
Zero	_	/^impl Zero for $T {$/;"	i
ZeroReader	_	/^pub struct ZeroReader;$/;"	s
Zip	_	/^pub struct Zip<T, U> {$/;"	s
Zl	_	pub fn Zl(c: char) -> bool {$/;"	f
Zp	_	pub fn Zp(c: char) -> bool {$/;"	f
Zs	_	pub fn Zs(c: char) -> bool {$/;"	f
_NSGetArgc	_	pub fn _NSGetArgc() -> *c_int;$/;"	f
_NSGetArgv	_	pub fn _NSGetArgv() -> ***c_char;$/;"	f
_NSGetExecutablePath	_	pub fn _NSGetExecutablePath(buf: *mut c_char, bufsize: *mut u0)$/;"	f
_Unwind_Action	_	pub enum _Unwind_Action$/;"	g
_Unwind_Context	_	pub enum _Unwind_Context {}$/;"	g
_Unwind_DeleteException	_	pub fn _Unwind_DeleteException(exception: *_Unwind_Exception);$/;"	f
_Unwind_Exception	_	pub struct _Unwind_Exception {$/;"	s
_Unwind_RaiseException	_	pub fn _Unwind_RaiseException(exception: *_Unwind_Exception) -> _Unwind_Reason_Code;$/;"	f
_Unwind_Reason_Code	_	pub enum _Unwind_Reason_Code {$/;"	g
_Unwind_State	_	pub enum _Unwind_State$/;"	g
__errno_location	_	fn __errno_location() -> *c_int;$/;"	f
__error	_	fn __error() -> *c_int;$/;"	f
__gcc_personality_v0	_	fn __gcc_personality_v0(state: uw::_Unwind_State,$/;"	f
__gcc_personality_v0	_	fn __gcc_personality_v0(version: c_int,$/;"	f
__pthread_get_minstack	_	unsafe fn __pthread_get_minstack(_: *libc::pthread_attr_t) -> libc::size_t {$/;"	f
__pthread_get_minstack	_	unsafe fn __pthread_get_minstack(attr: *libc::pthread_attr_t) -> libc::size_t {$/;"	f
__xpg_strerror_r	_	fn __xpg_strerror_r(errnum: c_int,$/;"	f
_exit	_	pub fn _exit(status: c_int) -> !;$/;"	f
_unsetenv	_	fn _unsetenv(n: &str) {$/;"	f
a_million_letter_X	_	fn a_million_letter_X() -> ~str {$/;"	f
a_million_letter_a	_	fn a_million_letter_a() -> ~str {$/;"	f
abort	_	pub fn abort() -> !;$/;"	f
abort	_	/^fn abort() -> ! {$/;"	f
abort	_	fn abort() -> ! {$/;"	f
abort	_	/^pub fn abort(msg: &str) -> ! {$/;"	f
abort_selection	_	fn abort_selection(&self) -> bool {$/;"	f
abort_selection	_	pub fn abort_selection(&mut self) -> Result<bool, Port<T>> {$/;"	f
abort_selection	_	fn abort_selection(&self) -> bool;$/;"	f
abort_selection	_	pub fn abort_selection(&mut self, _was_upgrade: bool) -> bool {$/;"	f
abort_selection	_	pub fn abort_selection(&mut self,$/;"	f
abs	_	pub fn abs(i: c_int) -> c_int;$/;"	f
abs	_	fn abs(&self) -> f0 { abs(*self) }$/;"	f
abs	_	fn abs(n: f0) -> f0 = intrinsics::fabsf0,$/;"	f
abs	_	fn abs(&self) -> f0 { abs(*self) }$/;"	f
abs	_	fn abs(n: f0) -> f0 = intrinsics::fabsf0,$/;"	f
abs	_	fn abs(&self) -> $T {$/;"	f
abs	_	fn abs(&self) -> Self;$/;"	f
abs_sub	_	pub fn abs_sub(a: c_double, b: c_double) -> c_double;$/;"	f
abs_sub	_	pub fn abs_sub(a: c_float, b: c_float) -> c_float;$/;"	f
abs_sub	_	fn abs_sub(&self, other: &f0) -> f0 { abs_sub(*self, *other) }$/;"	f
abs_sub	_	fn abs_sub(a: c_float, b: c_float) -> c_float = cmath::c_float::abs_sub,$/;"	f
abs_sub	_	fn abs_sub(&self, other: &f0) -> f0 { abs_sub(*self, *other) }$/;"	f
abs_sub	_	fn abs_sub(a: c_double, b: c_double) -> c_double = cmath::c_double::abs_sub,$/;"	f
abs_sub	_	fn abs_sub(&self, other: &$T) -> $T {$/;"	f
abs_sub	_	fn abs_sub(&self, other: &Self) -> Self;$/;"	f
accept	_	fn accept(&mut self) -> IoResult<T>;$/;"	f
accept	_	fn accept(&mut self) -> IoResult<TcpStream> {$/;"	f
accept	_	fn accept(&mut self) -> IoResult<UnixStream> {$/;"	f
accept	_	fn accept(&mut self) -> IoResult<T> {$/;"	f
accept	_	pub fn accept(socket: SOCKET, address: *mut sockaddr,$/;"	f
accept	_	pub fn accept(socket: c_int, address: *mut sockaddr,$/;"	f
accept	_	fn accept(&mut self) -> Result<~RtioPipe, IoError>;$/;"	f
accept	_	fn accept(&mut self) -> Result<~RtioTcpStream, IoError>;$/;"	f
accept_simultaneously	_	fn accept_simultaneously(&mut self) -> Result<(), IoError>;$/;"	f
access	_	pub fn access(path: *c_char, amode: c_int) -> c_int;$/;"	f
acos	_	pub fn acos(n: c_double) -> c_double;$/;"	f
acos	_	pub fn acos(n: c_float) -> c_float;$/;"	f
acos	_	fn acos(&self) -> f0 { acos(*self) }$/;"	f
acos	_	fn acos(n: c_float) -> c_float = cmath::c_float::acos,$/;"	f
acos	_	fn acos(&self) -> f0 { acos(*self) }$/;"	f
acos	_	fn acos(n: c_double) -> c_double = cmath::c_double::acos,$/;"	f
acos	_	fn acos(&self) -> Self;$/;"	f
acosh	_	fn acosh(&self) -> f0 {$/;"	f
acosh	_	fn acosh(&self) -> f0 {$/;"	f
acosh	_	fn acosh(&self) -> Self;$/;"	f
add	_	pub unsafe fn add(&mut self) {$/;"	f
add	_	fn add(&self, _: &Foo) -> Foo {$/;"	f
add	_	fn add(old: &mut int, new: &uint) -> Option<f0> {$/;"	f
add	_	fn add(&self, other: &f0) -> f0 { *self + *other }$/;"	f
add	_	fn add(&self, other: &f0) -> f0 { *self + *other }$/;"	f
add	_	fn add(&self, other: &$T) -> $T { *self + *other }$/;"	f
add	_	fn add(&self, other: &$T) -> $T { *self + *other }$/;"	f
add	_	fn add(&self, rhs: &RHS) -> Result;$/;"	f
add	_	fn add(&self, rhs: & &'a str) -> ~str {$/;"	f
add	_	fn add(&self, rhs: &V) -> ~[T] {$/;"	f
add	_	fn add(bh: &mut BenchHarness) {$/;"	f
addrinfo	_	/^pub mod addrinfo;$/;"	m
addrinfo	_	pub struct addrinfo {$/;"	s
advance	_	fn advance(&mut self, f: |A| -> bool) -> bool {$/;"	f
alarm	_	pub fn alarm(seconds: c_uint) -> c_uint;$/;"	f
align	_	pub fn align(&mut self, a: uint) {$/;"	f
align	_	/^pub fn align(size: uint, align: uint) -> uint {$/;"	f
align_of_0	_	fn align_of_0() {$/;"	f
align_of_0	_	fn align_of_0() {$/;"	f
align_of_basic	_	fn align_of_basic() {$/;"	f
align_of_val_basic	_	fn align_of_val_basic() {$/;"	f
align_to	_	pub fn align_to<T>(&mut self) {$/;"	f
align_to	_	/^fn align_to(size: uint, align: uint) -> uint {$/;"	f
all	_	fn all(&mut self, f: |A| -> bool) -> bool {$/;"	f
alloc	_	pub fn alloc(&mut self, drop_glue: fn(*mut u0), size: uint, align: uint) -> *mut Box {$/;"	f
alloc	_	fn alloc(&mut self, bits: int) -> ~Buffer<T> {$/;"	f
alloc	_	unsafe fn alloc(&mut self) -> *mut Node<T> {$/;"	f
alloc_managed_big	_	fn alloc_managed_big(bh: &mut BenchHarness) {$/;"	f
alloc_managed_small	_	fn alloc_managed_small(bh: &mut BenchHarness) {$/;"	f
alloc_obj_with_dtor	_	fn alloc_obj_with_dtor(bh: &mut BenchHarness) {$/;"	f
alloc_owned_big	_	fn alloc_owned_big(bh: &mut BenchHarness) {$/;"	f
alloc_owned_small	_	fn alloc_owned_small(bh: &mut BenchHarness) {$/;"	f
and	_	pub fn and<U>(self, optb: Option<U>) -> Option<U> {$/;"	f
and	_	pub fn and<U>(self, res: Result<U, E>) -> Result<U, E> {$/;"	f
and_then	_	pub fn and_then<U>(self, f: |T| -> Option<U>) -> Option<U> {$/;"	f
and_then	_	pub fn and_then<U>(self, op: |T| -> Result<U, E>) -> Result<U, E> {$/;"	f
android	_	pub mod android {$/;"	m
annihilate	_	/^pub unsafe fn annihilate() {$/;"	f
any	_	fn any(&mut self, f: |A| -> bool) -> bool {$/;"	f
any	_	/^pub mod any;$/;"	m
any_as_mut	_	fn any_as_mut() {$/;"	f
any_as_ref	_	fn any_as_ref() {$/;"	f
any_move	_	fn any_move() {$/;"	f
any_owning	_	fn any_owning() {$/;"	f
any_referenced	_	fn any_referenced() {$/;"	f
append	_	fn append(self, rhs: &str) -> ~str {$/;"	f
append	_	fn append(self, rhs: &str) -> ~str;$/;"	f
append	_	/^pub fn append<T:Clone>(lhs: ~[T], rhs: &[T]) -> ~[T] {$/;"	f
append	_	/^pub fn append<T:Clone>(mut first: Vec<T>, second: &[T]) -> Vec<T> {$/;"	f
append_one	_	/^pub fn append_one<T>(lhs: ~[T], x: T) -> ~[T] {$/;"	f
append_one	_	/^pub fn append_one<T>(mut lhs: Vec<T>, x: T) -> Vec<T> {$/;"	f
append_path	_	fn append_path(me: &mut Path, path: &str) {$/;"	f
arc	_	/^pub mod arc;$/;"	m
arch	_	pub mod arch {$/;"	m
arclike_newN	_	fn arclike_newN() {$/;"	f
args	_	/^pub fn args() -> ~[~str] {$/;"	f
args	_	/^pub mod args;$/;"	m
args_as_bytes	_	/^pub fn args_as_bytes() -> ~[~[u0]] {$/;"	f
argument	_	/^pub fn argument<'a, T>(f: extern "Rust" fn(&T, &mut Formatter) -> Result,$/;"	f
argument	_	fn argument(&mut self) -> Argument<'a> {$/;"	f
argumentstr	_	/^pub fn argumentstr<'a>(s: &'a &str) -> Argument<'a> {$/;"	f
argumentuint	_	/^pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {$/;"	f
arm	_	pub mod arm {$/;"	m
array_each	_	/^pub unsafe fn array_each<T>(arr: **T, cb: |*T|) {$/;"	f
array_each_with_len	_	/^pub unsafe fn array_each_with_len<T>(arr: **T, len: uint, cb: |*T|) {$/;"	f
as_box	_	fn as_box(&mut self) -> *mut Box {$/;"	f
as_bytes	_	pub fn as_bytes<'a>(&'a self) -> &'a [u0] {$/;"	f
as_bytes	_	fn as_bytes(&self) -> &'a [u0] {$/;"	f
as_bytes	_	fn as_bytes(&self) -> &'a [u0];$/;"	f
as_bytes_no_nul	_	pub fn as_bytes_no_nul<'a>(&'a self) -> &'a [u0] {$/;"	f
as_maybe_owned	_	pub fn as_maybe_owned(&self) -> MaybeOwned<'a> {$/;"	f
as_mut	_	fn as_mut<T: 'static>(self) -> Option<&'a mut T> {$/;"	f
as_mut	_	fn as_mut<T: 'static>(self) -> Option<&'a mut T>;$/;"	f
as_mut	_	unsafe fn as_mut<'a>(&'a self) -> &'a mut RefCell<T> {$/;"	f
as_mut	_	pub fn as_mut<'r>(&'r mut self) -> Option<&'r mut T> {$/;"	f
as_mut	_	pub fn as_mut<'r>(&'r mut self) -> Result<&'r mut T, &'r mut E> {$/;"	f
as_mut_ptr	_	fn as_mut_ptr(self) -> *mut T {$/;"	f
as_mut_ptr	_	fn as_mut_ptr(self) -> *mut T;$/;"	f
as_mut_slice	_	pub fn as_mut_slice<'r>(&'r mut self) -> &'r mut [T] {$/;"	f
as_mut_slice	_	fn as_mut_slice(self) -> &'a mut [T] { self }$/;"	f
as_mut_slice	_	fn as_mut_slice(self) -> &'a mut [T];$/;"	f
as_mut_slice	_	pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {$/;"	f
as_owned_vec	_	pub unsafe fn as_owned_vec<'a>(s: &'a mut ~str) -> &'a mut ~[u0] {$/;"	f
as_ptr	_	fn as_ptr(&self) -> *u0 {$/;"	f
as_ptr	_	fn as_ptr(&self) -> *u0;$/;"	f
as_ptr	_	fn as_ptr(&self) -> *T {$/;"	f
as_ptr	_	fn as_ptr(&self) -> *T;$/;"	f
as_ref	_	fn as_ref<T: 'static>(self) -> Option<&'a T> {$/;"	f
as_ref	_	fn as_ref<T: 'static>(self) -> Option<&'a T>;$/;"	f
as_ref	_	pub fn as_ref<'r>(&'r self) -> Option<&'r T> {$/;"	f
as_ref	_	pub fn as_ref<'r>(&'r self) -> Result<&'r T, &'r E> {$/;"	f
as_slice	_	pub fn as_slice<'r>(&'r self) -> &'r [T] {$/;"	f
as_slice	_	fn as_slice<'a>(&'a self) -> &'a str { *self }$/;"	f
as_slice	_	fn as_slice<'a>(&'a self) -> &'a str {$/;"	f
as_slice	_	fn as_slice<'a>(&'a self) -> &'a str;$/;"	f
as_slice	_	fn as_slice<'b>(&'b self) -> &'b str {$/;"	f
as_slice	_	fn as_slice<'a>(&'a self) -> &'a [T] { *self }$/;"	f
as_slice	_	fn as_slice<'a>(&'a self) -> &'a [T] { let v: &'a [T] = *self; v }$/;"	f
as_slice	_	fn as_slice<'a>(&'a self) -> &'a [T];$/;"	f
as_slice	_	pub fn as_slice<'a>(&'a self) -> &'a [T] {$/;"	f
as_socket	_	pub fn as_socket<T>(&mut self, f: |&mut UdpSocket| -> T) -> T {$/;"	f
as_str	_	pub fn as_str<'a>(&'a self) -> Option<&'a str> {$/;"	f
as_str	_	fn as_str<'a>(&'a self) -> Option<&'a str> {$/;"	f
as_str	_	fn as_str<'a>(&'a self) -> Option<&'a str> {$/;"	f
as_str_ascii	_	fn as_str_ascii<'a>(&'a self) -> &'a str {$/;"	f
as_str_ascii	_	fn as_str_ascii<'a>(&'a self) -> &'a str;$/;"	f
as_utf0_p	_	pub fn as_utf0_p<T>(s: &str, f: |*u0| -> T) -> T {$/;"	f
as_vec	_	fn as_vec<'a>(&'a self) -> &'a [u0];$/;"	f
as_vec	_	fn as_vec<'a>(&'a self) -> &'a [u0] {$/;"	f
as_vec	_	fn as_vec<'a>(&'a self) -> &'a [u0] {$/;"	f
ascii	_	/^pub mod ascii;$/;"	m
asin	_	pub fn asin(n: c_double) -> c_double;$/;"	f
asin	_	pub fn asin(n: c_float) -> c_float;$/;"	f
asin	_	fn asin(&self) -> f0 { asin(*self) }$/;"	f
asin	_	fn asin(n: c_float) -> c_float = cmath::c_float::asin,$/;"	f
asin	_	fn asin(&self) -> f0 { asin(*self) }$/;"	f
asin	_	fn asin(n: c_double) -> c_double = cmath::c_double::asin,$/;"	f
asin	_	fn asin(&self) -> Self;$/;"	f
asinh	_	fn asinh(&self) -> f0 {$/;"	f
asinh	_	fn asinh(&self) -> f0 {$/;"	f
asinh	_	fn asinh(&self) -> Self;$/;"	f
assert_sane	_	fn assert_sane(&self) {$/;"	f
assert_sane	_	fn assert_sane(&self) {}$/;"	f
at_exit	_	/^pub fn at_exit(f: proc()) {$/;"	f
at_exit_imp	_	/^mod at_exit_imp;$/;"	m
atan	_	pub fn atan(n: c_double) -> c_double;$/;"	f
atan	_	pub fn atan(n: c_float) -> c_float;$/;"	f
atan	_	fn atan(&self) -> f0 { atan(*self) }$/;"	f
atan	_	fn atan(n: c_float) -> c_float = cmath::c_float::atan,$/;"	f
atan	_	fn atan(&self) -> f0 { atan(*self) }$/;"	f
atan	_	fn atan(n: c_double) -> c_double = cmath::c_double::atan,$/;"	f
atan	_	fn atan(&self) -> Self;$/;"	f
atan0	_	pub fn atan0(a: c_double, b: c_double) -> c_double;$/;"	f
atan0	_	pub fn atan0(a: c_float, b: c_float) -> c_float;$/;"	f
atan0	_	fn atan0(&self, other: &f0) -> f0 { atan0(*self, *other) }$/;"	f
atan0	_	fn atan0(a: c_float, b: c_float) -> c_float = cmath::c_float::atan0,$/;"	f
atan0	_	fn atan0(&self, other: &f0) -> f0 { atan0(*self, *other) }$/;"	f
atan0	_	fn atan0(a: c_double, b: c_double) -> c_double = cmath::c_double::atan0,$/;"	f
atan0	_	fn atan0(&self, other: &Self) -> Self;$/;"	f
atanh	_	fn atanh(&self) -> f0 {$/;"	f
atanh	_	fn atanh(&self) -> f0 {$/;"	f
atanh	_	fn atanh(&self) -> Self;$/;"	f
atof	_	pub fn atof(s: *c_char) -> c_double;$/;"	f
atoi	_	pub fn atoi(s: *c_char) -> c_int;$/;"	f
atomic_add	_	/^pub unsafe fn atomic_add<T>(dst: &mut T, val: T, order: Ordering) -> T {$/;"	f
atomic_and	_	pub fn atomic_and<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_and	_	/^pub unsafe fn atomic_and<T>(dst: &mut T, val: T, order: Ordering) -> T {$/;"	f
atomic_and_acq	_	pub fn atomic_and_acq<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_and_acqrel	_	pub fn atomic_and_acqrel<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_and_rel	_	pub fn atomic_and_rel<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_and_relaxed	_	pub fn atomic_and_relaxed<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_compare_and_swap	_	/^pub unsafe fn atomic_compare_and_swap<T>(dst:&mut T, old:T, new:T, order: Ordering) -> T {$/;"	f
atomic_cxchg	_	pub fn atomic_cxchg<T>(dst: &mut T, old: T, src: T) -> T;$/;"	f
atomic_cxchg_acq	_	pub fn atomic_cxchg_acq<T>(dst: &mut T, old: T, src: T) -> T;$/;"	f
atomic_cxchg_acqrel	_	pub fn atomic_cxchg_acqrel<T>(dst: &mut T, old: T, src: T) -> T;$/;"	f
atomic_cxchg_rel	_	pub fn atomic_cxchg_rel<T>(dst: &mut T, old: T, src: T) -> T;$/;"	f
atomic_cxchg_relaxed	_	pub fn atomic_cxchg_relaxed<T>(dst: &mut T, old: T, src: T) -> T;$/;"	f
atomic_fence	_	pub fn atomic_fence();$/;"	f
atomic_fence_acq	_	pub fn atomic_fence_acq();$/;"	f
atomic_fence_acqrel	_	pub fn atomic_fence_acqrel();$/;"	f
atomic_fence_rel	_	pub fn atomic_fence_rel();$/;"	f
atomic_load	_	pub fn atomic_load<T>(src: &T) -> T;$/;"	f
atomic_load	_	/^pub unsafe fn atomic_load<T>(dst: &T, order:Ordering) -> T {$/;"	f
atomic_load_acq	_	pub fn atomic_load_acq<T>(src: &T) -> T;$/;"	f
atomic_load_relaxed	_	pub fn atomic_load_relaxed<T>(src: &T) -> T;$/;"	f
atomic_max	_	pub fn atomic_max<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_max_acq	_	pub fn atomic_max_acq<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_max_acqrel	_	pub fn atomic_max_acqrel<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_max_rel	_	pub fn atomic_max_rel<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_max_relaxed	_	pub fn atomic_max_relaxed<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_min	_	pub fn atomic_min<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_min_acq	_	pub fn atomic_min_acq<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_min_acqrel	_	pub fn atomic_min_acqrel<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_min_rel	_	pub fn atomic_min_rel<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_min_relaxed	_	pub fn atomic_min_relaxed<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_nand	_	pub fn atomic_nand<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_nand	_	/^pub unsafe fn atomic_nand<T>(dst: &mut T, val: T, order: Ordering) -> T {$/;"	f
atomic_nand_acq	_	pub fn atomic_nand_acq<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_nand_acqrel	_	pub fn atomic_nand_acqrel<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_nand_rel	_	pub fn atomic_nand_rel<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_nand_relaxed	_	pub fn atomic_nand_relaxed<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_or	_	pub fn atomic_or<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_or	_	/^pub unsafe fn atomic_or<T>(dst: &mut T, val: T, order: Ordering) -> T {$/;"	f
atomic_or_acq	_	pub fn atomic_or_acq<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_or_acqrel	_	pub fn atomic_or_acqrel<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_or_rel	_	pub fn atomic_or_rel<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_or_relaxed	_	pub fn atomic_or_relaxed<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_store	_	pub fn atomic_store<T>(dst: &mut T, val: T);$/;"	f
atomic_store	_	/^pub unsafe fn atomic_store<T>(dst: &mut T, val: T, order:Ordering) {$/;"	f
atomic_store_rel	_	pub fn atomic_store_rel<T>(dst: &mut T, val: T);$/;"	f
atomic_store_relaxed	_	pub fn atomic_store_relaxed<T>(dst: &mut T, val: T);$/;"	f
atomic_sub	_	/^pub unsafe fn atomic_sub<T>(dst: &mut T, val: T, order: Ordering) -> T {$/;"	f
atomic_swap	_	/^pub unsafe fn atomic_swap<T>(dst: &mut T, val: T, order: Ordering) -> T {$/;"	f
atomic_umax	_	pub fn atomic_umax<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_umax_acq	_	pub fn atomic_umax_acq<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_umax_acqrel	_	pub fn atomic_umax_acqrel<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_umax_rel	_	pub fn atomic_umax_rel<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_umax_relaxed	_	pub fn atomic_umax_relaxed<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_umin	_	pub fn atomic_umin<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_umin_acq	_	pub fn atomic_umin_acq<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_umin_acqrel	_	pub fn atomic_umin_acqrel<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_umin_rel	_	pub fn atomic_umin_rel<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_umin_relaxed	_	pub fn atomic_umin_relaxed<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_xadd	_	pub fn atomic_xadd<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_xadd_acq	_	pub fn atomic_xadd_acq<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_xadd_acqrel	_	pub fn atomic_xadd_acqrel<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_xadd_rel	_	pub fn atomic_xadd_rel<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_xadd_relaxed	_	pub fn atomic_xadd_relaxed<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_xchg	_	pub fn atomic_xchg<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_xchg_acq	_	pub fn atomic_xchg_acq<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_xchg_acqrel	_	pub fn atomic_xchg_acqrel<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_xchg_rel	_	pub fn atomic_xchg_rel<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_xchg_relaxed	_	pub fn atomic_xchg_relaxed<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_xor	_	pub fn atomic_xor<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_xor	_	/^pub unsafe fn atomic_xor<T>(dst: &mut T, val: T, order: Ordering) -> T {$/;"	f
atomic_xor_acq	_	pub fn atomic_xor_acq<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_xor_acqrel	_	pub fn atomic_xor_acqrel<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_xor_rel	_	pub fn atomic_xor_rel<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_xor_relaxed	_	pub fn atomic_xor_relaxed<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_xsub	_	pub fn atomic_xsub<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_xsub_acq	_	pub fn atomic_xsub_acq<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_xsub_acqrel	_	pub fn atomic_xsub_acqrel<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_xsub_rel	_	pub fn atomic_xsub_rel<T>(dst: &mut T, src: T) -> T;$/;"	f
atomic_xsub_relaxed	_	pub fn atomic_xsub_relaxed<T>(dst: &mut T, src: T) -> T;$/;"	f
atomics	_	/^pub mod atomics;$/;"	m
avoid_copying_the_body	_	/^fn avoid_copying_the_body(spawnfn: |v: proc()|) {$/;"	f
base	_	fn base(&self) -> u0 { $base }$/;"	f
base	_	fn base(&self) -> u0 { self.base }$/;"	f
base	_	fn base(&self) -> u0;$/;"	f
base_port	_	/^fn base_port() -> u0 {$/;"	f
begin_unwind	_	pub fn begin_unwind(&mut self, cause: ~Any) -> ! {$/;"	f
begin_unwind	_	/^pub fn begin_unwind<M: Any + Send>(msg: M, file: &'static str, line: uint) -> ! {$/;"	f
begin_unwind_fmt	_	/^pub fn begin_unwind_fmt(msg: &fmt::Arguments, file: &'static str, line: uint) -> ! {$/;"	f
begin_unwind_inner	_	/^fn begin_unwind_inner(msg: ~Any, file: &'static str, line: uint) -> ! {$/;"	f
begin_unwind_raw	_	/^pub fn begin_unwind_raw(msg: *u0, file: *u0, line: uint) -> ! {$/;"	f
bench	_	/^mod bench {$/;"	m
bench	_	/^mod bench {$/;"	m
bench	_	/^mod bench {$/;"	m
bench	_	/^mod bench {$/;"	m
bench	_	/^mod bench {$/;"	m
bench	_	/^mod bench {$/;"	m
bench	_	/^mod bench {$/;"	m
bench	_	/^mod bench {$/;"	m
bench	_	/^mod bench {$/;"	m
bench	_	/^mod bench {$/;"	m
bench	_	/^mod bench {$/;"	m
bench	_	/^mod bench {$/;"	m
bench	_	/^mod bench {$/;"	m
bench	_	/^mod bench {$/;"	m
bench	_	/^mod bench {$/;"	m
bench	_	/^mod bench {$/;"	m
bench	_	/^mod bench {$/;"	m
bench_as_ref	_	fn bench_as_ref(bh: &mut BenchHarness) {$/;"	f
bench_buffered_reader	_	fn bench_buffered_reader(bh: &mut Harness) {$/;"	f
bench_buffered_stream	_	fn bench_buffered_stream(bh: &mut Harness) {$/;"	f
bench_buffered_writer	_	fn bench_buffered_writer(bh: &mut Harness) {$/;"	f
bench_compound_0	_	fn bench_compound_0(bh: &mut BenchHarness) {$/;"	f
bench_connect	_	fn bench_connect(bh: &mut BenchHarness) {$/;"	f
bench_gamma_large_shape	_	fn bench_gamma_large_shape(bh: &mut BenchHarness) {$/;"	f
bench_gamma_small_shape	_	fn bench_gamma_small_shape(bh: &mut BenchHarness) {$/;"	f
bench_pow_function	_	fn bench_pow_function(b: &mut BenchHarness) {$/;"	f
bench_push_str	_	fn bench_push_str(bh: &mut BenchHarness) {$/;"	f
bench_str	_	fn bench_str(bh: &mut BenchHarness) {$/;"	f
bench_to_c_str_long	_	fn bench_to_c_str_long(bh: &mut BenchHarness) {$/;"	f
bench_to_c_str_medium	_	fn bench_to_c_str_medium(bh: &mut BenchHarness) {$/;"	f
bench_to_c_str_short	_	fn bench_to_c_str_short(bh: &mut BenchHarness) {$/;"	f
bench_to_c_str_unchecked	_	fn bench_to_c_str_unchecked(bh: &mut BenchHarness, s: &str) {$/;"	f
bench_to_c_str_unchecked_long	_	fn bench_to_c_str_unchecked_long(bh: &mut BenchHarness) {$/;"	f
bench_to_c_str_unchecked_medium	_	fn bench_to_c_str_unchecked_medium(bh: &mut BenchHarness) {$/;"	f
bench_to_c_str_unchecked_short	_	fn bench_to_c_str_unchecked_short(bh: &mut BenchHarness) {$/;"	f
bench_to_str	_	fn bench_to_str(bh: &mut BenchHarness, s: &str) {$/;"	f
bench_with_c_str	_	fn bench_with_c_str(bh: &mut BenchHarness, s: &str) {$/;"	f
bench_with_c_str_long	_	fn bench_with_c_str_long(bh: &mut BenchHarness) {$/;"	f
bench_with_c_str_medium	_	fn bench_with_c_str_medium(bh: &mut BenchHarness) {$/;"	f
bench_with_c_str_short	_	fn bench_with_c_str_short(bh: &mut BenchHarness) {$/;"	f
bench_with_c_str_unchecked	_	fn bench_with_c_str_unchecked(bh: &mut BenchHarness, s: &str) {$/;"	f
bench_with_c_str_unchecked_long	_	fn bench_with_c_str_unchecked_long(bh: &mut BenchHarness) {$/;"	f
bench_with_c_str_unchecked_medium	_	fn bench_with_c_str_unchecked_medium(bh: &mut BenchHarness) {$/;"	f
bench_with_c_str_unchecked_short	_	fn bench_with_c_str_unchecked_short(bh: &mut BenchHarness) {$/;"	f
bench_with_capacity	_	fn bench_with_capacity(bh: &mut BenchHarness) {$/;"	f
bind	_	pub fn bind(addr: SocketAddr) -> IoResult<TcpListener> {$/;"	f
bind	_	pub fn bind(addr: SocketAddr) -> IoResult<UdpSocket> {$/;"	f
bind	_	pub fn bind<P: ToCStr>(path: &P) -> IoResult<UnixListener> {$/;"	f
bind	_	pub fn bind(socket: SOCKET, address: *sockaddr,$/;"	f
bind	_	pub fn bind(socket: c_int, address: *sockaddr,$/;"	f
bitand	_	fn bitand(&self, b: &bool) -> bool { *self & *b }$/;"	f
bitand	_	fn bitand(&self, other: &$T) -> $T { *self & *other }$/;"	f
bitand	_	fn bitand(&self, other: &$T) -> $T { *self & *other }$/;"	f
bitand	_	fn bitand(&self, rhs: &RHS) -> Result;$/;"	f
bitor	_	fn bitor(&self, b: &bool) -> bool { *self | *b }$/;"	f
bitor	_	fn bitor(&self, other: &$T) -> $T { *self | *other }$/;"	f
bitor	_	fn bitor(&self, other: &$T) -> $T { *self | *other }$/;"	f
bitor	_	fn bitor(&self, rhs: &RHS) -> Result;$/;"	f
bitxor	_	fn bitxor(&self, b: &bool) -> bool { *self ^ *b }$/;"	f
bitxor	_	fn bitxor(&self, other: &$T) -> $T { *self ^ *other }$/;"	f
bitxor	_	fn bitxor(&self, other: &$T) -> $T { *self ^ *other }$/;"	f
bitxor	_	fn bitxor(&self, rhs: &RHS) -> Result;$/;"	f
block	_	pub fn block(task: ~Task) -> BlockedTask {$/;"	f
block_and_wake	_	fn block_and_wake() {$/;"	f
bookkeeping	_	/^pub mod bookkeeping;$/;"	m
bool	_	/^pub mod bool;$/;"	m
bool_and	_	fn bool_and() {$/;"	f
borrow	_	pub fn borrow<'a>(&'a self) -> Ref<'a, T> {$/;"	f
borrow	_	pub fn borrow<'r>(&'r self) -> &'r T {$/;"	f
borrow	_	pub fn borrow<'a>(&'a self) -> &'a T {$/;"	f
borrow	_	fn borrow(_: Option<Task>) -> local_ptr::Borrowed<Task> {$/;"	f
borrow	_	fn borrow(unused_value: Option<Self>) -> Borrowed;$/;"	f
borrow	_	/^pub unsafe fn borrow<T>() -> Borrowed<T> {$/;"	f
borrow	_	pub fn borrow() -> Option<LocalIo> {$/;"	f
borrow_mut	_	pub fn borrow_mut<'a>(&'a self) -> RefMut<'a, T> {$/;"	f
borrow_smoke_test	_	fn borrow_smoke_test() {$/;"	f
borrow_with	_	fn borrow_with() {$/;"	f
borrow_with_mut	_	fn borrow_with_mut() {$/;"	f
borrow_with_return	_	fn borrow_with_return() {$/;"	f
breakpoint	_	pub fn breakpoint();$/;"	f
bsd0	_	pub mod bsd0 {$/;"	m
bsd0	_	pub mod bsd0 {$/;"	m
bsd0	_	pub mod bsd0 {}$/;"	m
bsd0	_	pub mod bsd0 {$/;"	m
bsd0	_	pub mod bsd0 {}$/;"	m
bsd0	_	pub mod bsd0 {$/;"	m
bsearch	_	fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint> {$/;"	f
bsearch	_	fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint>;$/;"	f
bsearch_elem	_	fn bsearch_elem(&self, x: &T) -> Option<uint> {$/;"	f
bsearch_elem	_	fn bsearch_elem(&self, x: &T) -> Option<uint>;$/;"	f
bsearch_range_table	_	fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {$/;"	f
bsearch_range_value_table	_	fn bsearch_range_value_table(c: char, r: &'static [(char, char, u0)]) -> u0 {$/;"	f
bsearch_table	_	fn bsearch_table(c: char, r: &'static [(char, &'static [char])]) -> Option<&'static [char]> {$/;"	f
bswap0	_	pub fn bswap0(x: i0) -> i0;$/;"	f
bswap0	_	pub fn bswap0(x: i0) -> i0;$/;"	f
bswap0	_	pub fn bswap0(x: i0) -> i0;$/;"	f
buf_as_slice	_	pub unsafe fn buf_as_slice<T,U>(p: *T, len: uint, f: |v: &[T]| -> U)$/;"	f
buf_len	_	/^pub unsafe fn buf_len<T>(buf: **T) -> uint {$/;"	f
buffered	_	/^mod buffered;$/;"	m
build	_	/^pub fn build<A>(size: Option<uint>, builder: |push: |v: A||) -> ~[A] {$/;"	f
bump	_	fn bump(&mut self, amt: int) -> int {$/;"	f
bump	_	fn bump(&mut self, amt: int) -> int {$/;"	f
bump	_	pub fn bump(&mut self, sz: uint) {$/;"	f
bump_box_refcount	_	/^pub unsafe fn bump_box_refcount<T>(t: @T) { forget(t); }$/;"	f
bump_past	_	pub fn bump_past<T>(&mut self) {$/;"	f
but_always_run_this_function	_	fn but_always_run_this_function() { }$/;"	f
by_ref	_	fn by_ref<'a>(&'a mut self) -> RefReader<'a, Self> {$/;"	f
by_ref	_	fn by_ref<'a>(&'a mut self) -> RefWriter<'a, Self> {$/;"	f
by_ref	_	fn by_ref<'r>(&'r mut self) -> ByRef<'r, Self> {$/;"	f
bytes	_	fn bytes<'r>(&'r mut self) -> extensions::Bytes<'r, Self> {$/;"	f
bytes	_	fn bytes(&self) -> Bytes<'a> {$/;"	f
bytes	_	fn bytes(&self) -> Bytes<'a>;$/;"	f
bytes	_	/^pub mod bytes {$/;"	m
bytes_0_bytes	_	fn bytes_0_bytes() {$/;"	f
bytes_eof	_	fn bytes_eof() {$/;"	f
bytes_error	_	fn bytes_error() {$/;"	f
bytes_rev	_	fn bytes_rev(&self) -> RevBytes<'a> {$/;"	f
bytes_rev	_	fn bytes_rev(&self) -> RevBytes<'a>;$/;"	f
c0	_	pub mod c0 {$/;"	m
c0	_	pub mod c0 {$/;"	m
c0	_	pub mod c0 {$/;"	m
c0	_	pub mod c0 {$/;"	m
c0	_	pub mod c0 {$/;"	m
c_double	_	/^pub mod c_double {$/;"	m
c_float	_	/^pub mod c_float {$/;"	m
c_str	_	/^pub mod c_str;$/;"	m
c_str_to_static_slice	_	pub unsafe fn c_str_to_static_slice(s: *libc::c_char) -> &'static str {$/;"	f
c_void	_	pub enum c_void {$/;"	g
call	_	fn call(&mut self);$/;"	f
callback	_	fn callback(&mut self, proc());$/;"	f
calloc	_	pub fn calloc(nobj: size_t, size: size_t) -> *c_void;$/;"	f
can_block	_	fn can_block(&self) -> bool;$/;"	f
can_block	_	pub fn can_block(&self) -> bool {$/;"	f
can_recv	_	fn can_recv(&self) -> bool {$/;"	f
can_recv	_	pub fn can_recv(&mut self) -> Result<bool, Port<T>> {$/;"	f
can_recv	_	fn can_recv(&self) -> bool;$/;"	f
can_recv	_	pub fn can_recv(&mut self) -> bool {$/;"	f
can_recv	_	pub fn can_recv(&mut self) -> Result<bool, Port<T>> {$/;"	f
canonical	_	pub fn canonical(c: char, i: |char|) { d(c, i, false); }$/;"	f
canonical_combining_class	_	pub fn canonical_combining_class(c: char) -> u0 {$/;"	f
canonical_sort	_	/^fn canonical_sort(comb: &mut [(char, u0)]) {$/;"	f
capacity	_	fn capacity(&self) -> uint {$/;"	f
capacity	_	fn capacity(&self) -> uint;$/;"	f
capacity	_	fn capacity(&self) -> uint {$/;"	f
capacity	_	fn capacity(&self) -> uint;$/;"	f
capacity	_	pub fn capacity(&self) -> uint {$/;"	f
case	_	fn case(a: ~[uint], b: ~[uint]) {$/;"	f
cast	_	/^pub mod cast;$/;"	m
cast	_	/^pub fn cast<T: NumCast,U: NumCast>(n: T) -> Option<U> {$/;"	f
cast_from_uint	_	pub unsafe fn cast_from_uint(blocked_task_ptr: uint) -> BlockedTask {$/;"	f
cast_to_uint	_	pub unsafe fn cast_to_uint(self) -> uint {$/;"	f
casual_pop	_	pub fn casual_pop(&mut self) -> Option<T> {$/;"	f
cbrt	_	pub fn cbrt(n: c_double) -> c_double;$/;"	f
cbrt	_	pub fn cbrt(n: c_float) -> c_float;$/;"	f
cbrt	_	fn cbrt(&self) -> f0 { cbrt(*self) }$/;"	f
cbrt	_	fn cbrt(n: c_float) -> c_float = cmath::c_float::cbrt,$/;"	f
cbrt	_	fn cbrt(&self) -> f0 { cbrt(*self) }$/;"	f
cbrt	_	fn cbrt(n: c_double) -> c_double = cmath::c_double::cbrt,$/;"	f
cbrt	_	fn cbrt(&self) -> Self;$/;"	f
ceil	_	fn ceil(&self) -> f0 { ceil(*self) }$/;"	f
ceil	_	fn ceil(n: f0) -> f0 = intrinsics::ceilf0,$/;"	f
ceil	_	fn ceil(&self) -> f0 { ceil(*self) }$/;"	f
ceil	_	fn ceil(n: f0) -> f0 = intrinsics::ceilf0,$/;"	f
ceil	_	fn ceil(&self) -> Self;$/;"	f
ceilf0	_	pub fn ceilf0(x: f0) -> f0;$/;"	f
ceilf0	_	pub fn ceilf0(x: f0) -> f0;$/;"	f
cell	_	/^pub mod cell;$/;"	m
chain	_	fn chain<U: Iterator<A>>(self, other: U) -> Chain<Self, U> {$/;"	f
change_dir	_	/^pub fn change_dir(p: &Path) -> bool {$/;"	f
change_file_times	_	/^pub fn change_file_times(path: &Path, atime: u0, mtime: u0) -> IoResult<()> {$/;"	f
char	_	/^pub mod char;$/;"	m
char_at	_	fn char_at(&self, i: uint) -> char { self.char_range_at(i).ch }$/;"	f
char_at	_	fn char_at(&self, i: uint) -> char {$/;"	f
char_at	_	fn char_at(&self, i: uint) -> char;$/;"	f
char_at_reverse	_	fn char_at_reverse(&self, i: uint) -> char {$/;"	f
char_at_reverse	_	fn char_at_reverse(&self, i: uint) -> char;$/;"	f
char_indices	_	fn char_indices(&self) -> CharOffsets<'a> {$/;"	f
char_indices	_	fn char_indices(&self) -> CharOffsets<'a>;$/;"	f
char_indices_rev	_	fn char_indices_rev(&self) -> RevCharOffsets<'a> {$/;"	f
char_indices_rev	_	fn char_indices_rev(&self) -> RevCharOffsets<'a>;$/;"	f
char_indicesator	_	fn char_indicesator(bh: &mut BenchHarness) {$/;"	f
char_indicesator_rev	_	fn char_indicesator_rev(bh: &mut BenchHarness) {$/;"	f
char_iterator	_	fn char_iterator(bh: &mut BenchHarness) {$/;"	f
char_iterator_ascii	_	fn char_iterator_ascii(bh: &mut BenchHarness) {$/;"	f
char_iterator_rev	_	fn char_iterator_rev(bh: &mut BenchHarness) {$/;"	f
char_len	_	fn char_len(&self) -> uint { self.chars().len() }$/;"	f
char_len	_	fn char_len(&self) -> uint;$/;"	f
char_range_at	_	fn char_range_at(&self, i: uint) -> CharRange {$/;"	f
char_range_at	_	fn char_range_at(&self, start: uint) -> CharRange;$/;"	f
char_range_at_reverse	_	fn char_range_at_reverse(&self, start: uint) -> CharRange {$/;"	f
char_range_at_reverse	_	fn char_range_at_reverse(&self, start: uint) -> CharRange;$/;"	f
chars	_	fn chars<'r>(&'r mut self) -> Chars<'r, Self> {$/;"	f
chars	_	fn chars(&self) -> Chars<'a> {$/;"	f
chars	_	fn chars(&self) -> Chars<'a>;$/;"	f
chars_rev	_	fn chars_rev(&self) -> RevChars<'a> {$/;"	f
chars_rev	_	fn chars_rev(&self) -> RevChars<'a>;$/;"	f
chdir	_	pub fn chdir(dir: *c_char) -> c_int;$/;"	f
chdir	_	fn chdir(p: &Path) -> bool {$/;"	f
check	_	fn check(s: &str, c_str: *libc::c_char) {$/;"	f
check_for_errors_in	_	pub fn check_for_errors_in<T>(f: || -> T) -> Result<T, ~str> {$/;"	f
check_for_null	_	/^fn check_for_null(v: &[u0], buf: *mut libc::c_char) {$/;"	f
check_randacc_iter	_	fn check_randacc_iter<A: Eq, T: Clone + RandomAccessIterator<A>>(a: T, len: uint)$/;"	f
check_word_size	_	fn check_word_size() {$/;"	f
checked_add	_	fn checked_add(&self, v: &i0) -> Option<i0> {$/;"	f
checked_add	_	fn checked_add(&self, v: &i0) -> Option<i0> {$/;"	f
checked_add	_	fn checked_add(&self, v: &i0) -> Option<i0> {$/;"	f
checked_add	_	fn checked_add(&self, v: &i0) -> Option<i0> {$/;"	f
checked_add	_	fn checked_add(&self, v: &int) -> Option<int> {$/;"	f
checked_add	_	fn checked_add(&self, v: &Self) -> Option<Self>;$/;"	f
checked_add	_	fn checked_add(&self, v: &u0) -> Option<u0> {$/;"	f
checked_add	_	fn checked_add(&self, v: &u0) -> Option<u0> {$/;"	f
checked_add	_	fn checked_add(&self, v: &u0) -> Option<u0> {$/;"	f
checked_add	_	fn checked_add(&self, v: &u0) -> Option<u0> {$/;"	f
checked_add	_	fn checked_add(&self, v: &uint) -> Option<uint> {$/;"	f
checked_div	_	fn checked_div(&self, v: &$T) -> Option<$T> {$/;"	f
checked_div	_	fn checked_div(&self, v: &Self) -> Option<Self>;$/;"	f
checked_div	_	fn checked_div(&self, v: &$T) -> Option<$T> {$/;"	f
checked_mul	_	fn checked_mul(&self, v: &i0) -> Option<i0> {$/;"	f
checked_mul	_	fn checked_mul(&self, v: &i0) -> Option<i0> {$/;"	f
checked_mul	_	fn checked_mul(&self, v: &i0) -> Option<i0> {$/;"	f
checked_mul	_	fn checked_mul(&self, v: &i0) -> Option<i0> {$/;"	f
checked_mul	_	fn checked_mul(&self, v: &int) -> Option<int> {$/;"	f
checked_mul	_	fn checked_mul(&self, v: &Self) -> Option<Self>;$/;"	f
checked_mul	_	fn checked_mul(&self, v: &u0) -> Option<u0> {$/;"	f
checked_mul	_	fn checked_mul(&self, v: &u0) -> Option<u0> {$/;"	f
checked_mul	_	fn checked_mul(&self, v: &u0) -> Option<u0> {$/;"	f
checked_mul	_	fn checked_mul(&self, v: &u0) -> Option<u0> {$/;"	f
checked_mul	_	fn checked_mul(&self, v: &uint) -> Option<uint> {$/;"	f
checked_next_power_of_two	_	/^pub fn checked_next_power_of_two<T: Unsigned + Int>(n: T) -> Option<T> {$/;"	f
checked_sub	_	fn checked_sub(&self, v: &i0) -> Option<i0> {$/;"	f
checked_sub	_	fn checked_sub(&self, v: &i0) -> Option<i0> {$/;"	f
checked_sub	_	fn checked_sub(&self, v: &i0) -> Option<i0> {$/;"	f
checked_sub	_	fn checked_sub(&self, v: &i0) -> Option<i0> {$/;"	f
checked_sub	_	fn checked_sub(&self, v: &int) -> Option<int> {$/;"	f
checked_sub	_	fn checked_sub(&self, v: &Self) -> Option<Self>;$/;"	f
checked_sub	_	fn checked_sub(&self, v: &u0) -> Option<u0> {$/;"	f
checked_sub	_	fn checked_sub(&self, v: &u0) -> Option<u0> {$/;"	f
checked_sub	_	fn checked_sub(&self, v: &u0) -> Option<u0> {$/;"	f
checked_sub	_	fn checked_sub(&self, v: &u0) -> Option<u0> {$/;"	f
checked_sub	_	fn checked_sub(&self, v: &uint) -> Option<uint> {$/;"	f
child_no	_	fn child_no(x: uint) -> proc() {$/;"	f
chmod	_	/^pub fn chmod(path: &Path, mode: io::FilePermission) -> IoResult<()> {$/;"	f
chmod	_	pub fn chmod(path: *c_char, mode: c_int) -> c_int;$/;"	f
chmod	_	pub fn chmod(path: *c_char, mode: mode_t) -> c_int;$/;"	f
choose	_	fn choose<T: Clone>(&mut self, values: &[T]) -> T {$/;"	f
choose_option	_	fn choose_option<'a, T>(&mut self, values: &'a [T]) -> Option<&'a T> {$/;"	f
chown	_	/^pub fn chown(path: &Path, uid: int, gid: int) -> IoResult<()> {$/;"	f
chown	_	pub fn chown(path: *c_char, uid: uid_t, gid: gid_t) -> c_int;$/;"	f
chunks	_	fn chunks(self, size: uint) -> Chunks<'a, T> {$/;"	f
chunks	_	fn chunks(self, size: uint) -> Chunks<'a, T>;$/;"	f
claim	_	fn claim(&mut self, _alloc: &mut AllocHeader) {}$/;"	f
claim	_	fn claim(&mut self, alloc: &mut AllocHeader) {$/;"	f
classify	_	fn classify(&self) -> FPCategory {$/;"	f
classify	_	fn classify(&self) -> FPCategory {$/;"	f
classify	_	fn classify(&self) -> FPCategory;$/;"	f
cleanup	_	/^pub mod cleanup;$/;"	m
cleanup	_	pub fn cleanup() {$/;"	f
cleanup	_	pub unsafe fn cleanup() {$/;"	f
cleanup	_	pub unsafe fn cleanup() {$/;"	f
cleanup	_	pub unsafe fn cleanup() {}$/;"	f
cleanup	_	/^pub unsafe fn cleanup() {$/;"	f
cleanup_task	_	fn cleanup_task(mut t: ~Task) {$/;"	f
clear	_	fn clear(&mut self);$/;"	f
clear	_	fn clear(&mut self) {$/;"	f
clear	_	pub fn clear(&mut self, order: Ordering) {$/;"	f
clear	_	fn clear(&mut self) { self.truncate(0) }$/;"	f
clone	_	fn clone(&self) -> CString {$/;"	f
clone	_	fn clone(&self) -> Cell<T> {$/;"	f
clone	_	fn clone(&self) -> RefCell<T> {$/;"	f
clone	_	fn clone(&self) -> $t { *self }$/;"	f
clone	_	fn clone(&self) -> extern "Rust" fn($($A),*) -> ReturnType { *self }$/;"	f
clone	_	fn clone(&self) -> &'a T { *self }$/;"	f
clone	_	fn clone(&self) -> &'a [T] { *self }$/;"	f
clone	_	fn clone(&self) -> &'a str { *self }$/;"	f
clone	_	fn clone(&self) -> @T { *self }$/;"	f
clone	_	fn clone(&self) -> Self;$/;"	f
clone	_	fn clone(&self) -> ~T { ~(**self).clone() }$/;"	f
clone	_	fn clone(&self) -> Chan<T> {$/;"	f
clone	_	fn clone(&self) -> Gc<T> {$/;"	f
clone	_	fn clone(&self) -> SipState {$/;"	f
clone	_	fn clone(&self) -> ChanWriter {$/;"	f
clone	_	fn clone(&self) -> TcpStream {$/;"	f
clone	_	fn clone(&self) -> UdpSocket {$/;"	f
clone	_	fn clone(&self) -> UnixStream {$/;"	f
clone	_	fn clone(&self) -> PipeStream {$/;"	f
clone	_	fn clone(&self) -> Foo {$/;"	f
clone	_	/^pub mod clone;$/;"	m
clone	_	fn clone(&self) -> *T {$/;"	f
clone	_	fn clone(&self) -> *mut T {$/;"	f
clone	_	fn clone(&self) -> Rc<T> {$/;"	f
clone	_	fn clone(&self) -> Weak<T> {$/;"	f
clone	_	pub fn clone() -> Option<~[~[u0]]> {$/;"	f
clone	_	fn clone(&self) -> ~RtioPipe;$/;"	f
clone	_	fn clone(&self) -> ~RtioTcpStream;$/;"	f
clone	_	fn clone(&self) -> ~RtioUdpSocket;$/;"	f
clone	_	fn clone(&self) -> MaybeOwned<'a> {$/;"	f
clone	_	fn clone(&self) -> ~str {$/;"	f
clone	_	fn clone(&self) -> UnsafeArc<T> {$/;"	f
clone	_	fn clone(&self) -> BufferPool<T> { BufferPool { pool: self.pool.clone() } }$/;"	f
clone	_	fn clone(&self) -> Stealer<T> { Stealer { deque: self.deque.clone() } }$/;"	f
clone	_	fn clone(&self) -> Queue<T> {$/;"	f
clone	_	fn clone(&self) -> ($($T,)+) {$/;"	f
clone	_	fn clone(&self) -> Exclusive<T> {$/;"	f
clone	_	fn clone(&self) -> S {$/;"	f
clone	_	fn clone(&self) -> Items<'a, T> { *self }$/;"	f
clone	_	fn clone(&self) -> ~[A] {$/;"	f
clone	_	fn clone(&self) -> Vec<T> {$/;"	f
clone_chan	_	pub fn clone_chan(&mut self) {$/;"	f
clone_from	_	fn clone_from(&mut self, source: &Self) {$/;"	f
clone_from	_	fn clone_from(&mut self, source: &~T) {$/;"	f
clone_from	_	fn clone_from(&mut self, source: &~[A]) {$/;"	f
close	_	pub fn close(fd: c_int) -> c_int;$/;"	f
close	_	/^pub fn close(fd: int) -> int {$/;"	f
close	_	pub unsafe fn close(handle: *u0) {$/;"	f
close_outputs	_	fn close_outputs() {$/;"	f
closedir	_	pub fn closedir(dirp: *DIR) -> c_int;$/;"	f
closesocket	_	pub fn closesocket(socket: SOCKET) -> c_int;$/;"	f
closure_exchange_malloc	_	/^pub unsafe fn closure_exchange_malloc(drop_glue: fn(*mut u0), size: uint, align: uint) -> *u0 {$/;"	f
closure_exchange_malloc_	_	/^pub unsafe fn closure_exchange_malloc_(drop_glue: fn(*mut u0), size: uint, align: uint) -> *u0 {$/;"	f
cmath	_	/^mod cmath;$/;"	m
cmp	_	fn cmp(&self, other: &bool) -> Ordering {$/;"	f
cmp	_	fn cmp(&self, other: &$t) -> Ordering {$/;"	f
cmp	_	fn cmp(&self, other: &Ordering) -> Ordering {$/;"	f
cmp	_	fn cmp(&self, other: &Self) -> Ordering;$/;"	f
cmp	_	pub fn cmp<A: TotalOrd, T: Iterator<A>>(mut a: T, mut b: T) -> cmp::Ordering {$/;"	f
cmp	_	fn cmp(&self, other: &@T) -> Ordering { (**self).cmp(*other) }$/;"	f
cmp	_	fn cmp(&self, other: &~T) -> Ordering { (**self).cmp(*other) }$/;"	f
cmp	_	fn cmp(&self, other: & &'a T) -> Ordering { (**self).cmp(*other) }$/;"	f
cmp	_	fn cmp(&self, other: & &'a str) -> Ordering {$/;"	f
cmp	_	fn cmp(&self, other: &~str) -> Ordering { self.as_slice().cmp(&other.as_slice()) }$/;"	f
cmp	_	fn cmp(&self, other: &MaybeOwned) -> Ordering {$/;"	f
cmp	_	fn cmp(&self, other: &($($T,)+)) -> Ordering {$/;"	f
cmp	_	fn cmp(&self, _other: &()) -> Ordering { Equal }$/;"	f
cmp	_	fn cmp(&self, other: & &'a [T]) -> Ordering {$/;"	f
cmp	_	fn cmp(&self, other: &~[T]) -> Ordering { self.as_slice().cmp(&other.as_slice()) }$/;"	f
cmp	_	fn cmp(&self, other: &Vec<T>) -> Ordering {$/;"	f
cmp0	_	/^pub fn cmp0<A:TotalOrd,B:TotalOrd>($/;"	f
collect	_	fn collect<B: FromIterator<A>>(&mut self) -> B {$/;"	f
collect	_	/^pub fn collect<T, Iter: Iterator<Option<T>>, V: FromIterator<T>>(iter: Iter) -> Option<V> {$/;"	f
collect	_	/^pub fn collect<T, E, Iter: Iterator<Result<T, E>>, V: FromIterator<T>>(iter: Iter) -> Result<V, E> {$/;"	f
collect_failure	_	pub fn collect_failure(&mut self, result: TaskResult) {$/;"	f
combine	_	/^fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i0) -> IoResult<u0> {$/;"	f
comm	_	/^pub mod comm;$/;"	m
comm_adapters	_	/^mod comm_adapters;$/;"	m
comm_shared_chan	_	fn comm_shared_chan() {$/;"	f
comm_stream	_	fn comm_stream() {$/;"	f
commit	_	pub fn commit(fd: c_int) -> c_int;$/;"	f
common	_	pub mod common {$/;"	m
common	_	pub mod common {$/;"	m
comp_requires_verbatim	_	fn comp_requires_verbatim(s: &str) -> bool {$/;"	f
compare_and_swap	_	pub fn compare_and_swap(&mut self, old: *mut T, new: *mut T, order: Ordering) -> *mut T {$/;"	f
compare_and_swap	_	pub fn compare_and_swap(&mut self, old: bool, new: bool, order: Ordering) -> bool {$/;"	f
compare_and_swap	_	pub fn compare_and_swap(&mut self, old: int, new: int, order: Ordering) -> int {$/;"	f
compare_and_swap	_	pub fn compare_and_swap(&mut self, old: u0, new: u0, order: Ordering) -> u0 {$/;"	f
compare_and_swap	_	pub fn compare_and_swap(&mut self, old: uint, new: uint, order: Ordering) -> uint {$/;"	f
compatibility	_	pub fn compatibility(c: char, i: |char|) { d(c, i, true); }$/;"	f
compiled	_	/^pub mod compiled {$/;"	m
components	_	pub fn components<'a>(&'a self) -> Components<'a> {$/;"	f
components	_	pub fn components<'a>(&'a self) -> Components<'a> {$/;"	f
concat	_	fn concat(&self) -> ~str {$/;"	f
concat	_	fn concat(&self) -> ~str;$/;"	f
concat	_	fn concat(bh: &mut BenchHarness) {$/;"	f
concat_vec	_	fn concat_vec(&self) -> ~[T] {$/;"	f
concat_vec	_	fn concat_vec(&self) -> ~[T];$/;"	f
configure	_	pub fn configure(config: ProcessConfig) -> IoResult<Process> {$/;"	f
connect	_	fn connect(i: int, addr: SocketAddr) {$/;"	f
connect	_	pub fn connect(addr: SocketAddr) -> IoResult<TcpStream> {$/;"	f
connect	_	pub fn connect(self, other: SocketAddr) -> UdpStream {$/;"	f
connect	_	pub fn connect<P: ToCStr>(path: &P) -> IoResult<UnixStream> {$/;"	f
connect	_	pub fn connect(socket: SOCKET, address: *sockaddr,$/;"	f
connect	_	pub fn connect(socket: c_int, address: *sockaddr,$/;"	f
connect	_	fn connect(&self, sep: &str) -> ~str {$/;"	f
connect	_	fn connect(&self, sep: &str) -> ~str;$/;"	f
connect	_	fn connect(bh: &mut BenchHarness) {$/;"	f
connect_vec	_	fn connect_vec(&self, sep: &T) -> ~[T] {$/;"	f
connect_vec	_	fn connect_vec(&self, sep: &T) -> ~[T];$/;"	f
construct_range	_	fn construct_range(low: $ty, high: $ty) -> Range<$ty> {$/;"	f
construct_range	_	fn construct_range(low: Self, high: Self) -> Range<Self>;$/;"	f
consts	_	/^pub mod consts {$/;"	m
consts	_	/^pub mod consts {$/;"	m
consts	_	/^pub mod consts {$/;"	m
consts	_	/^pub mod consts {$/;"	m
consume	_	fn consume(&mut self, c: char) -> bool {$/;"	f
consume	_	fn consume(&mut self, amt: uint) { self.inner.consume(amt) }$/;"	f
consume	_	fn consume(&mut self, amt: uint) {$/;"	f
consume	_	fn consume(&mut self, amt: uint) { self.pos += amt; }$/;"	f
consume	_	fn consume(&mut self, amt: uint);$/;"	f
container	_	/^pub mod container;$/;"	m
container_as_bytes	_	fn container_as_bytes<'a>(&'a self) -> &'a [u0] {$/;"	f
container_as_bytes	_	fn container_as_bytes<'a>(&'a self) -> &'a [u0];$/;"	f
container_as_bytes	_	fn container_as_bytes<'b>(&'b self) -> &'b [u0] {$/;"	f
container_as_bytes	_	fn container_as_bytes<'a>(&'a self) -> &'a [u0] {$/;"	f
container_as_bytes	_	fn container_as_bytes<'a>(&'a self) -> &'a [u0] {$/;"	f
container_as_str	_	fn container_as_str<'a>(&'a self) -> Option<&'a str> {$/;"	f
container_as_str	_	fn container_as_str<'b>(&'b self) -> Option<&'b str> {$/;"	f
container_as_str	_	fn container_as_str<'a>(&'a self) -> Option<&'a str> {$/;"	f
container_into_owned_bytes	_	fn container_into_owned_bytes(self) -> ~[u0] {$/;"	f
container_into_owned_bytes	_	fn container_into_owned_bytes(self) -> ~[u0] {$/;"	f
container_into_owned_bytes	_	fn container_into_owned_bytes(self) -> ~[u0] {$/;"	f
contains	_	fn contains(&self, value: &T) -> bool;$/;"	f
contains	_	fn contains<'a>(&self, needle: &'a str) -> bool {$/;"	f
contains	_	fn contains<'a>(&self, needle: &'a str) -> bool;$/;"	f
contains	_	fn contains(&self, x: &T) -> bool {$/;"	f
contains	_	fn contains(&self, x: &T) -> bool;$/;"	f
contains	_	pub fn contains(&self, x: &T) -> bool {$/;"	f
contains_char	_	fn contains_char(&self, needle: char) -> bool {$/;"	f
contains_char	_	fn contains_char(&self, needle: char) -> bool;$/;"	f
contains_key	_	fn contains_key(&self, key: &K) -> bool {$/;"	f
contains_last_element	_	fn contains_last_element(bh: &mut BenchHarness) {$/;"	f
contains_nul	_	/^fn contains_nul(v: &[u0]) -> bool {$/;"	f
control_congestion	_	fn control_congestion(&mut self) -> Result<(), IoError>;$/;"	f
convert	_	fn convert<'a>(x: Option<&'a str>) -> &'a [u0] {$/;"	f
copy	_	/^pub fn copy(from: &Path, to: &Path) -> IoResult<()> {$/;"	f
copy	_	/^pub fn copy<R: Reader, W: Writer>(r: &mut R, w: &mut W) -> io::IoResult<()> {$/;"	f
copy_from	_	fn copy_from(self, &[T]) -> uint;$/;"	f
copy_from	_	fn copy_from(self, src: &[T]) -> uint {$/;"	f
copy_lifetime	_	/^pub unsafe fn copy_lifetime<'a,S,T>(_ptr: &'a S, ptr: &T) -> &'a T {$/;"	f
copy_lifetime_vec	_	/^pub unsafe fn copy_lifetime_vec<'a,S,T>(_ptr: &'a [S], ptr: &T) -> &'a T {$/;"	f
copy_memory	_	pub fn copy_memory<T>(dst: *mut T, src: *T, count: uint);$/;"	f
copy_memory	_	/^pub unsafe fn copy_memory<T>(dst: *mut T, src: *T, count: uint) {$/;"	f
copy_memory	_	pub fn copy_memory(dst: &mut [u0], src: &[u0]) {$/;"	f
copy_memory	_	unsafe fn copy_memory(self, src: &[T]) {$/;"	f
copy_memory	_	unsafe fn copy_memory(self, src: &[T]);$/;"	f
copy_mut_lifetime	_	/^pub unsafe fn copy_mut_lifetime<'a,S,T>(_ptr: &'a mut S, ptr: &mut T) -> &'a mut T {$/;"	f
copy_nonoverlapping_memory	_	pub fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *T, count: uint);$/;"	f
copy_nonoverlapping_memory	_	/^pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T,$/;"	f
copysign	_	fn copysign(x: f0, y: f0) -> f0 = intrinsics::copysignf0,$/;"	f
copysign	_	fn copysign(x: f0, y: f0) -> f0 = intrinsics::copysignf0,$/;"	f
copysignf0	_	pub fn copysignf0(x: f0, y: f0) -> f0;$/;"	f
copysignf0	_	pub fn copysignf0(x: f0, y: f0) -> f0;$/;"	f
cos	_	fn cos(&self) -> f0 { cos(*self) }$/;"	f
cos	_	fn cos(n: f0) -> f0 = intrinsics::cosf0,$/;"	f
cos	_	fn cos(&self) -> f0 { cos(*self) }$/;"	f
cos	_	fn cos(n: f0) -> f0 = intrinsics::cosf0,$/;"	f
cos	_	fn cos(&self) -> Self;$/;"	f
cosf0	_	pub fn cosf0(x: f0) -> f0;$/;"	f
cosf0	_	pub fn cosf0(x: f0) -> f0;$/;"	f
cosh	_	pub fn cosh(n: c_double) -> c_double;$/;"	f
cosh	_	pub fn cosh(n: c_float) -> c_float;$/;"	f
cosh	_	fn cosh(&self) -> f0 { cosh(*self) }$/;"	f
cosh	_	fn cosh(n: c_float) -> c_float = cmath::c_float::cosh,$/;"	f
cosh	_	fn cosh(&self) -> f0 { cosh(*self) }$/;"	f
cosh	_	fn cosh(n: c_double) -> c_double = cmath::c_double::cosh,$/;"	f
cosh	_	fn cosh(&self) -> Self;$/;"	f
count	_	fn count(&mut self) -> Count<'a> {$/;"	f
count	_	fn count(st: &mut uint) -> Option<uint> {$/;"	f
count	_	fn count(&mut self, predicate: |A| -> bool) -> uint {$/;"	f
count	_	/^pub fn count<A>(start: A, step: A) -> Counter<A> {$/;"	f
count_ones	_	fn count_ones(&self) -> i0 { unsafe { intrinsics::ctpop0(*self) } }$/;"	f
count_ones	_	fn count_ones(&self) -> i0 { unsafe { intrinsics::ctpop0(*self) } }$/;"	f
count_ones	_	fn count_ones(&self) -> i0 { unsafe { intrinsics::ctpop0(*self) } }$/;"	f
count_ones	_	fn count_ones(&self) -> i0 { unsafe { intrinsics::ctpop0(*self) } }$/;"	f
count_ones	_	fn count_ones(&self) -> int { (*self as i0).count_ones() as int }$/;"	f
count_ones	_	fn count_ones(&self) -> int { (*self as i0).count_ones() as int }$/;"	f
count_ones	_	fn count_ones(&self) -> Self;$/;"	f
count_ones	_	fn count_ones(&self) -> $T {$/;"	f
count_zeros	_	fn count_zeros(&self) -> Self {$/;"	f
crate_map	_	/^pub mod crate_map;$/;"	m
creat	_	pub fn creat(path: *c_char, mode: c_int) -> c_int;$/;"	f
creat	_	pub fn creat(path: *c_char, mode: mode_t) -> c_int;$/;"	f
create	_	pub fn create(path: &Path) -> IoResult<File> {$/;"	f
create	_	pub unsafe fn create(stack: uint, p: ~proc()) -> rust_thread {$/;"	f
create	_	/^pub unsafe fn create(key: &mut Key) {$/;"	f
ctlz0	_	pub fn ctlz0(x: i0) -> i0;$/;"	f
ctlz0	_	pub fn ctlz0(x: i0) -> i0;$/;"	f
ctlz0	_	pub fn ctlz0(x: i0) -> i0;$/;"	f
ctlz0	_	pub fn ctlz0(x: i0) -> i0;$/;"	f
ctpop0	_	pub fn ctpop0(x: i0) -> i0;$/;"	f
ctpop0	_	pub fn ctpop0(x: i0) -> i0;$/;"	f
ctpop0	_	pub fn ctpop0(x: i0) -> i0;$/;"	f
ctpop0	_	pub fn ctpop0(x: i0) -> i0;$/;"	f
cttz0	_	pub fn cttz0(x: i0) -> i0;$/;"	f
cttz0	_	pub fn cttz0(x: i0) -> i0;$/;"	f
cttz0	_	pub fn cttz0(x: i0) -> i0;$/;"	f
cttz0	_	pub fn cttz0(x: i0) -> i0;$/;"	f
ctype	_	pub mod ctype {$/;"	m
cycle	_	fn cycle(self) -> Cycle<Self>;$/;"	f
cycle	_	fn cycle(self) -> Cycle<T> {$/;"	f
d	_	fn d(c: char, i: |char|, k: bool) {$/;"	f
darwin_fd_limit	_	/^mod darwin_fd_limit {$/;"	m
data	_	fn data() { assert_eq!(Thread::start(proc () { 0 }).join(), 0); }$/;"	f
datasync	_	pub fn datasync(&mut self) -> IoResult<()> {$/;"	f
datasync	_	fn datasync(&mut self) -> Result<(), IoError>;$/;"	f
debug_borrow	_	/^pub fn debug_borrow() -> bool {$/;"	f
debug_mem	_	/^fn debug_mem() -> bool {$/;"	f
decompose	_	/^pub mod decompose {$/;"	m
decompose_canonical	_	/^pub fn decompose_canonical(c: char, f: |char|) {$/;"	f
decompose_compatible	_	/^pub fn decompose_compatible(c: char, f: |char|) {$/;"	f
decompose_hangul	_	/^fn decompose_hangul(s: char, f: |char|) {$/;"	f
decrement	_	fn decrement(&mut self, task: BlockedTask) -> Result<(), BlockedTask> {$/;"	f
decrement	_	fn decrement(&mut self, task: BlockedTask) -> Result<(), BlockedTask> {$/;"	f
decrement	_	/^pub fn decrement() {$/;"	f
dedup	_	fn dedup(&mut self) {$/;"	f
dedup	_	fn dedup(&mut self);$/;"	f
deep_clone	_	fn deep_clone(&self) -> RefCell<T> {$/;"	f
deep_clone	_	fn deep_clone(&self) -> $t { *self }$/;"	f
deep_clone	_	fn deep_clone(&self) -> extern "Rust" fn($($A),*) -> ReturnType { *self }$/;"	f
deep_clone	_	fn deep_clone(&self) -> @T { @(**self).deep_clone() }$/;"	f
deep_clone	_	fn deep_clone(&self) -> Self;$/;"	f
deep_clone	_	fn deep_clone(&self) -> ~T { ~(**self).deep_clone() }$/;"	f
deep_clone	_	fn deep_clone(&self) -> Gc<T> {$/;"	f
deep_clone	_	fn deep_clone(&self) -> Rc<T> {$/;"	f
deep_clone	_	fn deep_clone(&self) -> MaybeOwned<'a> {$/;"	f
deep_clone	_	fn deep_clone(&self) -> ~str {$/;"	f
deep_clone	_	fn deep_clone(&self) -> ~[A] {$/;"	f
deep_clone_from	_	fn deep_clone_from(&mut self, source: &Self) {$/;"	f
deep_clone_from	_	fn deep_clone_from(&mut self, source: &~T) {$/;"	f
deep_clone_from	_	fn deep_clone_from(&mut self, source: &~[A]) {$/;"	f
default	_	fn default() -> bool { false }$/;"	f
default	_	fn default() -> char { '\\x0' }$/;"	f
default	_	fn default() -> @T { @Default::default() }$/;"	f
default	_	fn default() -> Self;$/;"	f
default	_	fn default() -> ~T { ~Default::default() }$/;"	f
default	_	fn default() -> SipHasher {$/;"	f
default	_	fn default() -> SipState {$/;"	f
default	_	/^pub mod default;$/;"	m
default	_	fn default() -> f0 { 0.0 }$/;"	f
default	_	fn default() -> f0 { 0.0 }$/;"	f
default	_	fn default() -> $T { 0 }$/;"	f
default	_	fn default() -> $T { 0 }$/;"	f
default	_	fn default() -> Option<T> { None }$/;"	f
default	_	fn default() -> Counter {$/;"	f
default	_	fn default() -> ReseedWithDefault { ReseedWithDefault }$/;"	f
default	_	fn default() -> &'a str { "" }$/;"	f
default	_	fn default() -> MaybeOwned<'a> { Slice("") }$/;"	f
default	_	fn default() -> ~str { ~"" }$/;"	f
default	_	fn default() -> ($($T,)+) {$/;"	f
default	_	fn default() -> () { () }$/;"	f
default	_	fn default() -> &'a [A] { &'a [] }$/;"	f
default	_	fn default() -> ~[A] { ~[] }$/;"	f
default	_	fn default() -> Vec<T> {$/;"	f
default_sched_threads	_	/^pub fn default_sched_threads() -> uint {$/;"	f
defined	_	/^trait defined in this module. For loops can be viewed as a syntactical expansion$/;"	t
deque	_	pub fn deque(&mut self) -> (Worker<T>, Stealer<T>) {$/;"	f
deque	_	/^pub mod deque;$/;"	m
deref	_	fn deref<'a>(&'a self) -> &'a T {$/;"	f
deref	_	fn deref<'a>(&'a self) -> &'a Result;$/;"	f
deref	_	fn deref<'a>(&'a self) -> &'a T {$/;"	f
deref_mut	_	fn deref_mut<'a>(&'a mut self) -> &'a mut T {$/;"	f
deref_mut	_	fn deref_mut<'a>(&'a mut self) -> &'a mut Result;$/;"	f
derived_property	_	/^pub mod derived_property {$/;"	m
deschedule	_	fn deschedule(~self, times: uint, cur_task: ~Task,$/;"	f
deschedule	_	pub fn deschedule(mut ~self, amt: uint,$/;"	f
deschedule	_	/^pub fn deschedule() {$/;"	f
describe	_	fn describe(&self) -> &'static str {$/;"	f
destroy	_	/^pub unsafe fn destroy(key: Key) {$/;"	f
destroy	_	pub unsafe fn destroy(&mut self) {$/;"	f
destroy	_	pub unsafe fn destroy(&mut self) { self.inner.destroy() }$/;"	f
destroy_immediately	_	fn destroy_immediately() {$/;"	f
detach	_	pub unsafe fn detach(native: rust_thread) {$/;"	f
detached	_	fn detached() { Thread::spawn(proc () {}) }$/;"	f
different_sizes	_	fn different_sizes() {$/;"	f
digit	_	fn digit(&self, x: u0) -> u0 {$/;"	f
digit	_	fn digit(&self, x: u0) -> u0 {$/;"	f
digit	_	fn digit(&self, x: u0) -> u0;$/;"	f
digits	_	fn digits(_: Option<f0>) -> uint { 0 }$/;"	f
digits	_	fn digits(_: Option<f0>) -> uint { 0 }$/;"	f
digits	_	fn digits(unused_self: Option<Self>) -> uint;$/;"	f
dir_path	_	fn dir_path(&self) -> Self {$/;"	f
dir_path	_	fn dir_path(&self) -> Path {$/;"	f
dirent	_	pub mod dirent {$/;"	m
dirent_t	_	pub enum dirent_t {}$/;"	g
dirname	_	fn dirname<'a>(&'a self) -> &'a [u0];$/;"	f
dirname	_	fn dirname<'a>(&'a self) -> &'a [u0] {$/;"	f
dirname	_	fn dirname<'a>(&'a self) -> &'a [u0] {$/;"	f
dirname_str	_	fn dirname_str<'a>(&'a self) -> Option<&'a str> {$/;"	f
dirname_str	_	fn dirname_str<'a>(&'a self) -> Option<&'a str> {$/;"	f
discard_doesnt_unborrow	_	fn discard_doesnt_unborrow() {$/;"	f
disconnect	_	pub fn disconnect(self) -> UdpSocket { self.socket }$/;"	f
display	_	fn display<'a>(&'a self) -> Display<'a, Self> {$/;"	f
distributions	_	/^pub mod distributions;$/;"	m
div	_	fn div(&self, other: &f0) -> f0 { *self \/ *other }$/;"	f
div	_	fn div(&self, other: &f0) -> f0 { *self \/ *other }$/;"	f
div	_	fn div(&self, other: &$T) -> $T { *self \/ *other }$/;"	f
div	_	fn div(&self, other: &$T) -> $T { *self \/ *other }$/;"	f
div	_	fn div(&self, rhs: &RHS) -> Result;$/;"	f
div_rem	_	/^pub fn div_rem<T: Div<T, T> + Rem<T, T>>(x: T, y: T) -> (T, T) {$/;"	f
dl	_	/^pub mod dl {$/;"	m
dlclose	_	fn dlclose(handle: *libc::c_void) -> libc::c_int;$/;"	f
dlerror	_	fn dlerror() -> *libc::c_char;$/;"	f
dll_filename	_	/^pub fn dll_filename(base: &str) -> ~str {$/;"	f
dlopen	_	fn dlopen(filename: *libc::c_char, flag: libc::c_int) -> *libc::c_void;$/;"	f
dlsym	_	fn dlsym(handle: *libc::c_void, symbol: *libc::c_char) -> *libc::c_void;$/;"	f
do_inspect	_	fn do_inspect(&self, elt: Option<A>) -> Option<A> {$/;"	f
do_iter_crate_map	_	/^fn do_iter_crate_map<'a>($/;"	f
do_map	_	fn do_map(&self, elt: Option<A>) -> Option<B> {$/;"	f
do_send	_	fn do_send(&mut self, t: Message<T>) -> UpgradeResult {$/;"	f
do_some_fallible_work	_	fn do_some_fallible_work() {}$/;"	f
dont_accept_simultaneously	_	fn dont_accept_simultaneously(&mut self) -> Result<(), IoError>;$/;"	f
dont_loop_multicast_locally	_	fn dont_loop_multicast_locally(&mut self) -> Result<(), IoError>;$/;"	f
double_borrow_single_release_no_borrow_mut	_	fn double_borrow_single_release_no_borrow_mut() {$/;"	f
double_imm_borrow	_	fn double_imm_borrow() {$/;"	f
downgrade	_	pub fn downgrade(&self) -> Weak<T> {$/;"	f
drop	_	fn drop(&mut self) {$/;"	f
drop	_	fn drop(&mut self) {$/;"	f
drop	_	fn drop(&mut self) {$/;"	f
drop	_	fn drop(&mut self) {$/;"	f
drop	_	fn drop(&mut self) {$/;"	f
drop	_	fn drop(&mut self) {$/;"	f
drop	_	fn drop(&mut self) {$/;"	f
drop	_	fn drop(&mut self) {$/;"	f
drop	_	fn drop(&mut self) {$/;"	f
drop	_	fn drop(&mut self) {$/;"	f
drop	_	fn drop(&mut self) {$/;"	f
drop	_	/^pub fn drop<T>(_x: T) { }$/;"	f
drop	_	fn drop(&mut self) {$/;"	f
drop	_	fn drop(&mut self);$/;"	f
drop	_	fn drop(&mut self) {$/;"	f
drop	_	fn drop(&mut self) {$/;"	f
drop	_	fn drop(&mut self) {$/;"	f
drop	_	fn drop(&mut self) {$/;"	f
drop	_	fn drop(&mut self) {$/;"	f
drop	_	fn drop(&mut self) {$/;"	f
drop	_	fn drop(&mut self) {$/;"	f
drop	_	fn drop(&mut self) {$/;"	f
drop	_	fn drop(&mut self) {$/;"	f
drop	_	fn drop(&mut self) {$/;"	f
drop	_	fn drop(&mut self) {$/;"	f
drop	_	fn drop(&mut self) {$/;"	f
drop	_	fn drop(&mut self) {$/;"	f
drop	_	fn drop(&mut self) {$/;"	f
drop	_	fn drop(&mut self) {$/;"	f
drop	_	fn drop(&mut self) {$/;"	f
drop	_	fn drop(&mut self) {$/;"	f
drop	_	fn drop(&mut self) {$/;"	f
drop	_	fn drop(&mut self) {$/;"	f
drop_chan	_	pub fn drop_chan(&mut self) {$/;"	f
drop_chan	_	pub fn drop_chan(&mut self) {$/;"	f
drop_chan	_	pub fn drop_chan(&mut self) {$/;"	f
drop_full	_	fn drop_full() {$/;"	f
drop_port	_	pub fn drop_port(&mut self) {$/;"	f
drop_port	_	pub fn drop_port(&mut self) {$/;"	f
drop_port	_	pub fn drop_port(&mut self) {$/;"	f
dumb_println	_	/^pub fn dumb_println(args: &fmt::Arguments) {$/;"	f
dup	_	pub fn dup(fd: c_int) -> c_int;$/;"	f
dup0	_	pub fn dup0(src: c_int, dst: c_int) -> c_int;$/;"	f
dynamic_lib	_	/^pub mod dynamic_lib;$/;"	m
e	_	fn e() -> f0 { 0.0 }$/;"	f
e	_	fn e() -> f0 { 0.0 }$/;"	f
e	_	fn e() -> Self;$/;"	f
eabi	_	/^pub mod eabi {$/;"	m
each_live_alloc	_	/^unsafe fn each_live_alloc(read_next_before: bool,$/;"	f
empty	_	pub fn empty() -> AtomicOption<T> { AtomicOption { p: 0 } }$/;"	f
encode_utf0	_	fn encode_utf0(&self, dst: &mut [u0]) -> uint;$/;"	f
encode_utf0	_	fn encode_utf0<'a>(&self, dst: &'a mut [u0]) -> uint {$/;"	f
ends_with	_	fn ends_with(&self, needle: &str) -> bool {$/;"	f
ends_with	_	fn ends_with(&self, needle: &str) -> bool;$/;"	f
ends_with	_	fn ends_with(&self, needle: &[T]) -> bool {$/;"	f
ends_with	_	fn ends_with(&self, needle: &[T]) -> bool;$/;"	f
ends_with_diff_one_element_at_beginning	_	fn ends_with_diff_one_element_at_beginning(bh: &mut BenchHarness) {$/;"	f
ends_with_path	_	fn ends_with_path(&self, child: &Self) -> bool;$/;"	f
ends_with_path	_	fn ends_with_path(&self, child: &Path) -> bool {$/;"	f
ends_with_path	_	fn ends_with_path(&self, child: &Path) -> bool {$/;"	f
ends_with_path_home_dir	_	fn ends_with_path_home_dir(bh: &mut BenchHarness) {$/;"	f
ends_with_path_missmatch_jome_home	_	fn ends_with_path_missmatch_jome_home(bh: &mut BenchHarness) {$/;"	f
ends_with_same_vector	_	fn ends_with_same_vector(bh: &mut BenchHarness) {$/;"	f
ends_with_single_element	_	fn ends_with_single_element(bh: &mut BenchHarness) {$/;"	f
enumerate	_	fn enumerate(self) -> Enumerate<Self> {$/;"	f
env	_	/^pub fn env() -> ~[(~str,~str)] {$/;"	f
env	_	/^pub mod env;$/;"	m
env_as_bytes	_	/^pub fn env_as_bytes() -> ~[(~[u0],~[u0])] {$/;"	f
env_convert	_	fn env_convert(input: ~[~[u0]]) -> ~[(~[u0], ~[u0])] {$/;"	f
eof	_	pub fn eof(&self) -> bool {$/;"	f
eof	_	pub fn eof(&self) -> bool { self.pos >= self.buf.len() }$/;"	f
epsilon	_	fn epsilon() -> f0 { 0.0e-0 }$/;"	f
epsilon	_	fn epsilon() -> f0 { 0.0e-0 }$/;"	f
epsilon	_	fn epsilon() -> Self;$/;"	f
eq	_	fn eq(&self, other: &bool) -> bool { (*self) == (*other) }$/;"	f
eq	_	fn eq(&self, other: &CString) -> bool {$/;"	f
eq	_	fn eq(&self, other: &Cell<T>) -> bool {$/;"	f
eq	_	fn eq(&self, other: &RefCell<T>) -> bool {$/;"	f
eq	_	fn eq(&self, other: &char) -> bool { (*self) == (*other) }$/;"	f
eq	_	fn eq(&self, other: &Self) -> bool;$/;"	f
eq	_	pub fn eq<A: Eq, T: Iterator<A>>(mut a: T, mut b: T) -> bool {$/;"	f
eq	_	fn eq(&self, other: &@T) -> bool { *(*self) == *(*other) }$/;"	f
eq	_	fn eq(&self, other: &f0) -> bool { (*self) == (*other) }$/;"	f
eq	_	fn eq(&self, other: &f0) -> bool { (*self) == (*other) }$/;"	f
eq	_	fn eq(&self, other: &$T) -> bool { return (*self) == (*other); }$/;"	f
eq	_	fn eq(&self, other: &$T) -> bool { return (*self) == (*other); }$/;"	f
eq	_	fn eq(&self, other: &~T) -> bool { *(*self) == *(*other) }$/;"	f
eq	_	fn eq(&self, other: &Path) -> bool {$/;"	f
eq	_	fn eq(&self, other: &Path) -> bool {$/;"	f
eq	_	fn eq(&self, other: &extern "C" fn($($p),*) -> _R) -> bool {$/;"	f
eq	_	fn eq(&self, other: &extern "C" fn() -> _R) -> bool {$/;"	f
eq	_	fn eq(&self, other: &*T) -> bool {$/;"	f
eq	_	fn eq(&self, other: &*mut T) -> bool {$/;"	f
eq	_	fn eq(&self, other: &Rc<T>) -> bool { *self.borrow() == *other.borrow() }$/;"	f
eq	_	fn eq(&self, other: & &'a T) -> bool {$/;"	f
eq	_	fn eq(&self, other: & &'a str) -> bool {$/;"	f
eq	_	fn eq(&self, other: &~str) -> bool {$/;"	f
eq	_	fn eq(&self, other: &MaybeOwned) -> bool {$/;"	f
eq	_	/^pub fn eq(a: &~str, b: &~str) -> bool {$/;"	f
eq	_	fn eq(&self, other: &($($T,)+)) -> bool {$/;"	f
eq	_	fn eq(&self, _other: &()) -> bool { true }$/;"	f
eq	_	fn eq(&self, other: & &'a [T]) -> bool {$/;"	f
eq	_	fn eq(&self, other: &~[T]) -> bool { self.as_slice() == *other }$/;"	f
eq	_	fn eq(&self, other: &Vec<T>) -> bool {$/;"	f
eq_ignore_ascii_case	_	fn eq_ignore_ascii_case(&self, other: &str) -> bool {$/;"	f
eq_ignore_ascii_case	_	fn eq_ignore_ascii_case(&self, other: &str) -> bool;$/;"	f
eq_ignore_case	_	fn eq_ignore_case(self, other: &[Ascii]) -> bool {$/;"	f
eq_ignore_case	_	fn eq_ignore_case(self, other: &[Ascii]) -> bool;$/;"	f
eq_ignore_case	_	pub fn eq_ignore_case(self, other: Ascii) -> bool {$/;"	f
eq_slice	_	/^pub fn eq_slice(a: &str, b: &str) -> bool {$/;"	f
eq_slice_	_	/^fn eq_slice_(a: &str, b: &str) -> bool {$/;"	f
equals	_	fn equals(&self, other: &$t) -> bool { *self == *other }$/;"	f
equals	_	fn equals(&self, other: &Ordering) -> bool {$/;"	f
equals	_	fn equals(&self, other: &Self) -> bool;$/;"	f
equals	_	pub fn equals<A: TotalEq, T: Iterator<A>>(mut a: T, mut b: T) -> bool {$/;"	f
equals	_	fn equals(&self, other: &@T) -> bool { (**self).equals(*other) }$/;"	f
equals	_	fn equals(&self, other: &~T) -> bool { (**self).equals(*other) }$/;"	f
equals	_	fn equals(&self, other: & &'a T) -> bool { (**self).equals(*other) }$/;"	f
equals	_	fn equals(&self, other: & &'a str) -> bool {$/;"	f
equals	_	fn equals(&self, other: &~str) -> bool {$/;"	f
equals	_	fn equals(&self, other: &MaybeOwned) -> bool {$/;"	f
equals	_	fn equals(&self, other: &($($T,)+)) -> bool {$/;"	f
equals	_	fn equals(&self, _other: &()) -> bool { true }$/;"	f
equals	_	fn equals(&self, other: & &'a [T]) -> bool {$/;"	f
equals	_	fn equals(&self, other: &~[T]) -> bool { self.as_slice().equals(&other.as_slice()) }$/;"	f
equals	_	fn equals(&self, other: &Vec<T>) -> bool {$/;"	f
equiv	_	fn equiv(&self, other: &T) -> bool;$/;"	f
equiv	_	fn equiv(&self, other: &*T) -> bool {$/;"	f
equiv	_	fn equiv(&self, other: &*mut T) -> bool {$/;"	f
equiv	_	fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }$/;"	f
equiv	_	fn equiv(&self, other: &S) -> bool {$/;"	f
equiv	_	fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }$/;"	f
equiv_prefix	_	fn equiv_prefix(&self, other: &Path) -> bool {$/;"	f
erf	_	pub fn erf(n: c_double) -> c_double;$/;"	f
erf	_	pub fn erf(n: c_float) -> c_float;$/;"	f
erfc	_	pub fn erfc(n: c_double) -> c_double;$/;"	f
erfc	_	pub fn erfc(n: c_float) -> c_float;$/;"	f
err	_	fn err(&mut self, msg: &str) {$/;"	f
err	_	pub fn err(self) -> Option<E> {$/;"	f
errno	_	/^pub fn errno() -> int {$/;"	f
errno	_	/^pub fn errno() -> uint {$/;"	f
errno_location	_	fn errno_location() -> *c_int {$/;"	f
escape	_	fn escape(&mut self) -> char {$/;"	f
escape_default	_	fn escape_default(&self, f: |char|) { escape_default(*self, f) }$/;"	f
escape_default	_	fn escape_default(&self, f: |char|);$/;"	f
escape_default	_	/^pub fn escape_default(c: char, f: |char|) {$/;"	f
escape_default	_	fn escape_default(&self) -> ~str {$/;"	f
escape_default	_	fn escape_default(&self) -> ~str;$/;"	f
escape_unicode	_	fn escape_unicode(&self, f: |char|) { escape_unicode(*self, f) }$/;"	f
escape_unicode	_	fn escape_unicode(&self, f: |char|);$/;"	f
escape_unicode	_	/^pub fn escape_unicode(c: char, f: |char|) {$/;"	f
escape_unicode	_	fn escape_unicode(&self) -> ~str {$/;"	f
escape_unicode	_	fn escape_unicode(&self) -> ~str;$/;"	f
exact_test	_	fn exact_test<T>(t: &T, e:&str) {$/;"	f
exception_cleanup	_	extern "C" fn exception_cleanup(_unwind_code: uw::_Unwind_Reason_Code,$/;"	f
exchange_free	_	/^pub unsafe fn exchange_free(ptr: *u0) {$/;"	f
exchange_free_	_	/^pub unsafe fn exchange_free_(ptr: *u0) {$/;"	f
exchange_malloc	_	/^pub unsafe fn exchange_malloc(size: uint) -> *u0 {$/;"	f
exclusive_new_arc	_	fn exclusive_new_arc() {$/;"	f
exclusive_new_poison	_	fn exclusive_new_poison() {$/;"	f
execute	_	fn execute(&mut self, method: &rt::Method, arg: Argument) -> Result {$/;"	f
execv	_	pub fn execv(prog: *c_char, argv: **c_char) -> c_int;$/;"	f
execv	_	pub fn execv(prog: *c_char, argv: **c_char) -> intptr_t;$/;"	f
execve	_	pub fn execve(prog: *c_char, argv: **c_char, envp: **c_char)$/;"	f
execvp	_	pub fn execvp(c: *c_char, argv: **c_char) -> c_int;$/;"	f
execvpe	_	pub fn execvpe(c: *c_char, argv: **c_char, envp: **c_char)$/;"	f
exists	_	pub fn exists(&self) -> bool {$/;"	f
exists	_	fn exists(_: Option<Task>) -> bool { local_ptr::exists() }$/;"	f
exists	_	fn exists(unused_value: Option<Self>) -> bool;$/;"	f
exists	_	pub fn exists() -> bool {$/;"	f
exit	_	pub fn exit(status: c_int) -> !;$/;"	f
exp	_	fn exp(&self) -> f0 { exp(*self) }$/;"	f
exp	_	fn exp(n: f0) -> f0 = intrinsics::expf0,$/;"	f
exp	_	fn exp(&self) -> f0 { exp(*self) }$/;"	f
exp	_	fn exp(n: f0) -> f0 = intrinsics::expf0,$/;"	f
exp	_	fn exp(&self) -> Self;$/;"	f
exp0	_	fn exp0(&self) -> f0 { exp0(*self) }$/;"	f
exp0	_	fn exp0(n: f0) -> f0 = intrinsics::exp0f0,$/;"	f
exp0	_	fn exp0(&self) -> f0 { exp0(*self) }$/;"	f
exp0	_	fn exp0(n: f0) -> f0 = intrinsics::exp0f0,$/;"	f
exp0	_	fn exp0(&self) -> Self;$/;"	f
exp0f0	_	pub fn exp0f0(x: f0) -> f0;$/;"	f
exp0f0	_	pub fn exp0f0(x: f0) -> f0;$/;"	f
exp_m0	_	pub fn exp_m0(n: c_double) -> c_double;$/;"	f
exp_m0	_	pub fn exp_m0(n: c_float) -> c_float;$/;"	f
exp_m0	_	fn exp_m0(&self) -> f0 { exp_m0(*self) }$/;"	f
exp_m0	_	fn exp_m0(n: c_float) -> c_float = cmath::c_float::exp_m0,$/;"	f
exp_m0	_	fn exp_m0(&self) -> f0 { exp_m0(*self) }$/;"	f
exp_m0	_	fn exp_m0(n: c_double) -> c_double = cmath::c_double::exp_m0,$/;"	f
exp_m0	_	fn exp_m0(&self) -> Self;$/;"	f
expect	_	pub fn expect<M: Any + Send>(self, msg: M) -> T {$/;"	f
expf0	_	pub fn expf0(x: f0) -> f0;$/;"	f
expf0	_	pub fn expf0(x: f0) -> f0;$/;"	f
exponential	_	/^pub mod exponential;$/;"	m
extend	_	fn extend<T: Iterator<A>>(&mut self, iterator: &mut T);$/;"	f
extend	_	fn extend<T: Iterator<char>>(&mut self, iterator: &mut T) {$/;"	f
extend	_	fn extend<T: Iterator<A>>(&mut self, iterator: &mut T) {$/;"	f
extend	_	fn extend<I: Iterator<T>>(&mut self, iterator: &mut I) {$/;"	f
extend_sign	_	/^fn extend_sign(val: u0, nbytes: uint) -> i0 {$/;"	f
extension	_	fn extension<'a>(&'a self) -> Option<&'a [u0]> {$/;"	f
extension_str	_	fn extension_str<'a>(&'a self) -> Option<&'a str> {$/;"	f
extension_str	_	fn extension_str<'a>(&'a self) -> Option<&'a str> {$/;"	f
extensions	_	/^pub mod extensions;$/;"	m
externfnpointers	_	/^mod externfnpointers {$/;"	m
extra	_	pub mod extra {$/;"	m
extra	_	pub mod extra {}$/;"	m
extra	_	pub mod extra {$/;"	m
extra	_	pub mod extra {$/;"	m
f	_	fn f() $b$/;"	f
f	_	fn f() $b$/;"	f
f	_	fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }$/;"	f
f	_	fn f(i: int, ch: Chan<()>) {$/;"	f
f0x0	_	/^pub struct f0x0(f0, f0, f0, f0);$/;"	s
f0	_	mod f0 {$/;"	m
f0x0	_	/^pub struct f0x0(f0, f0);$/;"	s
fabsf0	_	pub fn fabsf0(x: f0) -> f0;$/;"	f
fabsf0	_	pub fn fabsf0(x: f0) -> f0;$/;"	f
fail_	_	/^pub fn fail_(expr: *u0, file: *u0, line: uint) -> ! {$/;"	f
fail_bounds_check	_	/^pub fn fail_bounds_check(file: *u0, line: uint, index: uint, len: uint) -> ! {$/;"	f
failing	_	/^pub fn failing() -> bool {$/;"	f
fchmod	_	pub fn fchmod(fd: c_int, mode: mode_t) -> c_int;$/;"	f
fclose	_	pub fn fclose(file: *FILE) -> c_int;$/;"	f
fcntl	_	pub fn fcntl(fd: c_int, cmd: c_int) -> c_int;$/;"	f
fcntl	_	pub mod fcntl {$/;"	m
fdatasync	_	pub fn fdatasync(fd: c_int) -> c_int;$/;"	f
fdopen	_	pub fn fdopen(fd: c_int, mode: *c_char) -> *FILE;$/;"	f
fence	_	/^pub fn fence(order: Ordering) {$/;"	f
feof	_	pub fn feof(stream: *FILE) -> c_int;$/;"	f
ferror	_	pub fn ferror(stream: *FILE) -> c_int;$/;"	f
fetch_add	_	pub fn fetch_add(&mut self, val: int, order: Ordering) -> int {$/;"	f
fetch_add	_	pub fn fetch_add(&mut self, val: u0, order: Ordering) -> u0 {$/;"	f
fetch_add	_	pub fn fetch_add(&mut self, val: uint, order: Ordering) -> uint {$/;"	f
fetch_and	_	pub fn fetch_and(&mut self, val: bool, order: Ordering) -> bool {$/;"	f
fetch_nand	_	pub fn fetch_nand(&mut self, val: bool, order: Ordering) -> bool {$/;"	f
fetch_or	_	pub fn fetch_or(&mut self, val: bool, order: Ordering) -> bool {$/;"	f
fetch_sub	_	pub fn fetch_sub(&mut self, val: int, order: Ordering) -> int {$/;"	f
fetch_sub	_	pub fn fetch_sub(&mut self, val: u0, order: Ordering) -> u0 {$/;"	f
fetch_sub	_	pub fn fetch_sub(&mut self, val: uint, order: Ordering) -> uint {$/;"	f
fetch_xor	_	pub fn fetch_xor(&mut self, val: bool, order: Ordering) -> bool {$/;"	f
fflush	_	pub fn fflush(file: *FILE) -> c_int;$/;"	f
fgetc	_	pub fn fgetc(stream: *FILE) -> c_int;$/;"	f
fgetpos	_	pub fn fgetpos(stream: *FILE, ptr: *fpos_t) -> c_int;$/;"	f
fgets	_	pub fn fgets(buf: *mut c_char, n: c_int, stream: *FILE)$/;"	f
filename	_	fn filename<'a>(&'a self) -> Option<&'a [u0]>;$/;"	f
filename	_	fn filename<'a>(&'a self) -> Option<&'a [u0]> {$/;"	f
filename	_	fn filename<'a>(&'a self) -> Option<&'a [u0]> {$/;"	f
filename_display	_	fn filename_display<'a>(&'a self) -> Display<'a, Self> {$/;"	f
filename_str	_	fn filename_str<'a>(&'a self) -> Option<&'a str> {$/;"	f
filename_str	_	fn filename_str<'a>(&'a self) -> Option<&'a str> {$/;"	f
fileno	_	pub fn fileno(stream: *FILE) -> c_int;$/;"	f
filestem	_	fn filestem<'a>(&'a self) -> Option<&'a [u0]> {$/;"	f
filestem_str	_	fn filestem_str<'a>(&'a self) -> Option<&'a str> {$/;"	f
filestem_str	_	fn filestem_str<'a>(&'a self) -> Option<&'a str> {$/;"	f
fill	_	fn fill<'a>(&'a mut self) -> IoResult<&'a [u0]> { self.inner.fill() }$/;"	f
fill	_	fn fill<'a>(&'a mut self) -> IoResult<&'a [u0]> {$/;"	f
fill	_	fn fill<'a>(&'a mut self) -> IoResult<&'a [u0]> {$/;"	f
fill	_	fn fill<'a>(&'a mut self) -> IoResult<&'a [u0]>;$/;"	f
fill	_	pub fn fill(&mut self, val: ~T, order: Ordering) -> Option<~T> {$/;"	f
fill_bytes	_	fn fill_bytes(&mut self, bytes: &mut [u0]) {$/;"	f
fill_bytes	_	fn fill_bytes(&mut self, dest: &mut [u0]) {$/;"	f
fill_bytes	_	fn fill_bytes(&mut self, v: &mut [u0]) {$/;"	f
fill_bytes	_	fn fill_bytes(&mut self, v: &mut [u0]) {$/;"	f
fill_bytes	_	fn fill_bytes(&mut self, dest: &mut [u0]) {$/;"	f
fill_utf0_buf_and_decode	_	pub fn fill_utf0_buf_and_decode(f: |*mut u0, DWORD| -> DWORD)$/;"	f
filter	_	fn filter<'r>(self, predicate: 'r |&A| -> bool) -> Filter<'r, A, Self> {$/;"	f
filter_map	_	fn filter_map<'r, B>(self, f: 'r |A| -> Option<B>) -> FilterMap<'r, A, B, Self> {$/;"	f
filtered	_	pub fn filtered(self, f: |t: &T| -> bool) -> Option<T> {$/;"	f
finally	_	fn finally(&self, dtor: ||) -> T {$/;"	f
finally	_	fn finally(&self, dtor: ||) -> T;$/;"	f
finally	_	/^pub mod finally;$/;"	m
find	_	fn find<'a>(&'a self, key: &K) -> Option<&'a V>;$/;"	f
find	_	fn find(&mut self, predicate: |&A| -> bool) -> Option<A> {$/;"	f
find	_	fn find<C: CharEq>(&self, search: C) -> Option<uint> {$/;"	f
find	_	fn find<C: CharEq>(&self, search: C) -> Option<uint>;$/;"	f
find_mut	_	fn find_mut<'a>(&'a mut self, key: &K) -> Option<&'a mut V>;$/;"	f
find_str	_	fn find_str(&self, &str) -> Option<uint>;$/;"	f
find_str	_	fn find_str(&self, needle: &str) -> Option<uint> {$/;"	f
fire	_	fn fire(&mut self);$/;"	f
first_non_utf0_index	_	/^fn first_non_utf0_index(v: &[u0]) -> Option<uint> {$/;"	f
flag	_	fn flag() {$/;"	f
flat_map	_	fn flat_map<'r, B, U: Iterator<B>>(self, f: 'r |A| -> U)$/;"	f
flat_map	_	fn flat_map<U>(&self, f: |t: &T| -> ~[U]) -> ~[U] {$/;"	f
flat_map	_	fn flat_map<U>(&self, f: |t: &T| -> ~[U]) -> ~[U];$/;"	f
flat_map	_	/^pub fn flat_map<T, U>(v: &[T], f: |t: &T| -> ~[U]) -> ~[U] {$/;"	f
float_to_str	_	fn float_to_str(bh: &mut BenchHarness) {$/;"	f
float_to_str_bytes_common	_	/^pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+Round+$/;"	f
float_to_str_common	_	/^pub fn float_to_str_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Float+Round+$/;"	f
floating_point_edge_cases	_	fn floating_point_edge_cases() {$/;"	f
floor	_	fn floor(&self) -> f0 { floor(*self) }$/;"	f
floor	_	fn floor(x: f0) -> f0 = intrinsics::floorf0,$/;"	f
floor	_	fn floor(&self) -> f0 { floor(*self) }$/;"	f
floor	_	fn floor(x: f0) -> f0 = intrinsics::floorf0,$/;"	f
floor	_	fn floor(&self) -> Self;$/;"	f
floorf0	_	pub fn floorf0(x: f0) -> f0;$/;"	f
floorf0	_	pub fn floorf0(x: f0) -> f0;$/;"	f
flush	_	fn flush(&mut self) -> IoResult<()> { self.inner.flush() }$/;"	f
flush	_	fn flush(&mut self) -> IoResult<()> {$/;"	f
flush	_	fn flush(&mut self) { fail!() }$/;"	f
flush	_	fn flush(&mut self) -> IoResult<()> { Ok(()) }$/;"	f
flush	_	fn flush(&mut self) -> IoResult<()> { self.flush() }$/;"	f
flush	_	fn flush(&mut self) -> IoResult<()> { self.inner.flush() }$/;"	f
flush	_	fn flush(&mut self) -> IoResult<()> {$/;"	f
flush	_	/^pub fn flush() {$/;"	f
flush	_	fn flush(&mut self) -> io::IoResult<()> {$/;"	f
flush	_	fn flush(&mut self) -> io::IoResult<()> {$/;"	f
flush_buf	_	fn flush_buf(&mut self) -> IoResult<()> {$/;"	f
fmaf0	_	pub fn fmaf0(a: f0, b: f0, c: f0) -> f0;$/;"	f
fmaf0	_	pub fn fmaf0(a: f0, b: f0, c: f0) -> f0;$/;"	f
fmax	_	pub fn fmax(a: c_double, b: c_double) -> c_double;$/;"	f
fmax	_	pub fn fmax(a: c_float, b: c_float) -> c_float;$/;"	f
fmin	_	pub fn fmin(a: c_double, b: c_double) -> c_double;$/;"	f
fmin	_	pub fn fmin(a: c_float, b: c_float) -> c_float;$/;"	f
fmt	_	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {$/;"	f
fmt	_	/^impl fmt::Show for ~Any {$/;"	i
fmt	_	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {$/;"	f
fmt	_	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {$/;"	f
fmt	_	fn fmt(&self, f: &mut Formatter) -> Result {$/;"	f
fmt	_	fn fmt(&self, fmt: &mut Formatter) -> Result {$/;"	f
fmt	_	fn fmt(&self, f: &mut Formatter) -> Result { secret_pointer(self, f) }$/;"	f
fmt	_	fn fmt(&self, f: &mut Formatter) -> Result { secret_show(&**self, f) }$/;"	f
fmt	_	fn fmt(&self, f: &mut Formatter) -> Result { secret_show(*self, f) }$/;"	f
fmt	_	fn fmt(&self, f: &mut Formatter) -> Result {$/;"	f
fmt	_	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {$/;"	f
fmt	_	/^fn fmt(&self, f: &mut std::fmt::Formatter) -> fmt::Result;$/;"	f
fmt	_	/^impl fmt::Binary for Vector0D {$/;"	i
fmt	_	/^impl fmt::Show for Vector0D {$/;"	i
fmt	_	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {$/;"	f
fmt	_	impl fmt::$Trait for $T {$/;"	i
fmt	_	impl fmt::Show for RadixFmt<$T, Radix> {$/;"	i
fmt	_	fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {$/;"	f
fmt	_	/^impl fmt::Show for IoError {$/;"	i
fmt	_	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {$/;"	f
fmt	_	fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {$/;"	f
fmt	_	/^impl fmt::Show for IpAddr {$/;"	i
fmt	_	/^impl fmt::Show for SocketAddr {$/;"	i
fmt	_	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {$/;"	f
fmt	_	/^impl fmt::Show for ProcessExit {$/;"	i
fmt	_	/^pub mod fmt;$/;"	m
fmt	_	fn fmt(&self, out: &mut fmt::Formatter) -> fmt::Result {$/;"	f
fmt	_	/^impl fmt::Show for MapError {$/;"	i
fmt	_	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {$/;"	f
fmt	_	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {$/;"	f
fmt	_	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {$/;"	f
fmt	_	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {$/;"	f
fmt	_	/^impl fmt::Show for () {$/;"	i
fmt	_	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {$/;"	f
fmt	_	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {$/;"	f
fmt_int	_	fn fmt_int<T: Int>(&self, mut x: T, f: &mut fmt::Formatter) -> fmt::Result {$/;"	f
fmtdflt	_	fn fmtdflt() -> FormatSpec<'static> {$/;"	f
fold	_	fn fold<B>(&mut self, init: B, f: |B, A| -> B) -> B {$/;"	f
fold	_	/^pub fn fold<T,$/;"	f
fold_	_	/^pub fn fold_<T,E,Iter:Iterator<Result<T,E>>>(iterator: Iter) -> Result<(),E> {$/;"	f
foo	_	fn foo(f: |c: &CString|) {$/;"	f
fopen	_	pub fn fopen(filename: *c_char, mode: *c_char) -> *FILE;$/;"	f
forget	_	/^pub unsafe fn forget<T>(thing: T) { intrinsics::forget(thing); }$/;"	f
forget	_	pub fn forget<T>(_: T) -> ();$/;"	f
fork	_	pub fn fork() -> pid_t;$/;"	f
format	_	/^pub fn format(args: &Arguments) -> ~str {$/;"	f
format	_	fn format(&mut self) -> FormatSpec<'a> {$/;"	f
format_align_fill	_	fn format_align_fill() {$/;"	f
format_base_0	_	fn format_base_0(bh: &mut BenchHarness) {$/;"	f
format_bin	_	fn format_bin(bh: &mut BenchHarness) {$/;"	f
format_counts	_	fn format_counts() {$/;"	f
format_dec	_	fn format_dec(bh: &mut BenchHarness) {$/;"	f
format_flags	_	fn format_flags() {$/;"	f
format_hex	_	fn format_hex(bh: &mut BenchHarness) {$/;"	f
format_mixture	_	fn format_mixture() {$/;"	f
format_nothing	_	fn format_nothing() {$/;"	f
format_oct	_	fn format_oct(bh: &mut BenchHarness) {$/;"	f
format_position	_	fn format_position() {$/;"	f
format_position_nothing_else	_	fn format_position_nothing_else() {$/;"	f
format_type	_	fn format_type() {$/;"	f
format_unsafe	_	/^pub unsafe fn format_unsafe(fmt: &[rt::Piece], args: &[Argument]) -> ~str {$/;"	f
fpathconf	_	pub fn fpathconf(filedes: c_int, name: c_int) -> c_long;$/;"	f
fpos_t	_	pub enum fpos_t {}$/;"	g
fputc	_	pub fn fputc(c: c_int, stream: *FILE) -> c_int;$/;"	f
fputs	_	pub fn fputs(s: *c_char, stream: *FILE) -> *c_char;$/;"	f
frac_0_pi	_	fn frac_0_pi() -> f0 { 0.0 }$/;"	f
frac_0_pi	_	fn frac_0_pi() -> f0 { 0.0 }$/;"	f
frac_0_pi	_	fn frac_0_pi() -> Self;$/;"	f
frac_0_sqrt0	_	fn frac_0_sqrt0() -> f0 { 0.0 }$/;"	f
frac_0_sqrt0	_	fn frac_0_sqrt0() -> f0 { 0.0 }$/;"	f
frac_0_sqrt0	_	fn frac_0_sqrt0() -> Self;$/;"	f
frac_0_pi	_	fn frac_0_pi() -> f0 { 0.0 }$/;"	f
frac_0_pi	_	fn frac_0_pi() -> f0 { 0.0 }$/;"	f
frac_0_pi	_	fn frac_0_pi() -> Self;$/;"	f
frac_0_sqrtpi	_	fn frac_0_sqrtpi() -> f0 { 0.0 }$/;"	f
frac_0_sqrtpi	_	fn frac_0_sqrtpi() -> f0 { 0.0 }$/;"	f
frac_0_sqrtpi	_	fn frac_0_sqrtpi() -> Self;$/;"	f
frac_pi_0	_	fn frac_pi_0() -> f0 { 0.0 }$/;"	f
frac_pi_0	_	fn frac_pi_0() -> f0 { 0.0 }$/;"	f
frac_pi_0	_	fn frac_pi_0() -> Self;$/;"	f
frac_pi_0	_	fn frac_pi_0() -> f0 { 0.0 }$/;"	f
frac_pi_0	_	fn frac_pi_0() -> f0 { 0.0 }$/;"	f
frac_pi_0	_	fn frac_pi_0() -> Self;$/;"	f
frac_pi_0	_	fn frac_pi_0() -> f0 { 0.0 }$/;"	f
frac_pi_0	_	fn frac_pi_0() -> f0 { 0.0 }$/;"	f
frac_pi_0	_	fn frac_pi_0() -> Self;$/;"	f
frac_pi_0	_	fn frac_pi_0() -> f0 { 0.0 }$/;"	f
frac_pi_0	_	fn frac_pi_0() -> f0 { 0.0 }$/;"	f
frac_pi_0	_	fn frac_pi_0() -> Self;$/;"	f
frac_pi_0	_	fn frac_pi_0() -> f0 { 0.0 }$/;"	f
frac_pi_0	_	fn frac_pi_0() -> f0 { 0.0 }$/;"	f
frac_pi_0	_	fn frac_pi_0() -> Self;$/;"	f
fract	_	fn fract(&self) -> f0 { *self - self.trunc() }$/;"	f
fract	_	fn fract(&self) -> f0 { *self - self.trunc() }$/;"	f
fract	_	fn fract(&self) -> Self;$/;"	f
fractional_part	_	fn fractional_part(&self) -> $t { self.fract() }$/;"	f
fractional_part	_	fn fractional_part(&self) -> Self;$/;"	f
fread	_	pub fn fread(ptr: *mut c_void,$/;"	f
free	_	pub fn free(p: *mut c_void);$/;"	f
free	_	fn free(&mut self, alloc: *mut Box) {$/;"	f
free	_	pub fn free(&mut self, alloc: *mut Box) {$/;"	f
free	_	fn free(&mut self, buf: ~Buffer<T>) {$/;"	f
free_cond	_	pub unsafe fn free_cond(h: uint) {$/;"	f
free_lock	_	pub unsafe fn free_lock(h: uint) {$/;"	f
freebsd	_	pub mod freebsd {$/;"	m
freopen	_	pub fn freopen(filename: *c_char, mode: *c_char, file: *FILE)$/;"	f
frexp	_	pub fn frexp(n: c_double, value: &mut c_int) -> c_double;$/;"	f
frexp	_	pub fn frexp(n: c_float, value: &mut c_int) -> c_float;$/;"	f
frexp	_	fn frexp(&self) -> (f0, int) {$/;"	f
frexp	_	fn frexp(n: c_float, value: &mut c_int) -> c_float = cmath::c_float::frexp,$/;"	f
frexp	_	fn frexp(&self) -> (f0, int) {$/;"	f
frexp	_	fn frexp(n: c_double, value: &mut c_int) -> c_double = cmath::c_double::frexp,$/;"	f
frexp	_	fn frexp(&self) -> (Self, int);$/;"	f
from	_	fn from<N: ToPrimitive>(n: N) -> Option<$T> {$/;"	f
from	_	fn from<T: ToPrimitive>(n: T) -> Option<Self>;$/;"	f
from	_	fn from(a_box: *mut Box) -> *mut AllocHeader {$/;"	f
from_buf	_	/^pub unsafe fn from_buf<T>(ptr: *T, elts: uint) -> ~[T] {$/;"	f
from_buf_len	_	pub unsafe fn from_buf_len(buf: *u0, len: uint) -> ~str {$/;"	f
from_buf_raw	_	pub unsafe fn from_buf_raw<T>(ptr: *T, elts: uint) -> ~[T] {$/;"	f
from_byte	_	pub unsafe fn from_byte(u: u0) -> ~str { from_utf0_owned(~[u]) }$/;"	f
from_byte	_	/^pub fn from_byte(b: u0) -> ~str {$/;"	f
from_c_multistring	_	/^pub unsafe fn from_c_multistring(buf: *libc::c_char,$/;"	f
from_c_str	_	pub unsafe fn from_c_str(buf: *libc::c_char) -> ~str {$/;"	f
from_char	_	/^pub fn from_char(ch: char) -> ~str {$/;"	f
from_chars	_	/^pub fn from_chars(chs: &[char]) -> ~str {$/;"	f
from_digit	_	fn from_digit(num: uint, radix: uint) -> Option<char> { from_digit(num, radix) }$/;"	f
from_digit	_	fn from_digit(num: uint, radix: uint) -> Option<char>;$/;"	f
from_digit	_	/^pub fn from_digit(num: uint, radix: uint) -> Option<char> {$/;"	f
from_elem	_	/^pub fn from_elem<T:Clone>(n_elts: uint, t: T) -> ~[T] {$/;"	f
from_elem	_	pub fn from_elem(length: uint, value: T) -> Vec<T> {$/;"	f
from_f0	_	fn from_f0(n: f0) -> Option<Self> {$/;"	f
from_f0	_	/^pub fn from_f0<A: FromPrimitive>(n: f0) -> Option<A> {$/;"	f
from_f0	_	fn from_f0(n: f0) -> Option<Self> {$/;"	f
from_f0	_	/^pub fn from_f0<A: FromPrimitive>(n: f0) -> Option<A> {$/;"	f
from_fn	_	/^pub fn from_fn<T>(n_elts: uint, op: |uint| -> T) -> ~[T] {$/;"	f
from_fn	_	pub fn from_fn(length: uint, op: |uint| -> T) -> Vec<T> {$/;"	f
from_i0	_	fn from_i0(n: i0) -> Option<Self> {$/;"	f
from_i0	_	/^pub fn from_i0<A: FromPrimitive>(n: i0) -> Option<A> {$/;"	f
from_i0	_	fn from_i0(n: i0) -> Option<Self> {$/;"	f
from_i0	_	/^pub fn from_i0<A: FromPrimitive>(n: i0) -> Option<A> {$/;"	f
from_i0	_	fn from_i0(n: i0) -> Option<Value> { Some(Value { x: n as int }) }$/;"	f
from_i0	_	fn from_i0(n: i0) -> Option<Self>;$/;"	f
from_i0	_	/^pub fn from_i0<A: FromPrimitive>(n: i0) -> Option<A> {$/;"	f
from_i0	_	fn from_i0(n: i0) -> Option<Self> {$/;"	f
from_i0	_	/^pub fn from_i0<A: FromPrimitive>(n: i0) -> Option<A> {$/;"	f
from_int	_	fn from_int(n: int) -> Option<Self> {$/;"	f
from_int	_	/^pub fn from_int<A: FromPrimitive>(n: int) -> Option<A> {$/;"	f
from_iterator	_	fn from_iterator<T: Iterator<A>>(iterator: &mut T) -> Self;$/;"	f
from_iterator	_	fn from_iterator<T: Iterator<char>>(iterator: &mut T) -> ~str {$/;"	f
from_iterator	_	fn from_iterator<T: Iterator<A>>(iterator: &mut T) -> ~[A] {$/;"	f
from_iterator	_	fn from_iterator<I:Iterator<T>>(iterator: &mut I) -> Vec<T> {$/;"	f
from_seed	_	fn from_seed(seed: &'a [u0]) -> IsaacRng {$/;"	f
from_seed	_	fn from_seed(seed: &'a [u0]) -> Isaac0Rng {$/;"	f
from_seed	_	fn from_seed(seed: &'a [uint]) -> StdRng {$/;"	f
from_seed	_	fn from_seed(seed: Seed) -> Self;$/;"	f
from_seed	_	fn from_seed(seed: [u0, .. 0]) -> XorShiftRng {$/;"	f
from_seed	_	fn from_seed(seed: u0) -> Counter {$/;"	f
from_seed	_	fn from_seed((rsdr, seed): (Rsdr, S)) -> ReseedingRng<R, Rsdr> {$/;"	f
from_str	_	fn from_str(s: &str) -> Option<bool> {$/;"	f
from_str	_	fn from_str(s: &str) -> Option<Self>;$/;"	f
from_str	_	/^pub fn from_str<A: FromStr>(s: &str) -> Option<A> {$/;"	f
from_str	_	fn from_str(s: &str) -> Option<IpAddr> {$/;"	f
from_str	_	fn from_str(s: &str) -> Option<SocketAddr> {$/;"	f
from_str	_	/^pub mod from_str;$/;"	m
from_str	_	fn from_str(val: &str) -> Option<f0> {$/;"	f
from_str	_	fn from_str(val: &str) -> Option<f0> {$/;"	f
from_str	_	fn from_str(s: &str) -> Option<$T> {$/;"	f
from_str	_	fn from_str(s: &str) -> Option<$T> {$/;"	f
from_str	_	fn from_str(s: &str) -> Option<Path> {$/;"	f
from_str	_	fn from_str(s: &str) -> Option<Path> {$/;"	f
from_str	_	fn from_str(s: &str) -> Option<~str> { Some(s.to_owned()) }$/;"	f
from_str_bytes_common	_	/^pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Div<T,T>+$/;"	f
from_str_common	_	/^pub fn from_str_common<T:NumCast+Zero+One+Eq+Ord+Div<T,T>+Mul<T,T>+$/;"	f
from_str_hex	_	/^pub fn from_str_hex(num: &str) -> Option<f0> {$/;"	f
from_str_hex	_	/^pub fn from_str_hex(num: &str) -> Option<f0> {$/;"	f
from_str_ignore_underscores	_	fn from_str_ignore_underscores() {$/;"	f
from_str_issue0	_	fn from_str_issue0() {$/;"	f
from_str_issue0	_	fn from_str_issue0() {$/;"	f
from_str_radix	_	fn from_str_radix(val: &str, rdx: uint) -> Option<f0> {$/;"	f
from_str_radix	_	fn from_str_radix(val: &str, rdx: uint) -> Option<f0> {$/;"	f
from_str_radix	_	fn from_str_radix(s: &str, radix: uint) -> Option<$T> {$/;"	f
from_str_radix	_	fn from_str_radix(str: &str, radix: uint) -> Option<Self>;$/;"	f
from_str_radix	_	/^pub fn from_str_radix<T: FromStrRadix>(str: &str, radix: uint) -> Option<T> {$/;"	f
from_str_radix	_	fn from_str_radix(s: &str, radix: uint) -> Option<$T> {$/;"	f
from_u0	_	fn from_u0(n: u0) -> Option<Self> {$/;"	f
from_u0	_	/^pub fn from_u0<A: FromPrimitive>(n: u0) -> Option<A> {$/;"	f
from_u0	_	/^pub fn from_u0(i: u0) -> Option<char> {$/;"	f
from_u0	_	fn from_u0(n: u0) -> Option<Self> {$/;"	f
from_u0	_	/^pub fn from_u0<A: FromPrimitive>(n: u0) -> Option<A> {$/;"	f
from_u0	_	fn from_u0(n: u0) -> Option<Value> { Some(Value { x: n as int }) }$/;"	f
from_u0	_	fn from_u0(n: u0) -> Option<Self>;$/;"	f
from_u0	_	/^pub fn from_u0<A: FromPrimitive>(n: u0) -> Option<A> {$/;"	f
from_u0	_	fn from_u0(n: u0) -> Option<Self> {$/;"	f
from_u0	_	/^pub fn from_u0<A: FromPrimitive>(n: u0) -> Option<A> {$/;"	f
from_uint	_	fn from_uint(n: uint) -> Option<Self> {$/;"	f
from_uint	_	/^pub fn from_uint<A: FromPrimitive>(n: uint) -> Option<A> {$/;"	f
from_utf0	_	/^pub fn from_utf0(v: &[u0]) -> Option<~str> {$/;"	f
from_utf0_lossy	_	/^pub fn from_utf0_lossy(v: &[u0]) -> ~str {$/;"	f
from_utf0	_	pub unsafe fn from_utf0<'a>(v: &'a [u0]) -> &'a str {$/;"	f
from_utf0	_	/^pub fn from_utf0<'a>(v: &'a [u0]) -> Option<&'a str> {$/;"	f
from_utf0_lossy	_	/^pub fn from_utf0_lossy<'a>(v: &'a [u0]) -> MaybeOwned<'a> {$/;"	f
from_utf0_lossy_0_ascii	_	fn from_utf0_lossy_0_ascii(bh: &mut BenchHarness) {$/;"	f
from_utf0_lossy_0_invalid	_	fn from_utf0_lossy_0_invalid(bh: &mut BenchHarness) {$/;"	f
from_utf0_lossy_0_multibyte	_	fn from_utf0_lossy_0_multibyte(bh: &mut BenchHarness) {$/;"	f
from_utf0_lossy_invalid	_	fn from_utf0_lossy_invalid(bh: &mut BenchHarness) {$/;"	f
from_utf0_owned	_	pub unsafe fn from_utf0_owned(v: ~[u0]) -> ~str {$/;"	f
from_utf0_owned	_	/^pub fn from_utf0_owned(vv: ~[u0]) -> Option<~str> {$/;"	f
fs	_	/^pub mod fs;$/;"	m
fs_chmod	_	fn fs_chmod(&mut self, path: &CString,$/;"	f
fs_chown	_	fn fs_chown(&mut self, path: &CString, uid: int, gid: int) ->$/;"	f
fs_from_raw_fd	_	fn fs_from_raw_fd(&mut self, fd: c_int, close: CloseBehavior) -> ~RtioFileStream;$/;"	f
fs_link	_	fn fs_link(&mut self, src: &CString, dst: &CString) -> Result<(), IoError>;$/;"	f
fs_lstat	_	fn fs_lstat(&mut self, path: &CString) -> Result<FileStat, IoError>;$/;"	f
fs_mkdir	_	fn fs_mkdir(&mut self, path: &CString,$/;"	f
fs_open	_	fn fs_open(&mut self, path: &CString, fm: FileMode, fa: FileAccess)$/;"	f
fs_readdir	_	fn fs_readdir(&mut self, path: &CString, flags: c_int) ->$/;"	f
fs_readlink	_	fn fs_readlink(&mut self, path: &CString) -> Result<Path, IoError>;$/;"	f
fs_rename	_	fn fs_rename(&mut self, path: &CString, to: &CString) -> Result<(), IoError>;$/;"	f
fs_rmdir	_	fn fs_rmdir(&mut self, path: &CString) -> Result<(), IoError>;$/;"	f
fs_stat	_	fn fs_stat(&mut self, path: &CString) -> Result<FileStat, IoError>;$/;"	f
fs_symlink	_	fn fs_symlink(&mut self, src: &CString, dst: &CString) -> Result<(), IoError>;$/;"	f
fs_unlink	_	fn fs_unlink(&mut self, path: &CString) -> Result<(), IoError>;$/;"	f
fs_utime	_	fn fs_utime(&mut self, src: &CString, atime: u0, mtime: u0) ->$/;"	f
fseek	_	pub fn fseek(stream: *FILE, offset: c_long, whence: c_int)$/;"	f
fsetpos	_	pub fn fsetpos(stream: *FILE, ptr: *fpos_t) -> c_int;$/;"	f
fstat	_	pub fn fstat(fildes: c_int, buf: *mut stat) -> c_int;$/;"	f
fsync	_	pub fn fsync(&mut self) -> IoResult<()> {$/;"	f
fsync	_	pub fn fsync(fd: c_int) -> c_int;$/;"	f
fsync	_	fn fsync(&mut self) -> Result<(), IoError>;$/;"	f
ftell	_	pub fn ftell(stream: *FILE) -> c_long;$/;"	f
ftruncate	_	pub fn ftruncate(fd: c_int, length: off_t) -> c_int;$/;"	f
funcs	_	/^pub mod funcs {$/;"	m
fuse	_	fn fuse(self) -> Fuse<Self> {$/;"	f
future_result	_	pub fn future_result(&mut self) -> Port<TaskResult> {$/;"	f
fwrite	_	pub fn fwrite(ptr: *c_void,$/;"	f
g	_	fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }$/;"	f
gamma	_	/^pub mod gamma;$/;"	m
gc	_	/^pub mod gc;$/;"	m
gc_inside	_	fn gc_inside() {$/;"	f
ge	_	fn ge(&self, other: &Self) -> bool { !self.lt(other) }$/;"	f
ge	_	pub fn ge<A: Eq + Ord, T: Iterator<A>>(mut a: T, mut b: T) -> bool {$/;"	f
ge	_	fn ge(&self, other: &@T) -> bool { *(*self) >= *(*other) }$/;"	f
ge	_	fn ge(&self, other: &f0) -> bool { (*self) >= (*other) }$/;"	f
ge	_	fn ge(&self, other: &f0) -> bool { (*self) >= (*other) }$/;"	f
ge	_	fn ge(&self, other: &~T) -> bool { *(*self) >= *(*other) }$/;"	f
ge	_	fn ge(&self, other: &*T) -> bool {$/;"	f
ge	_	fn ge(&self, other: &*mut T) -> bool {$/;"	f
ge	_	fn ge(&self, other: &Rc<T>) -> bool { *self.borrow() >= *other.borrow() }$/;"	f
ge	_	fn ge(&self, other: & &'a T) -> bool {$/;"	f
ge	_	fn ge(&self, other: &($($T,)+)) -> bool {$/;"	f
ge	_	fn ge(&self, other: & &'a [T]) -> bool {$/;"	f
ge	_	fn ge(&self, other: &~[T]) -> bool { self.as_slice() >= other.as_slice() }$/;"	f
gen	_	fn gen<T: Rand>(&mut self) -> T {$/;"	f
gen_ascii_str	_	fn gen_ascii_str(&mut self, len: uint) -> ~str {$/;"	f
gen_range	_	fn gen_range<T: Ord + SampleRange>(&mut self, low: T, high: T) -> T {$/;"	f
gen_vec	_	fn gen_vec<T: Rand>(&mut self, len: uint) -> ~[T] {$/;"	f
gen_weighted_bool	_	fn gen_weighted_bool(&mut self, n: uint) -> bool {$/;"	f
general_category	_	/^pub mod general_category {$/;"	m
get	_	pub fn get(&self) -> T {$/;"	f
get	_	pub fn get<'a>(&'a mut self) -> &'a mut T {$/;"	f
get	_	pub fn get<'a>(&'a self) -> &'a T {$/;"	f
get	_	/^pub fn get<T: 'static, U>(key: Key<T>, f: |Option<&T>| -> U) -> U {$/;"	f
get	_	pub fn get<T>(&mut self, f: |&mut ReprVisitor, &T| -> bool) -> bool {$/;"	f
get	_	pub fn get<'a>(&'a mut self) -> &'a mut T {$/;"	f
get	_	pub fn get<'a>(&'a mut self) -> &'a mut IoFactory {$/;"	f
get	_	/^pub unsafe fn get(key: Key) -> *mut u0 {$/;"	f
get	_	pub fn get(&self) -> *mut T {$/;"	f
get	_	unsafe fn get(&self, i: int) -> T {$/;"	f
get	_	fn get(&self, index: uint) -> Option<&'a T> {$/;"	f
get	_	fn get(&self, index: uint) -> Option<&'a T>;$/;"	f
get	_	pub fn get<'a>(&'a self, index: uint) -> &'a T {$/;"	f
get_box_size	_	/^pub fn get_box_size(body_size: uint, body_align: uint) -> uint {$/;"	f
get_crate_map	_	/^pub fn get_crate_map() -> Option<&'static CrateMap<'static>> {$/;"	f
get_end	_	fn get_end(&mut self) -> Option<&'a str> {$/;"	f
get_env_pairs	_	unsafe fn get_env_pairs() -> ~[~[u0]] {$/;"	f
get_exit_status	_	/^pub fn get_exit_status() -> int {$/;"	f
get_global_ptr	_	fn get_global_ptr() -> *mut Option<~~[~[u0]]> {$/;"	f
get_host_addresses	_	/^pub fn get_host_addresses(host: &str) -> IoResult<~[IpAddr]> {$/;"	f
get_host_addresses	_	fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,$/;"	f
get_immut	_	pub fn get_immut(&self) -> *T {$/;"	f
get_local_map	_	/^unsafe fn get_local_map() -> &mut Map {$/;"	f
get_mut	_	/^pub fn get_mut<T: 'static, U>(key: Key<T>, f: |Option<&mut T>| -> U) -> U {$/;"	f
get_mut	_	pub fn get_mut<'a>(&'a mut self, index: uint) -> &'a mut T {$/;"	f
get_mut_ref	_	fn get_mut_ref<'a>(&'a mut self) -> &'a mut BufferedWriter<W> {$/;"	f
get_mut_ref	_	pub fn get_mut_ref<'a>(&'a mut self) -> &'a mut T {$/;"	f
get_osfhandle	_	pub fn get_osfhandle(fd: c_int) -> c_long;$/;"	f
get_ref	_	pub fn get_ref<'a>(&'a self) -> &'a R { &self.inner }$/;"	f
get_ref	_	pub fn get_ref<'a>(&'a self) -> &'a S {$/;"	f
get_ref	_	pub fn get_ref<'a>(&'a self) -> &'a W { self.inner.get_ref() }$/;"	f
get_ref	_	pub fn get_ref<'a>(&'a self) -> &'a [u0] { self.buf.as_slice() }$/;"	f
get_ref	_	pub fn get_ref<'a>(&'a self) -> &'a T {$/;"	f
get_sp_limit	_	fn get_sp_limit() -> *c_void;$/;"	f
get_sp_limit	_	/^pub unsafe fn get_sp_limit() -> uint {$/;"	f
get_tydesc	_	pub fn get_tydesc<T>() -> *TyDesc;$/;"	f
get_type_id	_	fn get_type_id(&self) -> TypeId {$/;"	f
get_type_id	_	fn get_type_id(&self) -> TypeId;$/;"	f
get_winsize	_	fn get_winsize(&mut self) -> Result<(int, int), IoError>;$/;"	f
get_with	_	/^fn get_with<T:'static,$/;"	f
getcond	_	unsafe fn getcond(&mut self) -> *mut c_void {$/;"	f
getcount	_	fn getcount(&mut self, cnt: &rt::Count) -> Option<uint> {$/;"	f
getcwd	_	pub fn getcwd(buf: *mut c_char, size: size_t) -> *c_char;$/;"	f
getcwd	_	/^pub fn getcwd() -> Path {$/;"	f
getdtablesize	_	pub fn getdtablesize() -> c_int;$/;"	f
getegid	_	pub fn getegid() -> gid_t;$/;"	f
getenv	_	pub fn getenv(s: *c_char) -> *c_char;$/;"	f
getenv	_	/^pub fn getenv(n: &str) -> Option<~str> {$/;"	f
getenv_as_bytes	_	/^pub fn getenv_as_bytes(n: &str) -> Option<~[u0]> {$/;"	f
getenv_nonempty	_	fn getenv_nonempty(v: &str) -> Option<Path> {$/;"	f
geteuid	_	pub fn geteuid() -> uid_t;$/;"	f
getgid	_	pub fn getgid() -> gid_t ;$/;"	f
getgroups	_	pub fn getgroups(ngroups_max: c_int, groups: *mut gid_t)$/;"	f
getlock	_	unsafe fn getlock(&mut self) -> *mut c_void {$/;"	f
getlogin	_	pub fn getlogin() -> *c_char;$/;"	f
getopt	_	pub fn getopt(argc: c_int, argv: **c_char, optstr: *c_char)$/;"	f
getpeername	_	pub fn getpeername(socket: SOCKET, address: *mut sockaddr,$/;"	f
getpeername	_	pub fn getpeername(socket: c_int, address: *mut sockaddr,$/;"	f
getpgrp	_	pub fn getpgrp() -> pid_t;$/;"	f
getpid	_	pub fn getpid() -> c_int;$/;"	f
getpid	_	pub fn getpid() -> pid_t;$/;"	f
getppid	_	pub fn getppid() -> pid_t;$/;"	f
getrlimit	_	fn getrlimit(resource: libc::c_int, rlp: *mut rlimit) -> libc::c_int;$/;"	f
getsockname	_	pub fn getsockname(socket: SOCKET, address: *mut sockaddr,$/;"	f
getsockname	_	pub fn getsockname(socket: c_int, address: *mut sockaddr,$/;"	f
getuid	_	pub fn getuid() -> uid_t;$/;"	f
glob	_	pub fn glob(pattern: *c_char,$/;"	f
glob	_	pub mod glob {$/;"	m
glob_t	_	pub struct glob_t {$/;"	s
global_heap	_	/^pub mod global_heap;$/;"	m
globfree	_	pub fn globfree(pglob: *mut glob_t);$/;"	f
granularity	_	pub fn granularity() -> uint {$/;"	f
grow	_	fn grow(&mut self, n: uint, initval: &T) {$/;"	f
grow	_	fn grow(&mut self, n: uint, initval: &T);$/;"	f
grow	_	pub fn grow(&mut self, n: uint, initval: &T) {$/;"	f
grow_fn	_	fn grow_fn(&mut self, n: uint, op: |uint| -> T) {$/;"	f
grow_fn	_	fn grow_fn(&mut self, n: uint, op: |uint| -> T);$/;"	f
grow_set	_	fn grow_set(&mut self, index: uint, initval: &T, val: T) {$/;"	f
grow_set	_	fn grow_set(&mut self, index: uint, initval: &T, val: T);$/;"	f
grow_set	_	pub fn grow_set(&mut self, index: uint, initval: &T, val: T) {$/;"	f
gt	_	fn gt(&self, other: &Self) -> bool {  other.lt(self) }$/;"	f
gt	_	pub fn gt<A: Eq + Ord, T: Iterator<A>>(mut a: T, mut b: T) -> bool {$/;"	f
gt	_	fn gt(&self, other: &@T) -> bool { *(*self) > *(*other) }$/;"	f
gt	_	fn gt(&self, other: &f0) -> bool { (*self) > (*other) }$/;"	f
gt	_	fn gt(&self, other: &f0) -> bool { (*self) > (*other) }$/;"	f
gt	_	fn gt(&self, other: &~T) -> bool { *(*self) > *(*other) }$/;"	f
gt	_	fn gt(&self, other: &*T) -> bool {$/;"	f
gt	_	fn gt(&self, other: &*mut T) -> bool {$/;"	f
gt	_	fn gt(&self, other: &Rc<T>) -> bool { *self.borrow() > *other.borrow() }$/;"	f
gt	_	fn gt(&self, other: & &'a T) -> bool {$/;"	f
gt	_	fn gt(&self, other: &($($T,)+)) -> bool {$/;"	f
gt	_	fn gt(&self, other: & &'a [T]) -> bool {$/;"	f
gt	_	fn gt(&self, other: &~[T]) -> bool { self.as_slice() > other.as_slice() }$/;"	f
half_a_million_letter_X	_	fn half_a_million_letter_X() -> ~str {$/;"	f
half_a_million_letter_a	_	fn half_a_million_letter_a() -> ~str {$/;"	f
handle	_	pub fn handle<'a, T: Send>(&'a self, port: &'a Port<T>) -> Handle<'a, T> {$/;"	f
has_active_io	_	fn has_active_io(&self) -> bool;$/;"	f
has_nonsemantic_trailing_slash	_	fn has_nonsemantic_trailing_slash(&self) -> bool {$/;"	f
hash	_	fn hash(&self, state: &mut S) {$/;"	f
hash	_	fn hash(&self, state: &mut S) {$/;"	f
hash	_	fn hash(&self, state: &mut u0) {$/;"	f
hash	_	fn hash<T: Hash<MyWriter>>(&self, value: &T) -> u0 {$/;"	f
hash	_	fn hash(&self, state: &mut S) {$/;"	f
hash	_	fn hash(&self, state: &mut S);$/;"	f
hash	_	fn hash<T: Hash<S>>(&self, value: &T) -> u0;$/;"	f
hash	_	fn hash(&self, state: &mut S) {$/;"	f
hash	_	fn hash<T: Hash<SipState>>(&self, value: &T) -> u0 {$/;"	f
hash	_	/^pub fn hash<T: Hash<SipState>>(value: &T) -> u0 {$/;"	f
hash	_	/^pub mod hash;$/;"	m
hash	_	fn hash(&self, s: &mut sip::SipState) {$/;"	f
hash	_	fn hash(&self, s: &mut sip::SipState) {$/;"	f
hash	_	fn hash(&self, s: &mut sip::SipState) {$/;"	f
hash_with_keys	_	/^pub fn hash_with_keys<T: Hash<SipState>>(k0: u0, k0: u0, value: &T) -> u0 {$/;"	f
head	_	fn head(&self) -> Option<&'a T> {$/;"	f
head	_	fn head(&self) -> Option<&'a T>;$/;"	f
heap_cycles	_	fn heap_cycles() {$/;"	f
hear_broadcasts	_	fn hear_broadcasts(&mut self) -> Result<(), IoError>;$/;"	f
hold_and_signal	_	pub unsafe fn hold_and_signal(&self, f: |x: &mut T|) {$/;"	f
hold_and_wait	_	pub unsafe fn hold_and_wait(&self, f: |x: &T| -> bool) {$/;"	f
homedir	_	fn homedir() {$/;"	f
homedir	_	/^pub fn homedir() -> Option<Path> {$/;"	f
hypot	_	pub fn hypot(x: c_double, y: c_double) -> c_double;$/;"	f
hypot	_	pub fn hypot(x: c_float, y: c_float) -> c_float;$/;"	f
hypot	_	fn hypot(&self, other: &f0) -> f0 { hypot(*self, *other) }$/;"	f
hypot	_	fn hypot(x: c_float, y: c_float) -> c_float = cmath::c_float::hypot,$/;"	f
hypot	_	fn hypot(&self, other: &f0) -> f0 { hypot(*self, *other) }$/;"	f
hypot	_	fn hypot(x: c_double, y: c_double) -> c_double = cmath::c_double::hypot,$/;"	f
hypot	_	fn hypot(&self, other: &Self) -> Self;$/;"	f
i0_add_with_overflow	_	pub fn i0_add_with_overflow(x: i0, y: i0) -> (i0, bool);$/;"	f
i0_mul_with_overflow	_	pub fn i0_mul_with_overflow(x: i0, y: i0) -> (i0, bool);$/;"	f
i0_sub_with_overflow	_	pub fn i0_sub_with_overflow(x: i0, y: i0) -> (i0, bool);$/;"	f
i0x0	_	/^pub struct i0x0(i0, i0, i0, i0, i0, i0, i0, i0);$/;"	s
i0_add_with_overflow	_	pub fn i0_add_with_overflow(x: i0, y: i0) -> (i0, bool);$/;"	f
i0_mul_with_overflow	_	pub fn i0_mul_with_overflow(x: i0, y: i0) -> (i0, bool);$/;"	f
i0_sub_with_overflow	_	pub fn i0_sub_with_overflow(x: i0, y: i0) -> (i0, bool);$/;"	f
i0x0	_	/^pub struct i0x0(i0, i0, i0, i0);$/;"	s
i0_add_with_overflow	_	pub fn i0_add_with_overflow(x: i0, y: i0) -> (i0, bool);$/;"	f
i0_mul_with_overflow	_	pub fn i0_mul_with_overflow(x: i0, y: i0) -> (i0, bool);$/;"	f
i0_sub_with_overflow	_	pub fn i0_sub_with_overflow(x: i0, y: i0) -> (i0, bool);$/;"	f
i0x0	_	/^pub struct i0x0(i0, i0);$/;"	s
i0_add_with_overflow	_	pub fn i0_add_with_overflow(x: i0, y: i0) -> (i0, bool);$/;"	f
i0_mul_with_overflow	_	pub fn i0_mul_with_overflow(x: i0, y: i0) -> (i0, bool);$/;"	f
i0_sub_with_overflow	_	pub fn i0_sub_with_overflow(x: i0, y: i0) -> (i0, bool);$/;"	f
i0x0	_	/^pub struct i0x0(i0, i0, i0, i0, i0, i0, i0, i0, i0, i0, i0, i0, i0, i0, i0, i0);$/;"	s
id	_	pub fn id(&self) -> uint { self.id }$/;"	f
id	_	pub fn id(&self) -> libc::pid_t { self.handle.id() }$/;"	f
id	_	fn id(&self) -> libc::pid_t;$/;"	f
idx	_	fn idx(&self, _: uint) -> Option<A> { Some(self.element.clone()) }$/;"	f
idx	_	fn idx(&self, index: uint) -> Option<(A, B)> {$/;"	f
idx	_	fn idx(&self, index: uint) -> Option<(uint, A)> {$/;"	f
idx	_	fn idx(&self, index: uint) -> Option<A> {$/;"	f
idx	_	fn idx(&self, index: uint) -> Option<A>;$/;"	f
idx	_	fn idx(&self, index: uint) -> Option<B> {$/;"	f
idx	_	fn idx(&self, index: uint) -> Option<&'a T> {$/;"	f
idx	_	fn idx(&self, index: uint) -> Option<&'a [T]> {$/;"	f
ignore_broadcasts	_	fn ignore_broadcasts(&mut self) -> Result<(), IoError>;$/;"	f
ilog_radix	_	pub fn ilog_radix(n: c_double) -> c_int;$/;"	f
ilog_radix	_	pub fn ilog_radix(n: c_float) -> c_int;$/;"	f
imm_release_borrow_mut	_	fn imm_release_borrow_mut() {$/;"	f
imp	_	/^mod imp {$/;"	m
imp	_	/^mod imp {$/;"	m
imp	_	/^mod imp {$/;"	m
in0_addr	_	pub struct in0_addr {$/;"	s
in_addr	_	pub struct in_addr {$/;"	s
incoming	_	fn incoming<'r>(&'r mut self) -> IncomingConnections<'r, Self> {$/;"	f
increment	_	/^pub fn increment() {$/;"	f
ind_sample	_	fn ind_sample<R: Rng>(&self, rng: &mut R) -> f0 {$/;"	f
ind_sample	_	fn ind_sample<R: Rng>(&self, rng: &mut R) -> f0 {$/;"	f
ind_sample	_	fn ind_sample<R: Rng>(&self, &mut R) -> Support;$/;"	f
ind_sample	_	fn ind_sample<R: Rng>(&self, rng: &mut R) -> Sup {$/;"	f
ind_sample	_	fn ind_sample<R: Rng>(&self, rng: &mut R) -> T {$/;"	f
ind_sample	_	fn ind_sample<R: Rng>(&self, rng: &mut R) -> f0 {$/;"	f
ind_sample	_	fn ind_sample<R: Rng>(&self, rng: &mut R) -> Sup {$/;"	f
index	_	fn index(&self, index: &Index) -> Result;$/;"	f
indexable	_	fn indexable(&self) -> uint { self.iter.indexable() }$/;"	f
indexable	_	fn indexable(&self) -> uint { uint::MAX }$/;"	f
indexable	_	fn indexable(&self) -> uint {$/;"	f
indexable	_	fn indexable(&self) -> uint;$/;"	f
indexable	_	fn indexable(&self) -> uint {$/;"	f
inf	_	fn inf()      -> Option<$t> { Some( 0.0 \/ 0.0) }$/;"	f
inf	_	fn inf()      -> Option<Self>;$/;"	f
infinity	_	fn infinity() -> f0 { 0.0 \/ 0.0 }$/;"	f
infinity	_	fn infinity() -> f0 { 0.0 \/ 0.0 }$/;"	f
infinity	_	fn infinity() -> Self;$/;"	f
inherit_blocker	_	pub fn inherit_blocker(&mut self, task: Option<BlockedTask>) {$/;"	f
init	_	pub fn init<T>() -> T;$/;"	f
init	_	/^pub unsafe fn init<T>() -> T {$/;"	f
init	_	fn init(&mut self, use_rsl: bool) {$/;"	f
init	_	pub unsafe fn init(_argc: int, _argv: **u0) {$/;"	f
init	_	pub unsafe fn init(argc: int, argv: **u0) {$/;"	f
init	_	/^pub unsafe fn init(argc: int, argv: **u0) { imp::init(argc, argv) }$/;"	f
init	_	/^pub unsafe fn init(argc: int, argv: **u0) { realargs::init(argc, argv) }$/;"	f
init	_	/^pub fn init() {$/;"	f
init	_	/^pub fn init() {$/;"	f
init	_	fn init(&mut self, _size: u0) {}$/;"	f
init	_	fn init(&mut self, size: u0) {$/;"	f
init	_	pub fn init() {$/;"	f
init	_	pub fn init() {}$/;"	f
init	_	/^pub fn init() {$/;"	f
init	_	/^pub fn init(argc: int, argv: **u0) {$/;"	f
init	_	fn init(&self) -> &'a [T] {$/;"	f
init	_	fn init(&self) -> &'a [T];$/;"	f
init	_	pub fn init<'a>(&'a self) -> &'a [T] {$/;"	f
init_cond	_	pub unsafe fn init_cond() -> uint {$/;"	f
init_elem	_	unsafe fn init_elem(self, i: uint, val: T) {$/;"	f
init_elem	_	unsafe fn init_elem(self, i: uint, val: T);$/;"	f
init_lock	_	pub unsafe fn init_lock() -> uint {$/;"	f
initn	_	fn initn(&self, n: uint) -> &'a [T] {$/;"	f
initn	_	fn initn(&self, n: uint) -> &'a [T];$/;"	f
insert	_	fn insert(&mut self, key: K, value: V) -> bool {$/;"	f
insert	_	fn insert(&mut self, value: T) -> bool;$/;"	f
insert	_	fn insert(&mut self, position: uint, substring: &str) {$/;"	f
insert	_	fn insert(&mut self, position: uint, substring: &str);$/;"	f
insert	_	fn insert(&mut self, i: uint, x: T) {$/;"	f
insert	_	fn insert(&mut self, i: uint, x:T);$/;"	f
insert	_	pub fn insert(&mut self, index: uint, element: T) {$/;"	f
insert_char	_	fn insert_char(&mut self, position: uint, ch: char) {$/;"	f
insert_char	_	fn insert_char(&mut self, position: uint, ch: char);$/;"	f
insertion_position	_	fn insertion_position(map: &mut Map,$/;"	f
insertion_sort	_	/^fn insertion_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {$/;"	f
inspect	_	fn inspect<'r>(self, f: 'r |&A|) -> Inspect<'r, A, Self> {$/;"	f
int	_	mod int {$/;"	m
int	_	mod int {$/;"	m
int_to_str_bytes_common	_	/^pub fn int_to_str_bytes_common<T: Int>(num: T, radix: uint, sign: SignFormat, f: |u0|) {$/;"	f
integer	_	fn integer(&mut self) -> Option<uint> {$/;"	f
integer_decode	_	fn integer_decode(&self) -> (u0, i0, i0) {$/;"	f
integer_decode	_	fn integer_decode(&self) -> (u0, i0, i0) {$/;"	f
integer_decode	_	fn integer_decode(&self) -> (u0, i0, i0);$/;"	f
into_ascii	_	fn into_ascii(self) -> ~[Ascii] {$/;"	f
into_ascii_lower	_	fn into_ascii_lower(self) -> ~str {$/;"	f
into_ascii_lower	_	fn into_ascii_lower(self) -> ~str;$/;"	f
into_ascii_nocheck	_	unsafe fn into_ascii_nocheck(self) -> ~[Ascii] {$/;"	f
into_ascii_nocheck	_	unsafe fn into_ascii_nocheck(self) -> ~[Ascii];$/;"	f
into_ascii_opt	_	fn into_ascii_opt(self) -> Option<~[Ascii]> {$/;"	f
into_ascii_upper	_	fn into_ascii_upper(self) -> ~str {$/;"	f
into_ascii_upper	_	fn into_ascii_upper(self) -> ~str;$/;"	f
into_bytes	_	fn into_bytes(self) -> ~[u0] {$/;"	f
into_bytes	_	fn into_bytes(self) -> ~[u0];$/;"	f
into_bytes	_	fn into_bytes(self) -> ~[u0] {$/;"	f
into_bytes	_	fn into_bytes(self) -> ~[u0];$/;"	f
into_maybe_owned	_	fn into_maybe_owned(self) -> MaybeOwned<'a> { Owned(self) }$/;"	f
into_maybe_owned	_	fn into_maybe_owned(self) -> MaybeOwned<'a> { Slice(self) }$/;"	f
into_maybe_owned	_	fn into_maybe_owned(self) -> MaybeOwned<'a> { self }$/;"	f
into_maybe_owned	_	fn into_maybe_owned(self) -> MaybeOwned<'a>;$/;"	f
into_option	_	pub fn into_option(self) -> Option<(T,T)> {$/;"	f
into_owned	_	fn into_owned(self) -> ~str { self }$/;"	f
into_owned	_	fn into_owned(self) -> ~str { self.to_owned() }$/;"	f
into_owned	_	fn into_owned(self) -> ~str {$/;"	f
into_owned	_	fn into_owned(self) -> ~str;$/;"	f
into_owned	_	fn into_owned(self) -> ~[T] { self }$/;"	f
into_owned	_	fn into_owned(self) -> ~[T] { self.to_owned() }$/;"	f
into_owned	_	fn into_owned(self) -> ~[T];$/;"	f
into_str	_	fn into_str(self) -> ~str {$/;"	f
into_str	_	fn into_str(self) -> ~str;$/;"	f
into_vec	_	fn into_vec(self) -> ~[u0];$/;"	f
into_vec	_	fn into_vec(self) -> ~[u0] {$/;"	f
into_vec	_	fn into_vec(self) -> ~[u0] {$/;"	f
intrinsics	_	/^pub mod intrinsics;$/;"	m
io	_	impl io::Reader for S {$/;"	i
io	_	impl io::Writer for S {$/;"	i
io	_	/^pub mod io;$/;"	m
io	_	fn io<'a>(&'a mut self) -> Option<&'a mut IoFactory>;$/;"	f
io	_	impl io::Writer for Stderr {$/;"	i
ip	_	/^pub mod ip;$/;"	m
ip0_mreq	_	pub struct ip0_mreq {$/;"	s
ip_mreq	_	pub struct ip_mreq {$/;"	s
ipv0_addr_from_head_tail	_	fn ipv0_addr_from_head_tail(head: &[u0], tail: &[u0]) -> IpAddr {$/;"	f
ipv0_addr_to_str	_	fn ipv0_addr_to_str() {$/;"	f
is	_	fn is<T: 'static>(self) -> bool {$/;"	f
is	_	fn is<T: 'static>(self) -> bool;$/;"	f
is_XID_continue	_	fn is_XID_continue(&self) -> bool { is_XID_continue(*self) }$/;"	f
is_XID_continue	_	fn is_XID_continue(&self) -> bool;$/;"	f
is_XID_continue	_	/^pub fn is_XID_continue(c: char) -> bool { derived_property::XID_Continue(c) }$/;"	f
is_XID_start	_	fn is_XID_start(&self) -> bool { is_XID_start(*self) }$/;"	f
is_XID_start	_	fn is_XID_start(&self) -> bool;$/;"	f
is_XID_start	_	/^pub fn is_XID_start(c: char) -> bool    { derived_property::XID_Start(c) }$/;"	f
is_absolute	_	fn is_absolute(&self) -> bool;$/;"	f
is_absolute	_	fn is_absolute(&self) -> bool {$/;"	f
is_absolute	_	fn is_absolute(&self) -> bool {$/;"	f
is_alnum	_	pub fn is_alnum(&self) -> bool {$/;"	f
is_alpha	_	pub fn is_alpha(&self) -> bool {$/;"	f
is_alphabetic	_	fn is_alphabetic(&self) -> bool { is_alphabetic(*self) }$/;"	f
is_alphabetic	_	fn is_alphabetic(&self) -> bool;$/;"	f
is_alphabetic	_	/^pub fn is_alphabetic(c: char) -> bool   { derived_property::Alphabetic(c) }$/;"	f
is_alphanumeric	_	fn is_alphanumeric(&self) -> bool { is_alphanumeric(*self) }$/;"	f
is_alphanumeric	_	fn is_alphanumeric(&self) -> bool;$/;"	f
is_alphanumeric	_	/^pub fn is_alphanumeric(c: char) -> bool {$/;"	f
is_alphanumeric	_	fn is_alphanumeric(&self) -> bool { self.chars().all(char::is_alphanumeric) }$/;"	f
is_alphanumeric	_	fn is_alphanumeric(&self) -> bool;$/;"	f
is_ancestor_of	_	fn is_ancestor_of(&self, other: &Self) -> bool;$/;"	f
is_ancestor_of	_	fn is_ancestor_of(&self, other: &Path) -> bool {$/;"	f
is_ancestor_of	_	fn is_ancestor_of(&self, other: &Path) -> bool {$/;"	f
is_ancestor_of_path_with_0_dirs	_	fn is_ancestor_of_path_with_0_dirs(bh: &mut BenchHarness) {$/;"	f
is_ascii	_	fn is_ascii(&self) -> bool {$/;"	f
is_ascii	_	fn is_ascii(&self) -> bool;$/;"	f
is_blank	_	pub fn is_blank(&self) -> bool {$/;"	f
is_char_boundary	_	fn is_char_boundary(&self, index: uint) -> bool {$/;"	f
is_char_boundary	_	fn is_char_boundary(&self, index: uint) -> bool;$/;"	f
is_control	_	pub fn is_control(&self) -> bool {$/;"	f
is_control	_	fn is_control(&self) -> bool { is_control(*self) }$/;"	f
is_control	_	fn is_control(&self) -> bool;$/;"	f
is_control	_	/^pub fn is_control(c: char) -> bool { general_category::Cc(c) }$/;"	f
is_cwd_relative	_	/^pub fn is_cwd_relative(path: &Path) -> bool {$/;"	f
is_digit	_	pub fn is_digit(&self) -> bool {$/;"	f
is_digit	_	fn is_digit(&self) -> bool { is_digit(*self) }$/;"	f
is_digit	_	fn is_digit(&self) -> bool;$/;"	f
is_digit	_	/^pub fn is_digit(c: char) -> bool {$/;"	f
is_digit_radix	_	fn is_digit_radix(&self, radix: uint) -> bool { is_digit_radix(*self, radix) }$/;"	f
is_digit_radix	_	fn is_digit_radix(&self, radix: uint) -> bool;$/;"	f
is_digit_radix	_	/^pub fn is_digit_radix(c: char, radix: uint) -> bool {$/;"	f
is_dir	_	pub fn is_dir(&self) -> bool {$/;"	f
is_disjoint	_	fn is_disjoint(&self, other: &Self) -> bool;$/;"	f
is_empty	_	fn is_empty(&self) -> bool {$/;"	f
is_empty	_	pub fn is_empty(&mut self) -> bool {$/;"	f
is_empty	_	pub fn is_empty(&mut self, order: Ordering) -> bool {$/;"	f
is_eof	_	fn is_eof(&self) -> bool {$/;"	f
is_err	_	pub fn is_err(&self) -> bool {$/;"	f
is_file	_	pub fn is_file(&self) -> bool {$/;"	f
is_finite	_	fn is_finite(&self) -> bool {$/;"	f
is_finite	_	fn is_finite(&self) -> bool {$/;"	f
is_finite	_	fn is_finite(&self) -> bool;$/;"	f
is_graph	_	pub fn is_graph(&self) -> bool {$/;"	f
is_hex	_	pub fn is_hex(&self) -> bool {$/;"	f
is_infinite	_	fn is_infinite(&self) -> bool {$/;"	f
is_infinite	_	fn is_infinite(&self) -> bool {$/;"	f
is_infinite	_	fn is_infinite(&self) -> bool;$/;"	f
is_lower	_	pub fn is_lower(&self) -> bool {$/;"	f
is_lowercase	_	fn is_lowercase(&self) -> bool { is_lowercase(*self) }$/;"	f
is_lowercase	_	fn is_lowercase(&self) -> bool;$/;"	f
is_lowercase	_	/^pub fn is_lowercase(c: char) -> bool { derived_property::Lowercase(c) }$/;"	f
is_nan	_	fn is_nan(&self) -> bool { *self != *self }$/;"	f
is_nan	_	fn is_nan(&self) -> bool { *self != *self }$/;"	f
is_nan	_	fn is_nan(&self) -> bool;$/;"	f
is_negative	_	fn is_negative(&self) -> bool { *self < 0.0 || (0.0 \/ *self) == NEG_INFINITY }$/;"	f
is_negative	_	fn is_negative(&self) -> bool { *self < 0.0 || (0.0 \/ *self) == NEG_INFINITY }$/;"	f
is_negative	_	fn is_negative(&self) -> bool { *self < 0 }$/;"	f
is_negative	_	fn is_negative(&self) -> bool;$/;"	f
is_none	_	pub fn is_none(&self) -> bool {$/;"	f
is_normal	_	fn is_normal(&self) -> bool {$/;"	f
is_normal	_	fn is_normal(&self) -> bool {$/;"	f
is_normal	_	fn is_normal(&self) -> bool;$/;"	f
is_not_null	_	pub fn is_not_null(&self) -> bool {$/;"	f
is_not_null	_	fn is_not_null(&self) -> bool { !self.is_null() }$/;"	f
is_null	_	pub fn is_null(&self) -> bool {$/;"	f
is_null	_	fn is_null(&self) -> bool { *self == RawPtr::null() }$/;"	f
is_null	_	fn is_null(&self) -> bool;$/;"	f
is_odd	_	fn is_odd(n: &uint) -> bool { *n % 0u == 0u }$/;"	f
is_ok	_	pub fn is_ok(&self) -> bool {$/;"	f
is_owned	_	pub fn is_owned(&self) -> bool {$/;"	f
is_owned	_	pub fn is_owned(&self) -> bool {$/;"	f
is_positive	_	fn is_positive(&self) -> bool { *self > 0.0 || (0.0 \/ *self) == INFINITY }$/;"	f
is_positive	_	fn is_positive(&self) -> bool { *self > 0.0 || (0.0 \/ *self) == INFINITY }$/;"	f
is_positive	_	fn is_positive(&self) -> bool { *self > 0 }$/;"	f
is_positive	_	fn is_positive(&self) -> bool;$/;"	f
is_print	_	pub fn is_print(&self) -> bool {$/;"	f
is_punctuation	_	pub fn is_punctuation(&self) -> bool {$/;"	f
is_relative	_	fn is_relative(&self) -> bool {$/;"	f
is_relative	_	fn is_relative(&self) -> bool {$/;"	f
is_sep	_	/^pub fn is_sep(c: char) -> bool {$/;"	f
is_sep	_	/^pub fn is_sep(c: char) -> bool {$/;"	f
is_sep_	_	fn is_sep_(prefix: Option<PathPrefix>, u: u0) -> bool {$/;"	f
is_sep_byte	_	/^pub fn is_sep_byte(u: &u0) -> bool {$/;"	f
is_sep_byte	_	/^pub fn is_sep_byte(u: &u0) -> bool {$/;"	f
is_sep_byte_verbatim	_	/^pub fn is_sep_byte_verbatim(u: &u0) -> bool {$/;"	f
is_sep_verbatim	_	/^pub fn is_sep_verbatim(c: char) -> bool {$/;"	f
is_slice	_	pub fn is_slice(&self) -> bool {$/;"	f
is_some	_	pub fn is_some(&self) -> bool {$/;"	f
is_str	_	fn is_str(_: Option<&'a str>) -> bool { true }$/;"	f
is_str	_	fn is_str(_: Option<Self>) -> bool { false }$/;"	f
is_str	_	fn is_str(_: Option<str::MaybeOwned>) -> bool { true }$/;"	f
is_str	_	fn is_str(_: Option<~str>) -> bool { true }$/;"	f
is_str	_	fn is_str(_: Option<&'a Path>) -> bool { true }$/;"	f
is_str	_	fn is_str(_: Option<Path>) -> bool { true }$/;"	f
is_subset	_	fn is_subset(&self, other: &Self) -> bool;$/;"	f
is_superset	_	fn is_superset(&self, other: &Self) -> bool;$/;"	f
is_upper	_	pub fn is_upper(&self) -> bool {$/;"	f
is_uppercase	_	fn is_uppercase(&self) -> bool { is_uppercase(*self) }$/;"	f
is_uppercase	_	fn is_uppercase(&self) -> bool;$/;"	f
is_uppercase	_	/^pub fn is_uppercase(c: char) -> bool { derived_property::Uppercase(c) }$/;"	f
is_utf0	_	/^pub fn is_utf0(v: &[u0]) -> bool {$/;"	f
is_utf0	_	/^pub fn is_utf0(v: &[u0]) -> bool {$/;"	f
is_utf0_0_ascii	_	fn is_utf0_0_ascii(bh: &mut BenchHarness) {$/;"	f
is_utf0_0_multibyte	_	fn is_utf0_0_multibyte(bh: &mut BenchHarness) {$/;"	f
is_verbatim	_	/^pub fn is_verbatim(path: &Path) -> bool {$/;"	f
is_vol_abs	_	fn is_vol_abs(path: &str, prefix: Option<PathPrefix>) -> bool {$/;"	f
is_vol_relative	_	/^pub fn is_vol_relative(path: &Path) -> bool {$/;"	f
is_whitespace	_	fn is_whitespace(&self) -> bool { is_whitespace(*self) }$/;"	f
is_whitespace	_	fn is_whitespace(&self) -> bool;$/;"	f
is_whitespace	_	/^pub fn is_whitespace(c: char) -> bool {$/;"	f
is_whitespace	_	fn is_whitespace(&self) -> bool { self.chars().all(char::is_whitespace) }$/;"	f
is_whitespace	_	fn is_whitespace(&self) -> bool;$/;"	f
is_zero	_	fn is_zero(&self) -> bool { *self == 0.0 || *self == -0.0 }$/;"	f
is_zero	_	fn is_zero(&self) -> bool { *self == 0.0 || *self == -0.0 }$/;"	f
is_zero	_	fn is_zero(&self) -> bool { *self == 0 }$/;"	f
is_zero	_	fn is_zero(&self) -> bool;$/;"	f
is_zero	_	fn is_zero(&self) -> bool { *self == 0 }$/;"	f
isaac	_	fn isaac(&mut self) {$/;"	f
isaac	_	/^pub mod isaac;$/;"	m
isaac0	_	fn isaac0(&mut self) {$/;"	f
isalnum	_	pub fn isalnum(c: c_int) -> c_int;$/;"	f
isalpha	_	pub fn isalpha(c: c_int) -> c_int;$/;"	f
isatty	_	pub fn isatty(&self) -> bool {$/;"	f
isatty	_	pub fn isatty(fd: c_int) -> c_int;$/;"	f
isatty	_	fn isatty(&self) -> bool;$/;"	f
iscntrl	_	pub fn iscntrl(c: c_int) -> c_int;$/;"	f
isdigit	_	pub fn isdigit(c: c_int) -> c_int;$/;"	f
isgraph	_	pub fn isgraph(c: c_int) -> c_int;$/;"	f
islower	_	pub fn islower(c: c_int) -> c_int;$/;"	f
isprint	_	pub fn isprint(c: c_int) -> c_int;$/;"	f
ispunct	_	pub fn ispunct(c: c_int) -> c_int;$/;"	f
isspace	_	pub fn isspace(c: c_int) -> c_int;$/;"	f
isupper	_	pub fn isupper(c: c_int) -> c_int;$/;"	f
isxdigit	_	pub fn isxdigit(c: c_int) -> c_int;$/;"	f
iter	_	pub fn iter<'a>(&'a self) -> CChars<'a> {$/;"	f
iter	_	pub fn iter<'a>(&'a self) -> Messages<'a, T> {$/;"	f
iter	_	fn iter(&self) -> Packets { Packets { cur: self.head } }$/;"	f
iter	_	/^pub mod iter;$/;"	m
iter	_	pub fn iter<'r>(&'r self) -> Item<&'r T> {$/;"	f
iter	_	fn iter(self) -> Items<'a, T> {$/;"	f
iter	_	fn iter(self) -> Items<'a, T>;$/;"	f
iter	_	pub fn iter<'a>(&'a self) -> Items<'a,T> {$/;"	f
iter_crate_map	_	/^pub fn iter_crate_map<'a>(crate_map: &'a CrateMap<'a>, f: |&'a ModEntry<'a>|) {$/;"	f
iter_crate_map_duplicates	_	fn iter_crate_map_duplicates() {$/;"	f
iter_crate_map_follow_children	_	fn iter_crate_map_follow_children() {$/;"	f
iterator	_	fn iterator(bh: &mut BenchHarness) {$/;"	f
j0	_	pub fn j0(n: c_double) -> c_double;$/;"	f
j0	_	pub fn j0(n: c_double) -> c_double;$/;"	f
jn	_	pub fn jn(i: c_int, n: c_double) -> c_double;$/;"	f
join	_	fn join(&self, path: &str) -> Path {$/;"	f
join	_	fn join<T: BytesContainer>(&self, path: T) -> Self {$/;"	f
join	_	pub fn join(mut self) -> T {$/;"	f
join	_	pub unsafe fn join(native: rust_thread) {$/;"	f
join_abs_path_home_dir	_	fn join_abs_path_home_dir(bh: &mut BenchHarness) {$/;"	f
join_home_dir	_	fn join_home_dir(bh: &mut BenchHarness) {$/;"	f
join_many	_	fn join_many<T: BytesContainer>(&self, paths: &[T]) -> Self {$/;"	f
join_many_abs_path_home_dir	_	fn join_many_abs_path_home_dir(bh: &mut BenchHarness) {$/;"	f
join_many_home_dir	_	fn join_many_home_dir(bh: &mut BenchHarness) {$/;"	f
join_multicast	_	fn join_multicast(&mut self, multi: IpAddr) -> Result<(), IoError>;$/;"	f
keepalive	_	fn keepalive(&mut self, delay_in_seconds: uint) -> Result<(), IoError>;$/;"	f
kernel0	_	pub mod kernel0 {$/;"	m
key_to_key_value	_	/^fn key_to_key_value<T: 'static>(key: Key<T>) -> *u0 {$/;"	f
kill	_	pub fn kill(id: libc::pid_t, signal: int) -> IoResult<()> {$/;"	f
kill	_	pub fn kill(pid: pid_t, sig: c_int) -> c_int;$/;"	f
kill	_	fn kill(&mut self, pid: libc::pid_t, signal: int) -> Result<(), IoError>;$/;"	f
kill	_	fn kill(&mut self, signal: int) -> Result<(), IoError>;$/;"	f
labs	_	pub fn labs(i: c_long) -> c_long;$/;"	f
last	_	fn last(&mut self) -> Option<A> {$/;"	f
last	_	fn last(&self) -> Option<&'a T> {$/;"	f
last	_	fn last(&self) -> Option<&'a T>;$/;"	f
last	_	pub fn last<'a>(&'a self) -> Option<&'a T> {$/;"	f
last_os_error	_	pub fn last_os_error() {$/;"	f
last_os_error	_	/^pub fn last_os_error() -> ~str {$/;"	f
ldexp	_	pub fn ldexp(x: c_double, n: c_int) -> c_double;$/;"	f
ldexp	_	pub fn ldexp(x: c_float, n: c_int) -> c_float;$/;"	f
ldexp	_	fn ldexp(x: c_float, n: c_int) -> c_float = cmath::c_float::ldexp,$/;"	f
ldexp	_	fn ldexp(x: f0, exp: int) -> f0 {$/;"	f
ldexp	_	fn ldexp(x: c_double, n: c_int) -> c_double = cmath::c_double::ldexp,$/;"	f
ldexp	_	fn ldexp(x: f0, exp: int) -> f0 {$/;"	f
ldexp	_	fn ldexp(x: Self, exp: int) -> Self;$/;"	f
ldexp_radix	_	pub fn ldexp_radix(n: c_double, i: c_int) -> c_double;$/;"	f
ldexp_radix	_	pub fn ldexp_radix(n: c_float, i: c_int) -> c_float;$/;"	f
le	_	fn le(&self, other: &Self) -> bool { !other.lt(self) }$/;"	f
le	_	pub fn le<A: Eq + Ord, T: Iterator<A>>(mut a: T, mut b: T) -> bool {$/;"	f
le	_	fn le(&self, other: &@T) -> bool { *(*self) <= *(*other) }$/;"	f
le	_	fn le(&self, other: &f0) -> bool { (*self) <= (*other) }$/;"	f
le	_	fn le(&self, other: &f0) -> bool { (*self) <= (*other) }$/;"	f
le	_	fn le(&self, other: &~T) -> bool { *(*self) <= *(*other) }$/;"	f
le	_	fn le(&self, other: &*T) -> bool {$/;"	f
le	_	fn le(&self, other: &*mut T) -> bool {$/;"	f
le	_	fn le(&self, other: &Rc<T>) -> bool { *self.borrow() <= *other.borrow() }$/;"	f
le	_	fn le(&self, other: & &'a T) -> bool {$/;"	f
le	_	fn le(&self, other: &($($T,)+)) -> bool {$/;"	f
le	_	fn le(&self, other: & &'a [T]) -> bool {$/;"	f
le	_	fn le(&self, other: &~[T]) -> bool { self.as_slice() <= other.as_slice() }$/;"	f
leading_zeros	_	fn leading_zeros(&self) -> i0 { unsafe { intrinsics::ctlz0(*self) } }$/;"	f
leading_zeros	_	fn leading_zeros(&self) -> i0 { unsafe { intrinsics::ctlz0(*self) } }$/;"	f
leading_zeros	_	fn leading_zeros(&self) -> i0 { unsafe { intrinsics::ctlz0(*self) } }$/;"	f
leading_zeros	_	fn leading_zeros(&self) -> i0 { unsafe { intrinsics::ctlz0(*self) } }$/;"	f
leading_zeros	_	fn leading_zeros(&self) -> int { (*self as i0).leading_zeros() as int }$/;"	f
leading_zeros	_	fn leading_zeros(&self) -> int { (*self as i0).leading_zeros() as int }$/;"	f
leading_zeros	_	fn leading_zeros(&self) -> Self;$/;"	f
leading_zeros	_	fn leading_zeros(&self) -> $T {$/;"	f
leave_multicast	_	fn leave_multicast(&mut self, multi: IpAddr) -> Result<(), IoError>;$/;"	f
len	_	fn len(&self) -> uint {$/;"	f
len	_	fn len(&self) -> uint;$/;"	f
len	_	fn len(&mut self) -> uint {$/;"	f
len	_	fn len(&self) -> uint { self.as_slice().len() }$/;"	f
len	_	fn len(&self) -> uint {$/;"	f
len	_	fn len(&self) -> uint {$/;"	f
len	_	fn len(&self) -> uint {$/;"	f
len_utf0_bytes	_	fn len_utf0_bytes(&self) -> uint { len_utf0_bytes(*self) }$/;"	f
len_utf0_bytes	_	fn len_utf0_bytes(&self) -> uint;$/;"	f
len_utf0_bytes	_	/^pub fn len_utf0_bytes(c: char) -> uint {$/;"	f
letdie	_	fn letdie(&mut self) -> Result<(), IoError>;$/;"	f
lev_distance	_	fn lev_distance(&self, t: &str) -> uint {$/;"	f
lev_distance	_	fn lev_distance(&self, t: &str) -> uint;$/;"	f
lexical_ordering	_	/^pub fn lexical_ordering(o0: Ordering, o0: Ordering) -> Ordering {$/;"	f
lgamma	_	pub fn lgamma(n: c_double, sign: &mut c_int) -> c_double;$/;"	f
lgamma	_	pub fn lgamma(n: c_float, sign: &mut c_int) -> c_float;$/;"	f
libc	_	/^pub mod libc;$/;"	m
libunwind	_	/^mod libunwind {$/;"	m
limit	_	pub fn limit(&self) -> uint { self.limit }$/;"	f
limit_thread_creation_due_to_osx_and_valgrind	_	/^pub fn limit_thread_creation_due_to_osx_and_valgrind() -> bool {$/;"	f
lines	_	fn lines<'r>(&'r mut self) -> Lines<'r, Self> {$/;"	f
lines	_	fn lines(&self) -> CharSplits<'a, char> {$/;"	f
lines	_	fn lines(&self) -> CharSplits<'a, char>;$/;"	f
lines_any	_	fn lines_any(&self) -> AnyLines<'a> {$/;"	f
lines_any	_	fn lines_any(&self) -> AnyLines<'a>;$/;"	f
link	_	/^pub fn link(src: &Path, dst: &Path) -> IoResult<()> {$/;"	f
link	_	pub fn link(src: *c_char, dst: *c_char) -> c_int;$/;"	f
linux	_	pub mod linux {$/;"	m
listen	_	fn listen(self) -> IoResult<A>;$/;"	f
listen	_	fn listen(self) -> IoResult<TcpAcceptor> {$/;"	f
listen	_	fn listen(self) -> IoResult<UnixAcceptor> {$/;"	f
listen	_	fn listen(self) -> IoResult<A> {$/;"	f
listen	_	pub fn listen(socket: SOCKET, backlog: c_int) -> c_int;$/;"	f
listen	_	pub fn listen(socket: c_int, backlog: c_int) -> c_int;$/;"	f
listen	_	fn listen(~self) -> Result<~RtioTcpAcceptor, IoError>;$/;"	f
listen	_	fn listen(~self) -> Result<~RtioUnixAcceptor, IoError>;$/;"	f
live_allocs	_	/^pub fn live_allocs() -> *mut Box {$/;"	f
ln	_	fn ln(&self) -> f0 { ln(*self) }$/;"	f
ln	_	fn ln(n: f0) -> f0 = intrinsics::logf0,$/;"	f
ln	_	fn ln(&self) -> f0 { ln(*self) }$/;"	f
ln	_	fn ln(n: f0) -> f0 = intrinsics::logf0,$/;"	f
ln	_	fn ln(&self) -> Self;$/;"	f
ln_0	_	fn ln_0() -> f0 { 0.0 }$/;"	f
ln_0	_	fn ln_0() -> f0 { 0.0 }$/;"	f
ln_0	_	fn ln_0() -> Self;$/;"	f
ln_0p	_	pub fn ln_0p(n: c_double) -> c_double;$/;"	f
ln_0p	_	pub fn ln_0p(n: c_float) -> c_float;$/;"	f
ln_0p	_	fn ln_0p(&self) -> f0 { ln_0p(*self) }$/;"	f
ln_0p	_	fn ln_0p(n: c_float) -> c_float = cmath::c_float::ln_0p,$/;"	f
ln_0p	_	fn ln_0p(&self) -> f0 { ln_0p(*self) }$/;"	f
ln_0p	_	fn ln_0p(n: c_double) -> c_double = cmath::c_double::ln_0p,$/;"	f
ln_0p	_	fn ln_0p(&self) -> Self;$/;"	f
ln_0	_	fn ln_0() -> f0 { 0.0 }$/;"	f
ln_0	_	fn ln_0() -> f0 { 0.0 }$/;"	f
ln_0	_	fn ln_0() -> Self;$/;"	f
load	_	pub fn load(&self, order: Ordering) -> *mut T {$/;"	f
load	_	pub fn load(&self, order: Ordering) -> bool {$/;"	f
load	_	pub fn load(&self, order: Ordering) -> int {$/;"	f
load	_	pub fn load(&self, order: Ordering) -> u0 {$/;"	f
load	_	pub fn load(&self, order: Ordering) -> uint {$/;"	f
load_argc_and_argv	_	/^unsafe fn load_argc_and_argv(argc: int, argv: **c_char) -> ~[~[u0]] {$/;"	f
load_argc_and_argv	_	unsafe fn load_argc_and_argv(argc: int, argv: **u0) -> ~[~[u0]] {$/;"	f
load_self	_	fn load_self() -> Option<~[u0]> {$/;"	f
local	_	/^pub mod local;$/;"	m
local_data	_	/^pub mod local_data;$/;"	m
local_free	_	/^pub unsafe fn local_free(ptr: *u0) {$/;"	f
local_free_	_	/^pub unsafe fn local_free_(ptr: *u0) {$/;"	f
local_heap	_	/^pub mod local_heap;$/;"	m
local_heap	_	fn local_heap() {$/;"	f
local_io	_	fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>>;$/;"	f
local_io	_	pub fn local_io<'a>(&'a mut self) -> Option<LocalIo<'a>> {$/;"	f
local_malloc	_	/^pub unsafe fn local_malloc(drop_glue: fn(*mut u0), size: uint, align: uint) -> *u0 {$/;"	f
local_malloc_	_	/^pub unsafe fn local_malloc_(drop_glue: fn(*mut u0), size: uint, align: uint) -> *u0 {$/;"	f
local_ptr	_	/^mod local_ptr;$/;"	m
lock	_	pub unsafe fn lock(&mut self) { pthread_mutex_lock(&mut self.lock); }$/;"	f
lock	_	pub unsafe fn lock(&mut self) {$/;"	f
lock	_	pub unsafe fn lock<'a>(&'a mut self) -> LockGuard<'a> {$/;"	f
lock_noguard	_	pub unsafe fn lock_noguard(&mut self) { self.inner.lock() }$/;"	f
lock_noguard	_	pub unsafe fn lock_noguard(&mut self) { self.inner.lock_noguard() }$/;"	f
log	_	fn log(&mut self, _level: u0, args: &fmt::Arguments) {$/;"	f
log	_	fn log(&mut self, level: u0, args: &fmt::Arguments);$/;"	f
log	_	/^pub fn log(level: u0, args: &fmt::Arguments) {$/;"	f
log	_	fn log(&self, base: &f0) -> f0 { self.ln() \/ base.ln() }$/;"	f
log	_	fn log(&self, base: &f0) -> f0 { self.ln() \/ base.ln() }$/;"	f
log	_	fn log(&self, base: &Self) -> Self;$/;"	f
log0	_	fn log0(&self) -> f0 { log0(*self) }$/;"	f
log0	_	fn log0(n: f0) -> f0 = intrinsics::log0f0,$/;"	f
log0	_	fn log0(&self) -> f0 { log0(*self) }$/;"	f
log0	_	fn log0(n: f0) -> f0 = intrinsics::log0f0,$/;"	f
log0	_	fn log0(&self) -> Self;$/;"	f
log0_e	_	fn log0_e() -> f0 { 0.0 }$/;"	f
log0_e	_	fn log0_e() -> f0 { 0.0 }$/;"	f
log0_e	_	fn log0_e() -> Self;$/;"	f
log0f0	_	pub fn log0f0(x: f0) -> f0;$/;"	f
log0f0	_	pub fn log0f0(x: f0) -> f0;$/;"	f
log0	_	fn log0(&self) -> f0 { log0(*self) }$/;"	f
log0	_	fn log0(n: f0) -> f0 = intrinsics::log0f0,$/;"	f
log0	_	fn log0(&self) -> f0 { log0(*self) }$/;"	f
log0	_	fn log0(n: f0) -> f0 = intrinsics::log0f0,$/;"	f
log0	_	fn log0(&self) -> Self;$/;"	f
log0_e	_	fn log0_e() -> f0 { 0.0 }$/;"	f
log0_e	_	fn log0_e() -> f0 { 0.0 }$/;"	f
log0_e	_	fn log0_e() -> Self;$/;"	f
log0f0	_	pub fn log0f0(x: f0) -> f0;$/;"	f
log0f0	_	pub fn log0f0(x: f0) -> f0;$/;"	f
log_radix	_	pub fn log_radix(n: c_double) -> c_double;$/;"	f
log_radix	_	pub fn log_radix(n: c_float) -> c_float;$/;"	f
logf0	_	pub fn logf0(x: f0) -> f0;$/;"	f
logf0	_	pub fn logf0(x: f0) -> f0;$/;"	f
logging	_	/^pub mod logging;$/;"	m
logging	_	/^pub mod logging;$/;"	m
logging	_	fn logging() {$/;"	f
lookup	_	/^fn lookup(hostname: Option<&str>, servname: Option<&str>, hint: Option<Hint>)$/;"	f
lookup	_	fn lookup() -> Path {$/;"	f
loop_multicast_locally	_	fn loop_multicast_locally(&mut self) -> Result<(), IoError>;$/;"	f
lseek	_	pub fn lseek(fd: c_int, offset: c_long, origin: c_int)$/;"	f
lseek	_	pub fn lseek(fd: c_int, offset: off_t, whence: c_int)$/;"	f
lseek_	_	fn lseek_(fd: c_int, size: uint) {$/;"	f
lstat	_	/^pub fn lstat(path: &Path) -> IoResult<FileStat> {$/;"	f
lstat	_	pub fn lstat(path: *c_char, buf: *mut stat) -> c_int;$/;"	f
lt	_	fn lt(&self, other: &bool) -> bool {$/;"	f
lt	_	fn lt(&self, other: &char) -> bool { *self < *other }$/;"	f
lt	_	fn lt(&self, other: &Ordering) -> bool { (*self as int) < (*other as int) }$/;"	f
lt	_	fn lt(&self, other: &Self) -> bool;$/;"	f
lt	_	fn lt(&self, _: &Foo) -> bool {$/;"	f
lt	_	pub fn lt<A: Eq + Ord, T: Iterator<A>>(mut a: T, mut b: T) -> bool {$/;"	f
lt	_	fn lt(&self, other: &@T) -> bool { *(*self) < *(*other) }$/;"	f
lt	_	fn lt(&self, other: &f0) -> bool { (*self) < (*other) }$/;"	f
lt	_	fn lt(&self, other: &f0) -> bool { (*self) < (*other) }$/;"	f
lt	_	fn lt(&self, other: &$T) -> bool { return (*self) < (*other); }$/;"	f
lt	_	fn lt(&self, other: &$T) -> bool { (*self) < (*other) }$/;"	f
lt	_	fn lt(&self, other: &~T) -> bool { *(*self) < *(*other) }$/;"	f
lt	_	fn lt(&self, other: &*T) -> bool {$/;"	f
lt	_	fn lt(&self, other: &*mut T) -> bool {$/;"	f
lt	_	fn lt(&self, other: &Rc<T>) -> bool { *self.borrow() < *other.borrow() }$/;"	f
lt	_	fn lt(&self, other: & &'a T) -> bool {$/;"	f
lt	_	fn lt(&self, other: & &'a str) -> bool { self.cmp(other) == Less }$/;"	f
lt	_	fn lt(&self, other: &~str) -> bool { self.cmp(other) == Less }$/;"	f
lt	_	fn lt(&self, other: &MaybeOwned) -> bool {$/;"	f
lt	_	fn lt(&self, other: &($($T,)+)) -> bool {$/;"	f
lt	_	fn lt(&self, _other: &()) -> bool { false }$/;"	f
lt	_	fn lt(&self, other: & &'a [T]) -> bool {$/;"	f
lt	_	fn lt(&self, other: &~[T]) -> bool { self.as_slice() < other.as_slice() }$/;"	f
mach_timebase_info	_	pub struct mach_timebase_info {$/;"	s
macos	_	pub mod macos {$/;"	m
macros	_	/^pub mod macros;$/;"	m
macros	_	/^mod macros;$/;"	m
madvise	_	pub fn madvise(addr: *c_void, len: size_t, advice: c_int)$/;"	f
main	_	/^fn main() {$/;"	f
main	_	/^fn main() {$/;"	f
make_absolute	_	/^pub fn make_absolute(p: &Path) -> Path {$/;"	f
make_non_verbatim	_	/^pub fn make_non_verbatim(path: &Path) -> Option<Path> {$/;"	f
make_rand_name	_	fn make_rand_name() -> ~str {$/;"	f
make_selectable	_	pub fn make_selectable(self, num_handles: uint) -> Take<BlockedTasks>$/;"	f
malloc	_	pub fn malloc(size: size_t) -> *mut c_void;$/;"	f
malloc	_	fn malloc(&mut self, size: uint) -> *mut Box {$/;"	f
malloc_raw	_	/^pub unsafe fn malloc_raw(size: uint) -> *mut u0 {$/;"	f
managed	_	/^pub mod managed;$/;"	m
mantissa_digits	_	fn mantissa_digits(_: Option<f0>) -> uint { 0 }$/;"	f
mantissa_digits	_	fn mantissa_digits(_: Option<f0>) -> uint { 0 }$/;"	f
mantissa_digits	_	fn mantissa_digits(unused_self: Option<Self>) -> uint;$/;"	f
manual_crate_map	_	/^fn manual_crate_map() -> Option<&'static CrateMap<'static>> {$/;"	f
many_stampede	_	fn many_stampede() {$/;"	f
map	_	fn map<'r, B>(self, f: 'r |A| -> B) -> Map<'r, A, B, Self> {$/;"	f
map	_	pub fn map<U>(self, f: |T| -> U) -> Option<U> {$/;"	f
map	_	pub fn map<U>(self, op: |T| -> U) -> Result<U,E> {$/;"	f
map	_	fn map<U>(&self, f: |t: &T| -> U) -> ~[U] {$/;"	f
map	_	fn map<U>(&self, |t: &T| -> U) -> ~[U];$/;"	f
map	_	pub fn map<U>(&self, f: |t: &T| -> U) -> Vec<U> {$/;"	f
map_err	_	pub fn map_err<F>(self, op: |E| -> F) -> Result<T,F> {$/;"	f
map_or	_	pub fn map_or<U>(self, def: U, f: |T| -> U) -> U {$/;"	f
marker	_	/^pub mod marker {$/;"	m
mask	_	fn mask(&self) -> int { (0 << self.log_size) - 0 }$/;"	f
match_indices	_	fn match_indices(&self, sep: &'a str) -> MatchIndices<'a> {$/;"	f
match_indices	_	fn match_indices(&self, sep: &'a str) -> MatchIndices<'a>;$/;"	f
match_option_some	_	fn match_option_some(bh: &mut BenchHarness) {$/;"	f
match_vec_pattern	_	fn match_vec_pattern(bh: &mut BenchHarness) {$/;"	f
matches	_	fn matches(&self, c: char) -> bool {$/;"	f
matches	_	fn matches(&self, c: char) -> bool { (*self)(c) }$/;"	f
matches	_	fn matches(&self, c: char) -> bool { *self == c }$/;"	f
matches	_	fn matches(&self, c: char) -> bool {$/;"	f
matches	_	fn matches(&self, char) -> bool;$/;"	f
matches_exit_status	_	pub fn matches_exit_status(&self, wanted: int) -> bool {$/;"	f
max	_	/^pub fn max<T:Ord>(v0: T, v0: T) -> T {$/;"	f
max	_	fn max(&mut self) -> Option<A> {$/;"	f
max	_	fn max(&mut self) -> Option<A>;$/;"	f
max	_	fn max(self, other: f0) -> f0 {$/;"	f
max	_	fn max(self, other: f0) -> f0 {$/;"	f
max	_	fn max(self, other: Self) -> Self;$/;"	f
max_0_exp	_	fn max_0_exp(_: Option<f0>) -> int { 0 }$/;"	f
max_0_exp	_	fn max_0_exp(_: Option<f0>) -> int { 0 }$/;"	f
max_0_exp	_	fn max_0_exp(unused_self: Option<Self>) -> int;$/;"	f
max_by	_	fn max_by<B: Ord>(&mut self, f: |&A| -> B) -> Option<A> {$/;"	f
max_cached_stacks	_	/^pub fn max_cached_stacks() -> uint {$/;"	f
max_exp	_	fn max_exp(_: Option<f0>) -> int { 0 }$/;"	f
max_exp	_	fn max_exp(_: Option<f0>) -> int { 0 }$/;"	f
max_exp	_	fn max_exp(unused_self: Option<Self>) -> int;$/;"	f
max_value	_	fn max_value() -> f0 { 0.0e+0 }$/;"	f
max_value	_	fn max_value() -> f0 { 0.0e+0 }$/;"	f
max_value	_	fn max_value() -> $T { MAX }$/;"	f
max_value	_	fn max_value() -> Self;$/;"	f
max_value	_	fn max_value() -> $T { MAX }$/;"	f
maybe_raise	_	pub fn maybe_raise<T>(f: |io: &mut IoFactory| -> IoResult<T>)$/;"	f
maybe_shrink	_	unsafe fn maybe_shrink(&mut self, b: int, t: int) {$/;"	f
maybe_take_runtime	_	pub fn maybe_take_runtime<T: 'static>(&mut self) -> Option<~T> {$/;"	f
maybe_tls_key	_	pub fn maybe_tls_key() -> Option<tls::Key> {$/;"	f
maybe_yield	_	fn maybe_yield(~self, cur_task: ~Task);$/;"	f
maybe_yield	_	pub fn maybe_yield(mut ~self) {$/;"	f
mem	_	/^mod mem;$/;"	m
mem	_	/^pub mod mem;$/;"	m
memchr	_	pub fn memchr(cx: *c_void, c: c_int, n: size_t) -> *c_void;$/;"	f
memcmp	_	pub fn memcmp(cx: *c_void, ct: *c_void, n: size_t) -> c_int;$/;"	f
memory_map_file	_	fn memory_map_file() {$/;"	f
memory_map_rw	_	fn memory_map_rw() {$/;"	f
merge_sort	_	/^fn merge_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {$/;"	f
method	_	fn method(&mut self) -> Option<~Method<'a>> {$/;"	f
method	_	fn method(&self) -> int {$/;"	f
method	_	fn method(&self) -> int;$/;"	f
min	_	/^pub fn min<T:Ord>(v0: T, v0: T) -> T {$/;"	f
min	_	fn min(&mut self) -> Option<A> {$/;"	f
min	_	fn min(&mut self) -> Option<A>;$/;"	f
min	_	fn min(self, other: f0) -> f0 {$/;"	f
min	_	fn min(self, other: f0) -> f0 {$/;"	f
min	_	fn min(self, other: Self) -> Self;$/;"	f
min_0_exp	_	fn min_0_exp(_: Option<f0>) -> int { -0 }$/;"	f
min_0_exp	_	fn min_0_exp(_: Option<f0>) -> int { -0 }$/;"	f
min_0_exp	_	fn min_0_exp(unused_self: Option<Self>) -> int;$/;"	f
min_align_of	_	pub fn min_align_of<T>() -> uint;$/;"	f
min_align_of	_	/^pub fn min_align_of<T>() -> uint {$/;"	f
min_align_of_val	_	/^pub fn min_align_of_val<T>(_val: &T) -> uint {$/;"	f
min_by	_	fn min_by<B: Ord>(&mut self, f: |&A| -> B) -> Option<A> {$/;"	f
min_exp	_	fn min_exp(_: Option<f0>) -> int { -0 }$/;"	f
min_exp	_	fn min_exp(_: Option<f0>) -> int { -0 }$/;"	f
min_exp	_	fn min_exp(unused_self: Option<Self>) -> int;$/;"	f
min_max	_	fn min_max(&mut self) -> MinMaxResult<A> {$/;"	f
min_max	_	fn min_max(&mut self) -> MinMaxResult<A>;$/;"	f
min_stack	_	/^pub fn min_stack() -> uint {$/;"	f
min_value	_	fn min_value() -> f0 { 0.0e-0 }$/;"	f
min_value	_	fn min_value() -> f0 { 0.0e-0 }$/;"	f
min_value	_	fn min_value() -> $T { MIN }$/;"	f
min_value	_	fn min_value() -> Self;$/;"	f
min_value	_	fn min_value() -> $T { MIN }$/;"	f
mincore	_	pub fn mincore(addr: *c_void, len: size_t, vec: *c_uchar)$/;"	f
mips	_	pub mod mips {$/;"	m
mkdir	_	/^pub fn mkdir(path: &Path, mode: FilePermission) -> IoResult<()> {$/;"	f
mkdir	_	pub fn mkdir(path: *c_char) -> c_int;$/;"	f
mkdir	_	pub fn mkdir(path: *c_char, mode: mode_t) -> c_int;$/;"	f
mkdir_recursive	_	/^pub fn mkdir_recursive(path: &Path, mode: FilePermission) -> IoResult<()> {$/;"	f
mkfifo	_	pub fn mkfifo(path: *c_char, mode: mode_t) -> c_int;$/;"	f
mlock	_	pub fn mlock(addr: *c_void, len: size_t) -> c_int;$/;"	f
mlockall	_	pub fn mlockall(flags: c_int) -> c_int;$/;"	f
mman	_	pub mod mman {$/;"	m
mmap	_	pub fn mmap(addr: *c_void,$/;"	f
modf	_	pub fn modf(n: c_double, iptr: &mut c_double) -> c_double;$/;"	f
modf	_	pub fn modf(n: c_float, iptr: &mut c_float) -> c_float;$/;"	f
modify	_	/^pub fn modify<T: 'static>(key: Key<T>, f: |Option<T>| -> Option<T>) {$/;"	f
move	_	fn move<T: 'static>(self) -> Result<~T, Self>;$/;"	f
move	_	fn move<T: 'static>(self) -> Result<~T, ~Any> {$/;"	f
move_from	_	fn move_from(self, mut src: ~[T], start: uint, end: uint) -> uint {$/;"	f
move_from	_	fn move_from(self, src: ~[T], start: uint, end: uint) -> uint;$/;"	f
move_iter	_	pub fn move_iter(self) -> Item<T> {$/;"	f
move_iter	_	fn move_iter(self) -> MoveItems<T> {$/;"	f
move_iter	_	fn move_iter(self) -> MoveItems<T>;$/;"	f
move_iter	_	pub fn move_iter(self) -> MoveItems<T> {$/;"	f
move_ptr	_	fn move_ptr(&mut self, adjustment: |*u0| -> *u0);$/;"	f
move_ptr	_	fn move_ptr(&mut self, adjustment: |*u0| -> *u0) {$/;"	f
move_rev_iter	_	fn move_rev_iter(self) -> RevMoveItems<T> {$/;"	f
move_rev_iter	_	fn move_rev_iter(self) -> RevMoveItems<T>;$/;"	f
move_val_init	_	pub fn move_val_init<T>(dst: &mut T, src: T);$/;"	f
move_val_init	_	/^pub unsafe fn move_val_init<T>(dst: &mut T, src: T) {$/;"	f
mpmc_bounded_queue	_	/^pub mod mpmc_bounded_queue;$/;"	m
mprotect	_	pub fn mprotect(addr: *c_void, len: size_t, prot: c_int)$/;"	f
mpsc_queue	_	/^pub mod mpsc_queue;$/;"	m
msvcrt	_	pub mod msvcrt {$/;"	m
msync	_	pub fn msync(addr: *c_void, len: size_t, flags: c_int)$/;"	f
mul	_	fn mul(&self, _: &Foo) -> Foo {$/;"	f
mul	_	fn mul(&self, other: &f0) -> f0 { *self * *other }$/;"	f
mul	_	fn mul(&self, other: &f0) -> f0 { *self * *other }$/;"	f
mul	_	fn mul(&self, other: &$T) -> $T { *self * *other }$/;"	f
mul	_	fn mul(&self, other: &$T) -> $T { *self * *other }$/;"	f
mul	_	fn mul(&self, rhs: &RHS) -> Result;$/;"	f
mul_add	_	fn mul_add(&self, a: f0, b: f0) -> f0 {$/;"	f
mul_add	_	fn mul_add(a: f0, b: f0, c: f0) -> f0 = intrinsics::fmaf0,$/;"	f
mul_add	_	fn mul_add(&self, a: f0, b: f0) -> f0 {$/;"	f
mul_add	_	fn mul_add(a: f0, b: f0, c: f0) -> f0 = intrinsics::fmaf0,$/;"	f
mul_add	_	fn mul_add(&self, a: Self, b: Self) -> Self;$/;"	f
multibyte_char_range_at	_	fn multibyte_char_range_at(s: &str, i: uint) -> CharRange {$/;"	f
multibyte_char_range_at_reverse	_	fn multibyte_char_range_at_reverse(s: &str, mut i: uint) -> CharRange {$/;"	f
multicast_time_to_live	_	fn multicast_time_to_live(&mut self, ttl: int) -> Result<(), IoError>;$/;"	f
munlock	_	pub fn munlock(addr: *c_void, len: size_t) -> c_int;$/;"	f
munlockall	_	pub fn munlockall() -> c_int;$/;"	f
munmap	_	pub fn munmap(addr: *c_void, len: size_t) -> c_int;$/;"	f
must_consume	_	fn must_consume(&mut self, c: char) {$/;"	f
musterr	_	fn musterr(s: &str) {$/;"	f
mut_borrow_with	_	fn mut_borrow_with() {$/;"	f
mut_buf_as_slice	_	pub unsafe fn mut_buf_as_slice<T,$/;"	f
mut_chunks	_	fn mut_chunks(self, chunk_size: uint) -> MutChunks<'a, T> {$/;"	f
mut_chunks	_	fn mut_chunks(self, chunk_size: uint) -> MutChunks<'a, T>;$/;"	f
mut_iter	_	pub fn mut_iter<'r>(&'r mut self) -> Item<&'r mut T> {$/;"	f
mut_iter	_	fn mut_iter(self) -> MutItems<'a, T> {$/;"	f
mut_iter	_	fn mut_iter(self) -> MutItems<'a, T>;$/;"	f
mut_iter	_	pub fn mut_iter<'a>(&'a mut self) -> MutItems<'a,T> {$/;"	f
mut_iterator	_	fn mut_iterator(bh: &mut BenchHarness) {$/;"	f
mut_last	_	fn mut_last(self) -> Option<&'a mut T> {$/;"	f
mut_last	_	fn mut_last(self) -> Option<&'a mut T>;$/;"	f
mut_last	_	pub fn mut_last<'a>(&'a mut self) -> Option<&'a mut T> {$/;"	f
mut_null	_	/^pub fn mut_null<T>() -> *mut T { 0 as *mut T }$/;"	f
mut_pop_ref	_	fn mut_pop_ref(&mut self) -> Option<&'a mut T> {$/;"	f
mut_pop_ref	_	fn mut_pop_ref(&mut self) -> Option<&'a mut T>;$/;"	f
mut_ref_slice	_	/^pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {$/;"	f
mut_release_borrow_mut	_	fn mut_release_borrow_mut() {$/;"	f
mut_rev_iter	_	fn mut_rev_iter(self) -> RevMutItems<'a, T> {$/;"	f
mut_rev_iter	_	fn mut_rev_iter(self) -> RevMutItems<'a, T>;$/;"	f
mut_shift_ref	_	fn mut_shift_ref(&mut self) -> Option<&'a mut T> {$/;"	f
mut_shift_ref	_	fn mut_shift_ref(&mut self) -> Option<&'a mut T>;$/;"	f
mut_slice	_	fn mut_slice(self, start: uint, end: uint) -> &'a mut [T] {$/;"	f
mut_slice	_	fn mut_slice(self, start: uint, end: uint) -> &'a mut [T];$/;"	f
mut_slice_from	_	fn mut_slice_from(self, start: uint) -> &'a mut [T] {$/;"	f
mut_slice_from	_	fn mut_slice_from(self, start: uint) -> &'a mut [T];$/;"	f
mut_slice_to	_	fn mut_slice_to(self, end: uint) -> &'a mut [T] {$/;"	f
mut_slice_to	_	fn mut_slice_to(self, end: uint) -> &'a mut [T];$/;"	f
mut_split	_	fn mut_split(self, pred: 'a |&T| -> bool) -> MutSplits<'a, T> {$/;"	f
mut_split	_	fn mut_split(self, pred: 'a |&T| -> bool) -> MutSplits<'a, T>;$/;"	f
mut_split_at	_	fn mut_split_at(self, mid: uint) -> (&'a mut [T], &'a mut [T]) {$/;"	f
mut_split_at	_	fn mut_split_at(self, mid: uint) -> (&'a mut [T], &'a mut [T]);$/;"	f
mutate	_	pub fn mutate(&mut self, f: |T| -> T) -> bool {$/;"	f
mutate_or_set	_	pub fn mutate_or_set(&mut self, def: T, f: |T| -> T) -> bool {$/;"	f
mutex	_	/^pub mod mutex;$/;"	m
my_new	_	fn my_new(inner: Flavor<T>) -> Chan<T> {$/;"	f
my_new	_	fn my_new(inner: Flavor<T>) -> Port<T> {$/;"	f
naive_pow	_	fn naive_pow<T: One + Mul<T, T>>(base: T, exp: uint) -> T {$/;"	f
named	_	pub fn named<S: IntoMaybeOwned<'static>>(mut self, name: S) -> TaskBuilder {$/;"	f
nan	_	fn nan() -> f0 { 0.0 \/ 0.0 }$/;"	f
nan	_	fn nan() -> f0 { 0.0 \/ 0.0 }$/;"	f
nan	_	fn nan() -> Self;$/;"	f
nan	_	fn nan()      -> Option<$t> { Some( 0.0 \/ 0.0) }$/;"	f
nan	_	fn nan()      -> Option<Self>;$/;"	f
nanosleep	_	pub fn nanosleep(rqtp: *timespec, rmtp: *mut timespec) -> c_int;$/;"	f
native	_	/^pub mod native {$/;"	m
ne	_	fn ne(&self, other: &Self) -> bool { !self.eq(other) }$/;"	f
ne	_	pub fn ne<A: Eq, T: Iterator<A>>(mut a: T, mut b: T) -> bool {$/;"	f
ne	_	fn ne(&self, other: &@T) -> bool { *(*self) != *(*other) }$/;"	f
ne	_	fn ne(&self, other: &~T) -> bool { *(*self) != *(*other) }$/;"	f
ne	_	fn ne(&self, other: &extern "C" fn($($p),*) -> _R) -> bool {$/;"	f
ne	_	fn ne(&self, other: &extern "C" fn() -> _R) -> bool {$/;"	f
ne	_	fn ne(&self, other: &*T) -> bool { !self.eq(other) }$/;"	f
ne	_	fn ne(&self, other: &*mut T) -> bool { !self.eq(other) }$/;"	f
ne	_	fn ne(&self, other: &Rc<T>) -> bool { *self.borrow() != *other.borrow() }$/;"	f
ne	_	fn ne(&self, other: & &'a T) -> bool {$/;"	f
ne	_	fn ne(&self, other: & &'a str) -> bool { !(*self).eq(other) }$/;"	f
ne	_	fn ne(&self, other: &($($T,)+)) -> bool {$/;"	f
ne	_	fn ne(&self, _other: &()) -> bool { false }$/;"	f
ne	_	fn ne(&self, other: & &'a [T]) -> bool {$/;"	f
ne	_	fn ne(&self, other: &~[T]) -> bool { !self.eq(other) }$/;"	f
nearbyint	_	fn nearbyint(n: f0) -> f0 = intrinsics::nearbyintf0,$/;"	f
nearbyint	_	fn nearbyint(n: f0) -> f0 = intrinsics::nearbyintf0,$/;"	f
nearbyintf0	_	pub fn nearbyintf0(x: f0) -> f0;$/;"	f
nearbyintf0	_	pub fn nearbyintf0(x: f0) -> f0;$/;"	f
needs_drop	_	pub fn needs_drop<T>() -> bool;$/;"	f
neg	_	fn neg(&self) -> f0 { -*self }$/;"	f
neg	_	fn neg(&self) -> f0 { -*self }$/;"	f
neg	_	fn neg(&self) -> $T { -*self }$/;"	f
neg	_	fn neg(&self) -> $T { -*self }$/;"	f
neg	_	fn neg(&self) -> Result;$/;"	f
neg_inf	_	fn neg_inf()  -> Option<$t> { Some(-0.0 \/ 0.0) }$/;"	f
neg_inf	_	fn neg_inf()  -> Option<Self>;$/;"	f
neg_infinity	_	fn neg_infinity() -> f0 { -0.0 \/ 0.0 }$/;"	f
neg_infinity	_	fn neg_infinity() -> f0 { -0.0 \/ 0.0 }$/;"	f
neg_infinity	_	fn neg_infinity() -> Self;$/;"	f
neg_zero	_	fn neg_zero() -> f0 { -0.0 }$/;"	f
neg_zero	_	fn neg_zero() -> f0 { -0.0 }$/;"	f
neg_zero	_	fn neg_zero() -> Self;$/;"	f
neg_zero	_	fn neg_zero() -> Option<$t> { Some(-0.0      ) }$/;"	f
neg_zero	_	fn neg_zero() -> Option<Self>;$/;"	f
net	_	/^pub mod net;$/;"	m
new	_	pub unsafe fn new(buf: *libc::c_char, owns_buffer: bool) -> CString {$/;"	f
new	_	pub fn new(value: T) -> Cell<T> {$/;"	f
new	_	pub fn new(value: T) -> RefCell<T> {$/;"	f
new	_	pub fn new() -> (Port<T>, Chan<T>) {$/;"	f
new	_	pub fn new() -> Packet<T> {$/;"	f
new	_	pub fn new() -> Select {$/;"	f
new	_	pub fn new() -> Packet<T> {$/;"	f
new	_	pub fn new() -> Packet<T> {$/;"	f
new	_	pub unsafe fn new<'a>(fmt: &'static [rt::Piece<'static>],$/;"	f
new	_	fn new(base: u0) -> Radix {$/;"	f
new	_	pub fn new<'a>(s: &'a str) -> Parser<'a> {$/;"	f
new	_	pub fn new(value: T) -> Gc<T> {$/;"	f
new	_	pub fn new() -> SipHasher {$/;"	f
new	_	pub fn new() -> SipState {$/;"	f
new	_	pub fn new(inner: R) -> BufferedReader<R> {$/;"	f
new	_	pub fn new(inner: S) -> BufferedStream<S> {$/;"	f
new	_	pub fn new(inner: W) -> BufferedWriter<W> {$/;"	f
new	_	pub fn new(inner: W) -> LineBufferedWriter<W> {$/;"	f
new	_	pub fn new(chan: Chan<~[u0]>) -> ChanWriter {$/;"	f
new	_	pub fn new(port: Port<~[u0]>) -> PortReader {$/;"	f
new	_	pub fn new(r: &'r mut R) -> Bytes<'r, R> {$/;"	f
new	_	pub fn new(inner_reader: R) -> InflateReader<R> {$/;"	f
new	_	pub fn new(inner_writer: W) -> DeflateWriter<W> {$/;"	f
new	_	pub fn new() -> MemWriter {$/;"	f
new	_	pub fn new(buf: ~[u0]) -> MemReader {$/;"	f
new	_	pub fn new<'a>(buf: &'a [u0]) -> BufReader<'a> {$/;"	f
new	_	pub fn new<'a>(buf: &'a mut [u0]) -> BufWriter<'a> {$/;"	f
new	_	fn new(s: &'a str) -> Parser<'a> {$/;"	f
new	_	fn new(s: ~RtioTcpStream) -> TcpStream {$/;"	f
new	_	fn new(obj: ~RtioPipe) -> UnixStream {$/;"	f
new	_	pub fn new(inner: ~RtioPipe) -> PipeStream {$/;"	f
new	_	pub fn new(prog: &str, args: &[~str]) -> IoResult<Process> {$/;"	f
new	_	pub fn new<'a>() -> ProcessConfig<'a> {$/;"	f
new	_	pub fn new() -> Listener {$/;"	f
new	_	pub fn new() -> IoResult<Timer> {$/;"	f
new	_	pub fn new(mut readers: I) -> ChainedReader<I, R> {$/;"	f
new	_	pub fn new(r: R, limit: uint) -> LimitReader<R> {$/;"	f
new	_	pub fn new(r: R, w: W) -> TeeReader<R, W> {$/;"	f
new	_	pub fn new(writers: ~[~Writer]) -> MultiWriter {$/;"	f
new	_	pub fn new(elt: A) -> Repeat<A> {$/;"	f
new	_	pub fn new<'a>(initial_state: St, f: 'a |&mut St| -> Option<A>)$/;"	f
new	_	pub fn new() -> SYSTEM_INFO {$/;"	f
new	_	pub fn new(min_len: uint, options: &[MapOption]) -> Result<MemoryMap, MapError> {$/;"	f
new	_	fn new<T: BytesContainer>(path: T) -> Self {$/;"	f
new	_	pub fn new<T: BytesContainer>(path: T) -> Path {$/;"	f
new	_	pub fn new<T: BytesContainer>(path: T) -> Path {$/;"	f
new	_	pub fn new(lambda: f0) -> Exp {$/;"	f
new	_	pub fn new(k: f0) -> ChiSquared {$/;"	f
new	_	pub fn new(m: f0, n: f0) -> FisherF {$/;"	f
new	_	pub fn new(n: f0) -> StudentT {$/;"	f
new	_	pub fn new(shape: f0, scale: f0) -> Gamma {$/;"	f
new	_	pub fn new(mut items: ~[Weighted<T>]) -> WeightedChoice<T> {$/;"	f
new	_	pub fn new(mean: f0, std_dev: f0) -> LogNormal {$/;"	f
new	_	pub fn new(mean: f0, std_dev: f0) -> Normal {$/;"	f
new	_	pub fn new(low: X, high: X) -> Range<X> {$/;"	f
new	_	pub fn new() -> Isaac0Rng {$/;"	f
new	_	pub fn new() -> IsaacRng {$/;"	f
new	_	pub fn new() -> StdRng {$/;"	f
new	_	pub fn new() -> XorShiftRng {$/;"	f
new	_	pub fn new() -> OSRng {$/;"	f
new	_	pub fn new(r: R) -> ReaderRng<R> {$/;"	f
new	_	pub fn new(rng: R, generation_threshold: uint, reseeder: Rsdr) -> ReseedingRng<R,Rsdr> {$/;"	f
new	_	pub fn new(value: T) -> Rc<T> {$/;"	f
new	_	pub fn new() -> LocalHeap {$/;"	f
new	_	pub fn new<'a>(io: &'a mut IoFactory) -> LocalIo<'a> {$/;"	f
new	_	pub fn new() -> Death {$/;"	f
new	_	pub fn new() -> Task {$/;"	f
new	_	pub fn new() -> Unwinder {$/;"	f
new	_	pub fn new(data: T) -> UnsafeArc<T> {$/;"	f
new	_	pub fn new() -> AtomicFlag {$/;"	f
new	_	pub fn new(p: *mut T) -> AtomicPtr<T> {$/;"	f
new	_	pub fn new(p: ~T) -> AtomicOption<T> {$/;"	f
new	_	pub fn new(v: bool) -> AtomicBool {$/;"	f
new	_	pub fn new(v: int) -> AtomicInt {$/;"	f
new	_	pub fn new(v: u0) -> AtomicU0 {$/;"	f
new	_	pub fn new(v: uint) -> AtomicUint {$/;"	f
new	_	fn new(mut pool: BufferPool<T>) -> Deque<T> {$/;"	f
new	_	pub fn new() -> BufferPool<T> {$/;"	f
new	_	unsafe fn new(log_size: int) -> Buffer<T> {$/;"	f
new	_	pub fn new() -> Queue<T> {$/;"	f
new	_	unsafe fn new(v: Option<T>) -> *mut Node<T> {$/;"	f
new	_	fn new() -> *mut Node<T> {$/;"	f
new	_	pub fn new(bound: uint) -> Queue<T> {$/;"	f
new	_	pub fn new() -> TaskOpts {$/;"	f
new	_	pub unsafe fn new() -> Mutex {$/;"	f
new	_	pub unsafe fn new() -> NativeMutex {$/;"	f
new	_	pub unsafe fn new() -> StaticNativeMutex {$/;"	f
new	_	pub fn new(user_data: T) -> Exclusive<T> {$/;"	f
new	_	pub fn new(length: uint) -> ElementSwaps {$/;"	f
new	_	pub fn new() -> Vec<T> {$/;"	f
new0	_	pub fn new0(data: T) -> (UnsafeArc<T>, UnsafeArc<T>) {$/;"	f
newN	_	pub fn newN(data: T, num_handles: uint) -> ~[UnsafeArc<T>] {$/;"	f
new_inner	_	/^unsafe fn new_inner<T: Send>(data: T, refcount: uint) -> *mut ArcData<T> {$/;"	f
new_opt	_	fn new_opt<T: BytesContainer>(path: T) -> Option<Self> {$/;"	f
new_opt	_	pub fn new_opt<T: BytesContainer>(path: T) -> Option<Path> {$/;"	f
new_opt	_	fn new_opt<T: BytesContainer>(path: T) -> Option<Path> {$/;"	f
new_opt	_	pub fn new_opt<T: BytesContainer>(path: T) -> Option<Path> {$/;"	f
new_pos	_	fn new_pos(i: uint, s: Direction) -> uint {$/;"	f
new_raw	_	fn new_raw(shape: f0, scale: f0) -> GammaLargeShape {$/;"	f
new_raw	_	fn new_raw(shape: f0, scale: f0) -> GammaSmallShape {$/;"	f
new_unchecked	_	unsafe fn new_unchecked<T: BytesContainer>(path: T) -> Self;$/;"	f
new_unchecked	_	unsafe fn new_unchecked<T: BytesContainer>(path: T) -> Path {$/;"	f
new_unchecked	_	unsafe fn new_unchecked<T: BytesContainer>(path: T) -> Path {$/;"	f
new_unseeded	_	pub fn new_unseeded() -> Isaac0Rng {$/;"	f
new_unseeded	_	pub fn new_unseeded() -> IsaacRng {$/;"	f
new_with_keys	_	pub fn new_with_keys(key0: u0, key0: u0) -> SipHasher {$/;"	f
new_with_keys	_	pub fn new_with_keys(key0: u0, key0: u0) -> SipState {$/;"	f
next	_	fn next(&mut self) -> Option<libc::c_char> {$/;"	f
next	_	fn next(&mut self) -> Option<T> { self.port.recv_opt() }$/;"	f
next	_	fn next(&mut self) -> Option<*mut Handle<'static, ()>> {$/;"	f
next	_	fn next(&mut self) -> Option<Piece<'a>> {$/;"	f
next	_	fn next(&mut self) -> Option<u0> {$/;"	f
next	_	fn next(&mut self) -> Option<Path> {$/;"	f
next	_	fn next(&mut self) -> Option<IoResult<T>> {$/;"	f
next	_	fn next(&mut self) -> Option<char> {$/;"	f
next	_	fn next(&mut self) -> Option<~str> {$/;"	f
next	_	fn next(&mut self) -> Option<(A, B)> {$/;"	f
next	_	fn next(&mut self) -> Option<(uint, A)> {$/;"	f
next	_	fn next(&mut self) -> Option<A> { self.idx(0) }$/;"	f
next	_	fn next(&mut self) -> Option<A> { self.iter.next() }$/;"	f
next	_	fn next(&mut self) -> Option<A> { self.iter.next_back() }$/;"	f
next	_	fn next(&mut self) -> Option<A> {$/;"	f
next	_	fn next(&mut self) -> Option<A>;$/;"	f
next	_	fn next(&mut self) -> Option<B> {$/;"	f
next	_	fn next(&mut self) -> Option<A> {$/;"	f
next	_	fn next(&mut self) -> Option<BlockedTask> {$/;"	f
next	_	fn next(&mut self) -> Option<&'a str> {$/;"	f
next	_	fn next(&mut self) -> Option<(uint, char)> {$/;"	f
next	_	fn next(&mut self) -> Option<(uint, uint)> {$/;"	f
next	_	fn next(&mut self) -> Option<UTF0Item> {$/;"	f
next	_	fn next(&mut self) -> Option<char> {$/;"	f
next	_	fn next(&mut self) -> Option<$elem> {$/;"	f
next	_	fn next(&mut self) -> Option<&'a [T]> {$/;"	f
next	_	fn next(&mut self) -> Option<&'a mut [T]> {$/;"	f
next	_	fn next(&mut self) -> Option<(uint, uint)> {$/;"	f
next	_	fn next(&mut self) -> Option<T> {$/;"	f
next	_	fn next(&mut self) -> Option<~[T]> {$/;"	f
next	_	fn next(&mut self) -> Option<T> {$/;"	f
next_after	_	pub fn next_after(x: c_double, y: c_double) -> c_double;$/;"	f
next_after	_	pub fn next_after(x: c_float, y: c_float) -> c_float;$/;"	f
next_after	_	fn next_after(&self, other: f0) -> f0 {$/;"	f
next_after	_	fn next_after(x: c_float, y: c_float) -> c_float = cmath::c_float::next_after,$/;"	f
next_after	_	fn next_after(&self, other: f0) -> f0 {$/;"	f
next_after	_	fn next_after(x: c_double, y: c_double) -> c_double = cmath::c_double::next_after,$/;"	f
next_after	_	fn next_after(&self, other: Self) -> Self;$/;"	f
next_back	_	fn next_back(&mut self) -> Option<(A, B)> {$/;"	f
next_back	_	fn next_back(&mut self) -> Option<(uint, A)> {$/;"	f
next_back	_	fn next_back(&mut self) -> Option<A> { self.idx(0) }$/;"	f
next_back	_	fn next_back(&mut self) -> Option<A> { self.iter.next() }$/;"	f
next_back	_	fn next_back(&mut self) -> Option<A> { self.iter.next_back() }$/;"	f
next_back	_	fn next_back(&mut self) -> Option<A> {$/;"	f
next_back	_	fn next_back(&mut self) -> Option<A>;$/;"	f
next_back	_	fn next_back(&mut self) -> Option<B> {$/;"	f
next_back	_	fn next_back(&mut self) -> Option<A> {$/;"	f
next_back	_	fn next_back(&mut self) -> Option<&'a str> {$/;"	f
next_back	_	fn next_back(&mut self) -> Option<(uint, char)> {$/;"	f
next_back	_	fn next_back(&mut self) -> Option<char> {$/;"	f
next_back	_	fn next_back(&mut self) -> Option<$elem> {$/;"	f
next_back	_	fn next_back(&mut self) -> Option<&'a [T]> {$/;"	f
next_back	_	fn next_back(&mut self) -> Option<&'a mut [T]> {$/;"	f
next_back	_	fn next_back(&mut self) -> Option<T> {$/;"	f
next_back	_	fn next_back(&mut self) -> Option<T> {$/;"	f
next_power_of_two	_	/^pub fn next_power_of_two<T: Unsigned + Int>(n: T) -> T {$/;"	f
next_test_ip0	_	/^pub fn next_test_ip0() -> SocketAddr {$/;"	f
next_test_ip0	_	/^pub fn next_test_ip0() -> SocketAddr {$/;"	f
next_test_port	_	/^pub fn next_test_port() -> u0 {$/;"	f
next_test_unix	_	/^pub fn next_test_unix() -> Path {$/;"	f
next_u0	_	fn next_u0(&mut self) -> u0 {$/;"	f
next_u0	_	fn next_u0(&mut self) -> u0 {$/;"	f
next_u0	_	fn next_u0(&mut self) -> u0 { self.i as u0 }$/;"	f
next_u0	_	fn next_u0(&mut self) -> u0 {$/;"	f
next_u0	_	fn next_u0(&mut self) -> u0;$/;"	f
next_u0	_	fn next_u0(&mut self) -> u0 {$/;"	f
next_u0	_	fn next_u0(&mut self) -> u0 {$/;"	f
next_u0	_	fn next_u0(&mut self) -> u0 {$/;"	f
next_u0	_	fn next_u0(&mut self) -> u0 {$/;"	f
next_u0	_	fn next_u0(&mut self) -> u0 {$/;"	f
next_u0	_	fn next_u0(&mut self) -> u0 {$/;"	f
next_u0	_	fn next_u0(&mut self) -> u0 {$/;"	f
next_u0	_	fn next_u0(&mut self) -> u0 { self.i }$/;"	f
next_u0	_	fn next_u0(&mut self) -> u0 {$/;"	f
next_u0	_	fn next_u0(&mut self) -> u0 {$/;"	f
next_u0	_	fn next_u0(&mut self) -> u0 {$/;"	f
next_u0	_	fn next_u0(&mut self) -> u0 {$/;"	f
next_u0	_	fn next_u0(&mut self) -> u0 {$/;"	f
nfd_chars	_	fn nfd_chars(&self) -> Normalizations<'a> {$/;"	f
nfd_chars	_	fn nfd_chars(&self) -> Normalizations<'a>;$/;"	f
nfkd_chars	_	fn nfkd_chars(&self) -> Normalizations<'a> {$/;"	f
nfkd_chars	_	fn nfkd_chars(&self) -> Normalizations<'a>;$/;"	f
no_double_borrow_mut	_	fn no_double_borrow_mut() {$/;"	f
no_imm_then_borrow_mut	_	fn no_imm_then_borrow_mut() {$/;"	f
no_mut_then_imm_borrow	_	fn no_mut_then_imm_borrow() {$/;"	f
no_runtime	_	fn no_runtime() {$/;"	f
no_starvation	_	fn no_starvation() {$/;"	f
nodelay	_	fn nodelay(&mut self) -> Result<(), IoError>;$/;"	f
nonzero_size_of	_	/^pub fn nonzero_size_of<T>() -> uint {$/;"	f
nonzero_size_of_basic	_	fn nonzero_size_of_basic() {$/;"	f
nonzero_size_of_val	_	/^pub fn nonzero_size_of_val<T>(_val: &T) -> uint {$/;"	f
nonzero_size_of_val_basic	_	fn nonzero_size_of_val_basic() {$/;"	f
normal	_	/^pub mod normal;$/;"	m
normalize	_	fn normalize<V: Vector<u0>+CloneableVector<u0>>(v: V) -> ~[u0] {$/;"	f
normalize_	_	fn normalize_<S: Str>(s: S) -> (Option<PathPrefix>, ~str) {$/;"	f
normalize__	_	fn normalize__(s: &str, prefix: Option<PathPrefix>) -> Option<~str> {$/;"	f
normalize_helper	_	/^fn normalize_helper<'a>(v: &'a [u0], is_abs: bool) -> Option<~[&'a [u0]]> {$/;"	f
normalize_helper	_	/^fn normalize_helper<'a>(s: &'a str, prefix: Option<PathPrefix>) -> (bool,Option<~[&'a str]>) {$/;"	f
not	_	fn not(&self) -> bool { !*self }$/;"	f
not	_	fn not(&self) -> $T { !*self }$/;"	f
not	_	fn not(&self) -> $T { !*self }$/;"	f
not	_	fn not(&self) -> Result;$/;"	f
nth	_	fn nth(&mut self, mut n: uint) -> Option<A> {$/;"	f
null	_	fn null() -> *T { null() }$/;"	f
null	_	fn null() -> *mut T { mut_null() }$/;"	f
null	_	fn null() -> Self;$/;"	f
null	_	/^pub fn null<T>() -> *T { 0 as *T }$/;"	f
num	_	/^mod num;$/;"	m
num	_	impl num::One for Foo {$/;"	i
num	_	/^pub mod num;$/;"	m
num	_	/^impl num::FromStrRadix for f0 {$/;"	i
num	_	/^impl num::ToStrRadix for f0 {$/;"	i
num	_	/^impl num::FromStrRadix for f0 {$/;"	i
num	_	/^impl num::ToStrRadix for f0 {$/;"	i
num_cpus	_	/^pub fn num_cpus() -> uint {$/;"	f
of	_	pub fn of<T: 'static>() -> TypeId {$/;"	f
offset	_	pub fn offset<T>(dst: *T, offset: int) -> *T;$/;"	f
offset	_	unsafe fn offset(self, count: int) -> *T { intrinsics::offset(self, count) }$/;"	f
offset	_	unsafe fn offset(self, count: int) -> *mut T { intrinsics::offset(self as *T, count) as *mut T }$/;"	f
offset	_	unsafe fn offset(self, count: int) -> Self;$/;"	f
ok	_	pub fn ok(self) -> Option<T> {$/;"	f
one	_	fn one() -> Foo {$/;"	f
one	_	fn one() -> f0 { 0.0 }$/;"	f
one	_	fn one() -> f0 { 0.0 }$/;"	f
one	_	fn one() -> $T { 0 }$/;"	f
one	_	fn one() -> Self;$/;"	f
one	_	fn one() -> $T { 0 }$/;"	f
oneshot	_	/^mod oneshot;$/;"	m
oneshot	_	pub fn oneshot(&mut self, msecs: u0) -> Port<()> {$/;"	f
oneshot	_	fn oneshot(&mut self, msecs: u0) -> Port<()>;$/;"	f
only_ascii	_	fn only_ascii(&self) -> bool { false }$/;"	f
only_ascii	_	fn only_ascii(&self) -> bool { (*self as uint) < 0 }$/;"	f
only_ascii	_	fn only_ascii(&self) -> bool { false }$/;"	f
only_ascii	_	fn only_ascii(&self) -> bool {$/;"	f
only_ascii	_	fn only_ascii(&self) -> bool;$/;"	f
op0	_	pub fn op0() -> Result<int, ~str> { Ok(0) }$/;"	f
op0	_	pub fn op0() -> Result<int, ~str> { Err(~"sadface") }$/;"	f
open	_	pub fn open(path: &Path) -> IoResult<File> {$/;"	f
open	_	pub fn open(fd: libc::c_int) -> IoResult<PipeStream> {$/;"	f
open	_	pub fn open(path: *c_char, oflag: c_int, mode: c_int)$/;"	f
open	_	pub fn open(filename: Option<&path::Path>) -> Result<DynamicLibrary, ~str> {$/;"	f
open_external	_	pub unsafe fn open_external(filename: &path::Path) -> *u0 {$/;"	f
open_internal	_	pub unsafe fn open_internal() -> *u0 {$/;"	f
open_mode	_	pub fn open_mode(path: &Path,$/;"	f
open_osfhandle	_	pub fn open_osfhandle(osfhandle: intptr_t,$/;"	f
opendir	_	pub unsafe fn opendir(dirname: *c_char) -> *DIR {$/;"	f
option	_	/^pub mod option;$/;"	m
option_empty	_	fn option_empty() {$/;"	f
option_fill	_	fn option_fill() {$/;"	f
option_swap	_	fn option_swap() {$/;"	f
option_take	_	fn option_take() {$/;"	f
or	_	pub fn or(self, optb: Option<T>) -> Option<T> {$/;"	f
or	_	pub fn or(self, res: Result<T, E>) -> Result<T, E> {$/;"	f
or_else	_	pub fn or_else(self, f: || -> Option<T>) -> Option<T> {$/;"	f
or_else	_	pub fn or_else<F>(self, op: |E| -> Result<T, F>) -> Result<T, F> {$/;"	f
order	_	/^pub mod order {$/;"	m
os	_	/^pub mod os;$/;"	m
os	_	pub mod os {$/;"	m
os	_	/^pub mod os;$/;"	m
os	_	mod os {$/;"	m
output	_	pub fn output(prog: &str, args: &[~str]) -> IoResult<ProcessOutput> {$/;"	f
owned	_	/^pub mod owned;$/;"	m
owns_buffer	_	pub fn owns_buffer(&self) -> bool {$/;"	f
owns_managed	_	pub fn owns_managed<T>() -> bool;$/;"	f
pad	_	pub fn pad(&mut self, s: &str) -> Result {$/;"	f
pad_integral	_	pub fn pad_integral(&mut self, is_positive: bool, prefix: &str, buf: &[u0]) -> Result {$/;"	f
page_size	_	/^pub fn page_size() -> uint {$/;"	f
parse	_	/^pub mod parse;$/;"	m
parse_bytes	_	/^pub fn parse_bytes(buf: &[u0], radix: uint) -> Option<$T> {$/;"	f
parse_bytes	_	/^pub fn parse_bytes(buf: &[u0], radix: uint) -> Option<$T> {$/;"	f
parse_digit	_	fn parse_digit(c: char, radix: u0) -> Option<u0> {$/;"	f
parse_log_level	_	/^fn parse_log_level(level: &str) -> Option<u0> {$/;"	f
parse_logging_spec	_	/^fn parse_logging_spec<'a>(spec: &'a str) -> Vec<LogDirective<'a>> {$/;"	f
parse_logging_spec_global	_	/^fn parse_logging_spec_global() {$/;"	f
parse_logging_spec_invalid_crate	_	/^fn parse_logging_spec_invalid_crate() {$/;"	f
parse_logging_spec_invalid_log_level	_	/^fn parse_logging_spec_invalid_log_level() {$/;"	f
parse_logging_spec_string_log_level	_	/^fn parse_logging_spec_string_log_level() {$/;"	f
parse_logging_spec_valid	_	/^fn parse_logging_spec_valid() {$/;"	f
parse_prefix	_	/^fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> {$/;"	f
parse_two_comps	_	fn parse_two_comps<'a>(mut path: &'a str, f: |char| -> bool)$/;"	f
partition	_	fn partition(self, f: |&T| -> bool) -> (~[T], ~[T]) {$/;"	f
partition	_	fn partition(self, f: |&T| -> bool) -> (~[T], ~[T]);$/;"	f
partitioned	_	fn partitioned(&self, f: |&T| -> bool) -> (~[T], ~[T]) {$/;"	f
partitioned	_	fn partitioned(&self, f: |&T| -> bool) -> (~[T], ~[T]);$/;"	f
path	_	fn path<'a>(&'a self) -> &'a Path {$/;"	f
path	_	pub fn path<'a>(&'a self) -> &'a Path {$/;"	f
path	_	/^impl path::Path {$/;"	i
path	_	/^pub mod path;$/;"	m
path_relative_from	_	fn path_relative_from(&self, base: &Self) -> Option<Self>;$/;"	f
path_relative_from	_	fn path_relative_from(&self, base: &Path) -> Option<Path> {$/;"	f
path_relative_from	_	fn path_relative_from(&self, base: &Path) -> Option<Path> {$/;"	f
path_relative_from_backward	_	fn path_relative_from_backward(bh: &mut BenchHarness) {$/;"	f
path_relative_from_forward	_	fn path_relative_from_forward(bh: &mut BenchHarness) {$/;"	f
path_relative_from_same_level	_	fn path_relative_from_same_level(bh: &mut BenchHarness) {$/;"	f
pathconf	_	pub fn pathconf(path: *c_char, name: c_int) -> c_long;$/;"	f
pausable_idle_callback	_	fn pausable_idle_callback(&mut self, ~Callback) -> ~PausableIdleCallback;$/;"	f
pause	_	pub fn pause() -> c_int;$/;"	f
pause	_	fn pause(&mut self);$/;"	f
pclose	_	pub fn pclose(stream: *FILE) -> c_int;$/;"	f
pdf	_	fn pdf(x: f0) -> f0 {$/;"	f
pdf	_	fn pdf(x: f0) -> f0 {$/;"	f
peek	_	pub fn peek(&'a mut self) -> Option<&'a A> {$/;"	f
peek	_	pub fn peek<'a>(&'a mut self) -> Option<&'a mut T> {$/;"	f
peekable	_	fn peekable(self) -> Peekable<A, Self> {$/;"	f
peer_name	_	pub fn peer_name(&mut self) -> IoResult<SocketAddr> {$/;"	f
peer_name	_	pub fn peer_name(addr: SocketAddr) {$/;"	f
peer_name	_	fn peer_name(&mut self) -> Result<SocketAddr, IoError>;$/;"	f
period	_	fn period(&mut self, msecs: u0) -> Port<()>;$/;"	f
periodic	_	pub fn periodic(&mut self, msecs: u0) -> Port<()> {$/;"	f
permutations	_	fn permutations(self) -> Permutations<T> {$/;"	f
permutations	_	fn permutations(self) -> Permutations<T>;$/;"	f
perror	_	pub fn perror(s: *c_char);$/;"	f
pi	_	fn pi() -> f0 { 0.0 }$/;"	f
pi	_	fn pi() -> f0 { 0.0 }$/;"	f
pi	_	fn pi() -> Self;$/;"	f
pipe	_	/^pub mod pipe;$/;"	m
pipe	_	pub fn pipe(fds: *mut c_int) -> c_int;$/;"	f
pipe	_	pub fn pipe(fds: *mut c_int, psize: c_uint, textmode: c_int)$/;"	f
pipe	_	/^pub fn pipe() -> Pipe {$/;"	f
pipe_open	_	fn pipe_open(&mut self, fd: c_int) -> Result<~RtioPipe, IoError>;$/;"	f
plural	_	fn plural(&mut self) -> ~Method<'a> {$/;"	f
plural_simple	_	fn plural_simple() {$/;"	f
pool	_	pub fn pool<'a>(&'a mut self) -> &'a mut BufferPool<T> {$/;"	f
pop	_	fn pop(&mut self, k: &K) -> Option<V>;$/;"	f
pop	_	/^pub fn pop<T: 'static>(key: Key<T>) -> Option<T> {$/;"	f
pop	_	fn pop(&mut self) -> bool;$/;"	f
pop	_	fn pop(&mut self) -> bool {$/;"	f
pop	_	fn pop(&mut self) -> bool {$/;"	f
pop	_	pub fn pop(&mut self) -> Option<T> {$/;"	f
pop	_	unsafe fn pop(&mut self) -> Option<T> {$/;"	f
pop	_	fn pop(&mut self) -> Option<T> {$/;"	f
pop	_	pub fn pop(&mut self) -> Option<T> {$/;"	f
pop	_	pub fn pop(&mut self) -> PopResult<T> {$/;"	f
pop	_	pub fn pop(&mut self) -> Option<T> {$/;"	f
pop	_	fn pop(&mut self) -> Option<T> {$/;"	f
pop	_	fn pop(&mut self) -> Option<T>;$/;"	f
pop	_	pub fn pop(&mut self) -> Option<T> {$/;"	f
pop_byte	_	pub unsafe fn pop_byte(s: &mut ~str) -> u0 {$/;"	f
pop_char	_	fn pop_char(&mut self) -> char {$/;"	f
pop_char	_	fn pop_char(&mut self) -> char;$/;"	f
pop_ptr	_	fn pop_ptr(&mut self);$/;"	f
pop_ptr	_	fn pop_ptr(&mut self) {$/;"	f
pop_ptr	_	pub unsafe fn pop_ptr<T>(slice: &mut Slice<T>) -> *T {$/;"	f
pop_ref	_	fn pop_ref(&mut self) -> Option<&'a T> {$/;"	f
pop_ref	_	fn pop_ref(&mut self) -> Option<&'a T>;$/;"	f
popen	_	pub fn popen(command: *c_char, mode: *c_char) -> *FILE;$/;"	f
position	_	fn position(&mut self) -> Position<'a> {$/;"	f
position	_	fn position(&mut self, predicate: |A| -> bool) -> Option<uint> {$/;"	f
position	_	/^pub unsafe fn position<T>(buf: *T, f: |&T| -> bool) -> uint {$/;"	f
position_elem	_	fn position_elem(&self, t: &T) -> Option<uint>;$/;"	f
position_elem	_	fn position_elem(&self, x: &T) -> Option<uint> {$/;"	f
posix	_	/^pub mod posix;$/;"	m
posix0	_	pub mod posix0 {$/;"	m
posix0	_	pub mod posix0 {$/;"	m
posix0	_	pub mod posix0 {}$/;"	m
posix0	_	pub mod posix0 {$/;"	m
posix0	_	pub mod posix0 {$/;"	m
posix0	_	pub mod posix0 {}$/;"	m
posix0	_	pub mod posix0 {$/;"	m
posix0	_	pub mod posix0 {}$/;"	m
posix0	_	pub mod posix0 {$/;"	m
posix0	_	pub mod posix0 {$/;"	m
posix0	_	pub mod posix0 {$/;"	m
posix0	_	pub mod posix0 {$/;"	m
posix_madvise	_	pub fn posix_madvise(addr: *c_void,$/;"	f
pow	_	fn pow(n: f0, e: f0) -> f0 = intrinsics::powf0,$/;"	f
pow	_	fn pow(n: f0, e: f0) -> f0 = intrinsics::powf0,$/;"	f
pow	_	/^pub fn pow<T: One + Mul<T, T>>(mut base: T, mut exp: uint) -> T {$/;"	f
powf	_	fn powf(&self, n: &f0) -> f0 { pow(*self, *n) }$/;"	f
powf	_	fn powf(&self, n: &f0) -> f0 { pow(*self, *n) }$/;"	f
powf	_	fn powf(&self, n: &Self) -> Self;$/;"	f
powf0	_	pub fn powf0(a: f0, x: f0) -> f0;$/;"	f
powf0	_	pub fn powf0(a: f0, x: f0) -> f0;$/;"	f
powi	_	fn powi(n: f0, e: i0) -> f0 = intrinsics::powif0,$/;"	f
powi	_	fn powi(n: f0, e: i0) -> f0 = intrinsics::powif0,$/;"	f
powif0	_	pub fn powif0(a: f0, x: i0) -> f0;$/;"	f
powif0	_	pub fn powif0(a: f0, x: i0) -> f0;$/;"	f
pread	_	pub fn pread(fd: c_int, buf: *c_void, count: size_t,$/;"	f
pread	_	fn pread(&mut self, buf: &mut [u0], offset: u0) -> Result<int, IoError>;$/;"	f
pred	_	fn pred(c: char) -> bool { c == ' ' }$/;"	f
pref_align_of	_	pub fn pref_align_of<T>() -> uint;$/;"	f
pref_align_of	_	/^pub fn pref_align_of<T>() -> uint {$/;"	f
pref_align_of_val	_	/^pub fn pref_align_of_val<T>(_val: &T) -> uint {$/;"	f
prefix	_	fn prefix(&self) -> &'static str { $prefix }$/;"	f
prefix	_	fn prefix(&self) -> &'static str { "" }$/;"	f
prefix	_	/^pub fn prefix(path: &Path) -> Option<PathPrefix> {$/;"	f
prefix_is_verbatim	_	/^fn prefix_is_verbatim(p: Option<PathPrefix>) -> bool {$/;"	f
prefix_len	_	fn prefix_len(&self) -> uint {$/;"	f
prefix_len	_	/^fn prefix_len(p: Option<PathPrefix>) -> uint {$/;"	f
prelude	_	/^pub mod prelude;$/;"	m
print	_	/^pub fn print(s: &str) {$/;"	f
print_args	_	/^pub fn print_args(fmt: &fmt::Arguments) {$/;"	f
println	_	/^pub fn println(s: &str) {$/;"	f
println_args	_	/^pub fn println_args(fmt: &fmt::Arguments) {$/;"	f
process	_	/^pub mod process;$/;"	m
product	_	fn product(&mut self) -> A {$/;"	f
product	_	fn product(&mut self) -> A;$/;"	f
property	_	/^pub mod property {$/;"	m
pthread_attr_init	_	fn pthread_attr_init(attr: *mut libc::pthread_attr_t) -> libc::c_int;$/;"	f
pthread_attr_setdetachstate	_	fn pthread_attr_setdetachstate(attr: *mut libc::pthread_attr_t,$/;"	f
pthread_attr_setstacksize	_	fn pthread_attr_setstacksize(attr: *mut libc::pthread_attr_t,$/;"	f
pthread_attr_t	_	pub struct pthread_attr_t {$/;"	s
pthread_cond_destroy	_	fn pthread_cond_destroy(cond: *mut pthread_cond_t) -> libc::c_int;$/;"	f
pthread_cond_init	_	fn pthread_cond_init(cond: *mut pthread_cond_t,$/;"	f
pthread_cond_signal	_	fn pthread_cond_signal(cond: *mut pthread_cond_t) -> libc::c_int;$/;"	f
pthread_cond_t	_	pub struct pthread_cond_t { value: libc::c_int }$/;"	s
pthread_cond_t	_	pub struct pthread_cond_t {$/;"	s
pthread_cond_wait	_	fn pthread_cond_wait(cond: *mut pthread_cond_t,$/;"	f
pthread_create	_	fn pthread_create(native: *mut libc::pthread_t,$/;"	f
pthread_detach	_	fn pthread_detach(thread: libc::pthread_t) -> libc::c_int;$/;"	f
pthread_getspecific	_	fn pthread_getspecific(key: pthread_key_t) -> *mut u0;$/;"	f
pthread_join	_	fn pthread_join(native: libc::pthread_t,$/;"	f
pthread_key_create	_	fn pthread_key_create(key: *mut pthread_key_t, dtor: *u0) -> c_int;$/;"	f
pthread_key_delete	_	fn pthread_key_delete(key: pthread_key_t) -> c_int;$/;"	f
pthread_mutex_destroy	_	fn pthread_mutex_destroy(lock: *mut pthread_mutex_t) -> libc::c_int;$/;"	f
pthread_mutex_init	_	fn pthread_mutex_init(lock: *mut pthread_mutex_t,$/;"	f
pthread_mutex_lock	_	fn pthread_mutex_lock(lock: *mut pthread_mutex_t) -> libc::c_int;$/;"	f
pthread_mutex_t	_	pub struct pthread_mutex_t { value: libc::c_int }$/;"	s
pthread_mutex_t	_	pub struct pthread_mutex_t {$/;"	s
pthread_mutex_trylock	_	fn pthread_mutex_trylock(lock: *mut pthread_mutex_t) -> libc::c_int;$/;"	f
pthread_mutex_unlock	_	fn pthread_mutex_unlock(lock: *mut pthread_mutex_t) -> libc::c_int;$/;"	f
pthread_setspecific	_	fn pthread_setspecific(key: pthread_key_t, value: *mut u0) -> c_int;$/;"	f
pthread_yield	_	fn pthread_yield() -> libc::c_int;$/;"	f
ptr	_	/^pub mod ptr;$/;"	m
ptr_eq	_	pub fn ptr_eq(&self, other: &Gc<T>) -> bool {$/;"	f
ptr_eq	_	/^pub fn ptr_eq<T>(a: @T, b: @T) -> bool {$/;"	f
ptr_tests	_	/^pub mod ptr_tests {$/;"	m
push	_	fn push<T: BytesContainer>(&mut self, path: T) {$/;"	f
push	_	/^pub fn push(f: proc()) {$/;"	f
push	_	pub fn push(&mut self, t: T) {$/;"	f
push	_	unsafe fn push(&mut self, data: T) {$/;"	f
push	_	fn push(&mut self, value: T) -> bool {$/;"	f
push	_	pub fn push(&mut self, value: T) -> bool {$/;"	f
push	_	pub fn push(&mut self, t: T) {$/;"	f
push	_	pub fn push(&mut self, t: T) {$/;"	f
push	_	fn push(&mut self, t: T) {$/;"	f
push	_	fn push(&mut self, t: T);$/;"	f
push	_	fn push(bh: &mut BenchHarness) {$/;"	f
push	_	pub fn push(&mut self, value: T) {$/;"	f
push_abs_path_home_dir	_	fn push_abs_path_home_dir(bh: &mut BenchHarness) {$/;"	f
push_all	_	fn push_all(&mut self, rhs: &[T]) {$/;"	f
push_all	_	fn push_all(&mut self, rhs: &[T]);$/;"	f
push_all	_	pub fn push_all(&mut self, other: &[T]) {$/;"	f
push_all_move	_	fn push_all_move(&mut self, mut rhs: ~[T]) {$/;"	f
push_all_move	_	fn push_all_move(&mut self, rhs: ~[T]);$/;"	f
push_all_move	_	pub fn push_all_move(&mut self, other: Vec<T>) {$/;"	f
push_byte	_	pub unsafe fn push_byte(s: &mut ~str, b: u0) {$/;"	f
push_bytes	_	fn push_bytes() {$/;"	f
push_bytes	_	fn push_bytes(&mut self, buf: &mut ~[u0], len: uint) -> IoResult<()> {$/;"	f
push_bytes	_	pub unsafe fn push_bytes(s: &mut ~str, bytes: &[u0]) {$/;"	f
push_bytes	_	pub fn push_bytes(dst: &mut ~[u0], src: &[u0]) {$/;"	f
push_bytes_eof	_	fn push_bytes_eof() {$/;"	f
push_bytes_error	_	fn push_bytes_error() {$/;"	f
push_bytes_partial	_	fn push_bytes_partial() {$/;"	f
push_char	_	fn push_char(&mut self, c: char) {$/;"	f
push_char	_	fn push_char(&mut self, c: char);$/;"	f
push_fast	_	unsafe fn push_fast<T>(this: &mut ~[T], t: T) {$/;"	f
push_home_dir	_	fn push_home_dir(bh: &mut BenchHarness) {$/;"	f
push_many	_	fn push_many<T: BytesContainer>(&mut self, paths: &[T]) {$/;"	f
push_many_abs_path_home_dir	_	fn push_many_abs_path_home_dir(bh: &mut BenchHarness) {$/;"	f
push_many_home_dir	_	fn push_many_home_dir(bh: &mut BenchHarness) {$/;"	f
push_ptr	_	fn push_ptr(&mut self);$/;"	f
push_ptr	_	fn push_ptr(&mut self) {$/;"	f
push_str	_	fn push_str(&mut self, rhs: &str) {$/;"	f
push_str	_	fn push_str(&mut self, rhs: &str);$/;"	f
push_str	_	/^pub fn push_str(lhs: &mut ~str, rhs: &str) {$/;"	f
push_str_no_overallocate	_	fn push_str_no_overallocate(&mut self, rhs: &str) {$/;"	f
push_str_no_overallocate	_	fn push_str_no_overallocate(&mut self, rhs: &str);$/;"	f
push_unchecked	_	unsafe fn push_unchecked<T: BytesContainer>(&mut self, path: T);$/;"	f
push_unchecked	_	unsafe fn push_unchecked<T: BytesContainer>(&mut self, path: T) {$/;"	f
push_unchecked	_	unsafe fn push_unchecked<T: BytesContainer>(&mut self, path: T) {$/;"	f
put	_	pub fn put(_args: ~[~[u0]]) {$/;"	f
put	_	pub fn put(args: ~[~[u0]]) {$/;"	f
put	_	fn put(value: ~Self);$/;"	f
put	_	fn put(value: ~Task) { unsafe { local_ptr::put(value) } }$/;"	f
put	_	pub unsafe fn put<T>(sched: ~T) {$/;"	f
put	_	unsafe fn put(&mut self, i: int, t: T) {$/;"	f
put_runtime	_	pub fn put_runtime(&mut self, ops: ~Runtime) {$/;"	f
putenv	_	pub fn putenv(string: *c_char) -> c_int;$/;"	f
puts	_	fn puts(s: *libc::c_char);$/;"	f
puts	_	pub fn puts(s: *c_char) -> c_int;$/;"	f
pwrite	_	pub fn pwrite(fd: c_int, buf: *c_void, count: size_t,$/;"	f
pwrite	_	fn pwrite(&mut self, buf: &[u0], offset: u0) -> Result<(), IoError>;$/;"	f
radix	_	/^pub fn radix<T>(x: T, base: u0) -> RadixFmt<T, Radix> {$/;"	f
raise_fd_limit	_	pub unsafe fn raise_fd_limit() {$/;"	f
raise_fd_limit	_	pub unsafe fn raise_fd_limit() {}$/;"	f
raise_fd_limit	_	/^pub fn raise_fd_limit() {$/;"	f
rand	_	/^pub mod rand;$/;"	m
rand	_	pub fn rand() -> c_int;$/;"	f
rand	_	fn rand<R:Rng>(rng: &mut R) -> Exp0 {$/;"	f
rand	_	fn rand<R: Rng>(_: &mut R) -> ConstRand {$/;"	f
rand	_	fn rand<R:Rng>(rng: &mut R) -> StandardNormal {$/;"	f
rand	_	fn rand<R: Rng>(rng: &mut R) -> Self;$/;"	f
rand	_	fn rand<R: Rng>(rng: &mut R) -> $ty {$/;"	f
rand	_	fn rand<R: Rng>(rng: &mut R) -> Closed0<$ty> {$/;"	f
rand	_	fn rand<R: Rng>(rng: &mut R) -> Open0<$ty> {$/;"	f
rand	_	fn rand<R: Rng>(_rng: &mut R) -> ( $( $tyvar ),* , ) {$/;"	f
rand	_	fn rand<R: Rng>(_: &mut R) -> () { () }$/;"	f
rand	_	fn rand<R: Rng>(rng: &mut R) -> @T { @rng.gen() }$/;"	f
rand	_	fn rand<R: Rng>(rng: &mut R) -> Option<T> {$/;"	f
rand	_	fn rand<R: Rng>(rng: &mut R) -> bool {$/;"	f
rand	_	fn rand<R: Rng>(rng: &mut R) -> char {$/;"	f
rand	_	fn rand<R: Rng>(rng: &mut R) -> i0 {$/;"	f
rand	_	fn rand<R: Rng>(rng: &mut R) -> i0 {$/;"	f
rand	_	fn rand<R: Rng>(rng: &mut R) -> i0 {$/;"	f
rand	_	fn rand<R: Rng>(rng: &mut R) -> i0 {$/;"	f
rand	_	fn rand<R: Rng>(rng: &mut R) -> int {$/;"	f
rand	_	fn rand<R: Rng>(rng: &mut R) -> u0 {$/;"	f
rand	_	fn rand<R: Rng>(rng: &mut R) -> u0 {$/;"	f
rand	_	fn rand<R: Rng>(rng: &mut R) -> u0 {$/;"	f
rand	_	fn rand<R: Rng>(rng: &mut R) -> u0 {$/;"	f
rand	_	fn rand<R: Rng>(rng: &mut R) -> uint {$/;"	f
rand	_	fn rand<R: Rng>(rng: &mut R) -> ~T { ~rng.gen() }$/;"	f
rand_closed	_	fn rand_closed() {$/;"	f
rand_exp	_	fn rand_exp(bh: &mut BenchHarness) {$/;"	f
rand_impls	_	/^mod rand_impls;$/;"	m
rand_isaac	_	fn rand_isaac(bh: &mut BenchHarness) {$/;"	f
rand_isaac0	_	fn rand_isaac0(bh: &mut BenchHarness) {$/;"	f
rand_normal	_	fn rand_normal(bh: &mut BenchHarness) {$/;"	f
rand_open	_	fn rand_open() {$/;"	f
rand_shuffle_0	_	fn rand_shuffle_0(bh: &mut BenchHarness) {$/;"	f
rand_std	_	fn rand_std(bh: &mut BenchHarness) {$/;"	f
rand_xorshift	_	fn rand_xorshift(bh: &mut BenchHarness) {$/;"	f
random	_	/^pub fn random<T: Rand>() -> T {$/;"	f
random_inserts	_	fn random_inserts(bh: &mut BenchHarness) {$/;"	f
random_removes	_	fn random_removes(bh: &mut BenchHarness) {$/;"	f
range	_	/^pub fn range<A: Add<A, A> + Ord + Clone + One>(start: A, stop: A) -> Range<A> {$/;"	f
range	_	/^pub mod range;$/;"	m
range_inclusive	_	/^pub fn range_inclusive<A: Add<A, A> + Ord + Clone + One + ToPrimitive>(start: A, stop: A)$/;"	f
range_step	_	/^pub fn range_step<A: CheckedAdd + Ord + Clone + Zero>(start: A, stop: A, step: A) -> RangeStep<A> {$/;"	f
range_step_inclusive	_	/^pub fn range_step_inclusive<A: CheckedAdd + Ord + Clone + Zero>(start: A, stop: A,$/;"	f
raw	_	/^pub mod raw;$/;"	m
raw	_	/^pub mod raw {$/;"	m
raw	_	/^pub mod raw {$/;"	m
rc	_	/^pub mod rc;$/;"	m
read	_	fn read(&mut self, _: &mut [u0]) -> io::IoResult<uint> {$/;"	f
read	_	fn read(&mut self, _: &mut [u0]) -> io::IoResult<uint> {$/;"	f
read	_	fn read(&mut self, buf: &mut [u0]) -> IoResult<uint> {$/;"	f
read	_	fn read(&mut self, buf: &mut [u0]) -> IoResult<uint> {$/;"	f
read	_	fn read(&mut self, _: &mut [u0]) -> io::IoResult<uint> {$/;"	f
read	_	fn read(&mut self, buf: &mut [u0]) -> io::IoResult<uint> {$/;"	f
read	_	fn read(&mut self, _buf: &mut [u0]) -> Option<uint> { fail!() }$/;"	f
read	_	fn read(&mut self, buf: &mut [u0]) -> IoResult<uint> {$/;"	f
read	_	fn read(&mut self, buf: &mut [u0]) -> IoResult<uint> {$/;"	f
read	_	fn read(&mut self, buf: &mut [u0]) -> IoResult<uint> { self.inner.read(buf) }$/;"	f
read	_	fn read(&mut self, buf: &mut [u0]) -> IoResult<uint> { self.read(buf) }$/;"	f
read	_	fn read(&mut self, buf: &mut [u0]) -> IoResult<uint>;$/;"	f
read	_	fn read(&mut self, buf: &mut [u0]) -> IoResult<uint> { self.obj.read(buf) }$/;"	f
read	_	fn read(&mut self, buf: &mut [u0]) -> IoResult<uint> {$/;"	f
read	_	fn read(&mut self, buf: &mut [u0]) -> IoResult<uint> { self.obj.read(buf) }$/;"	f
read	_	fn read(&mut self, buf: &mut [u0]) -> IoResult<uint> { self.obj.read(buf) }$/;"	f
read	_	fn read(stream: Option<io::PipeStream>) -> Port<IoResult<~[u0]>> {$/;"	f
read	_	fn read(&mut self, buf: &mut [u0]) -> IoResult<uint> {$/;"	f
read	_	fn read(&mut self, buf: &mut [u0]) -> IoResult<uint> {$/;"	f
read	_	fn read(&mut self, _buf: &mut [u0]) -> io::IoResult<uint> {$/;"	f
read	_	fn read(&mut self, buf: &mut [u0]) -> io::IoResult<uint> {$/;"	f
read	_	pub fn read(fd: c_int, buf: *mut c_void, count: c_uint)$/;"	f
read	_	pub fn read(fd: c_int, buf: *mut c_void, count: size_t)$/;"	f
read	_	/^pub unsafe fn read<T>(src: *T) -> T {$/;"	f
read	_	fn read(&mut self, buf: &mut [u0]) -> Result<int, IoError>;$/;"	f
read	_	fn read(&mut self, buf: &mut [u0]) -> Result<uint, IoError>;$/;"	f
read_all	_	pub fn read_all(input: &mut Reader) -> ~str {$/;"	f
read_and_zero	_	/^pub unsafe fn read_and_zero<T>(dest: *mut T) -> T {$/;"	f
read_atomically	_	fn read_atomically<T>(&mut self, cb: |&mut Parser| -> Option<T>)$/;"	f
read_be_f0	_	fn read_be_f0(&mut self) -> IoResult<f0> {$/;"	f
read_be_f0	_	fn read_be_f0(&mut self) -> IoResult<f0> {$/;"	f
read_be_i0	_	fn read_be_i0(&mut self) -> IoResult<i0> {$/;"	f
read_be_i0	_	fn read_be_i0(&mut self) -> IoResult<i0> {$/;"	f
read_be_i0	_	fn read_be_i0(&mut self) -> IoResult<i0> {$/;"	f
read_be_int	_	fn read_be_int(&mut self) -> IoResult<int> {$/;"	f
read_be_int_n	_	fn read_be_int_n(&mut self, nbytes: uint) -> IoResult<i0> {$/;"	f
read_be_u0	_	fn read_be_u0(&mut self) -> IoResult<u0> {$/;"	f
read_be_u0	_	fn read_be_u0(&mut self) -> IoResult<u0> {$/;"	f
read_be_u0	_	fn read_be_u0(&mut self) -> IoResult<u0> {$/;"	f
read_be_uint	_	fn read_be_uint(&mut self) -> IoResult<uint> {$/;"	f
read_be_uint_n	_	fn read_be_uint_n(&mut self, nbytes: uint) -> IoResult<u0> {$/;"	f
read_byte	_	fn read_byte() {$/;"	f
read_byte	_	fn read_byte(&mut self) -> IoResult<u0> {$/;"	f
read_byte_0_bytes	_	fn read_byte_0_bytes() {$/;"	f
read_byte_eof	_	fn read_byte_eof() {$/;"	f
read_byte_error	_	fn read_byte_error() {$/;"	f
read_bytes	_	fn read_bytes() {$/;"	f
read_bytes	_	fn read_bytes(&mut self, len: uint) -> IoResult<~[u0]> {$/;"	f
read_bytes_eof	_	fn read_bytes_eof() {$/;"	f
read_bytes_partial	_	fn read_bytes_partial() {$/;"	f
read_char	_	fn read_char(&mut self) -> IoResult<char> {$/;"	f
read_char	_	fn read_char(&mut self) -> Option<char> {$/;"	f
read_char_buffered	_	fn read_char_buffered() {$/;"	f
read_digit	_	fn read_digit(&mut self, radix: u0) -> Option<u0> {$/;"	f
read_given_char	_	fn read_given_char(&mut self, c: char) -> Option<char> {$/;"	f
read_groups	_	fn read_groups(p: &mut Parser, groups: &mut [u0, ..0], limit: uint) -> (uint, bool) {$/;"	f
read_i0	_	fn read_i0(&mut self) -> IoResult<i0> {$/;"	f
read_ip_addr	_	fn read_ip_addr(&mut self) -> Option<IpAddr> {$/;"	f
read_ipv0_addr	_	fn read_ipv0_addr(&mut self) -> Option<IpAddr> {$/;"	f
read_ipv0_addr_impl	_	fn read_ipv0_addr_impl(&mut self) -> Option<IpAddr> {$/;"	f
read_ipv0_addr	_	fn read_ipv0_addr(&mut self) -> Option<IpAddr> {$/;"	f
read_ipv0_addr_impl	_	fn read_ipv0_addr_impl(&mut self) -> Option<IpAddr> {$/;"	f
read_le_f0	_	fn read_le_f0(&mut self) -> IoResult<f0> {$/;"	f
read_le_f0	_	fn read_le_f0(&mut self) -> IoResult<f0> {$/;"	f
read_le_i0	_	fn read_le_i0(&mut self) -> IoResult<i0> {$/;"	f
read_le_i0	_	fn read_le_i0(&mut self) -> IoResult<i0> {$/;"	f
read_le_i0	_	fn read_le_i0(&mut self) -> IoResult<i0> {$/;"	f
read_le_int	_	fn read_le_int(&mut self) -> IoResult<int> {$/;"	f
read_le_int_n	_	fn read_le_int_n(&mut self, nbytes: uint) -> IoResult<i0> {$/;"	f
read_le_u0	_	fn read_le_u0(&mut self) -> IoResult<u0> {$/;"	f
read_le_u0	_	fn read_le_u0(&mut self) -> IoResult<u0> {$/;"	f
read_le_u0	_	fn read_le_u0(&mut self) -> IoResult<u0> {$/;"	f
read_le_uint	_	fn read_le_uint(&mut self) -> IoResult<uint> {$/;"	f
read_le_uint_n	_	fn read_le_uint_n(&mut self, nbytes: uint) -> IoResult<u0> {$/;"	f
read_line	_	fn read_line(&mut self) -> IoResult<~str> {$/;"	f
read_number	_	fn read_number(&mut self, radix: u0, max_digits: u0, upto: u0) -> Option<u0> {$/;"	f
read_number_impl	_	fn read_number_impl(&mut self, radix: u0, max_digits: u0, upto: u0) -> Option<u0> {$/;"	f
read_or	_	fn read_or<T>(&mut self, parsers: &[|&mut Parser| -> Option<T>])$/;"	f
read_seq_0	_	fn read_seq_0<A,$/;"	f
read_socket_addr	_	fn read_socket_addr(&mut self) -> Option<SocketAddr> {$/;"	f
read_till_eof	_	fn read_till_eof<T>(&mut self, cb: |&mut Parser| -> Option<T>)$/;"	f
read_to_end	_	fn read_to_end() {$/;"	f
read_to_end	_	fn read_to_end(&mut self) -> IoResult<~[u0]> {$/;"	f
read_to_end_error	_	fn read_to_end_error() {$/;"	f
read_to_str	_	fn read_to_str(&mut self) -> IoResult<~str> {$/;"	f
read_u0	_	fn read_u0(&mut self) -> IoResult<u0> {$/;"	f
read_until	_	fn read_until(&mut self, byte: u0) -> IoResult<~[u0]> {$/;"	f
readdir	_	/^pub fn readdir(path: &Path) -> IoResult<~[Path]> {$/;"	f
readdir_r	_	pub unsafe fn readdir_r(dirp: *DIR,$/;"	f
reader	_	/^pub mod reader;$/;"	m
readlink	_	/^pub fn readlink(path: &Path) -> IoResult<Path> {$/;"	f
readlink	_	pub fn readlink(path: *c_char,$/;"	f
real_args	_	/^fn real_args() -> ~[~str] {$/;"	f
real_args_as_bytes	_	/^fn real_args_as_bytes() -> ~[~[u0]] {$/;"	f
realloc	_	pub fn realloc(p: *mut c_void, size: size_t) -> *mut c_void;$/;"	f
realloc	_	fn realloc(&mut self, alloc: *mut Box, size: uint) -> *mut Box {$/;"	f
realloc	_	pub fn realloc(&mut self, ptr: *mut Box, size: uint) -> *mut Box {$/;"	f
realloc_raw	_	/^pub unsafe fn realloc_raw(ptr: *mut u0, size: uint) -> *mut u0 {$/;"	f
reawaken	_	fn reawaken(~self, to_wake: ~Task);$/;"	f
reawaken	_	pub fn reawaken(mut ~self) {$/;"	f
recip	_	fn recip(&self) -> f0 { 0.0 \/ *self }$/;"	f
recip	_	fn recip(&self) -> f0 { 0.0 \/ *self }$/;"	f
recip	_	fn recip(&self) -> Self;$/;"	f
record_sp_limit	_	fn record_sp_limit(limit: *c_void);$/;"	f
record_sp_limit	_	/^pub unsafe fn record_sp_limit(limit: uint) {$/;"	f
record_stack_bounds	_	/^pub unsafe fn record_stack_bounds(stack_lo: uint, stack_hi: uint) {$/;"	f
recv	_	fn recv(port: Port<~int>, i: int) {$/;"	f
recv	_	pub fn recv(&self) -> T {$/;"	f
recv	_	pub fn recv(&mut self) -> Result<T, Failure<T>> {$/;"	f
recv	_	pub fn recv(&mut self) -> T { self.port.recv() }$/;"	f
recv	_	pub fn recv(&mut self) -> Result<T, Failure> {$/;"	f
recv	_	pub fn recv(&mut self) -> Result<T, Failure<T>> {$/;"	f
recv	_	pub fn recv(socket: SOCKET, buf: *mut c_void, len: c_int,$/;"	f
recv	_	pub fn recv(socket: c_int, buf: *mut c_void, len: size_t,$/;"	f
recv_from_outside_runtime	_	fn recv_from_outside_runtime() {$/;"	f
recv_opt	_	pub fn recv_opt(&self) -> Option<T> {$/;"	f
recv_opt	_	pub fn recv_opt(&mut self) -> Option<T> { self.port.recv_opt() }$/;"	f
recvfrom	_	pub fn recvfrom(&mut self, buf: &mut [u0]) -> IoResult<(uint, SocketAddr)> {$/;"	f
recvfrom	_	pub fn recvfrom(socket: SOCKET, buf: *mut c_void, len: c_int,$/;"	f
recvfrom	_	pub fn recvfrom(socket: c_int, buf: *mut c_void, len: size_t,$/;"	f
recvfrom	_	fn recvfrom(&mut self, buf: &mut [u0]) -> Result<(uint, SocketAddr), IoError>;$/;"	f
ref_slice	_	/^pub fn ref_slice<'a, A>(s: &'a A) -> &'a [A] {$/;"	f
refcount	_	/^pub fn refcount<T>(t: @T) -> uint {$/;"	f
refcount_test	_	/^fn refcount_test() {$/;"	f
reference	_	/^mod reference;$/;"	m
reflect	_	/^pub mod reflect;$/;"	m
register	_	pub fn register(&mut self, signum: Signum) -> io::IoResult<()> {$/;"	f
release	_	fn release(&mut self, _alloc: &AllocHeader) {}$/;"	f
release	_	fn release(&mut self, alloc: &AllocHeader) {$/;"	f
rem	_	fn rem(&self, other: &f0) -> f0 { *self % *other }$/;"	f
rem	_	fn rem(&self, other: &f0) -> f0 { *self % *other }$/;"	f
rem	_	fn rem(&self, other: &$T) -> $T { *self % *other }$/;"	f
rem	_	fn rem(&self, other: &$T) -> $T { *self % *other }$/;"	f
rem	_	fn rem(&self, rhs: &RHS) -> Result;$/;"	f
remote_callback	_	fn remote_callback(&mut self, ~Callback) -> ~RemoteCallback;$/;"	f
remove	_	pub unsafe fn remove(&mut self) {$/;"	f
remove	_	fn remove(&mut self, key: &K) -> bool {$/;"	f
remove	_	fn remove(&mut self, value: &T) -> bool;$/;"	f
remove	_	pub fn remove(filename: *c_char) -> c_int;$/;"	f
remove	_	fn remove(&mut self, i: uint) -> Option<T> {$/;"	f
remove	_	fn remove(&mut self, i: uint) -> Option<T>;$/;"	f
rename	_	/^pub fn rename(from: &Path, to: &Path) -> IoResult<()> {$/;"	f
rename	_	pub fn rename(oldname: *c_char, newname: *c_char) -> c_int;$/;"	f
repeat	_	fn repeat(&self, nn: uint) -> ~str {$/;"	f
repeat	_	fn repeat(&self, nn: uint) -> ~str;$/;"	f
replace	_	/^pub fn replace<T>(dest: &mut T, mut src: T) -> T {$/;"	f
replace	_	/^pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {$/;"	f
replace	_	fn replace(&self, from: &str, to: &str) -> ~str {$/;"	f
replace	_	fn replace(&self, from: &str, to: &str) -> ~str;$/;"	f
replace	_	/^pub fn replace(s: &str, from: &str, to: &str) -> ~str {$/;"	f
replace_path	_	fn replace_path(me: &mut Path, path: &str, prefix: Option<PathPrefix>) {$/;"	f
repr	_	/^pub mod repr;$/;"	m
repr	_	fn repr(&self) -> T { unsafe { cast::transmute_copy(self) } }$/;"	f
repr_to_str	_	/^pub fn repr_to_str<T>(t: &T) -> ~str {$/;"	f
reseed	_	fn reseed(&mut self, seed: &'a [u0]) {$/;"	f
reseed	_	fn reseed(&mut self, seed: &'a [u0]) {$/;"	f
reseed	_	fn reseed(&mut self, Seed);$/;"	f
reseed	_	fn reseed(&mut self, rng: &mut StdRng) {$/;"	f
reseed	_	fn reseed(&mut self, seed: &'a [uint]) {$/;"	f
reseed	_	fn reseed(&mut self, seed: [u0, .. 0]) {$/;"	f
reseed	_	fn reseed(&mut self, seed: u0) {$/;"	f
reseed	_	fn reseed(&mut self, (rsdr, seed): (Rsdr, S)) {$/;"	f
reseed	_	fn reseed(&mut self, rng: &mut R) {$/;"	f
reseed	_	fn reseed(&mut self, rng: &mut R);$/;"	f
reseed_if_necessary	_	pub fn reseed_if_necessary(&mut self) {$/;"	f
reseeding	_	/^impl reseeding::Reseeder<StdRng> for TaskRngReseeder {$/;"	i
reseeding	_	/^pub mod reseeding;$/;"	m
reserve	_	fn reserve(&mut self, n: uint) {$/;"	f
reserve	_	fn reserve(&mut self, n: uint);$/;"	f
reserve	_	fn reserve(&mut self, n: uint) {$/;"	f
reserve	_	fn reserve(&mut self, n: uint);$/;"	f
reserve	_	pub fn reserve(&mut self, capacity: uint) {$/;"	f
reserve_additional	_	fn reserve_additional(&mut self, n: uint) {$/;"	f
reserve_additional	_	fn reserve_additional(&mut self, n: uint);$/;"	f
reserve_additional	_	pub fn reserve_additional(&mut self, extra: uint) {$/;"	f
reserve_exact	_	fn reserve_exact(&mut self, n: uint) {$/;"	f
reserve_exact	_	fn reserve_exact(&mut self, n: uint);$/;"	f
reserve_exact	_	fn reserve_exact(&mut self, n: uint) {$/;"	f
reserve_exact	_	fn reserve_exact(&mut self, n: uint);$/;"	f
reserve_exact	_	pub fn reserve_exact(&mut self, capacity: uint) {$/;"	f
reset	_	pub fn reset(&mut self) {$/;"	f
reset_fuse	_	pub fn reset_fuse(&mut self) {$/;"	f
reset_helper	_	/^fn reset_helper(w: ~Writer,$/;"	f
resize	_	unsafe fn resize(&self, b: int, t: int, delta: int) -> Buffer<T> {$/;"	f
result	_	pub fn result(&self) -> u0 {$/;"	f
result	_	/^mod result;$/;"	m
result	_	/^pub mod result;$/;"	m
result	_	pub fn result(&mut self) -> TaskResult {$/;"	f
result_bytes	_	fn result_bytes(h: u0) -> ~[u0] {$/;"	f
result_str	_	fn result_str(h: u0) -> ~str {$/;"	f
resume	_	fn resume(&mut self);$/;"	f
retain	_	fn retain(&mut self, f: |t: &T| -> bool) {$/;"	f
retain	_	fn retain(&mut self, f: |t: &T| -> bool);$/;"	f
rev	_	fn rev(self) -> Rev<Self> {$/;"	f
rev_components	_	pub fn rev_components<'a>(&'a self) -> RevComponents<'a> {$/;"	f
rev_components	_	pub fn rev_components<'a>(&'a self) -> RevComponents<'a> {$/;"	f
rev_iter	_	fn rev_iter(self) -> RevItems<'a, T> {$/;"	f
rev_iter	_	fn rev_iter(self) -> RevItems<'a, T>;$/;"	f
rev_iter	_	pub fn rev_iter<'a>(&'a self) -> RevItems<'a,T> {$/;"	f
rev_str_components	_	pub fn rev_str_components<'a>(&'a self) -> RevStrComponents<'a> {$/;"	f
rev_str_components	_	pub fn rev_str_components<'a>(&'a self) -> RevStrComponents<'a> {$/;"	f
reverse	_	fn reverse(self) {$/;"	f
reverse	_	fn reverse(self);$/;"	f
reverse_	_	fn reverse_(&mut self) {$/;"	f
reverse_	_	fn reverse_(&mut self);$/;"	f
rewind	_	pub fn rewind(stream: *FILE);$/;"	f
rewinddir	_	pub fn rewinddir(dirp: *DIR);$/;"	f
rfind	_	fn rfind<C: CharEq>(&self, search: C) -> Option<uint> {$/;"	f
rfind	_	fn rfind<C: CharEq>(&self, search: C) -> Option<uint>;$/;"	f
rint	_	fn rint(n: f0) -> f0 = intrinsics::rintf0,$/;"	f
rint	_	fn rint(n: f0) -> f0 = intrinsics::rintf0,$/;"	f
rintf0	_	pub fn rintf0(x: f0) -> f0;$/;"	f
rintf0	_	pub fn rintf0(x: f0) -> f0;$/;"	f
rlimit	_	struct rlimit {$/;"	s
rmdir	_	/^pub fn rmdir(path: &Path) -> IoResult<()> {$/;"	f
rmdir	_	pub fn rmdir(path: *c_char) -> c_int;$/;"	f
rmdir_recursive	_	/^pub fn rmdir_recursive(path: &Path) -> IoResult<()> {$/;"	f
rng	_	/^pub fn rng() -> StdRng {$/;"	f
rng	_	fn rng() {$/;"	f
root_path	_	fn root_path(&self) -> Option<Self>;$/;"	f
root_path	_	fn root_path(&self) -> Option<Path> {$/;"	f
root_path	_	fn root_path(&self) -> Option<Path> {$/;"	f
round	_	fn round(&self) -> f0 { round(*self) }$/;"	f
round	_	fn round(n: f0) -> f0 = intrinsics::roundf0,$/;"	f
round	_	fn round(&self) -> f0 { round(*self) }$/;"	f
round	_	fn round(n: f0) -> f0 = intrinsics::roundf0,$/;"	f
round	_	fn round(&self) -> Self;$/;"	f
round_to_zero	_	fn round_to_zero(&self) -> $t { self.trunc() }$/;"	f
round_to_zero	_	fn round_to_zero(&self)   -> Self;$/;"	f
round_up	_	/^fn round_up(from: uint, to: uint) -> uint {$/;"	f
roundf0	_	pub fn roundf0(x: f0) -> f0;$/;"	f
roundf0	_	pub fn roundf0(x: f0) -> f0;$/;"	f
rposition	_	fn rposition(&mut self, predicate: |A| -> bool) -> Option<uint> {$/;"	f
rposition_elem	_	fn rposition_elem(&self, t: &T) -> Option<uint> {$/;"	f
rposition_elem	_	fn rposition_elem(&self, t: &T) -> Option<uint>;$/;"	f
rsplit	_	fn rsplit<Sep: CharEq>(&self, sep: Sep) -> RevCharSplits<'a, Sep> {$/;"	f
rsplit	_	fn rsplit<Sep: CharEq>(&self, sep: Sep) -> RevCharSplits<'a, Sep>;$/;"	f
rsplit	_	fn rsplit(self, pred: 'a |&T| -> bool) -> RevSplits<'a, T> {$/;"	f
rsplit	_	fn rsplit(self, pred: 'a |&T| -> bool) -> RevSplits<'a, T>;$/;"	f
rsplitn	_	fn rsplitn<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitsN<'a, Sep>;$/;"	f
rsplitn	_	fn rsplitn<Sep: CharEq>(&self, sep: Sep, count: uint)$/;"	f
rsplitn	_	fn rsplitn(self,  n: uint, pred: 'a |&T| -> bool) -> RevSplits<'a, T>;$/;"	f
rsplitn	_	fn rsplitn(self, n: uint, pred: 'a |&T| -> bool) -> RevSplits<'a, T> {$/;"	f
rsqrt	_	fn rsqrt(&self) -> f0 { self.sqrt().recip() }$/;"	f
rsqrt	_	fn rsqrt(&self) -> f0 { self.sqrt().recip() }$/;"	f
rsqrt	_	fn rsqrt(&self) -> Self;$/;"	f
rt	_	/^pub mod rt;$/;"	m
rt	_	/^pub mod rt;$/;"	m
rtdeps	_	/^mod rtdeps;$/;"	m
rtio	_	/^pub mod rtio;$/;"	m
run	_	fn run(&mut self, piece: &rt::Piece, cur: Option<&str>) -> Result {$/;"	f
run	_	/^pub fn run() {$/;"	f
run	_	fn run(&mut self);$/;"	f
run	_	pub fn run(~self, f: ||) -> ~Task {$/;"	f
run_env	_	pub fn run_env(env: Option<~[(~str, ~str)]>) -> Process {$/;"	f
run_fmt	_	fn run_fmt(fmt: &::std::fmt::Arguments) -> ! {$/;"	f
run_in_bare_thread	_	/^pub fn run_in_bare_thread(f: proc()) {$/;"	f
run_output	_	pub fn run_output(args: ProcessConfig) -> ~str {$/;"	f
run_pwd	_	pub fn run_pwd(dir: Option<&Path>) -> Process {$/;"	f
run_stampede	_	fn run_stampede() {$/;"	f
run_utf0_validation_iterator	_	/^fn run_utf0_validation_iterator(iter: &mut vec::Items<u0>) -> bool {$/;"	f
running_on_valgrind	_	/^pub fn running_on_valgrind() -> bool {$/;"	f
runplural	_	fn runplural(&mut self, value: uint, pieces: &[rt::Piece]) -> Result {$/;"	f
rust_eh_personality	_	pub extern "C" fn rust_eh_personality($/;"	f
rust_eh_personality_catch	_	pub extern "C" fn rust_eh_personality_catch($/;"	f
rust_env_pairs	_	fn rust_env_pairs() -> **c_char;$/;"	f
rust_exception_class	_	/^fn rust_exception_class() -> uw::_Unwind_Exception_Class {$/;"	f
rust_fail	_	fn rust_fail() -> ! {$/;"	f
rust_get_num_cpus	_	fn rust_get_num_cpus() -> libc::uintptr_t;$/;"	f
rust_opendir	_	fn rust_opendir(dirname: *c_char) -> *DIR;$/;"	f
rust_readdir_r	_	fn rust_readdir_r(dirp: *DIR, entry: *mut dirent_t,$/;"	f
rust_running_on_valgrind	_	fn rust_running_on_valgrind() -> uintptr_t;$/;"	f
rust_set_crate_map	_	/^pub extern fn rust_set_crate_map(map: *CrateMap<'static>) {$/;"	f
rust_stack_exhausted	_	/^pub extern "C" fn rust_stack_exhausted() {$/;"	f
rust_try	_	fn rust_try(f: extern "C" fn(*c_void, *c_void),$/;"	f
rust_win0_rand_gen	_	fn rust_win0_rand_gen(hProv: HCRYPTPROV, dwLen: DWORD,$/;"	f
safe_get	_	fn safe_get(xs: &[u0], i: uint, total: uint) -> u0 {$/;"	f
same	_	fn same(fmt: &'static str, p: ~[Piece<'static>]) {$/;"	f
sample	_	fn sample<R: Rng>(&mut self, rng: &mut R) -> f0 { self.ind_sample(rng) }$/;"	f
sample	_	fn sample<R: Rng>(&mut self, rng: &mut R) -> f0 { self.ind_sample(rng) }$/;"	f
sample	_	fn sample<R: Rng>(&mut self, rng: &mut R) -> Sup { self.ind_sample(rng) }$/;"	f
sample	_	fn sample<R: Rng>(&mut self, rng: &mut R) -> Support;$/;"	f
sample	_	fn sample<R: Rng>(&mut self, rng: &mut R) -> T { self.ind_sample(rng) }$/;"	f
sample	_	fn sample<R: Rng>(&mut self, rng: &mut R) -> f0 { self.ind_sample(rng) }$/;"	f
sample	_	fn sample<R: Rng>(&mut self, rng: &mut R) -> Sup { self.ind_sample(rng) }$/;"	f
sample	_	fn sample<A, T: Iterator<A>>(&mut self, iter: T, n: uint) -> ~[A] {$/;"	f
sample_range	_	fn sample_range<R: Rng>(r: &Range<$ty>, rng: &mut R) -> $ty {$/;"	f
sample_range	_	fn sample_range<R: Rng>(r: &Range<Self>, rng: &mut R) -> Self;$/;"	f
saturating_add	_	fn saturating_add(self, v: Self) -> Self;$/;"	f
saturating_add	_	fn saturating_add(self, v: T) -> T {$/;"	f
saturating_sub	_	fn saturating_sub(self, v: Self) -> Self;$/;"	f
saturating_sub	_	fn saturating_sub(self, v: T) -> T {$/;"	f
scan	_	fn scan<'r, St, B>(self, initial_state: St, f: 'r |&mut St, A| -> Option<B>)$/;"	f
sched_yield	_	fn sched_yield() -> libc::c_int;$/;"	f
secondary	_	fn secondary() -> Option<Path> {$/;"	f
seek	_	fn seek(&mut self, pos: i0, style: SeekStyle) -> IoResult<()> {$/;"	f
seek	_	fn seek(&mut self, pos: i0, style: SeekStyle) -> IoResult<()> {$/;"	f
seek	_	fn seek(&mut self, pos: i0, style: SeekStyle) -> IoResult<()>;$/;"	f
seek	_	fn seek(&mut self, pos: i0, style: SeekStyle) -> IoResult<()> {$/;"	f
seek	_	fn seek(&mut self, pos: i0, whence: SeekStyle) -> Result<u0, IoError>;$/;"	f
seek_before_0	_	fn seek_before_0() {$/;"	f
seek_past_end	_	fn seek_past_end() {$/;"	f
seekdir	_	pub fn seekdir(dirp: *DIR, loc: c_long);$/;"	f
select	_	/^mod select;$/;"	m
select	_	fn select(&mut self) -> ~Method<'a> {$/;"	f
select_cases	_	fn select_cases() {$/;"	f
select_simple	_	fn select_simple() {$/;"	f
self_exe_name	_	/^pub fn self_exe_name() -> Option<Path> {$/;"	f
self_exe_path	_	/^pub fn self_exe_path() -> Option<Path> {$/;"	f
send	_	fn send(chan: Chan<~int>, i: int) {$/;"	f
send	_	pub fn send(&self, t: T) {$/;"	f
send	_	pub fn send(&mut self, t: T) -> bool {$/;"	f
send	_	pub fn send(&mut self, t: T) -> bool {$/;"	f
send	_	pub fn send(&mut self, t: T) -> bool {$/;"	f
send	_	pub fn send(socket: SOCKET, buf: *mut c_void, len: c_int,$/;"	f
send	_	pub fn send(socket: c_int, buf: *mut c_void, len: size_t,$/;"	f
send_from_outside_runtime	_	fn send_from_outside_runtime() {$/;"	f
sendto	_	pub fn sendto(&mut self, buf: &[u0], dst: SocketAddr) -> IoResult<()> {$/;"	f
sendto	_	pub fn sendto(socket: SOCKET, buf: *c_void, len: c_int,$/;"	f
sendto	_	pub fn sendto(socket: c_int, buf: *c_void, len: size_t,$/;"	f
sendto	_	fn sendto(&mut self, buf: &[u0], dst: SocketAddr) -> Result<(), IoError>;$/;"	f
sent	_	pub fn sent(&self) -> bool {$/;"	f
sepidx_or_prefix_len	_	fn sepidx_or_prefix_len(&self) -> Option<(uint,uint,uint)> {$/;"	f
set	_	pub fn set(&self, value: T) {$/;"	f
set	_	/^pub fn set<T: 'static>(key: Key<T>, data: T) {$/;"	f
set	_	/^pub unsafe fn set(key: Key, value: *mut u0) {$/;"	f
set_exit_status	_	/^pub fn set_exit_status(code: int) {$/;"	f
set_extension	_	fn set_extension<T: BytesContainer>(&mut self, extension: T) {$/;"	f
set_filename	_	fn set_filename<T: BytesContainer>(&mut self, filename: T) {$/;"	f
set_filename_unchecked	_	unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T);$/;"	f
set_filename_unchecked	_	unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T) {$/;"	f
set_filename_unchecked	_	unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T) {$/;"	f
set_len	_	unsafe fn set_len(&mut self, new_len: uint) {$/;"	f
set_len	_	unsafe fn set_len(&mut self, new_len: uint);$/;"	f
set_len	_	unsafe fn set_len(&mut self, new_len: uint) {$/;"	f
set_len	_	unsafe fn set_len(&mut self, new_len: uint);$/;"	f
set_len	_	pub unsafe fn set_len(&mut self, len: uint) {$/;"	f
set_logger	_	/^pub fn set_logger(logger: ~Logger) -> Option<~Logger> {$/;"	f
set_memory	_	pub fn set_memory<T>(dst: *mut T, val: u0, count: uint);$/;"	f
set_memory	_	/^pub unsafe fn set_memory<T>(dst: *mut T, c: u0, count: uint) {$/;"	f
set_memory	_	fn set_memory(self, value: u0) {$/;"	f
set_memory	_	fn set_memory(self, value: u0);$/;"	f
set_raw	_	pub fn set_raw(&mut self, raw: bool) -> IoResult<()> {$/;"	f
set_raw	_	fn set_raw(&mut self, raw: bool) -> Result<(), IoError>;$/;"	f
set_stderr	_	/^pub fn set_stderr(stderr: ~Writer) -> Option<~Writer> {$/;"	f
set_stdout	_	/^pub fn set_stdout(stdout: ~Writer) -> Option<~Writer> {$/;"	f
setbuf	_	pub fn setbuf(stream: *FILE, buf: *c_char);$/;"	f
setenv	_	pub fn setenv(name: *c_char, val: *c_char, overwrite: c_int)$/;"	f
setenv	_	/^pub fn setenv(n: &str, v: &str) {$/;"	f
setgid	_	pub fn setgid(gid: gid_t) -> c_int;$/;"	f
setpgid	_	pub fn setpgid(pid: pid_t, pgid: pid_t) -> c_int;$/;"	f
setrlimit	_	fn setrlimit(resource: libc::c_int, rlp: *rlimit) -> libc::c_int;$/;"	f
setsid	_	pub fn setsid() -> pid_t;$/;"	f
setsockopt	_	pub fn setsockopt(socket: SOCKET, level: c_int, name: c_int,$/;"	f
setsockopt	_	pub fn setsockopt(socket: c_int, level: c_int, name: c_int,$/;"	f
setuid	_	pub fn setuid(uid: uid_t) -> c_int;$/;"	f
setvbuf	_	pub fn setvbuf(stream: *FILE,$/;"	f
shared	_	/^mod shared;$/;"	m
shares_volume	_	fn shares_volume(me: &Path, path: &str) -> bool {$/;"	f
shift	_	fn shift(&mut self) -> Option<T> {$/;"	f
shift	_	fn shift(&mut self) -> Option<T>;$/;"	f
shift_byte	_	pub unsafe fn shift_byte(s: &mut ~str) -> u0 {$/;"	f
shift_char	_	fn shift_char(&mut self) -> char {$/;"	f
shift_char	_	fn shift_char(&mut self) -> char;$/;"	f
shift_ptr	_	pub unsafe fn shift_ptr<T>(slice: &mut Slice<T>) -> *T {$/;"	f
shift_ref	_	fn shift_ref(&mut self) -> Option<&'a T> {$/;"	f
shift_ref	_	fn shift_ref(&mut self) -> Option<&'a T>;$/;"	f
shl	_	fn shl(&self, other: &$T) -> $T { *self << *other }$/;"	f
shl	_	fn shl(&self, other: &$T) -> $T { *self << *other }$/;"	f
shl	_	fn shl(&self, rhs: &RHS) -> Result;$/;"	f
shm_open	_	pub fn shm_open(name: *c_char, oflag: c_int, mode: mode_t)$/;"	f
shm_unlink	_	pub fn shm_unlink(name: *c_char) -> c_int;$/;"	f
shouldnt_be_public	_	/^pub mod shouldnt_be_public {$/;"	m
shr	_	fn shr(&self, other: &$T) -> $T { *self >> *other }$/;"	f
shr	_	fn shr(&self, other: &$T) -> $T { *self >> *other }$/;"	f
shr	_	fn shr(&self, rhs: &RHS) -> Result;$/;"	f
shrink_to_fit	_	fn shrink_to_fit(&mut self) {$/;"	f
shrink_to_fit	_	fn shrink_to_fit(&mut self);$/;"	f
shrink_to_fit	_	pub fn shrink_to_fit(&mut self) {$/;"	f
shuffle	_	fn shuffle<T>(&mut self, values: ~[T]) -> ~[T] {$/;"	f
shuffle_mut	_	fn shuffle_mut<T>(&mut self, values: &mut [T]) {$/;"	f
sigint	_	fn sigint() {$/;"	f
signal	_	/^pub mod signal;$/;"	m
signal	_	pub fn signal(&mut self, signal: int) -> IoResult<()> {$/;"	f
signal	_	pub mod signal {$/;"	m
signal	_	fn signal(&mut self, signal: Signum, channel: Chan<Signum>)$/;"	f
signal	_	pub unsafe fn signal(&mut self) { pthread_cond_signal(&mut self.cond); }$/;"	f
signal	_	pub unsafe fn signal(&mut self) {$/;"	f
signal	_	pub unsafe fn signal(&mut self) {$/;"	f
signal_exit	_	pub fn signal_exit(&mut self) -> IoResult<()> {$/;"	f
signal_kill	_	pub fn signal_kill(&mut self) -> IoResult<()> {$/;"	f
signal_noguard	_	pub unsafe fn signal_noguard(&mut self) { self.inner.signal() }$/;"	f
signal_noguard	_	pub unsafe fn signal_noguard(&mut self) { self.inner.signal_noguard() }$/;"	f
signum	_	fn signum(&self) -> f0 {$/;"	f
signum	_	fn signum(&self) -> f0 {$/;"	f
signum	_	fn signum(&self) -> $T {$/;"	f
signum	_	fn signum(&self) -> Self;$/;"	f
simd	_	/^pub mod simd;$/;"	m
simple	_	fn simple() {$/;"	f
sin	_	fn sin(&self) -> f0 { sin(*self) }$/;"	f
sin	_	fn sin(n: f0) -> f0 = intrinsics::sinf0,$/;"	f
sin	_	fn sin(&self) -> f0 { sin(*self) }$/;"	f
sin	_	fn sin(n: f0) -> f0 = intrinsics::sinf0,$/;"	f
sin	_	fn sin(&self) -> Self;$/;"	f
sin_cos	_	fn sin_cos(&self) -> (f0, f0) {$/;"	f
sin_cos	_	fn sin_cos(&self) -> (f0, f0) {$/;"	f
sin_cos	_	fn sin_cos(&self) -> (Self, Self);$/;"	f
sinf0	_	pub fn sinf0(x: f0) -> f0;$/;"	f
sinf0	_	pub fn sinf0(x: f0) -> f0;$/;"	f
sinh	_	pub fn sinh(n: c_double) -> c_double;$/;"	f
sinh	_	pub fn sinh(n: c_float) -> c_float;$/;"	f
sinh	_	fn sinh(&self) -> f0 { sinh(*self) }$/;"	f
sinh	_	fn sinh(n: c_float) -> c_float = cmath::c_float::sinh,$/;"	f
sinh	_	fn sinh(&self) -> f0 { sinh(*self) }$/;"	f
sinh	_	fn sinh(n: c_double) -> c_double = cmath::c_double::sinh,$/;"	f
sinh	_	fn sinh(&self) -> Self;$/;"	f
sip	_	/^pub mod sip;$/;"	m
size	_	fn size() -> uint {$/;"	f
size	_	fn size(&self) -> int { 0 << self.log_size }$/;"	f
size_hint	_	fn size_hint(&self) -> (uint, Option<uint>) { (0, None) }$/;"	f
size_hint	_	fn size_hint(&self) -> (uint, Option<uint>) { (uint::MAX, None) }$/;"	f
size_hint	_	fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }$/;"	f
size_hint	_	fn size_hint(&self) -> (uint, Option<uint>) {$/;"	f
size_hint	_	fn size_hint(&self) -> (uint, Option<uint>) {$/;"	f
size_hint	_	fn size_hint(&self) -> (uint, Option<uint>) {$/;"	f
size_hint	_	fn size_hint(&self) -> (uint, Option<uint>) {$/;"	f
size_hint	_	fn size_hint(&self) -> (uint, Option<uint>) {$/;"	f
size_hint	_	fn size_hint(&self) -> (uint, Option<uint>) {$/;"	f
size_of	_	pub fn size_of<T>() -> uint;$/;"	f
size_of	_	/^pub fn size_of<T>() -> uint {$/;"	f
size_of_0	_	fn size_of_0() {$/;"	f
size_of_0	_	fn size_of_0() {$/;"	f
size_of_basic	_	fn size_of_basic() {$/;"	f
size_of_val	_	/^pub fn size_of_val<T>(_val: &T) -> uint {$/;"	f
size_of_val_basic	_	fn size_of_val_basic() {$/;"	f
skip	_	fn skip(self, n: uint) -> Skip<Self> {$/;"	f
skip_while	_	fn skip_while<'r>(self, predicate: 'r |&A| -> bool) -> SkipWhile<'r, A, Self> {$/;"	f
sleep	_	pub fn sleep(&mut self, msecs: u0) {$/;"	f
sleep	_	/^pub fn sleep(msecs: u0) {$/;"	f
sleep	_	pub fn sleep(secs: c_uint) -> c_uint;$/;"	f
sleep	_	fn sleep(&mut self, msecs: u0);$/;"	f
sleeper	_	pub fn sleeper() -> Process {$/;"	f
slice	_	fn slice(&self, begin: uint, end: uint) -> &'a str {$/;"	f
slice	_	fn slice(&self, begin: uint, end: uint) -> &'a str;$/;"	f
slice	_	fn slice(&self, start: uint, end: uint) -> &'a [T] {$/;"	f
slice	_	fn slice(&self, start: uint, end: uint) -> &'a [T];$/;"	f
slice	_	pub fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [T] {$/;"	f
slice_bytes	_	pub unsafe fn slice_bytes<'a>(s: &'a str, begin: uint, end: uint) -> &'a str {$/;"	f
slice_chars	_	fn slice_chars(&self, begin: uint, end: uint) -> &'a str {$/;"	f
slice_chars	_	fn slice_chars(&self, begin: uint, end: uint) -> &'a str;$/;"	f
slice_from	_	fn slice_from(&self, begin: uint) -> &'a str {$/;"	f
slice_from	_	fn slice_from(&self, begin: uint) -> &'a str;$/;"	f
slice_from	_	fn slice_from(&self, start: uint) -> &'a [T] {$/;"	f
slice_from	_	fn slice_from(&self, start: uint) -> &'a [T];$/;"	f
slice_from	_	pub fn slice_from<'a>(&'a self, start: uint) -> &'a [T] {$/;"	f
slice_shift_char	_	fn slice_shift_char(&self) -> (char, &'a str) {$/;"	f
slice_shift_char	_	fn slice_shift_char(&self) -> (char, &'a str);$/;"	f
slice_to	_	fn slice_to(&self, end: uint) -> &'a str {$/;"	f
slice_to	_	fn slice_to(&self, end: uint) -> &'a str;$/;"	f
slice_to	_	fn slice_to(&self, end: uint) -> &'a [T] {$/;"	f
slice_to	_	fn slice_to(&self, end: uint) -> &'a [T];$/;"	f
slice_unchecked	_	pub unsafe fn slice_unchecked<'a>(s: &'a str, begin: uint, end: uint) -> &'a str {$/;"	f
small_stacks	_	fn small_stacks() {$/;"	f
smalltest	_	pub fn smalltest(server: proc(UnixStream), client: proc(UnixStream)) {$/;"	f
smoke	_	fn smoke() { Thread::start(proc (){}).join(); }$/;"	f
smoke	_	fn smoke() {$/;"	f
smoke	_	fn smoke() {$/;"	f
smoke_bound	_	fn smoke_bound() {$/;"	f
smoke_cond	_	fn smoke_cond() {$/;"	f
smoke_cond_noguard	_	fn smoke_cond_noguard() {$/;"	f
smoke_lock	_	fn smoke_lock() {$/;"	f
smoke_lock_noguard	_	fn smoke_lock_noguard() {$/;"	f
smoke_test	_	fn smoke_test() {$/;"	f
smoketest_cell	_	fn smoketest_cell() {$/;"	f
sockaddr	_	pub struct sockaddr {$/;"	s
sockaddr_in	_	pub struct sockaddr_in {$/;"	s
sockaddr_in0	_	pub struct sockaddr_in0 {$/;"	s
sockaddr_storage	_	pub struct sockaddr_storage {$/;"	s
sockaddr_un	_	pub struct sockaddr_un {$/;"	s
socket	_	pub fn socket(domain: c_int, ty: c_int, protocol: c_int) -> SOCKET;$/;"	f
socket	_	pub fn socket(domain: c_int, ty: c_int, protocol: c_int) -> c_int;$/;"	f
socket_name	_	pub fn socket_name(&mut self) -> IoResult<SocketAddr> {$/;"	f
socket_name	_	pub fn socket_name(addr: SocketAddr) {$/;"	f
socket_name	_	pub fn socket_name(&mut self) -> IoResult<SocketAddr> {$/;"	f
socket_name	_	pub fn socket_name(addr: SocketAddr) {$/;"	f
socket_name	_	fn socket_name(&mut self) -> Result<SocketAddr, IoError>;$/;"	f
sort	_	fn sort(self) {$/;"	f
sort	_	fn sort(self);$/;"	f
sort_big_random_large	_	fn sort_big_random_large(bh: &mut BenchHarness) {$/;"	f
sort_big_random_medium	_	fn sort_big_random_medium(bh: &mut BenchHarness) {$/;"	f
sort_big_random_small	_	fn sort_big_random_small(bh: &mut BenchHarness) {$/;"	f
sort_big_sorted	_	fn sort_big_sorted(bh: &mut BenchHarness) {$/;"	f
sort_by	_	fn sort_by(self, compare: |&T, &T| -> Ordering) {$/;"	f
sort_by	_	fn sort_by(self, compare: |&T, &T| -> Ordering);$/;"	f
sort_by	_	pub fn sort_by(&mut self, compare: |&T, &T| -> Ordering) {$/;"	f
sort_random_large	_	fn sort_random_large(bh: &mut BenchHarness) {$/;"	f
sort_random_medium	_	fn sort_random_medium(bh: &mut BenchHarness) {$/;"	f
sort_random_small	_	fn sort_random_small(bh: &mut BenchHarness) {$/;"	f
sort_sorted	_	fn sort_sorted(bh: &mut BenchHarness) {$/;"	f
spawn	_	fn spawn(&mut self, config: ProcessConfig)$/;"	f
spawn	_	pub fn spawn(main: proc()) {$/;"	f
spawn	_	pub fn spawn(mut self, f: proc()) {$/;"	f
spawn	_	/^pub fn spawn(f: proc()) {$/;"	f
spawn_sibling	_	fn spawn_sibling(~self, cur_task: ~Task, opts: TaskOpts, f: proc());$/;"	f
spawn_sibling	_	pub fn spawn_sibling(mut ~self, opts: TaskOpts, f: proc()) {$/;"	f
spawn_stack	_	pub fn spawn_stack(stack: uint, main: proc()) {$/;"	f
split	_	fn split<Sep: CharEq>(&self, sep: Sep) -> CharSplits<'a, Sep> {$/;"	f
split	_	fn split<Sep: CharEq>(&self, sep: Sep) -> CharSplits<'a, Sep>;$/;"	f
split	_	fn split(self, pred: 'a |&T| -> bool) -> Splits<'a, T> {$/;"	f
split	_	fn split(self, pred: 'a |&T| -> bool) -> Splits<'a, T>;$/;"	f
split_ascii	_	fn split_ascii(bh: &mut BenchHarness) {$/;"	f
split_closure	_	fn split_closure(bh: &mut BenchHarness) {$/;"	f
split_extern_fn	_	fn split_extern_fn(bh: &mut BenchHarness) {$/;"	f
split_not_ascii	_	fn split_not_ascii(bh: &mut BenchHarness) {$/;"	f
split_slice	_	fn split_slice(bh: &mut BenchHarness) {$/;"	f
split_str	_	fn split_str(&self, &'a str) -> StrSplits<'a>;$/;"	f
split_str	_	fn split_str(&self, sep: &'a str) -> StrSplits<'a> {$/;"	f
split_terminator	_	fn split_terminator<Sep: CharEq>(&self, sep: Sep) -> CharSplits<'a, Sep>;$/;"	f
split_terminator	_	fn split_terminator<Sep: CharEq>(&self, sep: Sep)$/;"	f
split_unicode_ascii	_	fn split_unicode_ascii(bh: &mut BenchHarness) {$/;"	f
split_unicode_not_ascii	_	fn split_unicode_not_ascii(bh: &mut BenchHarness) {$/;"	f
splitn	_	fn splitn<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitsN<'a, Sep>;$/;"	f
splitn	_	fn splitn<Sep: CharEq>(&self, sep: Sep, count: uint)$/;"	f
splitn	_	fn splitn(self, n: uint, pred: 'a |&T| -> bool) -> Splits<'a, T> {$/;"	f
splitn	_	fn splitn(self, n: uint, pred: 'a |&T| -> bool) -> Splits<'a, T>;$/;"	f
spsc_queue	_	/^pub mod spsc_queue;$/;"	m
sqrt	_	fn sqrt(&self) -> f0 { sqrt(*self) }$/;"	f
sqrt	_	fn sqrt(n: f0) -> f0 = intrinsics::sqrtf0,$/;"	f
sqrt	_	fn sqrt(&self) -> f0 { sqrt(*self) }$/;"	f
sqrt	_	fn sqrt(n: f0) -> f0 = intrinsics::sqrtf0,$/;"	f
sqrt	_	fn sqrt(&self) -> Self;$/;"	f
sqrt0	_	fn sqrt0() -> f0 { 0.0 }$/;"	f
sqrt0	_	fn sqrt0() -> f0 { 0.0 }$/;"	f
sqrt0	_	fn sqrt0() -> Self;$/;"	f
sqrtf0	_	pub fn sqrtf0(x: f0) -> f0;$/;"	f
sqrtf0	_	pub fn sqrtf0(x: f0) -> f0;$/;"	f
square	_	fn square(n: uint) -> uint { n * n }$/;"	f
square_ref	_	fn square_ref(n: &uint) -> uint { square(*n) }$/;"	f
srand	_	pub fn srand(seed: c_uint);$/;"	f
src	_	/^fn src<T>(fd: libc::c_int, readable: bool, f: |StdSource| -> T) -> T {$/;"	f
stack	_	/^pub mod stack;$/;"	m
stack_bounds	_	fn stack_bounds(&self) -> (uint, uint); \/\/ (lo, hi)$/;"	f
stack_bounds	_	pub fn stack_bounds(&self) -> (uint, uint) {$/;"	f
stampede	_	fn stampede(mut w: Worker<~int>, s: Stealer<~int>,$/;"	f
standard_error	_	/^pub fn standard_error(kind: IoErrorKind) -> IoError {$/;"	f
start	_	pub fn start<T: Send>(main: proc() -> T) -> Thread<T> {$/;"	f
start_selection	_	fn start_selection(&self, mut task: BlockedTask) -> Result<(), BlockedTask>{$/;"	f
start_selection	_	pub fn start_selection(&mut self, task: BlockedTask) -> SelectionResult<T> {$/;"	f
start_selection	_	fn start_selection(&self, task: BlockedTask) -> Result<(), BlockedTask>;$/;"	f
start_selection	_	pub fn start_selection(&mut self,$/;"	f
start_selection	_	pub fn start_selection(&mut self, task: BlockedTask) -> SelectionResult<T> {$/;"	f
start_stack	_	pub fn start_stack<T: Send>(stack: uint, main: proc() -> T) -> Thread<T> {$/;"	f
starts_with	_	fn starts_with(&self, needle: &str) -> bool;$/;"	f
starts_with	_	fn starts_with<'a>(&self, needle: &'a str) -> bool {$/;"	f
starts_with	_	fn starts_with(&self, needle: &[T]) -> bool {$/;"	f
starts_with	_	fn starts_with(&self, needle: &[T]) -> bool;$/;"	f
starts_with_diff_one_element_at_end	_	fn starts_with_diff_one_element_at_end(bh: &mut BenchHarness) {$/;"	f
starts_with_same_vector	_	fn starts_with_same_vector(bh: &mut BenchHarness) {$/;"	f
starts_with_single_element	_	fn starts_with_single_element(bh: &mut BenchHarness) {$/;"	f
stat	_	pub fn stat(&self) -> IoResult<FileStat> { stat(self) }$/;"	f
stat	_	/^pub fn stat(path: &Path) -> IoResult<FileStat> {$/;"	f
stat	_	pub fn stat(path: *c_char, buf: *mut stat) -> c_int;$/;"	f
stat	_	pub struct stat {$/;"	s
stat_	_	pub mod stat_ {$/;"	m
static_char_ptr	_	fn static_char_ptr(p: *u0) -> &'static str {$/;"	f
static_init	_	fn static_init() {$/;"	f
status	_	pub fn status(prog: &str, args: &[~str]) -> IoResult<ProcessExit> {$/;"	f
std	_	/^mod std {$/;"	m
stderr	_	/^pub fn stderr() -> LineBufferedWriter<StdWriter> {$/;"	f
stderr_raw	_	/^pub fn stderr_raw() -> StdWriter {$/;"	f
stdin	_	/^pub fn stdin() -> BufferedReader<StdReader> {$/;"	f
stdin_raw	_	/^pub fn stdin_raw() -> StdReader {$/;"	f
stdio	_	/^pub mod stdio;$/;"	m
stdio	_	pub mod stdio {$/;"	m
stdlib	_	pub mod stdlib {$/;"	m
stdout	_	/^pub fn stdout() -> LineBufferedWriter<StdWriter> {$/;"	f
stdout_raw	_	/^pub fn stdout_raw() -> StdWriter {$/;"	f
steal	_	pub fn steal(&mut self) -> Stolen<T> {$/;"	f
steal	_	unsafe fn steal(&mut self) -> Stolen<T> {$/;"	f
stealpush	_	fn stealpush() {$/;"	f
stealpush_large	_	fn stealpush_large() {$/;"	f
step	_	unsafe fn step<T>(ptr: &mut *mut T) -> *mut T {$/;"	f
store	_	pub fn store(&mut self, ptr: *mut T, order: Ordering) {$/;"	f
store	_	pub fn store(&mut self, val: bool, order: Ordering) {$/;"	f
store	_	pub fn store(&mut self, val: int, order: Ordering) {$/;"	f
store	_	pub fn store(&mut self, val: u0, order: Ordering) {$/;"	f
store	_	pub fn store(&mut self, val: uint, order: Ordering) {$/;"	f
str	_	/^pub mod str;$/;"	m
str_components	_	pub fn str_components<'a>(&'a self) -> StrComponents<'a> {$/;"	f
str_components	_	pub fn str_components<'a>(&'a self) -> StrComponents<'a> {$/;"	f
str_copy_map_bytes	_	/^unsafe fn str_copy_map_bytes(string: &str, map: &'static [u0]) -> ~str {$/;"	f
str_map_bytes	_	/^unsafe fn str_map_bytes(string: ~str, map: &'static [u0]) -> ~str {$/;"	f
strcat	_	pub fn strcat(s: *c_char, ct: *c_char) -> *c_char;$/;"	f
strchr	_	pub fn strchr(cs: *c_char, c: c_int) -> *c_char;$/;"	f
strcmp	_	pub fn strcmp(cs: *c_char, ct: *c_char) -> c_int;$/;"	f
strcoll	_	pub fn strcoll(cs: *c_char, ct: *c_char) -> c_int;$/;"	f
strconv	_	/^pub mod strconv;$/;"	m
strcpy	_	pub fn strcpy(dst: *c_char, src: *c_char) -> *c_char;$/;"	f
strcspn	_	pub fn strcspn(cs: *c_char, ct: *c_char) -> size_t;$/;"	f
strdup_uniq	_	pub unsafe fn strdup_uniq(ptr: *u0, len: uint) -> ~str {$/;"	f
stream	_	/^mod stream;$/;"	m
strerror	_	pub fn strerror(n: c_int) -> *c_char;$/;"	f
strerror	_	fn strerror() -> ~str {$/;"	f
strerror_r	_	fn strerror_r(errnum: c_int, buf: *mut c_char,$/;"	f
strerror_r	_	fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: libc::size_t)$/;"	f
strerror_r	_	fn strerror_r(errnum: c_int, buf: *mut c_char,$/;"	f
stress	_	fn stress() {$/;"	f
stress	_	fn stress() {$/;"	f
stress_bound	_	fn stress_bound(bound: uint) {$/;"	f
stress_factor	_	pub fn stress_factor() -> uint {$/;"	f
string	_	fn string(c: char) -> ~str {$/;"	f
string	_	fn string(&mut self, start: uint) -> &'a str {$/;"	f
string	_	pub mod string {$/;"	m
strlen	_	pub fn strlen(cs: *c_char) -> size_t;$/;"	f
strncat	_	pub fn strncat(s: *c_char, ct: *c_char, n: size_t) -> *c_char;$/;"	f
strncmp	_	pub fn strncmp(cs: *c_char, ct: *c_char, n: size_t) -> c_int;$/;"	f
strncpy	_	pub fn strncpy(dst: *c_char, src: *c_char, n: size_t)$/;"	f
strpbrk	_	pub fn strpbrk(cs: *c_char, ct: *c_char) -> *c_char;$/;"	f
strrchr	_	pub fn strrchr(cs: *c_char, c: c_int) -> *c_char;$/;"	f
strspn	_	pub fn strspn(cs: *c_char, ct: *c_char) -> size_t;$/;"	f
strstr	_	pub fn strstr(cs: *c_char, ct: *c_char) -> *c_char;$/;"	f
strtod	_	pub fn strtod(s: *c_char, endp: **c_char) -> c_double;$/;"	f
strtok	_	pub fn strtok(s: *c_char, t: *c_char) -> *c_char;$/;"	f
strtol	_	pub fn strtol(s: *c_char, endp: **c_char, base: c_int)$/;"	f
strtoul	_	pub fn strtoul(s: *c_char, endp: **c_char, base: c_int)$/;"	f
strxfrm	_	pub fn strxfrm(s: *c_char, ct: *c_char, n: size_t) -> size_t;$/;"	f
sub	_	fn sub(&self, other: &f0) -> f0 { *self - *other }$/;"	f
sub	_	fn sub(&self, other: &f0) -> f0 { *self - *other }$/;"	f
sub	_	fn sub(&self, other: &$T) -> $T { *self - *other }$/;"	f
sub	_	fn sub(&self, other: &$T) -> $T { *self - *other }$/;"	f
sub	_	fn sub(&self, rhs: &RHS) -> Result;$/;"	f
subslice_offset	_	fn subslice_offset(&self, inner: &str) -> uint {$/;"	f
subslice_offset	_	fn subslice_offset(&self, inner: &str) -> uint;$/;"	f
success	_	pub fn success(&self) -> bool {$/;"	f
sum	_	fn sum(&mut self) -> A {$/;"	f
sum	_	fn sum(&mut self) -> A;$/;"	f
sum_len	_	fn sum_len<S: Container>(v: &[S]) -> uint {$/;"	f
swap	_	fn swap(&mut self, k: K, v: V) -> Option<V>;$/;"	f
swap	_	/^pub fn swap<T>(x: &mut T, y: &mut T) {$/;"	f
swap	_	/^pub unsafe fn swap<T>(x: *mut T, y: *mut T) {$/;"	f
swap	_	pub fn swap(&mut self, ptr: *mut T, order: Ordering) -> *mut T {$/;"	f
swap	_	pub fn swap(&mut self, val: bool, order: Ordering) -> bool {$/;"	f
swap	_	pub fn swap(&mut self, val: int, order: Ordering) -> int {$/;"	f
swap	_	pub fn swap(&mut self, val: u0, order: Ordering) -> u0 {$/;"	f
swap	_	pub fn swap(&mut self, val: uint, order: Ordering) -> uint {$/;"	f
swap	_	pub fn swap(&mut self, val: ~T, order: Ordering) -> Option<~T> {$/;"	f
swap	_	fn swap(self, a: uint, b: uint) {$/;"	f
swap	_	fn swap(self, a: uint, b: uint);$/;"	f
swap_buffer	_	unsafe fn swap_buffer(&mut self, b: int, old: *mut Buffer<T>,$/;"	f
swap_remove	_	fn swap_remove(&mut self, index: uint) -> Option<T> {$/;"	f
swap_remove	_	fn swap_remove(&mut self, index: uint) -> Option<T>;$/;"	f
swap_remove	_	pub fn swap_remove(&mut self, index: uint) -> Option<T> {$/;"	f
symbol	_	pub unsafe fn symbol(handle: *u0, symbol: *libc::c_char) -> *u0 {$/;"	f
symbol	_	pub unsafe fn symbol<T>(&self, symbol: &str) -> Result<T, ~str> {$/;"	f
symlink	_	/^pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> {$/;"	f
symlink	_	pub fn symlink(path0: *c_char, path0: *c_char) -> c_int;$/;"	f
sync	_	/^pub mod sync;$/;"	m
sync	_	/^pub mod sync;$/;"	m
synthesize_closure	_	fn synthesize_closure() {$/;"	f
sysconf	_	pub fn sysconf(name: c_int) -> c_long;$/;"	f
sysconf	_	pub mod sysconf {$/;"	m
sysctl	_	fn sysctl(name: *mut libc::c_int, namelen: libc::c_uint,$/;"	f
sysctl	_	pub fn sysctl(name: *c_int,$/;"	f
sysctlbyname	_	pub fn sysctlbyname(name: *c_char,$/;"	f
sysctlnametomib	_	pub fn sysctlnametomib(name: *c_char,$/;"	f
system	_	pub fn system(s: *c_char) -> c_int;$/;"	f
t	_	fn t(o0: Ordering, o0: Ordering, e: Ordering) {$/;"	f
t	_	fn t(a: &str, b: &str, start: uint) {$/;"	f
t	_	fn t(v: &[&str], s: &str) {$/;"	f
t	_	fn t(v: &[&str], sep: &str, s: &str) {$/;"	f
t	_	fn t(v: &[~str], s: &str) {$/;"	f
t	_	fn t(v: &[~str], sep: &str, s: &str) {$/;"	f
t	_	fn t<'a>(s: &str, sep: &'a str, u: ~[&str]) {$/;"	f
t	_	fn t<S: Default + Str>() {$/;"	f
tail	_	fn tail(&self) -> &'a [T] { self.slice(0, self.len()) }$/;"	f
tail	_	fn tail(&self) -> &'a [T];$/;"	f
tail	_	pub fn tail<'a>(&'a self) -> &'a [T] {$/;"	f
tailn	_	fn tailn(&self, n: uint) -> &'a [T] { self.slice(n, self.len()) }$/;"	f
tailn	_	fn tailn(&self, n: uint) -> &'a [T];$/;"	f
take	_	fn take(self, n: uint) -> Take<Self> {$/;"	f
take	_	pub fn take(&mut self) -> Option<T> {$/;"	f
take	_	pub fn take() -> Option<~[~[u0]]> {$/;"	f
take	_	fn take() -> ~Self;$/;"	f
take	_	fn take() -> ~Task { unsafe { local_ptr::take() } }$/;"	f
take	_	pub unsafe fn take<T>() -> ~T {$/;"	f
take	_	pub fn take(&mut self, order: Ordering) -> Option<~T> {$/;"	f
take_to_wake	_	fn take_to_wake(&mut self) -> BlockedTask {$/;"	f
take_to_wake	_	fn take_to_wake(&mut self) -> BlockedTask {$/;"	f
take_unwrap	_	pub fn take_unwrap(&mut self) -> T {$/;"	f
take_while	_	fn take_while<'r>(self, predicate: 'r |&A| -> bool) -> TakeWhile<'r, A, Self> {$/;"	f
tan	_	pub fn tan(n: c_double) -> c_double;$/;"	f
tan	_	pub fn tan(n: c_float) -> c_float;$/;"	f
tan	_	fn tan(&self) -> f0 { tan(*self) }$/;"	f
tan	_	fn tan(n: c_float) -> c_float = cmath::c_float::tan,$/;"	f
tan	_	fn tan(&self) -> f0 { tan(*self) }$/;"	f
tan	_	fn tan(n: c_double) -> c_double = cmath::c_double::tan,$/;"	f
tan	_	fn tan(&self) -> Self;$/;"	f
tanh	_	pub fn tanh(n: c_double) -> c_double;$/;"	f
tanh	_	pub fn tanh(n: c_float) -> c_float;$/;"	f
tanh	_	fn tanh(&self) -> f0 { tanh(*self) }$/;"	f
tanh	_	fn tanh(n: c_float) -> c_float = cmath::c_float::tanh$/;"	f
tanh	_	fn tanh(&self) -> f0 { tanh(*self) }$/;"	f
tanh	_	fn tanh(n: c_double) -> c_double = cmath::c_double::tanh$/;"	f
tanh	_	fn tanh(&self) -> Self;$/;"	f
target_get_sp_limit	_	unsafe fn target_get_sp_limit() -> uint {$/;"	f
target_record_sp_limit	_	unsafe fn target_record_sp_limit(limit: uint) {$/;"	f
target_record_stack_bounds	_	unsafe fn target_record_stack_bounds(_stack_lo: uint, _stack_hi: uint) {}$/;"	f
target_record_stack_bounds	_	unsafe fn target_record_stack_bounds(stack_lo: uint, stack_hi: uint) {$/;"	f
task	_	/^pub mod task;$/;"	m
task	_	/^pub mod task;$/;"	m
task	_	/^pub fn task() -> TaskBuilder {$/;"	f
task_rng	_	/^pub fn task_rng() -> TaskRng {$/;"	f
tcgetpgrp	_	pub fn tcgetpgrp(fd: c_int) -> pid_t;$/;"	f
tcp	_	/^pub mod tcp;$/;"	m
tcp_bind	_	fn tcp_bind(&mut self, addr: SocketAddr) -> Result<~RtioTcpListener, IoError>;$/;"	f
tcp_connect	_	fn tcp_connect(&mut self, addr: SocketAddr) -> Result<~RtioTcpStream, IoError>;$/;"	f
tell	_	fn tell(&self) -> IoResult<u0> {$/;"	f
tell	_	fn tell(&self) -> IoResult<u0> { Ok(self.pos as u0) }$/;"	f
tell	_	fn tell(&self) -> IoResult<u0>;$/;"	f
tell	_	fn tell(&self) -> IoResult<u0> {$/;"	f
tell	_	fn tell(&self) -> Result<u0, IoError>;$/;"	f
telldir	_	pub fn telldir(dirp: *DIR) -> c_long;$/;"	f
test	_	/^mod test {$/;"	m
test	_	/^mod test {$/;"	m
test	_	/^mod test {$/;"	m
test	_	/^mod test {$/;"	m
test	_	/^mod test {$/;"	m
test	_	/^mod test {$/;"	m
test	_	/^mod test {$/;"	m
test	_	/^mod test {$/;"	m
test	_	/^mod test {$/;"	m
test	_	/^pub mod test;$/;"	m
test	_	/^mod test {$/;"	m
test	_	/^mod test {$/;"	m
test	_	/^mod test {$/;"	m
test	_	/^mod test {$/;"	m
test	_	/^mod test {$/;"	m
test	_	/^mod test {$/;"	m
test	_	/^mod test {$/;"	m
test	_	/^mod test {$/;"	m
test	_	/^fn test() {$/;"	f
test	_	/^mod test {$/;"	m
test	_	fn test() {$/;"	f
test	_	fn test() {$/;"	f
test	_	/^mod test {$/;"	m
test	_	/^mod test {$/;"	m
test	_	/^mod test {$/;"	m
test	_	/^mod test {$/;"	m
test	_	/^mod test {$/;"	m
test	_	/^mod test {$/;"	m
test	_	/^mod test {$/;"	m
test	_	/^mod test {$/;"	m
test	_	/^mod test {$/;"	m
test	_	/^mod test {$/;"	m
test	_	fn test() {$/;"	f
test	_	fn test() {$/;"	f
test	_	/^mod test {$/;"	m
test	_	/^mod test {$/;"	m
test	_	/^mod test {$/;"	m
test_MinMaxResult	_	fn test_MinMaxResult() {$/;"	f
test_abs	_	pub fn test_abs() {$/;"	f
test_abs	_	pub fn test_abs() {$/;"	f
test_abs	_	pub fn test_abs() {$/;"	f
test_abs_sub	_	fn test_abs_sub() {$/;"	f
test_abs_sub	_	fn test_abs_sub() {$/;"	f
test_abs_sub	_	fn test_abs_sub() {$/;"	f
test_abs_sub_nowin	_	fn test_abs_sub_nowin() {$/;"	f
test_abs_sub_nowin	_	fn test_abs_sub_nowin() {$/;"	f
test_acosh	_	fn test_acosh() {$/;"	f
test_acosh	_	fn test_acosh() {$/;"	f
test_add	_	fn test_add() {$/;"	f
test_all	_	fn test_all() {$/;"	f
test_and	_	fn test_and() {$/;"	f
test_and	_	pub fn test_and() {$/;"	f
test_and_set	_	pub fn test_and_set(&mut self, order: Ordering) -> bool {$/;"	f
test_and_then	_	fn test_and_then() {$/;"	f
test_and_then	_	pub fn test_and_then() {$/;"	f
test_any	_	fn test_any() {$/;"	f
test_append	_	fn test_append() {$/;"	f
test_args	_	pub fn test_args() {$/;"	f
test_as_bytes	_	fn test_as_bytes() {$/;"	f
test_as_bytes	_	fn test_as_bytes() {$/;"	f
test_as_bytes_fail	_	fn test_as_bytes_fail() {$/;"	f
test_as_bytes_fail	_	fn test_as_bytes_fail() {$/;"	f
test_as_bytes_no_nul	_	fn test_as_bytes_no_nul() {$/;"	f
test_as_bytes_no_nul_fail	_	fn test_as_bytes_no_nul_fail() {$/;"	f
test_as_ptr	_	fn test_as_ptr() {$/;"	f
test_as_str	_	fn test_as_str() {$/;"	f
test_as_str_fail	_	fn test_as_str_fail() {$/;"	f
test_ascii	_	fn test_ascii() {$/;"	f
test_ascii_as_str	_	fn test_ascii_as_str() {$/;"	f
test_ascii_fail_char_slice	_	fn test_ascii_fail_char_slice() { 'λ'.to_ascii(); }$/;"	f
test_ascii_fail_u0_slice	_	fn test_ascii_fail_u0_slice() { 0u0.to_ascii(); }$/;"	f
test_ascii_into_str	_	fn test_ascii_into_str() {$/;"	f
test_ascii_to_bytes	_	fn test_ascii_to_bytes() {$/;"	f
test_ascii_vec	_	fn test_ascii_vec() {$/;"	f
test_ascii_vec_fail_str_slice	_	fn test_ascii_vec_fail_str_slice() { "zoä华".to_ascii(); }$/;"	f
test_ascii_vec_fail_u0_slice	_	fn test_ascii_vec_fail_u0_slice()  { (&[0u0, 0u0, 0u0]).to_ascii(); }$/;"	f
test_asinh	_	fn test_asinh() {$/;"	f
test_asinh	_	fn test_asinh() {$/;"	f
test_atanh	_	fn test_atanh() {$/;"	f
test_atanh	_	fn test_atanh() {$/;"	f
test_avoid_copying_the_body_spawn	_	/^fn test_avoid_copying_the_body_spawn() {$/;"	f
test_avoid_copying_the_body_task_spawn	_	/^fn test_avoid_copying_the_body_task_spawn() {$/;"	f
test_avoid_copying_the_body_try	_	/^fn test_avoid_copying_the_body_try() {$/;"	f
test_back_to_the_future_result	_	/^fn test_back_to_the_future_result() {$/;"	f
test_begin_unwind	_	fn test_begin_unwind() {$/;"	f
test_bitand	_	fn test_bitand() {$/;"	f
test_bitor	_	fn test_bitor() {$/;"	f
test_bitwise	_	fn test_bitwise() {$/;"	f
test_bitwise	_	fn test_bitwise() {$/;"	f
test_bitxor	_	fn test_bitxor() {$/;"	f
test_borrowed_clone	_	/^fn test_borrowed_clone() {$/;"	f
test_bsearch_elem	_	fn test_bsearch_elem() {$/;"	f
test_buf_len	_	fn test_buf_len() {$/;"	f
test_buf_reader	_	fn test_buf_reader() {$/;"	f
test_buf_writer	_	fn test_buf_writer() {$/;"	f
test_buf_writer_error	_	fn test_buf_writer_error() {$/;"	f
test_buf_writer_seek	_	fn test_buf_writer_seek() {$/;"	f
test_buffered_reader	_	fn test_buffered_reader() {$/;"	f
test_buffered_stream	_	fn test_buffered_stream() {$/;"	f
test_buffered_writer	_	fn test_buffered_writer() {$/;"	f
test_buffered_writer_inner_flushes	_	fn test_buffered_writer_inner_flushes() {$/;"	f
test_build_fail	_	fn test_build_fail() {$/;"	f
test_bump_managed_refcount	_	fn test_bump_managed_refcount() {$/;"	f
test_by_ref	_	fn test_by_ref() {$/;"	f
test_bytes_revator	_	fn test_bytes_revator() {$/;"	f
test_bytes_set_memory	_	fn test_bytes_set_memory() {$/;"	f
test_bytesator	_	fn test_bytesator() {$/;"	f
test_capacity	_	fn test_capacity() {$/;"	f
test_cast_range_i0_max	_	fn test_cast_range_i0_max() {$/;"	f
test_cast_range_i0_min	_	fn test_cast_range_i0_min() {$/;"	f
test_cast_range_i0_max	_	fn test_cast_range_i0_max() {$/;"	f
test_cast_range_i0_min	_	fn test_cast_range_i0_min() {$/;"	f
test_cast_range_i0_max	_	fn test_cast_range_i0_max() {$/;"	f
test_cast_range_i0_min	_	fn test_cast_range_i0_min() {$/;"	f
test_cast_range_i0_max	_	fn test_cast_range_i0_max() {$/;"	f
test_cast_range_i0_min	_	fn test_cast_range_i0_min() {$/;"	f
test_cast_range_int_max	_	fn test_cast_range_int_max() {$/;"	f
test_cast_range_int_min	_	fn test_cast_range_int_min() {$/;"	f
test_cast_range_u0_max	_	fn test_cast_range_u0_max() {$/;"	f
test_cast_range_u0_min	_	fn test_cast_range_u0_min() {$/;"	f
test_cast_range_u0_max	_	fn test_cast_range_u0_max() {$/;"	f
test_cast_range_u0_min	_	fn test_cast_range_u0_min() {$/;"	f
test_cast_range_u0_max	_	fn test_cast_range_u0_max() {$/;"	f
test_cast_range_u0_min	_	fn test_cast_range_u0_min() {$/;"	f
test_cast_range_u0_max	_	fn test_cast_range_u0_max() {$/;"	f
test_cast_range_u0_min	_	fn test_cast_range_u0_min() {$/;"	f
test_cast_range_uint_max	_	fn test_cast_range_uint_max() {$/;"	f
test_cast_range_uint_min	_	fn test_cast_range_uint_min() {$/;"	f
test_ceil	_	fn test_ceil() {$/;"	f
test_ceil	_	fn test_ceil() {$/;"	f
test_chained_reader	_	fn test_chained_reader() {$/;"	f
test_chan_writer	_	fn test_chan_writer() {$/;"	f
test_char_at	_	fn test_char_at() {$/;"	f
test_char_at_reverse	_	fn test_char_at_reverse() {$/;"	f
test_char_indices_revator	_	fn test_char_indices_revator() {$/;"	f
test_char_indicesator	_	fn test_char_indicesator() {$/;"	f
test_char_range_at	_	fn test_char_range_at() {$/;"	f
test_char_range_at_reverse_underflow	_	fn test_char_range_at_reverse_underflow() {$/;"	f
test_chars	_	fn test_chars() {$/;"	f
test_checked_add	_	fn test_checked_add() {$/;"	f
test_checked_mul	_	fn test_checked_mul() {$/;"	f
test_checked_sub	_	fn test_checked_sub() {$/;"	f
test_chi_squared_large	_	fn test_chi_squared_large() {$/;"	f
test_chi_squared_one	_	fn test_chi_squared_one() {$/;"	f
test_chi_squared_small	_	fn test_chi_squared_small() {$/;"	f
test_child_doesnt_ref_parent	_	/^fn test_child_doesnt_ref_parent() {$/;"	f
test_choose	_	fn test_choose() {$/;"	f
test_choose_option	_	fn test_choose_option() {$/;"	f
test_chunksator	_	fn test_chunksator() {$/;"	f
test_chunksator_0	_	fn test_chunksator_0() {$/;"	f
test_classify	_	fn test_classify() {$/;"	f
test_classify	_	fn test_classify() {$/;"	f
test_clear	_	fn test_clear() {$/;"	f
test_clear	_	fn test_clear() {$/;"	f
test_clone	_	fn test_clone() {$/;"	f
test_clone	_	fn test_clone() {$/;"	f
test_clone	_	fn test_clone() {$/;"	f
test_clone	_	fn test_clone() {$/;"	f
test_clone_eq_null	_	fn test_clone_eq_null() {$/;"	f
test_clone_from	_	/^fn test_clone_from() {$/;"	f
test_clone_noleak	_	fn test_clone_noleak() {$/;"	f
test_cmp0	_	fn test_cmp0() {$/;"	f
test_collect	_	fn test_collect() {$/;"	f
test_collect	_	fn test_collect() {$/;"	f
test_collect	_	fn test_collect() {$/;"	f
test_collect	_	fn test_collect() {$/;"	f
test_compact	_	/^fn test_compact() {$/;"	f
test_components	_	fn test_components() {$/;"	f
test_components	_	fn test_components() {$/;"	f
test_components_iter	_	fn test_components_iter() {$/;"	f
test_components_iter	_	fn test_components_iter() {$/;"	f
test_concat	_	fn test_concat() {$/;"	f
test_concat	_	fn test_concat() {$/;"	f
test_concat_slices	_	fn test_concat_slices() {$/;"	f
test_connect	_	fn test_connect() {$/;"	f
test_connect	_	fn test_connect() {$/;"	f
test_connect_slices	_	fn test_connect_slices() {$/;"	f
test_contains	_	fn test_contains() {$/;"	f
test_contains_char	_	fn test_contains_char() {$/;"	f
test_copy	_	fn test_copy() {$/;"	f
test_copy_from	_	fn test_copy_from() {$/;"	f
test_copy_memory_oob	_	fn test_copy_memory_oob() {$/;"	f
test_count	_	fn test_count() {$/;"	f
test_count_ones	_	fn test_count_ones() {$/;"	f
test_count_ones	_	fn test_count_ones() {$/;"	f
test_count_zeros	_	fn test_count_zeros() {$/;"	f
test_count_zeros	_	fn test_count_zeros() {$/;"	f
test_counter_from_iter	_	fn test_counter_from_iter() {$/;"	f
test_cstring	_	fn test_cstring() {$/;"	f
test_custom_state	_	fn test_custom_state() {$/;"	f
test_cycle	_	fn test_cycle() {$/;"	f
test_dead	_	fn test_dead() {$/;"	f
test_dedup	_	fn test_dedup() {$/;"	f
test_dedup_shared	_	fn test_dedup_shared() {$/;"	f
test_dedup_unique	_	fn test_dedup_unique() {$/;"	f
test_deep_clone	_	fn test_deep_clone() {$/;"	f
test_deep_clone	_	fn test_deep_clone() {$/;"	f
test_deep_clone_from	_	/^fn test_deep_clone_from() {$/;"	f
test_destructor	_	fn test_destructor() {$/;"	f
test_destructor	_	fn test_destructor() {$/;"	f
test_dir_path	_	fn test_dir_path() {$/;"	f
test_dir_path	_	fn test_dir_path() {$/;"	f
test_display	_	fn test_display() {$/;"	f
test_display	_	fn test_display() {$/;"	f
test_display_str	_	fn test_display_str() {$/;"	f
test_display_str	_	fn test_display_str() {$/;"	f
test_double_ended_chain	_	fn test_double_ended_chain() {$/;"	f
test_double_ended_enumerate	_	fn test_double_ended_enumerate() {$/;"	f
test_double_ended_filter	_	fn test_double_ended_filter() {$/;"	f
test_double_ended_filter_map	_	fn test_double_ended_filter_map() {$/;"	f
test_double_ended_flat_map	_	fn test_double_ended_flat_map() {$/;"	f
test_double_ended_map	_	fn test_double_ended_map() {$/;"	f
test_double_ended_range	_	fn test_double_ended_range() {$/;"	f
test_double_ended_zip	_	fn test_double_ended_zip() {$/;"	f
test_element_swaps	_	fn test_element_swaps() {$/;"	f
test_ends_with	_	fn test_ends_with() {$/;"	f
test_ends_with	_	fn test_ends_with() {$/;"	f
test_ends_with_path	_	fn test_ends_with_path() {$/;"	f
test_ends_with_path	_	fn test_ends_with_path() {$/;"	f
test_env_getenv	_	fn test_env_getenv() {$/;"	f
test_env_set_get_huge	_	fn test_env_set_get_huge() {$/;"	f
test_env_setenv	_	fn test_env_setenv() {$/;"	f
test_eq	_	fn test_eq() {$/;"	f
test_eq	_	fn test_eq() {$/;"	f
test_eq_ignore_ascii_case	_	fn test_eq_ignore_ascii_case() {$/;"	f
test_eq_slice	_	fn test_eq_slice() {$/;"	f
test_errors_do_not_crash	_	fn test_errors_do_not_crash() {$/;"	f
test_escape_default	_	/^fn test_escape_default() {$/;"	f
test_escape_default	_	fn test_escape_default() {$/;"	f
test_escape_unicode	_	/^fn test_escape_unicode() {$/;"	f
test_escape_unicode	_	fn test_escape_unicode() {$/;"	f
test_exp	_	fn test_exp() {$/;"	f
test_exp_invalid_lambda_neg	_	fn test_exp_invalid_lambda_neg() {$/;"	f
test_exp_invalid_lambda_zero	_	fn test_exp_invalid_lambda_zero() {$/;"	f
test_extend	_	fn test_extend() {$/;"	f
test_extend	_	fn test_extend() {$/;"	f
test_extern_fn_clone	_	/^fn test_extern_fn_clone() {$/;"	f
test_f	_	fn test_f() {$/;"	f
test_fail	_	/^fn test_fail() {$/;"	f
test_fill_bytes_default	_	fn test_fill_bytes_default() {$/;"	f
test_filter_map	_	fn test_filter_map() {$/;"	f
test_filtered	_	fn test_filtered() {$/;"	f
test_find	_	fn test_find() {$/;"	f
test_find	_	fn test_find() {$/;"	f
test_find_str	_	fn test_find_str() {$/;"	f
test_flat_map_fail	_	fn test_flat_map_fail() {$/;"	f
test_floats	_	fn test_floats() {$/;"	f
test_floor	_	fn test_floor() {$/;"	f
test_floor	_	fn test_floor() {$/;"	f
test_fmt_default	_	pub fn test_fmt_default() {$/;"	f
test_fn_a	_	fn test_fn_a() -> f0 { 0.0 }$/;"	f
test_fn_b	_	fn test_fn_b<T: Empty>(x: T) -> T { x }$/;"	f
test_fn_c	_	fn test_fn_c(_: int, _: f0, _: ~[int], _: int, _: int, _: int) {}$/;"	f
test_fold	_	fn test_fold() {$/;"	f
test_format_int	_	fn test_format_int() {$/;"	f
test_format_int_flags	_	fn test_format_int_flags() {$/;"	f
test_format_int_sign_padding	_	fn test_format_int_sign_padding() {$/;"	f
test_format_int_twos_complement	_	fn test_format_int_twos_complement() {$/;"	f
test_format_int_zero	_	fn test_format_int_zero() {$/;"	f
test_format_radix	_	fn test_format_radix() {$/;"	f
test_fract	_	fn test_fract() {$/;"	f
test_fract	_	fn test_fract() {$/;"	f
test_frexp	_	fn test_frexp() {$/;"	f
test_frexp	_	fn test_frexp() {$/;"	f
test_frexp_nowin	_	fn test_frexp_nowin() {$/;"	f
test_frexp_nowin	_	fn test_frexp_nowin() {$/;"	f
test_from_buf_len	_	fn test_from_buf_len() {$/;"	f
test_from_elem	_	fn test_from_elem() {$/;"	f
test_from_elem_fail	_	fn test_from_elem_fail() {$/;"	f
test_from_fn	_	fn test_from_fn() {$/;"	f
test_from_fn_fail	_	fn test_from_fn_fail() {$/;"	f
test_from_primitive	_	fn test_from_primitive() {$/;"	f
test_from_str	_	fn test_from_str() {$/;"	f
test_from_str	_	fn test_from_str() {$/;"	f
test_from_str	_	pub fn test_from_str() {$/;"	f
test_from_str	_	fn test_from_str() {$/;"	f
test_from_str_ipv0	_	fn test_from_str_ipv0() {$/;"	f
test_from_str_ipv0_in_ipv0	_	fn test_from_str_ipv0_in_ipv0() {$/;"	f
test_from_str_ipv0	_	fn test_from_str_ipv0() {$/;"	f
test_from_str_socket_addr	_	fn test_from_str_socket_addr() {$/;"	f
test_full	_	fn test_full() {$/;"	f
test_future_result	_	/^fn test_future_result() {$/;"	f
test_gen_ascii_str	_	fn test_gen_ascii_str() {$/;"	f
test_gen_f0	_	fn test_gen_f0() {$/;"	f
test_gen_range	_	fn test_gen_range() {$/;"	f
test_gen_range_fail_int	_	fn test_gen_range_fail_int() {$/;"	f
test_gen_range_fail_uint	_	fn test_gen_range_fail_uint() {$/;"	f
test_gen_vec	_	fn test_gen_vec() {$/;"	f
test_gen_weighted_bool	_	fn test_gen_weighted_bool() {$/;"	f
test_get	_	fn test_get() {$/;"	f
test_get_mut	_	fn test_get_mut() {$/;"	f
test_get_ptr	_	fn test_get_ptr() {$/;"	f
test_get_resource	_	fn test_get_resource() {$/;"	f
test_get_str	_	fn test_get_str() {$/;"	f
test_getenv_big	_	fn test_getenv_big() {$/;"	f
test_getters	_	fn test_getters() {$/;"	f
test_getters	_	fn test_getters() {$/;"	f
test_getters	_	fn test_getters() {$/;"	f
test_grow	_	fn test_grow() {$/;"	f
test_grow_fn	_	fn test_grow_fn() {$/;"	f
test_grow_fn_fail	_	fn test_grow_fn_fail() {$/;"	f
test_grow_set	_	fn test_grow_set() {$/;"	f
test_hash_idempotent	_	fn test_hash_idempotent() {$/;"	f
test_hash_no_bytes_dropped_0	_	fn test_hash_no_bytes_dropped_0() {$/;"	f
test_hash_no_bytes_dropped_0	_	fn test_hash_no_bytes_dropped_0() {$/;"	f
test_hash_no_concat_alias	_	fn test_hash_no_concat_alias() {$/;"	f
test_hash_uint	_	fn test_hash_uint() {$/;"	f
test_head	_	fn test_head() {$/;"	f
test_hex_radix_digit_overflow	_	fn test_hex_radix_digit_overflow() {$/;"	f
test_impl_map	_	pub fn test_impl_map() {$/;"	f
test_impl_map_err	_	pub fn test_impl_map_err() {$/;"	f
test_init	_	fn test_init() {$/;"	f
test_init_empty	_	fn test_init_empty() {$/;"	f
test_initn	_	fn test_initn() {$/;"	f
test_initn_empty	_	fn test_initn_empty() {$/;"	f
test_insert	_	fn test_insert() {$/;"	f
test_insert	_	fn test_insert() {$/;"	f
test_insert_char	_	fn test_insert_char() {$/;"	f
test_insert_oob	_	fn test_insert_oob() {$/;"	f
test_inspect	_	fn test_inspect() {$/;"	f
test_int_from_str_overflow	_	fn test_int_from_str_overflow() {$/;"	f
test_int_to_str_overflow	_	fn test_int_to_str_overflow() {$/;"	f
test_int_totaleq	_	fn test_int_totaleq() {$/;"	f
test_int_totalord	_	fn test_int_totalord() {$/;"	f
test_integer_decode	_	fn test_integer_decode() {$/;"	f
test_integer_decode	_	fn test_integer_decode() {$/;"	f
test_integers	_	fn test_integers() {$/;"	f
test_into_ascii_lower	_	fn test_into_ascii_lower() {$/;"	f
test_into_ascii_upper	_	fn test_into_ascii_upper() {$/;"	f
test_into_bytes	_	fn test_into_bytes() {$/;"	f
test_into_maybe_owned	_	fn test_into_maybe_owned() {$/;"	f
test_io_signal_invalid_signum	_	fn test_io_signal_invalid_signum() {$/;"	f
test_io_signal_smoketest	_	fn test_io_signal_smoketest() {$/;"	f
test_io_signal_two_signal_one_signum	_	fn test_io_signal_two_signal_one_signum() {$/;"	f
test_io_signal_unregister	_	fn test_io_signal_unregister() {$/;"	f
test_is_absolute	_	fn test_is_absolute() {$/;"	f
test_is_absolute	_	fn test_is_absolute() {$/;"	f
test_is_ancestor_of	_	fn test_is_ancestor_of() {$/;"	f
test_is_ancestor_of	_	fn test_is_ancestor_of() {$/;"	f
test_is_control	_	/^fn test_is_control() {$/;"	f
test_is_digit	_	/^fn test_is_digit() {$/;"	f
test_is_empty	_	fn test_is_empty() {$/;"	f
test_is_empty	_	fn test_is_empty() {$/;"	f
test_is_lowercase	_	/^fn test_is_lowercase() {$/;"	f
test_is_negative	_	fn test_is_negative() {$/;"	f
test_is_negative	_	fn test_is_negative() {$/;"	f
test_is_negative	_	fn test_is_negative() {$/;"	f
test_is_normal	_	fn test_is_normal() {$/;"	f
test_is_normal	_	fn test_is_normal() {$/;"	f
test_is_null	_	fn test_is_null() {$/;"	f
test_is_null	_	fn test_is_null() {$/;"	f
test_is_positive	_	fn test_is_positive() {$/;"	f
test_is_positive	_	fn test_is_positive() {$/;"	f
test_is_positive	_	fn test_is_positive() {$/;"	f
test_is_uppercase	_	/^fn test_is_uppercase() {$/;"	f
test_is_utf0	_	fn test_is_utf0() {$/;"	f
test_is_utf0	_	fn test_is_utf0() {$/;"	f
test_is_whitespace	_	/^fn test_is_whitespace() {$/;"	f
test_is_whitespace	_	fn test_is_whitespace() {$/;"	f
test_iter	_	fn test_iter() {$/;"	f
test_iter_clone	_	fn test_iter_clone() {$/;"	f
test_iter_fail	_	fn test_iter_fail() {$/;"	f
test_iter_size_hints	_	fn test_iter_size_hints() {$/;"	f
test_iter_zero_sized	_	fn test_iter_zero_sized() {$/;"	f
test_iterator	_	fn test_iterator() {$/;"	f
test_iterator	_	fn test_iterator() {$/;"	f
test_iterator	_	fn test_iterator() {$/;"	f
test_iterator_chain	_	fn test_iterator_chain() {$/;"	f
test_iterator_clone	_	fn test_iterator_clone() {$/;"	f
test_iterator_enumerate	_	fn test_iterator_enumerate() {$/;"	f
test_iterator_flat_map	_	fn test_iterator_flat_map() {$/;"	f
test_iterator_last	_	fn test_iterator_last() {$/;"	f
test_iterator_len	_	fn test_iterator_len() {$/;"	f
test_iterator_max	_	fn test_iterator_max() {$/;"	f
test_iterator_min	_	fn test_iterator_min() {$/;"	f
test_iterator_nth	_	fn test_iterator_nth() {$/;"	f
test_iterator_peekable	_	fn test_iterator_peekable() {$/;"	f
test_iterator_product	_	fn test_iterator_product() {$/;"	f
test_iterator_scan	_	fn test_iterator_scan() {$/;"	f
test_iterator_size_hint	_	fn test_iterator_size_hint() {$/;"	f
test_iterator_skip	_	fn test_iterator_skip() {$/;"	f
test_iterator_skip_while	_	fn test_iterator_skip_while() {$/;"	f
test_iterator_sum	_	fn test_iterator_sum() {$/;"	f
test_iterator_take	_	fn test_iterator_take() {$/;"	f
test_iterator_take_while	_	fn test_iterator_take_while() {$/;"	f
test_join	_	fn test_join() {$/;"	f
test_join	_	fn test_join() {$/;"	f
test_join_many	_	fn test_join_many() {$/;"	f
test_join_many	_	fn test_join_many() {$/;"	f
test_join_path	_	fn test_join_path() {$/;"	f
test_join_path	_	fn test_join_path() {$/;"	f
test_last	_	fn test_last() {$/;"	f
test_ldexp	_	fn test_ldexp() {$/;"	f
test_ldexp	_	fn test_ldexp() {$/;"	f
test_le	_	fn test_le() {$/;"	f
test_len	_	fn test_len() {$/;"	f
test_len_divzero	_	fn test_len_divzero() {$/;"	f
test_len_fail	_	fn test_len_fail() {$/;"	f
test_lexical_ordering	_	fn test_lexical_ordering() {$/;"	f
test_limit_reader_limit	_	fn test_limit_reader_limit() {$/;"	f
test_limit_reader_limited	_	fn test_limit_reader_limited() {$/;"	f
test_limit_reader_unlimited	_	fn test_limit_reader_unlimited() {$/;"	f
test_line_buffer	_	fn test_line_buffer() {$/;"	f
test_lines	_	fn test_lines() {$/;"	f
test_lines	_	fn test_lines() {$/;"	f
test_live	_	fn test_live() {$/;"	f
test_loading_cosine	_	fn test_loading_cosine() {$/;"	f
test_log_normal	_	fn test_log_normal() {$/;"	f
test_log_normal_invalid_dof	_	fn test_log_normal_invalid_dof() {$/;"	f
test_log_normal_invalid_sd	_	fn test_log_normal_invalid_sd() {$/;"	f
test_lt	_	fn test_lt() {$/;"	f
test_make_non_verbatim	_	fn test_make_non_verbatim() {$/;"	f
test_managed_clone	_	/^fn test_managed_clone() {$/;"	f
test_map	_	fn test_map() {$/;"	f
test_map_fail	_	fn test_map_fail() {$/;"	f
test_max_by	_	fn test_max_by() {$/;"	f
test_max_nan	_	fn test_max_nan() {$/;"	f
test_max_nan	_	fn test_max_nan() {$/;"	f
test_maybe_owned_clone	_	fn test_maybe_owned_clone() {$/;"	f
test_maybe_owned_into_owned	_	fn test_maybe_owned_into_owned() {$/;"	f
test_maybe_owned_methods	_	fn test_maybe_owned_methods() {$/;"	f
test_maybe_owned_traits	_	fn test_maybe_owned_traits() {$/;"	f
test_mem_reader	_	fn test_mem_reader() {$/;"	f
test_mem_writer	_	fn test_mem_writer() {$/;"	f
test_min_by	_	fn test_min_by() {$/;"	f
test_min_max	_	fn test_min_max() {$/;"	f
test_min_nan	_	fn test_min_nan() {$/;"	f
test_min_nan	_	fn test_min_nan() {$/;"	f
test_move_from	_	fn test_move_from() {$/;"	f
test_move_iterator	_	fn test_move_iterator() {$/;"	f
test_move_rev_iterator	_	fn test_move_rev_iterator() {$/;"	f
test_multi_writer	_	fn test_multi_writer() {$/;"	f
test_mut_chunks	_	fn test_mut_chunks() {$/;"	f
test_mut_chunks_0	_	fn test_mut_chunks_0() {$/;"	f
test_mut_chunks_rev	_	fn test_mut_chunks_rev() {$/;"	f
test_mut_iter	_	fn test_mut_iter() {$/;"	f
test_mut_iterator	_	fn test_mut_iterator() {$/;"	f
test_mut_last	_	fn test_mut_last() {$/;"	f
test_mut_pop_ref	_	fn test_mut_pop_ref() {$/;"	f
test_mut_rev_iterator	_	fn test_mut_rev_iterator() {$/;"	f
test_mut_shift_ref	_	fn test_mut_shift_ref() {$/;"	f
test_mut_split_at	_	fn test_mut_split_at() {$/;"	f
test_mut_splitator	_	fn test_mut_splitator() {$/;"	f
test_mut_splitator_rev	_	fn test_mut_splitator_rev() {$/;"	f
test_mutate	_	fn test_mutate() {$/;"	f
test_nested_get_mut0	_	fn test_nested_get_mut0() {$/;"	f
test_nested_get_mut0	_	fn test_nested_get_mut0() {$/;"	f
test_nested_get_mut0	_	fn test_nested_get_mut0() {$/;"	f
test_nested_get_set0	_	fn test_nested_get_set0() {$/;"	f
test_nfd_chars	_	fn test_nfd_chars() {$/;"	f
test_nfkd_chars	_	fn test_nfkd_chars() {$/;"	f
test_normal	_	fn test_normal() {$/;"	f
test_normal_invalid_sd	_	fn test_normal_invalid_sd() {$/;"	f
test_not	_	fn test_not() {$/;"	f
test_not_utf0_fail	_	fn test_not_utf0_fail() {$/;"	f
test_null_byte	_	fn test_null_byte() {$/;"	f
test_null_byte	_	fn test_null_byte() {$/;"	f
test_null_reader	_	fn test_null_reader() {$/;"	f
test_null_writer	_	fn test_null_writer() {$/;"	f
test_num	_	fn test_num() {$/;"	f
test_num	_	fn test_num() {$/;"	f
test_num	_	fn test_num() {$/;"	f
test_num	_	/^pub fn test_num<T:Num + NumCast + Show>(ten: T, two: T) {$/;"	f
test_num	_	fn test_num() {$/;"	f
test_opt	_	fn test_opt() {$/;"	f
test_opt_paths	_	fn test_opt_paths() {$/;"	f
test_opt_paths	_	fn test_opt_paths() {$/;"	f
test_option_dance	_	fn test_option_dance() {$/;"	f
test_option_reader	_	fn test_option_reader() {$/;"	f
test_option_reader_error	_	fn test_option_reader_error() {$/;"	f
test_option_too_much_dance	_	fn test_option_too_much_dance() {$/;"	f
test_option_while_some	_	fn test_option_while_some() {$/;"	f
test_option_writer	_	fn test_option_writer() {$/;"	f
test_option_writer_error	_	fn test_option_writer_error() {$/;"	f
test_or	_	fn test_or() {$/;"	f
test_or	_	pub fn test_or() {$/;"	f
test_or_else	_	fn test_or_else() {$/;"	f
test_or_else	_	pub fn test_or_else() {$/;"	f
test_ord	_	fn test_ord() {$/;"	f
test_ord	_	fn test_ord() {$/;"	f
test_ordering_order	_	fn test_ordering_order() {$/;"	f
test_os_rng	_	fn test_os_rng() {$/;"	f
test_os_rng_tasks	_	fn test_os_rng_tasks() {$/;"	f
test_overflow_does_not_cause_segfault	_	fn test_overflow_does_not_cause_segfault() {$/;"	f
test_overflow_does_not_cause_segfault_managed	_	fn test_overflow_does_not_cause_segfault_managed() {$/;"	f
test_overflows	_	fn test_overflows() {$/;"	f
test_overflows	_	fn test_overflows() {$/;"	f
test_owned	_	fn test_owned() {$/;"	f
test_owned_ascii_vec	_	fn test_owned_ascii_vec() {$/;"	f
test_owned_clone	_	/^fn test_owned_clone() {$/;"	f
test_owned_named_task	_	/^fn test_owned_named_task() {$/;"	f
test_parse_bytes	_	fn test_parse_bytes() {$/;"	f
test_parse_bytes	_	pub fn test_parse_bytes() {$/;"	f
test_parse_prefix	_	fn test_parse_prefix() {$/;"	f
test_partition	_	fn test_partition() {$/;"	f
test_partitioned	_	fn test_partitioned() {$/;"	f
test_path_relative_from	_	fn test_path_relative_from() {$/;"	f
test_path_relative_from	_	fn test_path_relative_from() {$/;"	f
test_paths	_	fn test_paths() {$/;"	f
test_paths	_	fn test_paths() {$/;"	f
test_peekable_is_empty	_	fn test_peekable_is_empty() {$/;"	f
test_permutations	_	fn test_permutations() {$/;"	f
test_permute_fail	_	fn test_permute_fail() {$/;"	f
test_pop	_	fn test_pop() {$/;"	f
test_pop	_	fn test_pop() {$/;"	f
test_pop	_	fn test_pop() {$/;"	f
test_pop_byte	_	fn test_pop_byte() {$/;"	f
test_pop_char	_	fn test_pop_char() {$/;"	f
test_pop_char_0	_	fn test_pop_char_0() {$/;"	f
test_pop_char_fail	_	fn test_pop_char_fail() {$/;"	f
test_pop_ref	_	fn test_pop_ref() {$/;"	f
test_port_reader	_	fn test_port_reader() {$/;"	f
test_position	_	fn test_position() {$/;"	f
test_position	_	fn test_position() {$/;"	f
test_position_elem	_	fn test_position_elem() {$/;"	f
test_pow	_	fn test_pow() {$/;"	f
test_ptr_addition	_	fn test_ptr_addition() {$/;"	f
test_ptr_array_each	_	fn test_ptr_array_each() {$/;"	f
test_ptr_array_each_null_ptr	_	fn test_ptr_array_each_null_ptr() {$/;"	f
test_ptr_array_each_with_len	_	fn test_ptr_array_each_with_len() {$/;"	f
test_ptr_array_each_with_len_null_ptr	_	fn test_ptr_array_each_with_len_null_ptr() {$/;"	f
test_ptr_eq	_	fn test_ptr_eq() {$/;"	f
test_ptr_subtraction	_	fn test_ptr_subtraction() {$/;"	f
test_push	_	fn test_push() {$/;"	f
test_push	_	fn test_push() {$/;"	f
test_push	_	fn test_push() {$/;"	f
test_push_byte	_	fn test_push_byte() {$/;"	f
test_push_char	_	fn test_push_char() {$/;"	f
test_push_many	_	fn test_push_many() {$/;"	f
test_push_many	_	fn test_push_many() {$/;"	f
test_push_path	_	fn test_push_path() {$/;"	f
test_push_path	_	fn test_push_path() {$/;"	f
test_push_str	_	fn test_push_str() {$/;"	f
test_radix_base	_	fn test_radix_base() {$/;"	f
test_radix_base_too_large	_	fn test_radix_base_too_large() {$/;"	f
test_radix_digit	_	fn test_radix_digit() {$/;"	f
test_radix_prefix	_	fn test_radix_prefix() {$/;"	f
test_rand_sample	_	fn test_rand_sample() {$/;"	f
test_random	_	fn test_random() {$/;"	f
test_random_access_chain	_	fn test_random_access_chain() {$/;"	f
test_random_access_cycle	_	fn test_random_access_cycle() {$/;"	f
test_random_access_enumerate	_	fn test_random_access_enumerate() {$/;"	f
test_random_access_inspect	_	fn test_random_access_inspect() {$/;"	f
test_random_access_iterator	_	fn test_random_access_iterator() {$/;"	f
test_random_access_map	_	fn test_random_access_map() {$/;"	f
test_random_access_rev	_	fn test_random_access_rev() {$/;"	f
test_random_access_skip	_	fn test_random_access_skip() {$/;"	f
test_random_access_take	_	fn test_random_access_take() {$/;"	f
test_random_access_zip	_	fn test_random_access_zip() {$/;"	f
test_range	_	fn test_range() {$/;"	f
test_range_bad_limits_equal	_	fn test_range_bad_limits_equal() {$/;"	f
test_range_bad_limits_flipped	_	fn test_range_bad_limits_flipped() {$/;"	f
test_range_inclusive	_	fn test_range_inclusive() {$/;"	f
test_range_step	_	fn test_range_step() {$/;"	f
test_range_step_inclusive	_	fn test_range_step_inclusive() {$/;"	f
test_raw_from_c_str	_	fn test_raw_from_c_str() {$/;"	f
test_read_bad_char	_	fn test_read_bad_char() {$/;"	f
test_read_be_int_n	_	fn test_read_be_int_n() {$/;"	f
test_read_char	_	fn test_read_char() {$/;"	f
test_read_f0	_	fn test_read_f0() {$/;"	f
test_read_line	_	fn test_read_line() {$/;"	f
test_read_until	_	fn test_read_until() {$/;"	f
test_read_whole_string_bad	_	fn test_read_whole_string_bad() {$/;"	f
test_read_write_be	_	fn test_read_write_be() {$/;"	f
test_read_write_f0	_	fn test_read_write_f0() {$/;"	f
test_read_write_le_mem	_	fn test_read_write_le_mem() {$/;"	f
test_reader_rng_fill_bytes	_	fn test_reader_rng_fill_bytes() {$/;"	f
test_reader_rng_insufficient_bytes	_	fn test_reader_rng_insufficient_bytes() {$/;"	f
test_reader_rng_u0	_	fn test_reader_rng_u0() {$/;"	f
test_reader_rng_u0	_	fn test_reader_rng_u0() {$/;"	f
test_real_consts	_	fn test_real_consts() {$/;"	f
test_real_consts	_	fn test_real_consts() {$/;"	f
test_remove	_	fn test_remove() {$/;"	f
test_repeat	_	fn test_repeat() {$/;"	f
test_replace	_	fn test_replace() {$/;"	f
test_replace	_	fn test_replace() {$/;"	f
test_replace_0a	_	fn test_replace_0a() {$/;"	f
test_replace_0b	_	fn test_replace_0b() {$/;"	f
test_replace_0c	_	fn test_replace_0c() {$/;"	f
test_replace_0d	_	fn test_replace_0d() {$/;"	f
test_repr	_	/^fn test_repr() {$/;"	f
test_reseeding	_	fn test_reseeding() {$/;"	f
test_reserve_additional	_	fn test_reserve_additional() {$/;"	f
test_retain	_	fn test_retain() {$/;"	f
test_retval	_	/^fn test_retval() {$/;"	f
test_rev	_	fn test_rev() {$/;"	f
test_rev_iterator	_	fn test_rev_iterator() {$/;"	f
test_rev_iterator	_	fn test_rev_iterator() {$/;"	f
test_rev_split_char_iterator_no_trailing	_	fn test_rev_split_char_iterator_no_trailing() {$/;"	f
test_reverse	_	fn test_reverse() {$/;"	f
test_reverse	_	fn test_reverse() {$/;"	f
test_reverse_part	_	fn test_reverse_part() {$/;"	f
test_rfind	_	fn test_rfind() {$/;"	f
test_rng_0_rand_seeded	_	fn test_rng_0_rand_seeded() {$/;"	f
test_rng_0_reseed	_	fn test_rng_0_reseed() {$/;"	f
test_rng_0_seeded	_	fn test_rng_0_seeded() {$/;"	f
test_rng_0_true_values	_	fn test_rng_0_true_values() {$/;"	f
test_rng_0_rand_seeded	_	fn test_rng_0_rand_seeded() {$/;"	f
test_rng_0_reseed	_	fn test_rng_0_reseed() {$/;"	f
test_rng_0_seeded	_	fn test_rng_0_seeded() {$/;"	f
test_rng_0_true_values	_	fn test_rng_0_true_values() {$/;"	f
test_rng_fill_bytes	_	fn test_rng_fill_bytes() {$/;"	f
test_rng_reseed	_	fn test_rng_reseed() {$/;"	f
test_rng_seeded	_	fn test_rng_seeded() {$/;"	f
test_root_path	_	fn test_root_path() {$/;"	f
test_root_path	_	fn test_root_path() {$/;"	f
test_round	_	fn test_round() {$/;"	f
test_round	_	fn test_round() {$/;"	f
test_rposition	_	fn test_rposition() {$/;"	f
test_rposition_fail	_	fn test_rposition_fail() {$/;"	f
test_rsplitator	_	fn test_rsplitator() {$/;"	f
test_rsplitn_char_iterator	_	fn test_rsplitn_char_iterator() {$/;"	f
test_rsplitnator	_	fn test_rsplitnator() {$/;"	f
test_run_basic	_	/^fn test_run_basic() {$/;"	f
test_run_in_bare_thread	_	/^fn test_run_in_bare_thread() {$/;"	f
test_run_in_bare_thread_exchange	_	/^fn test_run_in_bare_thread_exchange() {$/;"	f
test_same_key_type	_	fn test_same_key_type() {$/;"	f
test_sample	_	fn test_sample() {$/;"	f
test_saturating_add_int	_	fn test_saturating_add_int() {$/;"	f
test_saturating_add_uint	_	fn test_saturating_add_uint() {$/;"	f
test_saturating_sub_int	_	fn test_saturating_sub_int() {$/;"	f
test_saturating_sub_uint	_	fn test_saturating_sub_uint() {$/;"	f
test_self_exe_name	_	fn test_self_exe_name() {$/;"	f
test_self_exe_path	_	fn test_self_exe_path() {$/;"	f
test_send_named_task	_	/^fn test_send_named_task() {$/;"	f
test_set_memory	_	fn test_set_memory() {$/;"	f
test_setenv	_	fn test_setenv() {$/;"	f
test_setenv_overwrite	_	fn test_setenv_overwrite() {$/;"	f
test_setters	_	fn test_setters() {$/;"	f
test_setters	_	fn test_setters() {$/;"	f
test_shift	_	fn test_shift() {$/;"	f
test_shift_byte	_	fn test_shift_byte() {$/;"	f
test_shift_char	_	fn test_shift_char() {$/;"	f
test_shift_ref	_	fn test_shift_ref() {$/;"	f
test_short_reads	_	fn test_short_reads() {$/;"	f
test_show	_	fn test_show() {$/;"	f
test_show	_	fn test_show() {$/;"	f
test_show	_	fn test_show() {$/;"	f
test_show	_	fn test_show() {$/;"	f
test_shrink_to_fit	_	fn test_shrink_to_fit() {$/;"	f
test_shuffle	_	fn test_shuffle() {$/;"	f
test_signed_checked_div	_	fn test_signed_checked_div() {$/;"	f
test_signum	_	fn test_signum() {$/;"	f
test_signum	_	fn test_signum() {$/;"	f
test_signum	_	fn test_signum() {$/;"	f
test_simple	_	fn test_simple() {$/;"	f
test_simple	_	fn test_simple() {$/;"	f
test_simple_clone	_	fn test_simple_clone() {$/;"	f
test_simple_clone	_	fn test_simple_clone() {$/;"	f
test_simple_newsched_spawn	_	/^fn test_simple_newsched_spawn() {$/;"	f
test_simple_types	_	fn test_simple_types() {$/;"	f
test_siphash	_	fn test_siphash() {$/;"	f
test_size	_	fn test_size() {$/;"	f
test_slice	_	fn test_slice() {$/;"	f
test_slice	_	fn test_slice() {$/;"	f
test_slice_0	_	fn test_slice_0() {$/;"	f
test_slice_0	_	fn test_slice_0() {$/;"	f
test_slice_chars	_	fn test_slice_chars() {$/;"	f
test_slice_fail	_	fn test_slice_fail() {$/;"	f
test_slice_from	_	fn test_slice_from() {$/;"	f
test_slice_from	_	fn test_slice_from() {$/;"	f
test_slice_to	_	fn test_slice_to() {$/;"	f
test_slice_to	_	fn test_slice_to() {$/;"	f
test_sort	_	fn test_sort() {$/;"	f
test_sort_stability	_	fn test_sort_stability() {$/;"	f
test_spawn_sched	_	/^fn test_spawn_sched() {$/;"	f
test_spawn_sched_childs_on_default_sched	_	/^fn test_spawn_sched_childs_on_default_sched() {$/;"	f
test_split_char_iterator	_	fn test_split_char_iterator() {$/;"	f
test_split_char_iterator_no_trailing	_	fn test_split_char_iterator_no_trailing() {$/;"	f
test_split_strator	_	fn test_split_strator() {$/;"	f
test_splitator	_	fn test_splitator() {$/;"	f
test_splitn_char_iterator	_	fn test_splitn_char_iterator() {$/;"	f
test_splitnator	_	fn test_splitnator() {$/;"	f
test_starts_with	_	fn test_starts_with() {$/;"	f
test_starts_with	_	fn test_starts_with() {$/;"	f
test_static_named_task	_	/^fn test_static_named_task() {$/;"	f
test_static_pointer	_	fn test_static_pointer() {$/;"	f
test_std_rng_reseed	_	fn test_std_rng_reseed() {$/;"	f
test_std_rng_seeded	_	fn test_std_rng_seeded() {$/;"	f
test_str_components	_	fn test_str_components() {$/;"	f
test_str_components	_	fn test_str_components() {$/;"	f
test_str_container	_	fn test_str_container() {$/;"	f
test_str_default	_	fn test_str_default() {$/;"	f
test_str_from_utf0	_	fn test_str_from_utf0() {$/;"	f
test_str_from_utf0_lossy	_	fn test_str_from_utf0_lossy() {$/;"	f
test_str_from_utf0_owned	_	fn test_str_from_utf0_owned() {$/;"	f
test_str_multistring_parsing	_	fn test_str_multistring_parsing() {$/;"	f
test_str_to_c_str	_	fn test_str_to_c_str() {$/;"	f
test_str_truncate	_	fn test_str_truncate() {$/;"	f
test_str_truncate_invalid_len	_	fn test_str_truncate_invalid_len() {$/;"	f
test_str_truncate_split_codepoint	_	fn test_str_truncate_split_codepoint() {$/;"	f
test_subslice_offset	_	fn test_subslice_offset() {$/;"	f
test_subslice_offset_0	_	fn test_subslice_offset_0() {$/;"	f
test_success	_	/^fn test_success() {$/;"	f
test_swap	_	fn test_swap() {$/;"	f
test_swap_remove	_	fn test_swap_remove() {$/;"	f
test_swap_remove_noncopyable	_	fn test_swap_remove_noncopyable() {$/;"	f
test_t	_	fn test_t() {$/;"	f
test_tail	_	fn test_tail() {$/;"	f
test_tail_empty	_	fn test_tail_empty() {$/;"	f
test_tailn	_	fn test_tailn() {$/;"	f
test_tailn_empty	_	fn test_tailn_empty() {$/;"	f
test_task_rng	_	fn test_task_rng() {$/;"	f
test_tee_reader	_	fn test_tee_reader() {$/;"	f
test_tls_cleanup_on_failure	_	fn test_tls_cleanup_on_failure() {$/;"	f
test_tls_crust_automorestack_memorial_bug	_	fn test_tls_crust_automorestack_memorial_bug() {$/;"	f
test_tls_modify	_	fn test_tls_modify() {$/;"	f
test_tls_multiple_types	_	fn test_tls_multiple_types() {$/;"	f
test_tls_multitask	_	fn test_tls_multitask() {$/;"	f
test_tls_overwrite	_	fn test_tls_overwrite() {$/;"	f
test_tls_overwrite_multiple_types	_	fn test_tls_overwrite_multiple_types() {$/;"	f
test_tls_pop	_	fn test_tls_pop() {$/;"	f
test_to_ascii_lower	_	fn test_to_ascii_lower() {$/;"	f
test_to_ascii_upper	_	fn test_to_ascii_upper() {$/;"	f
test_to_bit	_	fn test_to_bit() {$/;"	f
test_to_c_str_fail	_	fn test_to_c_str_fail() {$/;"	f
test_to_c_str_unchecked	_	fn test_to_c_str_unchecked() {$/;"	f
test_to_digit	_	/^fn test_to_digit() {$/;"	f
test_to_option	_	fn test_to_option() {$/;"	f
test_to_primitive	_	fn test_to_primitive() {$/;"	f
test_to_str	_	fn test_to_str() {$/;"	f
test_to_str	_	fn test_to_str() {$/;"	f
test_to_str	_	/^fn test_to_str() {$/;"	f
test_to_str	_	fn test_to_str() {$/;"	f
test_to_str	_	pub fn test_to_str() {$/;"	f
test_to_str	_	pub fn test_to_str() {$/;"	f
test_total_ord	_	fn test_total_ord() {$/;"	f
test_total_ord	_	fn test_total_ord() {$/;"	f
test_totalord	_	fn test_totalord() {$/;"	f
test_transmute	_	fn test_transmute() {$/;"	f
test_transmute0	_	fn test_transmute0() {$/;"	f
test_transmute_copy	_	fn test_transmute_copy() {$/;"	f
test_trim	_	fn test_trim() {$/;"	f
test_trim_chars	_	fn test_trim_chars() {$/;"	f
test_trim_left	_	fn test_trim_left() {$/;"	f
test_trim_left_chars	_	fn test_trim_left_chars() {$/;"	f
test_trim_right	_	fn test_trim_right() {$/;"	f
test_trim_right_chars	_	fn test_trim_right_chars() {$/;"	f
test_trunc	_	fn test_trunc() {$/;"	f
test_trunc	_	fn test_trunc() {$/;"	f
test_truncate	_	fn test_truncate() {$/;"	f
test_truncate_utf0_at_nul	_	fn test_truncate_utf0_at_nul() {$/;"	f
test_try_fail	_	/^fn test_try_fail() {$/;"	f
test_try_fail_message_any	_	/^fn test_try_fail_message_any() {$/;"	f
test_try_fail_message_owned_str	_	/^fn test_try_fail_message_owned_str() {$/;"	f
test_try_fail_message_static_str	_	/^fn test_try_fail_message_static_str() {$/;"	f
test_try_fail_message_unit_struct	_	/^fn test_try_fail_message_unit_struct() {$/;"	f
test_try_success	_	/^fn test_try_success() {$/;"	f
test_tuple_cmp	_	fn test_tuple_cmp() {$/;"	f
test_u0_from_be_bytes	_	fn test_u0_from_be_bytes() {$/;"	f
test_uint_from_str_overflow	_	fn test_uint_from_str_overflow() {$/;"	f
test_uint_to_str_overflow	_	fn test_uint_to_str_overflow() {$/;"	f
test_unfoldr	_	fn test_unfoldr() {$/;"	f
test_unix	_	/^mod test_unix {$/;"	m
test_unnamed_task	_	/^fn test_unnamed_task() {$/;"	f
test_unsafe_ptrs	_	fn test_unsafe_ptrs() {$/;"	f
test_unsafe_slice	_	fn test_unsafe_slice() {$/;"	f
test_unsetenv	_	fn test_unsetenv() {$/;"	f
test_unshift	_	fn test_unshift() {$/;"	f
test_unshift_char	_	fn test_unshift_char() {$/;"	f
test_unsigned_checked_div	_	fn test_unsigned_checked_div() {$/;"	f
test_unwrap	_	fn test_unwrap() {$/;"	f
test_unwrap	_	fn test_unwrap() {$/;"	f
test_unwrap_fail0	_	fn test_unwrap_fail0() {$/;"	f
test_unwrap_fail0	_	fn test_unwrap_fail0() {$/;"	f
test_unwrap_or	_	fn test_unwrap_or() {$/;"	f
test_unwrap_or_else	_	fn test_unwrap_or_else() {$/;"	f
test_utf0	_	fn test_utf0() {$/;"	f
test_utf0_invalid	_	fn test_utf0_invalid() {$/;"	f
test_utf0_lossy	_	fn test_utf0_lossy() {$/;"	f
test_vec_default	_	fn test_vec_default() {$/;"	f
test_vec_to_c_str	_	fn test_vec_to_c_str() {$/;"	f
test_vectors	_	fn test_vectors() {$/;"	f
test_weighted_choice	_	fn test_weighted_choice() {$/;"	f
test_weighted_choice_no_items	_	fn test_weighted_choice_no_items() {$/;"	f
test_weighted_choice_weight_overflows	_	fn test_weighted_choice_weight_overflows() {$/;"	f
test_weighted_choice_zero_weight	_	fn test_weighted_choice_zero_weight() {$/;"	f
test_windows	_	/^mod test_windows {$/;"	m
test_windowsator	_	fn test_windowsator() {$/;"	f
test_windowsator_0	_	fn test_windowsator_0() {$/;"	f
test_with_helpers	_	fn test_with_helpers() {$/;"	f
test_with_helpers	_	fn test_with_helpers() {$/;"	f
test_with_ref	_	fn test_with_ref() {$/;"	f
test_with_ref_empty_fail	_	fn test_with_ref_empty_fail() {$/;"	f
test_with_wrapper	_	/^fn test_with_wrapper() {$/;"	f
test_words	_	fn test_words() {$/;"	f
test_write_char	_	fn test_write_char() {$/;"	f
test_write_strings	_	fn test_write_strings() {$/;"	f
test_writer_hasher	_	fn test_writer_hasher() {$/;"	f
test_zero_reader	_	fn test_zero_reader() {$/;"	f
test_zip_unzip	_	fn test_zip_unzip() {$/;"	f
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tests	_	/^mod tests {$/;"	m
tgamma	_	pub fn tgamma(n: c_double) -> c_double;$/;"	f
tgamma	_	pub fn tgamma(n: c_float) -> c_float;$/;"	f
thread	_	/^pub mod thread;$/;"	m
thread_local_storage	_	/^mod thread_local_storage;$/;"	m
thread_local_task_smoke_test	_	fn thread_local_task_smoke_test() {$/;"	f
thread_local_task_two_instances	_	fn thread_local_task_two_instances() {$/;"	f
thread_start	_	/^extern fn thread_start(main: *libc::c_void) -> imp::rust_thread_return {$/;"	f
time_to_live	_	fn time_to_live(&mut self, ttl: int) -> Result<(), IoError>;$/;"	f
timer	_	/^pub mod timer;$/;"	m
timer_init	_	fn timer_init(&mut self) -> Result<~RtioTimer, IoError>;$/;"	f
timespec	_	pub struct timespec {$/;"	s
timeval	_	pub struct timeval {$/;"	s
timezone	_	pub enum timezone {}$/;"	g
tls	_	fn tls() {$/;"	f
tls_key	_	fn tls_key() -> tls::Key {$/;"	f
tls_smoke_test	_	/^fn tls_smoke_test() {$/;"	f
tmpdir	_	pub fn tmpdir() -> TempDir {$/;"	f
tmpdir	_	/^pub fn tmpdir() -> Path {$/;"	f
tmpfile	_	pub fn tmpfile() -> *FILE;$/;"	f
to_ascii	_	fn to_ascii(&self) -> T {$/;"	f
to_ascii_lower	_	fn to_ascii_lower(&self) -> ~str {$/;"	f
to_ascii_lower	_	fn to_ascii_lower(&self) -> ~str;$/;"	f
to_ascii_nocheck	_	unsafe fn to_ascii_nocheck(&self) -> &'a [Ascii] {$/;"	f
to_ascii_nocheck	_	unsafe fn to_ascii_nocheck(&self) -> &'a[Ascii] {$/;"	f
to_ascii_nocheck	_	unsafe fn to_ascii_nocheck(&self) -> Ascii {$/;"	f
to_ascii_nocheck	_	unsafe fn to_ascii_nocheck(&self) -> T;$/;"	f
to_ascii_opt	_	fn to_ascii_opt(&self) -> Option<T> {$/;"	f
to_ascii_upper	_	fn to_ascii_upper(&self) -> ~str {$/;"	f
to_ascii_upper	_	fn to_ascii_upper(&self) -> ~str;$/;"	f
to_bit	_	/^pub fn to_bit<N: Int>(p: bool) -> N {$/;"	f
to_byte	_	pub fn to_byte(self) -> u0 {$/;"	f
to_c_str	_	fn to_c_str(&self) -> CString {$/;"	f
to_c_str	_	fn to_c_str(&self) -> CString;$/;"	f
to_c_str	_	fn to_c_str(&self) -> CString {$/;"	f
to_c_str	_	fn to_c_str(&self) -> CString {$/;"	f
to_c_str_unchecked	_	unsafe fn to_c_str_unchecked(&self) -> CString {$/;"	f
to_c_str_unchecked	_	unsafe fn to_c_str_unchecked(&self) -> CString;$/;"	f
to_c_str_unchecked	_	unsafe fn to_c_str_unchecked(&self) -> CString {$/;"	f
to_c_str_unchecked	_	unsafe fn to_c_str_unchecked(&self) -> CString {$/;"	f
to_char	_	pub fn to_char(self) -> char {$/;"	f
to_char_lossy	_	pub fn to_char_lossy(&self) -> char {$/;"	f
to_degrees	_	fn to_degrees(&self) -> f0 { *self * (0.0f0 \/ Float::pi()) }$/;"	f
to_degrees	_	fn to_degrees(&self) -> f0 { *self * (0.0f0 \/ Float::pi()) }$/;"	f
to_degrees	_	fn to_degrees(&self) -> Self;$/;"	f
to_digit	_	fn to_digit(&self, radix: uint) -> Option<uint> { to_digit(*self, radix) }$/;"	f
to_digit	_	fn to_digit(&self, radix: uint) -> Option<uint>;$/;"	f
to_digit	_	/^pub fn to_digit(c: char, radix: uint) -> Option<uint> {$/;"	f
to_f0	_	fn to_f0(&self) -> Option<f0> { Some(*self as f0) }$/;"	f
to_f0	_	fn to_f0(&self) -> Option<f0> { impl_to_primitive_float_to_float!($T, f0) }$/;"	f
to_f0	_	fn to_f0(&self) -> Option<f0> {$/;"	f
to_f0	_	fn to_f0(&self) -> Option<f0> { Some(*self as f0) }$/;"	f
to_f0	_	fn to_f0(&self) -> Option<f0> { impl_to_primitive_float_to_float!($T, f0) }$/;"	f
to_f0	_	fn to_f0(&self) -> Option<f0> {$/;"	f
to_hex_str	_	fn to_hex_str(r: &[u0, ..0]) -> ~str {$/;"	f
to_i0	_	fn to_i0(&self) -> Option<i0> { Some(*self as i0) }$/;"	f
to_i0	_	fn to_i0(&self) -> Option<i0> { impl_to_primitive_int_to_int!($T, i0) }$/;"	f
to_i0	_	fn to_i0(&self) -> Option<i0> { impl_to_primitive_uint_to_int!(i0) }$/;"	f
to_i0	_	fn to_i0(&self) -> Option<i0> {$/;"	f
to_i0	_	fn to_i0(&self) -> Option<i0> { Some(*self as i0) }$/;"	f
to_i0	_	fn to_i0(&self) -> Option<i0> { impl_to_primitive_int_to_int!($T, i0) }$/;"	f
to_i0	_	fn to_i0(&self) -> Option<i0> { impl_to_primitive_uint_to_int!(i0) }$/;"	f
to_i0	_	fn to_i0(&self) -> Option<i0> {$/;"	f
to_i0	_	fn to_i0(&self) -> Option<i0> { None }$/;"	f
to_i0	_	fn to_i0(&self) -> Option<i0> { Some(*self as i0) }$/;"	f
to_i0	_	fn to_i0(&self) -> Option<i0> { impl_to_primitive_int_to_int!($T, i0) }$/;"	f
to_i0	_	fn to_i0(&self) -> Option<i0> { impl_to_primitive_uint_to_int!(i0) }$/;"	f
to_i0	_	fn to_i0(&self) -> Option<i0> { self.x.to_i0() }$/;"	f
to_i0	_	fn to_i0(&self) -> Option<i0>;$/;"	f
to_i0	_	fn to_i0(&self) -> Option<i0> { Some(*self as i0) }$/;"	f
to_i0	_	fn to_i0(&self) -> Option<i0> { impl_to_primitive_int_to_int!($T, i0) }$/;"	f
to_i0	_	fn to_i0(&self) -> Option<i0> { impl_to_primitive_uint_to_int!(i0) }$/;"	f
to_i0	_	fn to_i0(&self) -> Option<i0> {$/;"	f
to_int	_	fn to_int(&self) -> Option<int> { Some(*self as int) }$/;"	f
to_int	_	fn to_int(&self) -> Option<int> { impl_to_primitive_int_to_int!($T, int) }$/;"	f
to_int	_	fn to_int(&self) -> Option<int> { impl_to_primitive_uint_to_int!(int) }$/;"	f
to_int	_	fn to_int(&self) -> Option<int> {$/;"	f
to_lower	_	fn to_lower(&self) -> ~[Ascii] {$/;"	f
to_lower	_	fn to_lower(&self) -> ~[Ascii];$/;"	f
to_lower	_	pub fn to_lower(self) -> Ascii {$/;"	f
to_option	_	unsafe fn to_option(&self) -> Option<&T> {$/;"	f
to_option	_	unsafe fn to_option(&self) -> Option<&T>;$/;"	f
to_owned	_	fn to_owned(&self) -> ~str {$/;"	f
to_owned	_	fn to_owned(&self) -> ~str;$/;"	f
to_owned	_	fn to_owned(&self) -> ~[T] { self.clone() }$/;"	f
to_owned	_	fn to_owned(&self) -> ~[T] {$/;"	f
to_owned	_	fn to_owned(&self) -> ~[T];$/;"	f
to_owned_vec	_	fn to_owned_vec(&mut self) -> ~[A] {$/;"	f
to_radians	_	fn to_radians(&self) -> f0 {$/;"	f
to_radians	_	fn to_radians(&self) -> f0 {$/;"	f
to_radians	_	fn to_radians(&self) -> Self;$/;"	f
to_str	_	/^pub mod to_str;$/;"	m
to_str	_	/^pub fn to_str(num: f0) -> ~str {$/;"	f
to_str	_	/^pub fn to_str(num: f0) -> ~str {$/;"	f
to_str	_	fn to_str(&self) -> ~str { format!("{}", *self) }$/;"	f
to_str	_	fn to_str(&self) -> ~str;$/;"	f
to_str_base_0	_	fn to_str_base_0(bh: &mut BenchHarness) {$/;"	f
to_str_bin	_	fn to_str_bin(bh: &mut BenchHarness) {$/;"	f
to_str_bytes	_	/^pub fn to_str_bytes<U>(n: $T, radix: uint, f: |v: &[u0]| -> U) -> U {$/;"	f
to_str_bytes	_	/^pub fn to_str_bytes<U>(n: $T, radix: uint, f: |v: &[u0]| -> U) -> U {$/;"	f
to_str_dec	_	fn to_str_dec(bh: &mut BenchHarness) {$/;"	f
to_str_digits	_	/^pub fn to_str_digits(num: f0, dig: uint) -> ~str {$/;"	f
to_str_digits	_	/^pub fn to_str_digits(num: f0, dig: uint) -> ~str {$/;"	f
to_str_exact	_	/^pub fn to_str_exact(num: f0, dig: uint) -> ~str {$/;"	f
to_str_exact	_	/^pub fn to_str_exact(num: f0, dig: uint) -> ~str {$/;"	f
to_str_exp_digits	_	/^pub fn to_str_exp_digits(num: f0, dig: uint, upper: bool) -> ~str {$/;"	f
to_str_exp_digits	_	/^pub fn to_str_exp_digits(num: f0, dig: uint, upper: bool) -> ~str {$/;"	f
to_str_exp_exact	_	/^pub fn to_str_exp_exact(num: f0, dig: uint, upper: bool) -> ~str {$/;"	f
to_str_exp_exact	_	/^pub fn to_str_exp_exact(num: f0, dig: uint, upper: bool) -> ~str {$/;"	f
to_str_hex	_	/^pub fn to_str_hex(num: f0) -> ~str {$/;"	f
to_str_hex	_	/^pub fn to_str_hex(num: f0) -> ~str {$/;"	f
to_str_hex	_	fn to_str_hex(bh: &mut BenchHarness) {$/;"	f
to_str_oct	_	fn to_str_oct(bh: &mut BenchHarness) {$/;"	f
to_str_radix	_	fn to_str_radix(&self, rdx: uint) -> ~str {$/;"	f
to_str_radix	_	fn to_str_radix(&self, rdx: uint) -> ~str {$/;"	f
to_str_radix	_	fn to_str_radix(&self, radix: uint) -> ~str {$/;"	f
to_str_radix	_	fn to_str_radix(&self, radix: uint) -> ~str;$/;"	f
to_str_radix	_	fn to_str_radix(&self, radix: uint) -> ~str {$/;"	f
to_str_radix0	_	pub fn to_str_radix0() {$/;"	f
to_str_radix0	_	pub fn to_str_radix0() {$/;"	f
to_str_radix_special	_	/^pub fn to_str_radix_special(num: f0, rdx: uint) -> (~str, bool) {$/;"	f
to_str_radix_special	_	/^pub fn to_str_radix_special(num: f0, rdx: uint) -> (~str, bool) {$/;"	f
to_u0	_	fn to_u0(&self) -> Option<u0> { Some(*self as u0) }$/;"	f
to_u0	_	fn to_u0(&self) -> Option<u0> { impl_to_primitive_int_to_uint!($T, u0) }$/;"	f
to_u0	_	fn to_u0(&self) -> Option<u0> { impl_to_primitive_uint_to_uint!($T, u0) }$/;"	f
to_u0	_	fn to_u0(&self) -> Option<u0> {$/;"	f
to_u0	_	fn to_u0(&self) -> Option<u0> { Some(*self as u0) }$/;"	f
to_u0	_	fn to_u0(&self) -> Option<u0> { impl_to_primitive_int_to_uint!($T, u0) }$/;"	f
to_u0	_	fn to_u0(&self) -> Option<u0> { impl_to_primitive_uint_to_uint!($T, u0) }$/;"	f
to_u0	_	fn to_u0(&self) -> Option<u0> {$/;"	f
to_u0	_	fn to_u0(&self) -> Option<u0> { None }$/;"	f
to_u0	_	fn to_u0(&self) -> Option<u0> { Some(*self as u0) }$/;"	f
to_u0	_	fn to_u0(&self) -> Option<u0> { impl_to_primitive_int_to_uint!($T, u0) }$/;"	f
to_u0	_	fn to_u0(&self) -> Option<u0> { impl_to_primitive_uint_to_uint!($T, u0) }$/;"	f
to_u0	_	fn to_u0(&self) -> Option<u0> { self.x.to_u0() }$/;"	f
to_u0	_	fn to_u0(&self) -> Option<u0>;$/;"	f
to_u0	_	fn to_u0(&self) -> Option<u0> { Some(*self as u0) }$/;"	f
to_u0	_	fn to_u0(&self) -> Option<u0> { impl_to_primitive_int_to_uint!($T, u0) }$/;"	f
to_u0	_	fn to_u0(&self) -> Option<u0> { impl_to_primitive_uint_to_uint!($T, u0) }$/;"	f
to_u0	_	fn to_u0(&self) -> Option<u0> {$/;"	f
to_uint	_	fn to_uint(&self) -> Option<uint> { Some(*self as uint) }$/;"	f
to_uint	_	fn to_uint(&self) -> Option<uint> { impl_to_primitive_int_to_uint!($T, uint) }$/;"	f
to_uint	_	fn to_uint(&self) -> Option<uint> { impl_to_primitive_uint_to_uint!($T, uint) }$/;"	f
to_uint	_	fn to_uint(&self) -> Option<uint> {$/;"	f
to_uint	_	fn to_uint(&self) -> uint { *self as uint }$/;"	f
to_uint	_	fn to_uint(&self) -> uint;$/;"	f
to_upper	_	fn to_upper(&self) -> ~[Ascii] {$/;"	f
to_upper	_	fn to_upper(&self) -> ~[Ascii];$/;"	f
to_upper	_	pub fn to_upper(self) -> Ascii {$/;"	f
to_utf0	_	fn to_utf0(&self) -> ~[u0] {$/;"	f
to_utf0	_	fn to_utf0(&self) -> ~[u0];$/;"	f
tolower	_	pub fn tolower(c: c_char) -> c_char;$/;"	f
toupper	_	pub fn toupper(c: c_char) -> c_char;$/;"	f
trailing_zeros	_	fn trailing_zeros(&self) -> i0 { unsafe { intrinsics::cttz0(*self) } }$/;"	f
trailing_zeros	_	fn trailing_zeros(&self) -> i0 { unsafe { intrinsics::cttz0(*self) } }$/;"	f
trailing_zeros	_	fn trailing_zeros(&self) -> i0 { unsafe { intrinsics::cttz0(*self) } }$/;"	f
trailing_zeros	_	fn trailing_zeros(&self) -> i0 { unsafe { intrinsics::cttz0(*self) } }$/;"	f
trailing_zeros	_	fn trailing_zeros(&self) -> int { (*self as i0).trailing_zeros() as int }$/;"	f
trailing_zeros	_	fn trailing_zeros(&self) -> int { (*self as i0).trailing_zeros() as int }$/;"	f
trailing_zeros	_	fn trailing_zeros(&self) -> Self;$/;"	f
trailing_zeros	_	fn trailing_zeros(&self) -> $T {$/;"	f
trait_static_method_call	_	fn trait_static_method_call(bh: &mut BenchHarness) {$/;"	f
trait_vtable_method_call	_	fn trait_vtable_method_call(bh: &mut BenchHarness) {$/;"	f
traits	_	/^pub mod traits {$/;"	m
traits	_	/^pub mod traits {}$/;"	m
traits	_	/^pub mod traits {$/;"	m
traits	_	/^pub mod traits {}$/;"	m
transmute	_	/^pub unsafe fn transmute<L, G>(thing: L) -> G {$/;"	f
transmute	_	pub fn transmute<T,U>(e: T) -> U;$/;"	f
transmute_copy	_	/^pub unsafe fn transmute_copy<T, U>(src: &T) -> U {$/;"	f
transmute_immut_unsafe	_	/^pub unsafe fn transmute_immut_unsafe<T>(ptr: *mut T) -> *T {$/;"	f
transmute_mut	_	/^pub unsafe fn transmute_mut<'a,T>(ptr: &'a T) -> &'a mut T { transmute(ptr) }$/;"	f
transmute_mut_region	_	/^pub unsafe fn transmute_mut_region<'a,'b,T>(ptr: &'a mut T) -> &'b mut T {$/;"	f
transmute_mut_unsafe	_	/^pub unsafe fn transmute_mut_unsafe<T>(ptr: *T) -> *mut T {$/;"	f
transmute_region	_	/^pub unsafe fn transmute_region<'a,'b,T>(ptr: &'a T) -> &'b T {$/;"	f
trim	_	fn trim(&self) -> &'a str {$/;"	f
trim	_	fn trim(&self) -> &'a str;$/;"	f
trim_chars	_	fn trim_chars<C: CharEq>(&self, to_trim: &C) -> &'a str {$/;"	f
trim_chars	_	fn trim_chars<C: CharEq>(&self, to_trim: &C) -> &'a str;$/;"	f
trim_left	_	fn trim_left(&self) -> &'a str {$/;"	f
trim_left	_	fn trim_left(&self) -> &'a str;$/;"	f
trim_left_chars	_	fn trim_left_chars<C: CharEq>(&self, to_trim: &C) -> &'a str {$/;"	f
trim_left_chars	_	fn trim_left_chars<C: CharEq>(&self, to_trim: &C) -> &'a str;$/;"	f
trim_right	_	fn trim_right(&self) -> &'a str {$/;"	f
trim_right	_	fn trim_right(&self) -> &'a str;$/;"	f
trim_right_chars	_	fn trim_right_chars<C: CharEq>(&self, to_trim: &C) -> &'a str {$/;"	f
trim_right_chars	_	fn trim_right_chars<C: CharEq>(&self, to_trim: &C) -> &'a str;$/;"	f
trunc	_	fn trunc(&self) -> f0 { trunc(*self) }$/;"	f
trunc	_	fn trunc(n: f0) -> f0 = intrinsics::truncf0,$/;"	f
trunc	_	fn trunc(&self) -> f0 { trunc(*self) }$/;"	f
trunc	_	fn trunc(n: f0) -> f0 = intrinsics::truncf0,$/;"	f
trunc	_	fn trunc(&self) -> Self;$/;"	f
truncate	_	pub fn truncate(&mut self, size: i0) -> IoResult<()> {$/;"	f
truncate	_	fn truncate(&mut self, offset: i0) -> Result<(), IoError>;$/;"	f
truncate	_	fn truncate(&mut self, len: uint) {$/;"	f
truncate	_	fn truncate(&mut self, len: uint);$/;"	f
truncate	_	fn truncate(&mut self, newlen: uint) {$/;"	f
truncate	_	fn truncate(&mut self, newlen: uint);$/;"	f
truncate	_	pub fn truncate(&mut self, len: uint) {$/;"	f
truncate_utf0_at_nul	_	/^pub fn truncate_utf0_at_nul<'a>(v: &'a [u0]) -> &'a [u0] {$/;"	f
truncf0	_	pub fn truncf0(x: f0) -> f0;$/;"	f
truncf0	_	pub fn truncf0(x: f0) -> f0;$/;"	f
try	_	pub fn try(&mut self, f: ||) {$/;"	f
try	_	pub fn try<T:Send>(mut self, f: proc() -> T) -> Result<T, ~Any> {$/;"	f
try	_	/^pub fn try<T:Send>(f: proc() -> T) -> Result<T, ~Any> {$/;"	f
try_borrow	_	pub fn try_borrow<'a>(&'a self) -> Option<Ref<'a, T>> {$/;"	f
try_borrow_mut	_	pub fn try_borrow_mut<'a>(&'a self) -> Option<RefMut<'a, T>> {$/;"	f
try_finally	_	/^pub fn try_finally<T,U,R>(mutate: &mut T,$/;"	f
try_fn	_	extern fn try_fn(code: *c_void, env: *c_void) {$/;"	f
try_recv	_	pub fn try_recv(&self) -> TryRecvResult<T> {$/;"	f
try_recv	_	pub fn try_recv(&mut self) -> Result<T, Failure<T>> {$/;"	f
try_recv	_	pub fn try_recv(&mut self) -> Result<T, Failure> {$/;"	f
try_recv	_	pub fn try_recv(&mut self) -> Result<T, Failure<T>> {$/;"	f
try_send	_	pub fn try_send(&self, t: T) -> bool {$/;"	f
try_take	_	fn try_take() -> Option<~Self>;$/;"	f
try_take	_	fn try_take() -> Option<~Task> { unsafe { local_ptr::try_take() } }$/;"	f
try_take	_	fn try_take() {$/;"	f
try_take	_	pub unsafe fn try_take<T>() -> Option<~T> {$/;"	f
try_unsafe_borrow	_	unsafe fn try_unsafe_borrow() -> Option<*mut Self>;$/;"	f
try_unsafe_borrow	_	unsafe fn try_unsafe_borrow() -> Option<*mut Task> {$/;"	f
try_unsafe_borrow	_	pub unsafe fn try_unsafe_borrow<T>() -> Option<*mut T> {$/;"	f
trylock	_	pub unsafe fn trylock(&mut self) -> bool {$/;"	f
trylock	_	pub unsafe fn trylock<'a>(&'a mut self) -> Option<LockGuard<'a>> {$/;"	f
trylock_noguard	_	pub unsafe fn trylock_noguard(&mut self) -> bool {$/;"	f
tty_open	_	fn tty_open(&mut self, fd: c_int, readable: bool)$/;"	f
ttyname	_	pub fn ttyname(fd: c_int) -> *c_char;$/;"	f
tuple	_	/^pub mod tuple;$/;"	m
two_pi	_	fn two_pi() -> f0 { 0.0 }$/;"	f
two_pi	_	fn two_pi() -> f0 { 0.0 }$/;"	f
two_pi	_	fn two_pi() -> Self;$/;"	f
type_id	_	pub fn type_id<T: 'static>() -> TypeId;$/;"	f
types	_	/^pub mod types {$/;"	m
u0_add_with_overflow	_	pub fn u0_add_with_overflow(x: u0, y: u0) -> (u0, bool);$/;"	f
u0_mul_with_overflow	_	pub fn u0_mul_with_overflow(x: u0, y: u0) -> (u0, bool);$/;"	f
u0_sub_with_overflow	_	pub fn u0_sub_with_overflow(x: u0, y: u0) -> (u0, bool);$/;"	f
u0x0	_	/^pub struct u0x0(u0, u0, u0, u0, u0, u0, u0, u0);$/;"	s
u0_add_with_overflow	_	pub fn u0_add_with_overflow(x: u0, y: u0) -> (u0, bool);$/;"	f
u0_mul_with_overflow	_	pub fn u0_mul_with_overflow(x: u0, y: u0) -> (u0, bool);$/;"	f
u0_sub_with_overflow	_	pub fn u0_sub_with_overflow(x: u0, y: u0) -> (u0, bool);$/;"	f
u0x0	_	/^pub struct u0x0(u0, u0, u0, u0);$/;"	s
u0_add_with_overflow	_	pub fn u0_add_with_overflow(x: u0, y: u0) -> (u0, bool);$/;"	f
u0_from_be_bytes	_	/^pub fn u0_from_be_bytes(data: &[u0],$/;"	f
u0_from_be_bytes_0_aligned	_	fn u0_from_be_bytes_0_aligned(bh: &mut BenchHarness) {$/;"	f
u0_from_be_bytes_0_unaligned	_	fn u0_from_be_bytes_0_unaligned(bh: &mut BenchHarness) {$/;"	f
u0_from_be_bytes_0_aligned	_	fn u0_from_be_bytes_0_aligned(bh: &mut BenchHarness) {$/;"	f
u0_from_be_bytes_0_unaligned	_	fn u0_from_be_bytes_0_unaligned(bh: &mut BenchHarness) {$/;"	f
u0_from_be_bytes_0_aligned	_	fn u0_from_be_bytes_0_aligned(bh: &mut BenchHarness) {$/;"	f
u0_from_be_bytes_0_unaligned	_	fn u0_from_be_bytes_0_unaligned(bh: &mut BenchHarness) {$/;"	f
u0_mul_with_overflow	_	pub fn u0_mul_with_overflow(x: u0, y: u0) -> (u0, bool);$/;"	f
u0_sub_with_overflow	_	pub fn u0_sub_with_overflow(x: u0, y: u0) -> (u0, bool);$/;"	f
u0_to_be_bytes	_	/^pub fn u0_to_be_bytes<T>(n: u0, size: uint, f: |v: &[u0]| -> T) -> T {$/;"	f
u0_to_le_bytes	_	/^pub fn u0_to_le_bytes<T>(n: u0, size: uint, f: |v: &[u0]| -> T) -> T {$/;"	f
u0x0	_	/^pub struct u0x0(u0, u0);$/;"	s
u0_add_with_overflow	_	pub fn u0_add_with_overflow(x: u0, y: u0) -> (u0, bool);$/;"	f
u0_mul_with_overflow	_	pub fn u0_mul_with_overflow(x: u0, y: u0) -> (u0, bool);$/;"	f
u0_sub_with_overflow	_	pub fn u0_sub_with_overflow(x: u0, y: u0) -> (u0, bool);$/;"	f
u0x0	_	/^pub struct u0x0(u0, u0, u0, u0, u0, u0, u0, u0, u0, u0, u0, u0, u0, u0, u0, u0);$/;"	s
udp	_	/^pub mod udp;$/;"	m
udp_bind	_	fn udp_bind(&mut self, addr: SocketAddr) -> Result<~RtioUdpSocket, IoError>;$/;"	f
uint	_	mod uint {$/;"	m
uint	_	mod uint {$/;"	m
ungetc	_	pub fn ungetc(c: c_int, stream: *FILE) -> c_int;$/;"	f
unicode	_	/^mod unicode;$/;"	m
uninit	_	pub fn uninit<T>() -> T;$/;"	f
uninit	_	/^pub unsafe fn uninit<T>() -> T {$/;"	f
unistd	_	pub mod unistd {$/;"	m
unit	_	/^pub mod unit;$/;"	m
unix	_	/^pub mod unix;$/;"	m
unix	_	pub mod unix {$/;"	m
unix_bind	_	fn unix_bind(&mut self, path: &CString) ->$/;"	f
unix_connect	_	fn unix_connect(&mut self, path: &CString) -> Result<~RtioPipe, IoError>;$/;"	f
unlink	_	/^pub fn unlink(path: &Path) -> IoResult<()> {$/;"	f
unlink	_	pub fn unlink(c: *c_char) -> c_int;$/;"	f
unlock	_	pub unsafe fn unlock(&mut self) { pthread_mutex_unlock(&mut self.lock); }$/;"	f
unlock	_	pub unsafe fn unlock(&mut self) {$/;"	f
unlock_noguard	_	pub unsafe fn unlock_noguard(&mut self) { self.inner.unlock() }$/;"	f
unlock_noguard	_	pub unsafe fn unlock_noguard(&mut self) { self.inner.unlock_noguard() }$/;"	f
unregister	_	pub fn unregister(&mut self, signum: Signum) {$/;"	f
unsafe_borrow	_	unsafe fn unsafe_borrow() -> *mut Self;$/;"	f
unsafe_borrow	_	unsafe fn unsafe_borrow() -> *mut Task { local_ptr::unsafe_borrow() }$/;"	f
unsafe_borrow	_	pub unsafe fn unsafe_borrow<T>() -> *mut T {$/;"	f
unsafe_get	_	fn unsafe_get(xs: &[u0], i: uint) -> u0 {$/;"	f
unsafe_mut_ref	_	unsafe fn unsafe_mut_ref(self, index: uint) -> &'a mut T {$/;"	f
unsafe_mut_ref	_	unsafe fn unsafe_mut_ref(self, index: uint) -> &'a mut T;$/;"	f
unsafe_ref	_	unsafe fn unsafe_ref(self, index: uint) -> &'a T {$/;"	f
unsafe_ref	_	unsafe fn unsafe_ref(self, index: uint) -> &'a T;$/;"	f
unsafe_set	_	unsafe fn unsafe_set(self, index: uint, val: T) {$/;"	f
unsafe_set	_	unsafe fn unsafe_set(self, index: uint, val: T);$/;"	f
unsafe_take	_	unsafe fn unsafe_take() -> ~Self;$/;"	f
unsafe_take	_	unsafe fn unsafe_take() -> ~Task { local_ptr::unsafe_take() }$/;"	f
unsafe_take	_	pub unsafe fn unsafe_take<T>() -> ~T {$/;"	f
unsetenv	_	pub fn unsetenv(name: *c_char) -> c_int;$/;"	f
unsetenv	_	/^pub fn unsetenv(n: &str) {$/;"	f
unshift	_	fn unshift(&mut self, x: T) {$/;"	f
unshift	_	fn unshift(&mut self, x: T);$/;"	f
unshift	_	pub fn unshift(&mut self, element: T) {$/;"	f
unshift_char	_	fn unshift_char(&mut self, ch: char) {$/;"	f
unshift_char	_	fn unshift_char(&mut self, ch: char);$/;"	f
unstable	_	/^pub mod unstable;$/;"	m
unwind	_	/^pub mod unwind;$/;"	m
unwind	_	fn unwind() {$/;"	f
unwinding	_	pub fn unwinding(&self) -> bool {$/;"	f
unwrap	_	pub unsafe fn unwrap(self) -> *libc::c_char {$/;"	f
unwrap	_	pub fn unwrap(self) -> T {$/;"	f
unwrap	_	pub fn unwrap(mut self) -> W {$/;"	f
unwrap	_	pub fn unwrap(self) -> R { self.inner }$/;"	f
unwrap	_	pub fn unwrap(self) -> S {$/;"	f
unwrap	_	pub fn unwrap(self) -> W { self.inner.unwrap() }$/;"	f
unwrap	_	pub fn unwrap(self) -> ~[u0] { self.buf }$/;"	f
unwrap	_	pub fn unwrap(self) -> (R, W) {$/;"	f
unwrap	_	pub fn unwrap(self) -> R { self.inner }$/;"	f
unwrap	_	pub fn unwrap(self) -> T {$/;"	f
unwrap	_	pub fn unwrap(self) -> V { self.inner }$/;"	f
unwrap	_	pub fn unwrap(self) -> T {$/;"	f
unwrap_err	_	pub fn unwrap_err(self) -> E {$/;"	f
unwrap_or	_	pub fn unwrap_or(self, def: T) -> T {$/;"	f
unwrap_or_default	_	pub fn unwrap_or_default(self) -> T {$/;"	f
unwrap_or_else	_	pub fn unwrap_or_else(self, f: || -> T) -> T {$/;"	f
unzip	_	/^pub fn unzip<T, U, V: Iterator<(T, U)>>(mut iter: V) -> (~[T], ~[U]) {$/;"	f
update	_	fn update(&mut self, _alloc: &mut AllocHeader, _orig: *AllocHeader) {}$/;"	f
update	_	fn update(&mut self, alloc: &mut AllocHeader, orig: *AllocHeader) {$/;"	f
update_entry	_	/^fn update_entry(dirs: &[LogDirective], entry: &ModEntry) -> u0 {$/;"	f
update_entry_match_beginning	_	/^fn update_entry_match_beginning() {$/;"	f
update_entry_match_beginning_longest_match	_	/^fn update_entry_match_beginning_longest_match() {$/;"	f
update_entry_match_default	_	/^fn update_entry_match_default() {$/;"	f
update_entry_match_full_path	_	/^fn update_entry_match_full_path() {$/;"	f
update_entry_no_match	_	/^fn update_entry_no_match() {$/;"	f
update_log_settings	_	/^fn update_log_settings(crate_map: &CrateMap, settings: &str) {$/;"	f
update_normalized	_	fn update_normalized<S: Str>(&mut self, s: S) {$/;"	f
update_sepidx	_	fn update_sepidx(&mut self) {$/;"	f
update_size	_	fn update_size(&mut self, _size: u0) {}$/;"	f
update_size	_	fn update_size(&mut self, size: u0) {$/;"	f
upgrade	_	pub fn upgrade(&mut self, up: Port<T>) -> UpgradeResult {$/;"	f
upgrade	_	pub fn upgrade(&mut self, up: Port<T>) -> UpgradeResult {$/;"	f
upgrade	_	pub fn upgrade(&self) -> Option<Rc<T>> {$/;"	f
usleep	_	pub fn usleep(secs: c_uint) -> c_int;$/;"	f
utf0_items	_	/^pub fn utf0_items<'a>(v: &'a [u0]) -> UTF0Items<'a> {$/;"	f
utf0_char_width	_	/^pub fn utf0_char_width(b: u0) -> uint {$/;"	f
util	_	/^pub mod util;$/;"	m
util	_	/^mod util;$/;"	m
utimbuf	_	pub struct utimbuf {$/;"	s
utime	_	fn utime() {$/;"	f
utime	_	pub fn utime(file: *c_char, buf: *utimbuf) -> c_int;$/;"	f
utime_noexist	_	fn utime_noexist() {$/;"	f
vec	_	/^pub mod vec;$/;"	m
vec_ng	_	/^pub mod vec_ng;$/;"	m
vec_str_conversions	_	fn vec_str_conversions() {$/;"	f
version	_	/^fn version(crate_map: &CrateMap) -> i0 {$/;"	f
visit_bool	_	fn visit_bool(&mut self) -> bool;$/;"	f
visit_bool	_	fn visit_bool(&mut self) -> bool {$/;"	f
visit_bool	_	fn visit_bool(&mut self) -> bool { self.write::<bool>() }$/;"	f
visit_bot	_	fn visit_bot(&mut self) -> bool;$/;"	f
visit_bot	_	fn visit_bot(&mut self) -> bool {$/;"	f
visit_bot	_	fn visit_bot(&mut self) -> bool {$/;"	f
visit_box	_	fn visit_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool;$/;"	f
visit_box	_	fn visit_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {$/;"	f
visit_box	_	fn visit_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {$/;"	f
visit_char	_	fn visit_char(&mut self) -> bool;$/;"	f
visit_char	_	fn visit_char(&mut self) -> bool {$/;"	f
visit_char	_	fn visit_char(&mut self) -> bool {$/;"	f
visit_class_field	_	fn visit_class_field(&mut self, i: uint, name: &str, named: bool,$/;"	f
visit_class_field	_	fn visit_class_field(&mut self, i: uint, name: &str, named: bool, mtbl: uint,$/;"	f
visit_class_field	_	fn visit_class_field(&mut self, i: uint, name: &str, named: bool,$/;"	f
visit_enter_class	_	fn visit_enter_class(&mut self, name: &str, named_fields: bool, n_fields: uint,$/;"	f
visit_enter_class	_	fn visit_enter_class(&mut self, name: &str, named_fields: bool, n_fields: uint, sz: uint,$/;"	f
visit_enter_class	_	fn visit_enter_class(&mut self, name: &str, named_fields: bool, n_fields: uint,$/;"	f
visit_enter_enum	_	fn visit_enter_enum(&mut self, n_variants: uint,$/;"	f
visit_enter_enum	_	fn visit_enter_enum(&mut self, n_variants: uint,$/;"	f
visit_enter_enum	_	fn visit_enter_enum(&mut self,$/;"	f
visit_enter_enum_variant	_	fn visit_enter_enum_variant(&mut self, variant: uint,$/;"	f
visit_enter_enum_variant	_	fn visit_enter_enum_variant(&mut self, variant: uint,$/;"	f
visit_enter_enum_variant	_	fn visit_enter_enum_variant(&mut self, _variant: uint,$/;"	f
visit_enter_fn	_	fn visit_enter_fn(&mut self, purity: uint, proto: uint,$/;"	f
visit_enter_fn	_	fn visit_enter_fn(&mut self, purity: uint, proto: uint,$/;"	f
visit_enter_fn	_	fn visit_enter_fn(&mut self, _purity: uint, _proto: uint,$/;"	f
visit_enter_rec	_	fn visit_enter_rec(&mut self, n_fields: uint,$/;"	f
visit_enter_rec	_	fn visit_enter_rec(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {$/;"	f
visit_enter_rec	_	fn visit_enter_rec(&mut self, _n_fields: uint,$/;"	f
visit_enter_tup	_	fn visit_enter_tup(&mut self, n_fields: uint,$/;"	f
visit_enter_tup	_	fn visit_enter_tup(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {$/;"	f
visit_enter_tup	_	fn visit_enter_tup(&mut self, _n_fields: uint,$/;"	f
visit_enum_variant_field	_	fn visit_enum_variant_field(&mut self, i: uint, offset: uint, inner: *TyDesc) -> bool;$/;"	f
visit_enum_variant_field	_	fn visit_enum_variant_field(&mut self, i: uint, offset: uint, inner: *TyDesc) -> bool {$/;"	f
visit_enum_variant_field	_	fn visit_enum_variant_field(&mut self,$/;"	f
visit_estr_box	_	fn visit_estr_box(&mut self) -> bool;$/;"	f
visit_estr_box	_	fn visit_estr_box(&mut self) -> bool {$/;"	f
visit_estr_box	_	fn visit_estr_box(&mut self) -> bool {$/;"	f
visit_estr_fixed	_	fn visit_estr_fixed(&mut self, n: uint, sz: uint, align: uint) -> bool;$/;"	f
visit_estr_fixed	_	fn visit_estr_fixed(&mut self, n: uint,$/;"	f
visit_estr_fixed	_	fn visit_estr_fixed(&mut self, _n: uint, _sz: uint,$/;"	f
visit_estr_slice	_	fn visit_estr_slice(&mut self) -> bool;$/;"	f
visit_estr_slice	_	fn visit_estr_slice(&mut self) -> bool {$/;"	f
visit_estr_slice	_	fn visit_estr_slice(&mut self) -> bool {$/;"	f
visit_estr_uniq	_	fn visit_estr_uniq(&mut self) -> bool;$/;"	f
visit_estr_uniq	_	fn visit_estr_uniq(&mut self) -> bool {$/;"	f
visit_estr_uniq	_	fn visit_estr_uniq(&mut self) -> bool {$/;"	f
visit_evec_box	_	fn visit_evec_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool;$/;"	f
visit_evec_box	_	fn visit_evec_box(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool {$/;"	f
visit_evec_box	_	fn visit_evec_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {$/;"	f
visit_evec_fixed	_	fn visit_evec_fixed(&mut self, n: uint, sz: uint, align: uint,$/;"	f
visit_evec_fixed	_	fn visit_evec_fixed(&mut self, n: uint, sz: uint, align: uint,$/;"	f
visit_evec_fixed	_	fn visit_evec_fixed(&mut self, n: uint, sz: uint, _align: uint,$/;"	f
visit_evec_slice	_	fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool;$/;"	f
visit_evec_slice	_	fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool {$/;"	f
visit_evec_slice	_	fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool {$/;"	f
visit_evec_uniq	_	fn visit_evec_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool;$/;"	f
visit_evec_uniq	_	fn visit_evec_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool {$/;"	f
visit_evec_uniq	_	fn visit_evec_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool {$/;"	f
visit_f0	_	fn visit_f0(&mut self) -> bool;$/;"	f
visit_f0	_	fn visit_f0(&mut self) -> bool {$/;"	f
visit_f0	_	fn visit_f0(&mut self) -> bool { self.write::<f0>() }$/;"	f
visit_f0	_	fn visit_f0(&mut self) -> bool;$/;"	f
visit_f0	_	fn visit_f0(&mut self) -> bool {$/;"	f
visit_f0	_	fn visit_f0(&mut self) -> bool { self.write::<f0>() }$/;"	f
visit_fn_input	_	fn visit_fn_input(&mut self, i: uint, mode: uint, inner: *TyDesc) -> bool;$/;"	f
visit_fn_input	_	fn visit_fn_input(&mut self, i: uint, mode: uint, inner: *TyDesc) -> bool {$/;"	f
visit_fn_input	_	fn visit_fn_input(&mut self, i: uint, _mode: uint, inner: *TyDesc) -> bool {$/;"	f
visit_fn_output	_	fn visit_fn_output(&mut self, retstyle: uint, variadic: bool, inner: *TyDesc) -> bool;$/;"	f
visit_fn_output	_	fn visit_fn_output(&mut self, retstyle: uint, variadic: bool, inner: *TyDesc) -> bool {$/;"	f
visit_fn_output	_	fn visit_fn_output(&mut self, _retstyle: uint, variadic: bool,$/;"	f
visit_i0	_	fn visit_i0(&mut self) -> bool;$/;"	f
visit_i0	_	fn visit_i0(&mut self) -> bool {$/;"	f
visit_i0	_	fn visit_i0(&mut self) -> bool { self.write::<i0>() }$/;"	f
visit_i0	_	fn visit_i0(&mut self) -> bool;$/;"	f
visit_i0	_	fn visit_i0(&mut self) -> bool {$/;"	f
visit_i0	_	fn visit_i0(&mut self) -> bool { self.write::<i0>()  }$/;"	f
visit_i0	_	fn visit_i0(&mut self) -> bool;$/;"	f
visit_i0	_	fn visit_i0(&mut self) -> bool {$/;"	f
visit_i0	_	fn visit_i0(&mut self) -> bool { self.write::<i0>() }$/;"	f
visit_i0	_	fn visit_i0(&mut self) -> bool;$/;"	f
visit_i0	_	fn visit_i0(&mut self) -> bool {$/;"	f
visit_i0	_	fn visit_i0(&mut self) -> bool { self.write::<i0>() }$/;"	f
visit_inner	_	pub fn visit_inner(&mut self, inner: *TyDesc) -> bool {$/;"	f
visit_int	_	fn visit_int(&mut self) -> bool;$/;"	f
visit_int	_	fn visit_int(&mut self) -> bool {$/;"	f
visit_int	_	fn visit_int(&mut self) -> bool { self.write::<int>() }$/;"	f
visit_leave_class	_	fn visit_leave_class(&mut self, name: &str, named_fields: bool, n_fields: uint,$/;"	f
visit_leave_class	_	fn visit_leave_class(&mut self, name: &str, named_fields: bool, n_fields: uint, sz: uint,$/;"	f
visit_leave_class	_	fn visit_leave_class(&mut self, _name: &str, named_fields: bool, n_fields: uint,$/;"	f
visit_leave_enum	_	fn visit_leave_enum(&mut self, n_variants: uint,$/;"	f
visit_leave_enum	_	fn visit_leave_enum(&mut self, n_variants: uint,$/;"	f
visit_leave_enum	_	fn visit_leave_enum(&mut self,$/;"	f
visit_leave_enum_variant	_	fn visit_leave_enum_variant(&mut self, variant: uint,$/;"	f
visit_leave_enum_variant	_	fn visit_leave_enum_variant(&mut self, variant: uint,$/;"	f
visit_leave_enum_variant	_	fn visit_leave_enum_variant(&mut self, _variant: uint,$/;"	f
visit_leave_fn	_	fn visit_leave_fn(&mut self, purity: uint, proto: uint,$/;"	f
visit_leave_fn	_	fn visit_leave_fn(&mut self, purity: uint, proto: uint,$/;"	f
visit_leave_fn	_	fn visit_leave_fn(&mut self, _purity: uint, _proto: uint,$/;"	f
visit_leave_rec	_	fn visit_leave_rec(&mut self, n_fields: uint,$/;"	f
visit_leave_rec	_	fn visit_leave_rec(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {$/;"	f
visit_leave_rec	_	fn visit_leave_rec(&mut self, _n_fields: uint,$/;"	f
visit_leave_tup	_	fn visit_leave_tup(&mut self, n_fields: uint,$/;"	f
visit_leave_tup	_	fn visit_leave_tup(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {$/;"	f
visit_leave_tup	_	fn visit_leave_tup(&mut self, _n_fields: uint,$/;"	f
visit_nil	_	fn visit_nil(&mut self) -> bool;$/;"	f
visit_nil	_	fn visit_nil(&mut self) -> bool {$/;"	f
visit_nil	_	fn visit_nil(&mut self) -> bool { self.write::<()>() }$/;"	f
visit_param	_	fn visit_param(&mut self, i: uint) -> bool;$/;"	f
visit_param	_	fn visit_param(&mut self, i: uint) -> bool {$/;"	f
visit_param	_	fn visit_param(&mut self, _i: uint) -> bool { true }$/;"	f
visit_ptr	_	fn visit_ptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool;$/;"	f
visit_ptr	_	fn visit_ptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool {$/;"	f
visit_ptr	_	fn visit_ptr(&mut self, mtbl: uint, _inner: *TyDesc) -> bool {$/;"	f
visit_ptr_inner	_	pub fn visit_ptr_inner(&mut self, ptr: *u0, inner: *TyDesc) -> bool {$/;"	f
visit_rec_field	_	fn visit_rec_field(&mut self, i: uint, name: &str,$/;"	f
visit_rec_field	_	fn visit_rec_field(&mut self, i: uint, name: &str,$/;"	f
visit_rec_field	_	fn visit_rec_field(&mut self, i: uint, name: &str,$/;"	f
visit_rptr	_	fn visit_rptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool;$/;"	f
visit_rptr	_	fn visit_rptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool {$/;"	f
visit_rptr	_	fn visit_rptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool {$/;"	f
visit_self	_	fn visit_self(&mut self) -> bool;$/;"	f
visit_self	_	fn visit_self(&mut self) -> bool {$/;"	f
visit_self	_	fn visit_self(&mut self) -> bool { true }$/;"	f
visit_trait	_	fn visit_trait(&mut self, name: &str) -> bool;$/;"	f
visit_trait	_	fn visit_trait(&mut self, name: &str) -> bool {$/;"	f
visit_trait	_	fn visit_trait(&mut self, name: &str) -> bool {$/;"	f
visit_tup_field	_	fn visit_tup_field(&mut self, i: uint, inner: *TyDesc) -> bool;$/;"	f
visit_tup_field	_	fn visit_tup_field(&mut self, i: uint, inner: *TyDesc) -> bool {$/;"	f
visit_tup_field	_	fn visit_tup_field(&mut self, i: uint, inner: *TyDesc) -> bool {$/;"	f
visit_tydesc	_	pub fn visit_tydesc(td: *TyDesc, tv: &mut TyVisitor);$/;"	f
visit_u0	_	fn visit_u0(&mut self) -> bool;$/;"	f
visit_u0	_	fn visit_u0(&mut self) -> bool {$/;"	f
visit_u0	_	fn visit_u0(&mut self) -> bool { self.write::<u0>() }$/;"	f
visit_u0	_	fn visit_u0(&mut self) -> bool;$/;"	f
visit_u0	_	fn visit_u0(&mut self) -> bool {$/;"	f
visit_u0	_	fn visit_u0(&mut self) -> bool { self.write::<u0>() }$/;"	f
visit_u0	_	fn visit_u0(&mut self) -> bool;$/;"	f
visit_u0	_	fn visit_u0(&mut self) -> bool {$/;"	f
visit_u0	_	fn visit_u0(&mut self) -> bool { self.write::<u0>() }$/;"	f
visit_u0	_	fn visit_u0(&mut self) -> bool;$/;"	f
visit_u0	_	fn visit_u0(&mut self) -> bool {$/;"	f
visit_u0	_	fn visit_u0(&mut self) -> bool { self.write::<u0>() }$/;"	f
visit_uint	_	fn visit_uint(&mut self) -> bool;$/;"	f
visit_uint	_	fn visit_uint(&mut self) -> bool {$/;"	f
visit_uint	_	fn visit_uint(&mut self) -> bool { self.write::<uint>() }$/;"	f
visit_unboxed_vec	_	fn visit_unboxed_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool;$/;"	f
visit_unboxed_vec	_	fn visit_unboxed_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool {$/;"	f
visit_unboxed_vec	_	fn visit_unboxed_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool {$/;"	f
visit_uniq	_	fn visit_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool;$/;"	f
visit_uniq	_	fn visit_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool {$/;"	f
visit_uniq	_	fn visit_uniq(&mut self, _mtbl: uint, inner: *TyDesc) -> bool {$/;"	f
visit_vec	_	fn visit_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool;$/;"	f
visit_vec	_	fn visit_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool {$/;"	f
visit_vec	_	fn visit_vec(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { fail!(); }$/;"	f
volatile_load	_	pub fn volatile_load<T>(src: *T) -> T;$/;"	f
volatile_store	_	pub fn volatile_store<T>(dst: *mut T, val: T);$/;"	f
wait	_	pub fn wait(&self) -> uint {$/;"	f
wait	_	pub fn wait(&mut self) -> ProcessExit {$/;"	f
wait	_	pub mod wait {$/;"	m
wait	_	fn wait(&mut self) -> ProcessExit;$/;"	f
wait	_	pub unsafe fn wait(&mut self) {$/;"	f
wait	_	pub unsafe fn wait(&mut self) {$/;"	f
wait0	_	fn wait0(&self, do_preflight_checks: bool) -> uint {$/;"	f
wait_for_other_tasks	_	/^pub fn wait_for_other_tasks() {$/;"	f
wait_noguard	_	pub unsafe fn wait_noguard(&mut self) { self.inner.wait() }$/;"	f
wait_noguard	_	pub unsafe fn wait_noguard(&mut self) { self.inner.wait_noguard() }$/;"	f
wait_with_output	_	pub fn wait_with_output(&mut self) -> ProcessOutput {$/;"	f
waitpid	_	pub fn waitpid(pid: pid_t, status: *mut c_int, options: c_int)$/;"	f
wake	_	pub fn wake(self) -> Option<~Task> {$/;"	f
walk_dir	_	/^pub fn walk_dir(path: &Path) -> IoResult<Directories> {$/;"	f
wchmod	_	pub fn wchmod(path: *wchar_t, mode: c_int) -> c_int;$/;"	f
wcslen	_	pub fn wcslen(buf: *wchar_t) -> size_t;$/;"	f
weak_rng	_	/^pub fn weak_rng() -> XorShiftRng {$/;"	f
weak_self_cyclic	_	fn weak_self_cyclic() {$/;"	f
while_some	_	pub fn while_some(self, blk: |v: T| -> Option<T>) {$/;"	f
win0	_	pub mod win0 {$/;"	m
win0	_	/^pub mod win0 {$/;"	m
windows	_	pub mod windows {$/;"	m
windows	_	/^pub mod windows;$/;"	m
windows	_	fn windows(self, size: uint) -> Windows<'a, T> {$/;"	f
windows	_	fn windows(self, size: uint) -> Windows<'a, T>;$/;"	f
winsize	_	pub fn winsize(&mut self) -> IoResult<(int, int)> {$/;"	f
with	_	pub fn with<U>(&self, blk: |&T| -> U) -> U {$/;"	f
with	_	pub unsafe fn with<U>(&self, f: |x: &mut T| -> U) -> U {$/;"	f
with_c_str	_	fn with_c_str<T>(&self, f: |*libc::c_char| -> T) -> T {$/;"	f
with_c_str	_	/^unsafe fn with_c_str<T>(v: &[u0], checked: bool, f: |*libc::c_char| -> T) -> T {$/;"	f
with_c_str_unchecked	_	unsafe fn with_c_str_unchecked<T>(&self, f: |*libc::c_char| -> T) -> T {$/;"	f
with_capacities	_	pub fn with_capacities(reader_cap: uint, writer_cap: uint, inner: S)$/;"	f
with_capacity	_	pub fn with_capacity(cap: uint, inner: R) -> BufferedReader<R> {$/;"	f
with_capacity	_	pub fn with_capacity(cap: uint, inner: W) -> BufferedWriter<W> {$/;"	f
with_capacity	_	pub fn with_capacity(n: uint) -> MemWriter {$/;"	f
with_capacity	_	/^pub fn with_capacity(capacity: uint) -> ~str {$/;"	f
with_capacity	_	fn with_capacity(capacity: uint) -> State<T> {$/;"	f
with_capacity	_	pub fn with_capacity(capacity: uint) -> Queue<T> {$/;"	f
with_capacity	_	/^pub fn with_capacity<T>(capacity: uint) -> ~[T] {$/;"	f
with_capacity	_	pub fn with_capacity(capacity: uint) -> Vec<T> {$/;"	f
with_env_lock	_	/^fn with_env_lock<T>(f: || -> T) -> T {$/;"	f
with_extension	_	fn with_extension<T: BytesContainer>(&self, extension: T) -> Self {$/;"	f
with_filename	_	fn with_filename<T: BytesContainer>(&self, filename: T) -> Self {$/;"	f
with_imm	_	pub unsafe fn with_imm<U>(&self, f: |x: &T| -> U) -> U {$/;"	f
with_lock	_	fn with_lock<T>(f: || -> T) -> T {$/;"	f
with_mut	_	pub fn with_mut<U>(&self, blk: |&mut T| -> U) -> U {$/;"	f
with_mut_ok	_	fn with_mut_ok() {$/;"	f
with_mut_ref	_	pub fn with_mut_ref<T>(&mut self, f: |*mut libc::c_char| -> T) -> T {$/;"	f
with_ok	_	fn with_ok() {$/;"	f
with_padding	_	fn with_padding(&mut self,$/;"	f
with_ref	_	pub fn with_ref<T>(&self, f: |*libc::c_char| -> T) -> T {$/;"	f
with_task_name	_	/^pub fn with_task_name<U>(blk: |Option<&str>| -> U) -> U {$/;"	f
with_task_stdout	_	/^fn with_task_stdout(f: |&mut Writer| -> IoResult<()> ) {$/;"	f
with_wrapper	_	pub fn with_wrapper(mut self, wrapper: proc(v: proc()) -> proc()) -> TaskBuilder {$/;"	f
wopen	_	pub fn wopen(path: *wchar_t, oflag: c_int, mode: c_int)$/;"	f
word	_	fn word(&mut self) -> &'a str {$/;"	f
words	_	fn words(&self) -> Words<'a> {$/;"	f
words	_	fn words(&self) -> Words<'a>;$/;"	f
wrap	_	fn wrap(~self) -> ~Any;$/;"	f
write	_	/^pub fn write(output: &mut io::Writer, args: &Arguments) -> Result {$/;"	f
write	_	fn write(&mut self, buf: &[u0]) -> IoResult<()> {$/;"	f
write	_	fn write(&mut self, msg: &[u0]) -> IoResult<()> {$/;"	f
write	_	fn write(&mut self, _: &[u0]) -> io::IoResult<()> { Ok(()) }$/;"	f
write	_	fn write(&mut self, _: &[u0]) -> io::IoResult<()> { Ok(()) }$/;"	f
write	_	fn write(&mut self, buf: &[u0]) -> IoResult<()> {$/;"	f
write	_	fn write(&mut self, buf: &[u0]) -> IoResult<()> {$/;"	f
write	_	fn write(&mut self, _buf: &[u0]) { fail!() }$/;"	f
write	_	fn write(&mut self, buf: &[u0]) -> IoResult<()> { self.fd.write(buf) }$/;"	f
write	_	fn write(&mut self, buf: &[u0]) -> IoResult<()> {$/;"	f
write	_	fn write(&mut self, buf: &[u0]) -> IoResult<()> { self.inner.write(buf) }$/;"	f
write	_	fn write(&mut self, buf: &[u0]) -> IoResult<()> { self.write(buf) }$/;"	f
write	_	fn write(&mut self, buf: &[u0]) -> IoResult<()>;$/;"	f
write	_	fn write(&mut self, buf: &[u0]) -> IoResult<()> { self.obj.write(buf) }$/;"	f
write	_	fn write(&mut self, buf: &[u0]) -> IoResult<()> {$/;"	f
write	_	fn write(&mut self, buf: &[u0]) -> IoResult<()> { self.obj.write(buf) }$/;"	f
write	_	fn write(&mut self, buf: &[u0]) -> IoResult<()> { self.obj.write(buf) }$/;"	f
write	_	fn write(&mut self, buf: &[u0]) -> IoResult<()> {$/;"	f
write	_	fn write(&mut self, data: &[u0]) -> IoResult<()> {$/;"	f
write	_	fn write(&mut self, buf: &[u0]) -> IoResult<()> {$/;"	f
write	_	fn write(&mut self, _buf: &[u0]) -> io::IoResult<()> {$/;"	f
write	_	fn write(&mut self, _buf: &[u0]) -> io::IoResult<()> { Ok(()) }$/;"	f
write	_	fn write(&mut self, buf: &[u0]) -> io::IoResult<()> {$/;"	f
write	_	pub fn write(fd: c_int, buf: *c_void, count: c_uint) -> c_int;$/;"	f
write	_	pub fn write(fd: c_int, buf: *c_void, count: size_t)$/;"	f
write	_	pub fn write<T:Repr>(&mut self) -> bool {$/;"	f
write	_	fn write(&mut self, buf: &[u0]) -> Result<(), IoError>;$/;"	f
write	_	fn write(&mut self, data: &[u0]) -> IoResult<()> {$/;"	f
write_be_f0	_	fn write_be_f0(&mut self, f: f0) -> IoResult<()> {$/;"	f
write_be_f0	_	fn write_be_f0(&mut self, f: f0) -> IoResult<()> {$/;"	f
write_be_i0	_	fn write_be_i0(&mut self, n: i0) -> IoResult<()> {$/;"	f
write_be_i0	_	fn write_be_i0(&mut self, n: i0) -> IoResult<()> {$/;"	f
write_be_i0	_	fn write_be_i0(&mut self, n: i0) -> IoResult<()> {$/;"	f
write_be_int	_	fn write_be_int(&mut self, n: int) -> IoResult<()> {$/;"	f
write_be_u0	_	fn write_be_u0(&mut self, n: u0) -> IoResult<()> {$/;"	f
write_be_u0	_	fn write_be_u0(&mut self, n: u0) -> IoResult<()> {$/;"	f
write_be_u0	_	fn write_be_u0(&mut self, n: u0) -> IoResult<()> {$/;"	f
write_be_uint	_	fn write_be_uint(&mut self, n: uint) -> IoResult<()> {$/;"	f
write_char	_	fn write_char(&mut self, c: char) -> IoResult<()> {$/;"	f
write_escaped_char	_	fn write_escaped_char(&mut self, ch: char, is_str: bool) -> bool {$/;"	f
write_escaped_slice	_	pub fn write_escaped_slice(&mut self, slice: &str) -> bool {$/;"	f
write_i0	_	fn write_i0(&mut self, n: i0) -> IoResult<()> {$/;"	f
write_int	_	fn write_int(&mut self, n: int) -> IoResult<()> {$/;"	f
write_le_f0	_	fn write_le_f0(&mut self, f: f0) -> IoResult<()> {$/;"	f
write_le_f0	_	fn write_le_f0(&mut self, f: f0) -> IoResult<()> {$/;"	f
write_le_i0	_	fn write_le_i0(&mut self, n: i0) -> IoResult<()> {$/;"	f
write_le_i0	_	fn write_le_i0(&mut self, n: i0) -> IoResult<()> {$/;"	f
write_le_i0	_	fn write_le_i0(&mut self, n: i0) -> IoResult<()> {$/;"	f
write_le_int	_	fn write_le_int(&mut self, n: int) -> IoResult<()> {$/;"	f
write_le_u0	_	fn write_le_u0(&mut self, n: u0) -> IoResult<()> {$/;"	f
write_le_u0	_	fn write_le_u0(&mut self, n: u0) -> IoResult<()> {$/;"	f
write_le_u0	_	fn write_le_u0(&mut self, n: u0) -> IoResult<()> {$/;"	f
write_le_uint	_	fn write_le_uint(&mut self, n: uint) -> IoResult<()> {$/;"	f
write_line	_	fn write_line(&mut self, s: &str) -> IoResult<()> {$/;"	f
write_mut_qualifier	_	pub fn write_mut_qualifier(&mut self, mtbl: uint) -> bool {$/;"	f
write_repr	_	fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()> {$/;"	f
write_repr	_	fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()>;$/;"	f
write_repr	_	/^pub fn write_repr<T>(writer: &mut io::Writer, object: &T) -> io::IoResult<()> {$/;"	f
write_str	_	fn write_str(&mut self, s: &str) -> IoResult<()> {$/;"	f
write_u0	_	fn write_u0(&mut self, n: u0) -> IoResult<()> {$/;"	f
write_uint	_	fn write_uint(&mut self, n: uint) -> IoResult<()> {$/;"	f
write_unboxed_vec_repr	_	pub fn write_unboxed_vec_repr(&mut self, _: uint, v: &raw::Vec<()>, inner: *TyDesc) -> bool {$/;"	f
write_unsafe	_	/^pub unsafe fn write_unsafe(output: &mut io::Writer,$/;"	f
write_vec_range	_	pub fn write_vec_range(&mut self, ptr: *(), len: uint, inner: *TyDesc) -> bool {$/;"	f
writeln	_	/^pub fn writeln(output: &mut io::Writer, args: &Arguments) -> Result {$/;"	f
wrmdir	_	pub fn wrmdir(path: *wchar_t) -> c_int;$/;"	f
ws	_	fn ws(&mut self) {$/;"	f
wsconsume	_	fn wsconsume(&mut self, c: char) -> bool {$/;"	f
wstat	_	pub fn wstat(path: *wchar_t, buf: *mut stat) -> c_int;$/;"	f
wutime	_	pub fn wutime(file: *wchar_t, buf: *utimbuf) -> c_int;$/;"	f
x0	_	pub mod x0 {$/;"	m
x0_0	_	pub mod x0_0 {$/;"	m
y0	_	pub fn y0(n: c_double) -> c_double;$/;"	f
y0	_	pub fn y0(n: c_double) -> c_double;$/;"	f
yield_now	_	fn yield_now(~self, cur_task: ~Task);$/;"	f
yield_now	_	pub fn yield_now(mut ~self) {$/;"	f
yield_now	_	pub fn yield_now() {$/;"	f
yield_now	_	pub unsafe fn yield_now() { assert_eq!(pthread_yield(), 0); }$/;"	f
yield_now	_	pub unsafe fn yield_now() { assert_eq!(sched_yield(), 0); }$/;"	f
yield_now	_	pub unsafe fn yield_now() {$/;"	f
yn	_	pub fn yn(i: c_int, n: c_double) -> c_double;$/;"	f
zero	_	fn zero() -> f0 { 0.0 }$/;"	f
zero	_	fn zero() -> f0 { 0.0 }$/;"	f
zero	_	fn zero() -> $T { 0 }$/;"	f
zero	_	fn zero() -> Self;$/;"	f
zero	_	fn zero() -> $T { 0 }$/;"	f
zero_0kb_fixed_repeat	_	fn zero_0kb_fixed_repeat(bh: &mut BenchHarness) {$/;"	f
zero_0kb_from_elem	_	fn zero_0kb_from_elem(bh: &mut BenchHarness) {$/;"	f
zero_0kb_loop_set	_	fn zero_0kb_loop_set(bh: &mut BenchHarness) {$/;"	f
zero_0kb_mut_iter	_	fn zero_0kb_mut_iter(bh: &mut BenchHarness) {$/;"	f
zero_0kb_set_memory	_	fn zero_0kb_set_memory(bh: &mut BenchHarness) {$/;"	f
zero_byte	_	fn zero_byte(val: u0, byte: uint) -> u0 {$/;"	f
zero_byte	_	fn zero_byte(val: u0, byte: uint) -> u0 {$/;"	f
zero_case	_	fn zero_case<R:Rng>(rng: &mut R, _u: f0) -> f0 {$/;"	f
zero_case	_	fn zero_case<R:Rng>(rng: &mut R, u: f0) -> f0 {$/;"	f
zero_memory	_	/^pub unsafe fn zero_memory<T>(dst: *mut T, count: uint) {$/;"	f
ziggurat	_	/^fn ziggurat<R:Rng>($/;"	f
ziggurat_tables	_	/^mod ziggurat_tables;$/;"	m
zip	_	fn zip<B, U: Iterator<B>>(self, other: U) -> Zip<Self, U> {$/;"	f
