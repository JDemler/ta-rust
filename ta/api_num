Add			impl Add<BigInt, BigInt> for BigInt 
Add			impl Add<BigUint, BigUint> for BigUint 
BigDigit			pub mod BigDigit 
BigInt			impl BigInt 
BigInt			pub struct BigInt 
BigUint			impl BigUint 
BigUint			pub struct BigUint 
BitAnd			impl BitAnd<BigUint, BigUint> for BigUint 
BitOr			impl BitOr<BigUint, BigUint> for BigUint 
BitXor			impl BitXor<BigUint, BigUint> for BigUint 
CheckedAdd			impl CheckedAdd for BigInt 
CheckedAdd			impl CheckedAdd for BigUint 
CheckedDiv			impl CheckedDiv for BigInt 
CheckedDiv			impl CheckedDiv for BigUint 
CheckedMul			impl CheckedMul for BigInt 
CheckedMul			impl CheckedMul for BigUint 
CheckedSub			impl CheckedSub for BigInt 
CheckedSub			impl CheckedSub for BigUint 
Complex			pub struct Complex<T> 
Default			impl Default for BigInt 
Default			impl Default for BigUint 
Div			impl Div<BigInt, BigInt> for BigInt 
Div			impl Div<BigUint, BigUint> for BigUint 
Eq			impl Eq for BigInt {}
Eq			impl Eq for BigUint {}
FromPrimitive			impl FromPrimitive for BigInt 
FromPrimitive			impl FromPrimitive for BigUint 
FromStr			impl FromStr for BigInt 
FromStr			impl FromStr for BigUint 
FromStrRadix			impl FromStrRadix for BigInt 
FromStrRadix			impl FromStrRadix for BigUint 
Integer			impl Integer for BigInt 
Integer			impl Integer for BigUint 
Integer			        impl Integer for 
Integer			pub trait Integer: Num + PartialOrd
Mul			impl Mul<BigInt, BigInt> for BigInt 
Mul			impl Mul<BigUint, BigUint> for BigUint 
Neg			impl Neg<BigInt> for BigInt 
Neg			impl Neg<BigUint> for BigUint 
Neg			impl Neg<Sign> for Sign 
Num			impl Num for BigInt {}
Num			impl Num for BigUint {}
One			impl One for BigInt 
One			impl One for BigUint 
Ord			impl Ord for BigInt 
Ord			impl Ord for BigUint 
PartialEq			impl PartialEq for BigInt 
PartialEq			impl PartialEq for BigUint 
PartialOrd			impl PartialOrd for BigInt 
PartialOrd			impl PartialOrd for BigUint 
RandBigInt			pub trait RandBigInt 
Ratio			impl Ratio<BigInt> 
Ratio			pub struct Ratio<T> 
Rem			impl Rem<BigInt, BigInt> for BigInt 
Rem			impl Rem<BigUint, BigUint> for BigUint 
Shl			impl Shl<uint, BigInt> for BigInt 
Shl			impl Shl<uint, BigUint> for BigUint 
Shr			impl Shr<uint, BigInt> for BigInt 
Shr			impl Shr<uint, BigUint> for BigUint 
Sign			pub enum Sign { Minus, Zero, Plus }
Signed			impl Signed for BigInt 
Sub			impl Sub<BigInt, BigInt> for BigInt 
Sub			impl Sub<BigUint, BigUint> for BigUint 
ToBigInt			        impl ToBigInt for 
ToBigInt			impl ToBigInt for BigInt 
ToBigInt			impl ToBigInt for BigUint 
ToBigInt			pub trait ToBigInt 
ToBigUint			        impl ToBigUint for 
ToBigUint			impl ToBigUint for BigInt 
ToBigUint			impl ToBigUint for BigUint 
ToBigUint			pub trait ToBigUint 
ToPrimitive			impl ToPrimitive for BigInt 
ToPrimitive			impl ToPrimitive for BigUint 
ToStrRadix			impl ToStrRadix for BigInt 
ToStrRadix			impl ToStrRadix for BigUint 
Unsigned			impl Unsigned for BigUint {}
Zero			impl Zero for BigInt 
Zero			impl Zero for BigUint 
abs			    fn abs(&self) -> BigInt 
abs_sub			    fn abs_sub(&self, other: &BigInt) -> BigInt 
add			    fn add(&self, other: &BigInt) -> BigInt 
add			    fn add(&self, other: &BigUint) -> BigUint 
add			    fn add(&self, other: &Complex<T>) -> Complex<T> 
arg			    pub fn arg(&self) -> T 
arith			    mod arith 
arith			    mod arith 
bench			mod bench 
bigint			pub mod bigint;
bigint_tests			mod bigint_tests 
biguint_tests			mod biguint_tests 
bitand			    fn bitand(&self, other: &BigUint) -> BigUint 
bitor			    fn bitor(&self, other: &BigUint) -> BigUint 
bits			    pub fn bits(&self) -> uint 
bitxor			    fn bitxor(&self, other: &BigUint) -> BigUint 
ceil			    pub fn ceil(&self) -> Ratio<T> 
check			        fn check(a: &BigInt, b: &BigInt, d: &BigInt, m: &BigInt) 
check			        fn check(a: &BigInt, b: &BigInt, q: &BigInt, r: &BigInt) 
check			        fn check(a: int, b: int, c: int) 
check			        fn check(a: uint, b: uint, c: uint) 
check			        fn check(b1: BigInt, i: i64) 
check			        fn check(b1: BigInt, u: u64) 
check			        fn check(b1: BigUint, i: i64) 
check			        fn check(b1: BigUint, u: u64) 
check			        fn check(inp_s: Sign, inp_n: uint, ans_s: Sign, ans_n: uint) 
check			        fn check(l: BigInt, u: BigInt) 
check			        fn check(left: &[BigDigit],
check			        fn check(n: BigInt, ans_1: BigUint) 
check			        fn check(n: BigUint, ans: BigInt) 
check			        fn check(n: int, ans: &str) 
check			        fn check(n: uint, s: &str) 
check			        fn check(s: &str, ans: Option<int>) 
check			        fn check(s: &str, shift: uint, ans: &str) 
check			        fn check(slice: &[BigDigit], data: &[BigDigit]) 
check_sub			        fn check_sub(a: &BigInt, b: &BigInt, ans_d: &BigInt, ans_m: &BigInt) 
check_sub			        fn check_sub(a: &BigInt, b: &BigInt, ans_q: &BigInt, ans_r: &BigInt) 
checked_add			    fn checked_add(&self, v: &BigInt) -> Option<BigInt> 
checked_add			    fn checked_add(&self, v: &BigUint) -> Option<BigUint> 
checked_div			    fn checked_div(&self, v: &BigInt) -> Option<BigInt> 
checked_div			    fn checked_div(&self, v: &BigUint) -> Option<BigUint> 
checked_mul			    fn checked_mul(&self, v: &BigInt) -> Option<BigInt> 
checked_mul			    fn checked_mul(&self, v: &BigUint) -> Option<BigUint> 
checked_sub			    fn checked_sub(&self, v: &BigInt) -> Option<BigInt> 
checked_sub			    fn checked_sub(&self, v: &BigUint) -> Option<BigUint> 
cmp			    fn cmp(&self, other: &BigInt) -> Ordering 
cmp			    fn cmp(&self, other: &BigUint) -> Ordering 
complex			pub mod complex;
conj			    pub fn conj(&self) -> Complex<T> 
convert_base			        fn convert_base(n: &BigUint, base: DoubleBigDigit) -> Vec<BigDigit> 
cut_at			        fn cut_at(a: &BigUint, n: uint) -> (BigUint, BigUint) 
default			    fn default() -> BigInt { Zero::zero() }
default			    fn default() -> BigUint { Zero::zero() }
denom			    pub fn denom<'a>(&'a self) -> &'a T 
div			    fn div(&self, other: &BigInt) -> BigInt 
div			    fn div(&self, other: &BigUint) -> BigUint 
div			    fn div(&self, other: &Complex<T>) -> Complex<T> 
div			    fn div(&self, rhs: &Ratio<T>) -> Ratio<T> 
div_estimate			        fn div_estimate(a: &BigUint, b: &BigUint, n: uint)
div_floor			    fn div_floor(&self, other: &BigInt) -> BigInt 
div_floor			    fn div_floor(&self, other: &BigUint) -> BigUint 
div_floor			            fn div_floor(&self, other: &
div_floor			            fn div_floor(&self, other: &
div_floor			    fn div_floor(&self, other: &Self) -> Self;
div_mod_floor			    fn div_mod_floor(&self, other: &BigInt) -> (BigInt, BigInt) 
div_mod_floor			    fn div_mod_floor(&self, other: &BigUint) -> (BigUint, BigUint) 
div_mod_floor			            fn div_mod_floor(&self, other: &
div_mod_floor			    fn div_mod_floor(&self, other: &Self) -> (Self, Self) 
div_mod_floor_inner			        fn div_mod_floor_inner(a: BigUint, b: BigUint) -> (BigUint, BigUint) 
div_rem			    fn div_rem(&self, other: &BigInt) -> (BigInt, BigInt) 
div_rem			    fn div_rem(&self, other: &BigUint) -> (BigUint, BigUint) 
div_rem			    fn div_rem(&self, other: &Self) -> (Self, Self) 
divides			    fn divides(&self, other: &BigInt) -> bool { self.data.divides(&other.data) }
divides			    fn divides(&self, other: &BigUint) -> bool { (*self % *other).is_zero() }
divides			            fn divides(&self, other: &
divides			    fn divides(&self, other: &Self) -> bool;
eq			    fn eq(&self, other: &BigInt) -> bool 
eq			    fn eq(&self, other: &BigUint) -> bool 
factor			        fn factor(n: uint) -> BigUint 
factorial			    fn factorial(n: uint) -> BigUint 
factorial_100			    fn factorial_100(b: &mut Bencher) 
fib			    fn fib(n: uint) -> BigUint 
fib_100			    fn fib_100(b: &mut Bencher) 
fill_concat			        fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> String 
floor			    pub fn floor(&self) -> Ratio<T> 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			impl fmt::Show for BigInt 
fmt			impl fmt::Show for BigUint 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fract			    pub fn fract(&self) -> Ratio<T> 
from_biguint			    pub fn from_biguint(sign: Sign, data: BigUint) -> BigInt 
from_doublebigdigit			    pub fn from_doublebigdigit(n: DoubleBigDigit) -> (BigDigit, BigDigit) 
from_float			    pub fn from_float<T: Float>(f: T) -> Option<BigRational> 
from_i64			    fn from_i64(n: i64) -> Option<BigInt> 
from_i64			    fn from_i64(n: i64) -> Option<BigUint> 
from_integer			    pub fn from_integer(t: T) -> Ratio<T> 
from_polar			    pub fn from_polar(r: &T, theta: &T) -> Complex<T> 
from_slice			    pub fn from_slice(sign: Sign, slice: &[BigDigit]) -> BigInt 
from_slice			    pub fn from_slice(slice: &[BigDigit]) -> BigUint 
from_str			    fn from_str(s: &str) -> Option<BigInt> 
from_str			    fn from_str(s: &str) -> Option<BigUint> 
from_str			    fn from_str(s: &str) -> Option<Ratio<T>> 
from_str_radix			    fn from_str_radix(s: &str, radix: uint) -> Option<BigInt> 
from_str_radix			    fn from_str_radix(s: &str, radix: uint) -> Option<BigUint> 
from_str_radix			    fn from_str_radix(s: &str, radix: uint) -> Option<Ratio<T>> 
from_u64			    fn from_u64(n: u64) -> Option<BigInt> 
from_u64			    fn from_u64(n: u64) -> Option<BigUint> 
gcd			    fn gcd(&self, other: &BigInt) -> BigInt 
gcd			    fn gcd(&self, other: &BigUint) -> BigUint 
gcd			            fn gcd(&self, other: &
gcd			    fn gcd(&self, other: &Self) -> Self;
gen_bigint			    fn gen_bigint(&mut self, bit_size: uint) -> BigInt 
gen_bigint			    fn gen_bigint(&mut self, bit_size: uint) -> BigInt;
gen_bigint_range			    fn gen_bigint_range(&mut self, lbound: &BigInt, ubound: &BigInt) -> BigInt;
gen_bigint_range			    fn gen_bigint_range(&mut self,
gen_biguint			    fn gen_biguint(&mut self, bit_size: uint) -> BigUint 
gen_biguint			    fn gen_biguint(&mut self, bit_size: uint) -> BigUint;
gen_biguint_below			    fn gen_biguint_below(&mut self, bound: &BigUint) -> BigUint 
gen_biguint_below			    fn gen_biguint_below(&mut self, bound: &BigUint) -> BigUint;
gen_biguint_range			    fn gen_biguint_range(&mut self, lbound: &BigUint, ubound: &BigUint) -> BigUint;
gen_biguint_range			    fn gen_biguint_range(&mut self,
get_hi			    fn get_hi(n: DoubleBigDigit) -> BigDigit { (n >> bits) as BigDigit }
get_lo			    fn get_lo(n: DoubleBigDigit) -> BigDigit { (n & lo_mask) as BigDigit }
get_radix_base			fn get_radix_base(radix: uint) -> (DoubleBigDigit, uint) 
integer			pub mod integer;
inv			    pub fn inv(&self) -> Complex<T> 
is_even			    fn is_even(&self) -> bool { self.data.is_even() }
is_even			    fn is_even(&self) -> bool 
is_even			            fn is_even(&self) -> bool { self & 1 == 0 }
is_even			    fn is_even(&self) -> bool;
is_integer			    pub fn is_integer(&self) -> bool 
is_negative			    fn is_negative(&self) -> bool { self.sign == Minus }
is_odd			    fn is_odd(&self) -> bool { !self.is_even() }
is_odd			    fn is_odd(&self) -> bool { self.data.is_odd() }
is_odd			            fn is_odd(&self) -> bool { !self.is_even() }
is_odd			    fn is_odd(&self) -> bool;
is_positive			    fn is_positive(&self) -> bool { self.sign == Plus }
is_zero			    fn is_zero(&self) -> bool { self.data.is_empty() }
is_zero			    fn is_zero(&self) -> bool { self.sign == Zero }
is_zero			    fn is_zero(&self) -> bool 
is_zero			    fn is_zero(&self) -> bool 
lcm			    fn lcm(&self, other: &BigInt) -> BigInt 
lcm			    fn lcm(&self, other: &BigUint) -> BigUint { ((*self * *other) \/ self.gcd(other)) }
lcm			            fn lcm(&self, other: &
lcm			    fn lcm(&self, other: &Self) -> Self;
mod_floor			    fn mod_floor(&self, other: &BigInt) -> BigInt 
mod_floor			    fn mod_floor(&self, other: &BigUint) -> BigUint 
mod_floor			            fn mod_floor(&self, other: &
mod_floor			            fn mod_floor(&self, other: &
mod_floor			    fn mod_floor(&self, other: &Self) -> Self;
mul			    fn mul(&self, other: &BigInt) -> BigInt 
mul			    fn mul(&self, other: &BigUint) -> BigUint 
mul			    fn mul(&self, other: &Complex<T>) -> Complex<T> 
mul			    fn mul(&self, rhs: &Ratio<T>) -> Ratio<T> 
mul_digit			        fn mul_digit(a: &BigUint, n: BigDigit) -> BigUint 
neg			    fn neg(&self) -> BigInt 
neg			    fn neg(&self) -> BigUint { fail!() }
neg			    fn neg(&self) -> Sign 
neg			    fn neg(&self) -> Complex<T> 
neg			    fn neg(&self) -> Ratio<T> 
new			    pub fn new(mut digits: Vec<BigDigit>) -> BigUint 
new			    pub fn new(sign: Sign, digits: Vec<BigDigit>) -> BigInt 
new			    pub fn new(re: T, im: T) -> Complex<T> 
new			    pub fn new(numer: T, denom: T) -> Ratio<T> 
new_raw			    pub fn new_raw(numer: T, denom: T) -> Ratio<T> 
norm			    pub fn norm(&self) -> T 
norm_sqr			    pub fn norm_sqr(&self) -> T 
numer			    pub fn numer<'a>(&'a self) -> &'a T 
one			    fn one() -> BigInt 
one			    fn one() -> BigUint { BigUint::new(vec!(1)) }
one			    fn one() -> Complex<T> 
one			    fn one() -> Ratio<T> 
parse_bytes			    pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<BigInt> 
parse_bytes			    pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<BigUint> 
partial_cmp			    fn partial_cmp(&self, other: &BigInt) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &BigUint) -> Option<Ordering> 
rational			pub mod rational;
recip			    pub fn recip(&self) -> Ratio<T> 
reduce			    fn reduce(&mut self) 
reduced			    pub fn reduced(&self) -> Ratio<T> 
rem			    fn rem(&self, other: &BigInt) -> BigInt 
rem			    fn rem(&self, other: &BigUint) -> BigUint 
round			    pub fn round(&self) -> Ratio<T> 
scale			    pub fn scale(&self, t: T) -> Complex<T> 
shl			    fn shl(&self, rhs: &uint) -> BigInt 
shl			    fn shl(&self, rhs: &uint) -> BigUint 
shl_bits			    fn shl_bits(&self, n_bits: uint) -> BigUint 
shl_unit			    fn shl_unit(&self, n_unit: uint) -> BigUint 
shr			    fn shr(&self, rhs: &uint) -> BigInt 
shr			    fn shr(&self, rhs: &uint) -> BigUint 
shr			    fn shr(b: &mut Bencher) 
shr_bits			    fn shr_bits(&self, n_bits: uint) -> BigUint 
shr_unit			    fn shr_unit(&self, n_unit: uint) -> BigUint 
signum			    fn signum(&self) -> BigInt 
sub			    fn sub(&self, other: &BigInt) -> BigInt 
sub			    fn sub(&self, other: &BigUint) -> BigUint 
sub			    fn sub(&self, other: &Complex<T>) -> Complex<T> 
sub_sign			        fn sub_sign(a: BigUint, b: BigUint) -> (Ordering, BigUint) 
test			        fn test(c : Complex64, r : f64, i: f64) 
test			        fn test(c : Complex64, s: String) 
test			        fn test(c: Complex64) 
test			        fn test(c: Complex64, arg: f64) 
test			        fn test(c: Complex64, ns: f64) 
test			mod test 
test			            fn test(a: Rational, b: Rational) 
test			            fn test(a: Rational, b: Rational, c: Rational) 
test			        fn test(r: Rational, s: String) 
test			        fn test(r: Rational, s: String, n: uint) 
test			        fn test(s: &str) 
test			        fn test<T: Float>(given: T, (numer, denom): (&str, &str)) 
test			mod test 
test16			        fn test16(r: Rational, s: String) { test(r, s, 16) }
test3			        fn test3(r: Rational, s: String) { test(r, s, 3) }
to_big			    pub fn to_big(n: Rational) -> BigRational 
to_bigint			            fn to_bigint(&self) -> Option<BigInt> 
to_bigint			    fn to_bigint(&self) -> Option<BigInt> 
to_bigint			    fn to_bigint(&self) -> Option<BigInt>;
to_biguint			            fn to_biguint(&self) -> Option<BigUint> 
to_biguint			    fn to_biguint(&self) -> Option<BigUint> 
to_biguint			    fn to_biguint(&self) -> Option<BigUint>;
to_biguint			    pub fn to_biguint(&self) -> Option<BigUint> 
to_doublebigdigit			    pub fn to_doublebigdigit(hi: BigDigit, lo: BigDigit) -> DoubleBigDigit 
to_i64			    fn to_i64(&self) -> Option<i64> 
to_integer			    pub fn to_integer(&self) -> T 
to_polar			    pub fn to_polar(&self) -> (T, T) 
to_str			    fn to_str(b: &mut Bencher) 
to_str_pairs			    fn to_str_pairs() -> Vec<(BigUint, Vec<(uint, String)>)> 
to_str_radix			    fn to_str_radix(&self, radix: uint) -> String 
to_str_radix			    fn to_str_radix(&self, radix: uint) -> String 
to_str_radix			    fn to_str_radix(&self, radix: uint) -> String 
to_u64			    fn to_u64(&self) -> Option<u64> 
trunc			    pub fn trunc(&self) -> Ratio<T> 
unscale			    pub fn unscale(&self, t: T) -> Complex<T> 
zero			    fn zero() -> BigInt 
zero			    fn zero() -> BigUint { BigUint::new(Vec::new()) }
zero			    fn zero() -> Complex<T> 
zero			    fn zero() -> Ratio<T> 
