Add			impl Add<BigInt, BigInt> for BigInt 
Add			impl Add<BigUint, BigUint> for BigUint 
BigDigit			pub mod BigDigit 
BigInt			impl BigInt 
BigInt			pub struct BigInt 
BigUint			impl BigUint 
BigUint			pub struct BigUint 
BitAnd			impl BitAnd<BigUint, BigUint> for BigUint 
BitOr			impl BitOr<BigUint, BigUint> for BigUint 
BitXor			impl BitXor<BigUint, BigUint> for BigUint 
CheckedAdd			impl CheckedAdd for BigInt 
CheckedAdd			impl CheckedAdd for BigUint 
CheckedDiv			impl CheckedDiv for BigInt 
CheckedDiv			impl CheckedDiv for BigUint 
CheckedMul			impl CheckedMul for BigInt 
CheckedMul			impl CheckedMul for BigUint 
CheckedSub			impl CheckedSub for BigInt 
CheckedSub			impl CheckedSub for BigUint 
Cmplx			pub struct Cmplx<T> 
Div			impl Div<BigInt, BigInt> for BigInt 
Div			impl Div<BigUint, BigUint> for BigUint 
Eq			impl Eq for BigInt 
Eq			impl Eq for BigUint 
FromPrimitive			impl FromPrimitive for BigInt 
FromPrimitive			impl FromPrimitive for BigUint 
FromStr			impl FromStr for BigInt 
FromStr			impl FromStr for BigUint 
FromStrRadix			impl FromStrRadix for BigInt 
FromStrRadix			impl FromStrRadix for BigUint 
Integer			impl Integer for BigInt 
Integer			impl Integer for BigUint 
Integer			        impl Integer for $T 
Integer			pub trait Integer: Num + Ord
Mul			impl Mul<BigInt, BigInt> for BigInt 
Mul			impl Mul<BigUint, BigUint> for BigUint 
Neg			impl Neg<BigInt> for BigInt 
Neg			impl Neg<BigUint> for BigUint 
Neg			impl Neg<Sign> for Sign 
Num			impl Num for BigInt {}
Num			impl Num for BigUint {}
One			impl One for BigInt 
One			impl One for BigUint 
Ord			impl Ord for BigInt 
Ord			impl Ord for BigUint 
RandBigInt			pub trait RandBigInt 
Ratio			impl Ratio<BigInt> 
Ratio			pub struct Ratio<T> 
Rem			impl Rem<BigInt, BigInt> for BigInt 
Rem			impl Rem<BigUint, BigUint> for BigUint 
Shl			impl Shl<uint, BigInt> for BigInt 
Shl			impl Shl<uint, BigUint> for BigUint 
Shr			impl Shr<uint, BigInt> for BigInt 
Shr			impl Shr<uint, BigUint> for BigUint 
Sign			pub enum Sign { Minus, Zero, Plus }
Signed			impl Signed for BigInt 
Sub			impl Sub<BigInt, BigInt> for BigInt 
Sub			impl Sub<BigUint, BigUint> for BigUint 
ToBigInt			        impl ToBigInt for $T 
ToBigInt			impl ToBigInt for BigInt 
ToBigInt			impl ToBigInt for BigUint 
ToBigInt			pub trait ToBigInt 
ToBigUint			        impl ToBigUint for $T 
ToBigUint			impl ToBigUint for BigInt 
ToBigUint			impl ToBigUint for BigUint 
ToBigUint			pub trait ToBigUint 
ToPrimitive			impl ToPrimitive for BigInt 
ToPrimitive			impl ToPrimitive for BigUint 
ToStrRadix			impl ToStrRadix for BigInt 
ToStrRadix			impl ToStrRadix for BigUint 
TotalEq			impl TotalEq for BigInt {}
TotalEq			impl TotalEq for BigUint {}
TotalOrd			impl TotalOrd for BigInt 
TotalOrd			impl TotalOrd for BigUint 
Unsigned			impl Unsigned for BigUint {}
Zero			impl Zero for BigInt 
Zero			impl Zero for BigUint 
abs			    fn abs(&self) -> BigInt 
abs_sub			    fn abs_sub(&self, other: &BigInt) -> BigInt 
add			    fn add(&self, other: &BigInt) -> BigInt 
add			    fn add(&self, other: &BigUint) -> BigUint 
add			    fn add(&self, other: &Cmplx<T>) -> Cmplx<T> 
arg			    pub fn arg(&self) -> T 
arith			    mod arith 
arith			    mod arith 
bench			mod bench 
bigint			pub mod bigint;
bigint_tests			mod bigint_tests 
biguint_tests			mod biguint_tests 
bitand			    fn bitand(&self, other: &BigUint) -> BigUint 
bitor			    fn bitor(&self, other: &BigUint) -> BigUint 
bits			    pub fn bits(&self) -> uint 
bitxor			    fn bitxor(&self, other: &BigUint) -> BigUint 
ceil			    fn ceil(&self) -> Ratio<T> 
check			        fn check(a: &BigInt, b: &BigInt, d: &BigInt, m: &BigInt) 
check			        fn check(a: &BigInt, b: &BigInt, q: &BigInt, r: &BigInt) 
check			        fn check(a: int, b: int, c: int) 
check			        fn check(a: uint, b: uint, c: uint) 
check			        fn check(b1: BigInt, i: i64) 
check			        fn check(b1: BigInt, u: u64) 
check			        fn check(b1: BigUint, i: i64) 
check			        fn check(b1: BigUint, u: u64) 
check			        fn check(inp_s: Sign, inp_n: uint, ans_s: Sign, ans_n: uint) 
check			        fn check(l: BigInt, u: BigInt) 
check			        fn check(left: &[BigDigit],
check			        fn check(n: BigInt, ans_1: BigUint) 
check			        fn check(n: BigUint, ans: BigInt) 
check			        fn check(n: int, ans: &str) 
check			        fn check(n: uint, s: &str) 
check			        fn check(s: &str, ans: Option<int>) 
check			        fn check(s: &str, shift: uint, ans: &str) 
check			        fn check(slice: &[BigDigit], data: &[BigDigit]) 
check_sub			        fn check_sub(a: &BigInt, b: &BigInt, ans_d: &BigInt, ans_m: &BigInt) 
check_sub			        fn check_sub(a: &BigInt, b: &BigInt, ans_q: &BigInt, ans_r: &BigInt) 
checked_add			    fn checked_add(&self, v: &BigInt) -> Option<BigInt> 
checked_add			    fn checked_add(&self, v: &BigUint) -> Option<BigUint> 
checked_div			    fn checked_div(&self, v: &BigInt) -> Option<BigInt> 
checked_div			    fn checked_div(&self, v: &BigUint) -> Option<BigUint> 
checked_mul			    fn checked_mul(&self, v: &BigInt) -> Option<BigInt> 
checked_mul			    fn checked_mul(&self, v: &BigUint) -> Option<BigUint> 
checked_sub			    fn checked_sub(&self, v: &BigInt) -> Option<BigInt> 
checked_sub			    fn checked_sub(&self, v: &BigUint) -> Option<BigUint> 
cmp			    fn cmp(&self, other: &BigInt) -> Ordering 
cmp			    fn cmp(&self, other: &BigUint) -> Ordering 
complex			pub mod complex;
conj			    pub fn conj(&self) -> Cmplx<T> 
convert_base			        fn convert_base(n: &BigUint, base: uint) -> Vec<BigDigit> 
cut_at			        fn cut_at(a: &BigUint, n: uint) -> (BigUint, BigUint) 
denom			    pub fn denom<'a>(&'a self) -> &'a T 
div			    fn div(&self, other: &BigInt) -> BigInt 
div			    fn div(&self, other: &BigUint) -> BigUint 
div			    fn div(&self, other: &Cmplx<T>) -> Cmplx<T> 
div			    fn div(&self, rhs: &Ratio<T>) -> Ratio<T> 
div_estimate			        fn div_estimate(a: &BigUint, b: &BigUint, n: uint)
div_floor			    fn div_floor(&self, other: &BigInt) -> BigInt 
div_floor			    fn div_floor(&self, other: &BigUint) -> BigUint 
div_floor			            fn div_floor(&self, other: &$T) -> $T { *self \/ *other }
div_floor			            fn div_floor(&self, other: &$T) -> $T 
div_floor			    fn div_floor(&self, other: &Self) -> Self;
div_mod_floor			    fn div_mod_floor(&self, other: &BigInt) -> (BigInt, BigInt) 
div_mod_floor			    fn div_mod_floor(&self, other: &BigUint) -> (BigUint, BigUint) 
div_mod_floor			            fn div_mod_floor(&self, other: &$T) -> ($T,$T) 
div_mod_floor			    fn div_mod_floor(&self, other: &Self) -> (Self, Self) 
div_mod_floor_inner			        fn div_mod_floor_inner(a: BigUint, b: BigUint) -> (BigUint, BigUint) 
div_rem			    fn div_rem(&self, other: &BigInt) -> (BigInt, BigInt) 
div_rem			    fn div_rem(&self, other: &BigUint) -> (BigUint, BigUint) 
div_rem			    fn div_rem(&self, other: &Self) -> (Self, Self) 
divides			    fn divides(&self, other: &BigInt) -> bool { self.data.divides(&other.data) }
divides			    fn divides(&self, other: &BigUint) -> bool { (*self % *other).is_zero() }
divides			            fn divides(&self, other: &$T) -> bool { *self % *other == 0 }
divides			    fn divides(&self, other: &Self) -> bool;
eq			    fn eq(&self, other: &BigInt) -> bool 
eq			    fn eq(&self, other: &BigUint) -> bool 
factor			        fn factor(n: uint) -> BigUint 
factorial			    fn factorial(n: uint) -> BigUint 
factorial_100			    fn factorial_100(bh: &mut BenchHarness) 
fib			    fn fib(n: uint) -> BigUint 
fib_100			    fn fib_100(bh: &mut BenchHarness) 
fill_concat			        fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> ~str 
floor			    fn floor(&self) -> Ratio<T> 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			impl fmt::Show for BigInt 
fmt			impl fmt::Show for BigUint 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fract			    fn fract(&self) -> Ratio<T> 
from_biguint			    pub fn from_biguint(sign: Sign, data: BigUint) -> BigInt 
from_float			    pub fn from_float<T: Float>(f: T) -> Option<BigRational> 
from_i64			    fn from_i64(n: i64) -> Option<BigInt> 
from_i64			    fn from_i64(n: i64) -> Option<BigUint> 
from_integer			    pub fn from_integer(t: T) -> Ratio<T> 
from_polar			    pub fn from_polar(r: &T, theta: &T) -> Cmplx<T> 
from_slice			    pub fn from_slice(sign: Sign, slice: &[BigDigit]) -> BigInt 
from_slice			    pub fn from_slice(slice: &[BigDigit]) -> BigUint 
from_str			    fn from_str(s: &str) -> Option<BigInt> 
from_str			    fn from_str(s: &str) -> Option<BigUint> 
from_str			    fn from_str(s: &str) -> Option<Ratio<T>> 
from_str_radix			    fn from_str_radix(s: &str, radix: uint) -> Option<BigInt> 
from_str_radix			    fn from_str_radix(s: &str, radix: uint)
from_str_radix			    fn from_str_radix(s: &str, radix: uint) -> Option<Ratio<T>> 
from_u64			    fn from_u64(n: u64) -> Option<BigInt> 
from_u64			    fn from_u64(n: u64) -> Option<BigUint> 
from_uint			    pub fn from_uint(n: uint) -> (BigDigit, BigDigit) 
gcd			    fn gcd(&self, other: &BigInt) -> BigInt 
gcd			    fn gcd(&self, other: &BigUint) -> BigUint 
gcd			            fn gcd(&self, other: &$T) -> $T 
gcd			    fn gcd(&self, other: &Self) -> Self;
gen_bigint			    fn gen_bigint(&mut self, bit_size: uint) -> BigInt 
gen_bigint			    fn gen_bigint(&mut self, bit_size: uint) -> BigInt;
gen_bigint_range			    fn gen_bigint_range(&mut self, lbound: &BigInt, ubound: &BigInt) -> BigInt;
gen_bigint_range			    fn gen_bigint_range(&mut self,
gen_biguint			    fn gen_biguint(&mut self, bit_size: uint) -> BigUint 
gen_biguint			    fn gen_biguint(&mut self, bit_size: uint) -> BigUint;
gen_biguint_below			    fn gen_biguint_below(&mut self, bound: &BigUint) -> BigUint 
gen_biguint_below			    fn gen_biguint_below(&mut self, bound: &BigUint) -> BigUint;
gen_biguint_range			    fn gen_biguint_range(&mut self, lbound: &BigUint, ubound: &BigUint) -> BigUint;
gen_biguint_range			    fn gen_biguint_range(&mut self,
get_hi			    fn get_hi(n: uint) -> BigDigit { (n >> bits) as BigDigit }
get_lo			    fn get_lo(n: uint) -> BigDigit { (n & lo_mask) as BigDigit }
get_radix_base			fn get_radix_base(radix: uint) -> (uint, uint) 
inv			    pub fn inv(&self) -> Cmplx<T> 
is_even			    fn is_even(&self) -> bool { self.data.is_even() }
is_even			    fn is_even(&self) -> bool 
is_even			            fn is_even(&self) -> bool { self & 1 == 0 }
is_even			    fn is_even(&self) -> bool;
is_integer			    pub fn is_integer(&self) -> bool 
is_negative			    fn is_negative(&self) -> bool { self.sign == Minus }
is_odd			    fn is_odd(&self) -> bool { !self.is_even() }
is_odd			    fn is_odd(&self) -> bool { self.data.is_odd() }
is_odd			            fn is_odd(&self) -> bool { !self.is_even() }
is_odd			    fn is_odd(&self) -> bool;
is_positive			    fn is_positive(&self) -> bool { self.sign == Plus }
is_zero			    fn is_zero(&self) -> bool { self.data.is_empty() }
is_zero			    fn is_zero(&self) -> bool { self.sign == Zero }
is_zero			    fn is_zero(&self) -> bool 
is_zero			    fn is_zero(&self) -> bool 
lcm			    fn lcm(&self, other: &BigInt) -> BigInt 
lcm			    fn lcm(&self, other: &BigUint) -> BigUint { ((*self * *other) \/ self.gcd(other)) }
lcm			            fn lcm(&self, other: &$T) -> $T 
lcm			    fn lcm(&self, other: &Self) -> Self;
lt			    fn lt(&self, other: &BigInt) -> bool 
lt			    fn lt(&self, other: &BigUint) -> bool 
mod_floor			    fn mod_floor(&self, other: &BigInt) -> BigInt 
mod_floor			    fn mod_floor(&self, other: &BigUint) -> BigUint 
mod_floor			            fn mod_floor(&self, other: &$T) -> $T { *self % *other }
mod_floor			            fn mod_floor(&self, other: &$T) -> $T 
mod_floor			    fn mod_floor(&self, other: &Self) -> Self;
mul			    fn mul(&self, other: &BigInt) -> BigInt 
mul			    fn mul(&self, other: &BigUint) -> BigUint 
mul			    fn mul(&self, other: &Cmplx<T>) -> Cmplx<T> 
mul			    fn mul(&self, rhs: &Ratio<T>) -> Ratio<T> 
mul_digit			        fn mul_digit(a: &BigUint, n: BigDigit) -> BigUint 
neg			    fn neg(&self) -> BigInt 
neg			    fn neg(&self) -> BigUint { fail!() }
neg			    fn neg(&self) -> Sign 
neg			    fn neg(&self) -> Cmplx<T> 
neg			    fn neg(&self) -> Ratio<T> 
new			    pub fn new(sign: Sign, v: Vec<BigDigit>) -> BigInt 
new			    pub fn new(v: Vec<BigDigit>) -> BigUint 
new			    pub fn new(re: T, im: T) -> Cmplx<T> 
new			    pub fn new(numer: T, denom: T) -> Ratio<T> 
new_raw			    pub fn new_raw(numer: T, denom: T) -> Ratio<T> 
norm			    pub fn norm(&self) -> T 
norm_sqr			    pub fn norm_sqr(&self) -> T 
numer			    pub fn numer<'a>(&'a self) -> &'a T 
one			    fn one() -> BigInt 
one			    fn one() -> BigUint { BigUint::new(vec!(1)) }
one			    fn one() -> Cmplx<T> 
one			    fn one() -> Ratio<T> 
parse_bytes			    pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<BigUint> 
parse_bytes			    pub fn parse_bytes(buf: &[u8], radix: uint)
rational			pub mod rational;
recip			    pub fn recip(&self) -> Ratio<T> 
reduce			    fn reduce(&mut self) 
reduced			    pub fn reduced(&self) -> Ratio<T> 
rem			    fn rem(&self, other: &BigInt) -> BigInt 
rem			    fn rem(&self, other: &BigUint) -> BigUint 
round			    fn round(&self) -> Ratio<T> 
scale			    pub fn scale(&self, t: T) -> Cmplx<T> 
shl			    fn shl(&self, rhs: &uint) -> BigInt 
shl			    fn shl(&self, rhs: &uint) -> BigUint 
shl_bits			    fn shl_bits(&self, n_bits: uint) -> BigUint 
shl_unit			    fn shl_unit(&self, n_unit: uint) -> BigUint 
shr			    fn shr(&self, rhs: &uint) -> BigInt 
shr			    fn shr(&self, rhs: &uint) -> BigUint 
shr			    fn shr(bh: &mut BenchHarness) 
shr_bits			    fn shr_bits(&self, n_bits: uint) -> BigUint 
shr_unit			    fn shr_unit(&self, n_unit: uint) -> BigUint 
signum			    fn signum(&self) -> BigInt 
sub			    fn sub(&self, other: &BigInt) -> BigInt 
sub			    fn sub(&self, other: &BigUint) -> BigUint 
sub			    fn sub(&self, other: &Cmplx<T>) -> Cmplx<T> 
sub_sign			        fn sub_sign(a: BigUint, b: BigUint) -> (Ordering, BigUint) 
test			        fn test(c : Complex64, r : f64, i: f64) 
test			        fn test(c : Complex64, s: ~str) 
test			        fn test(c: Complex64) 
test			        fn test(c: Complex64, arg: f64) 
test			        fn test(c: Complex64, ns: f64) 
test			mod test 
test			            fn test(a: Rational, b: Rational) 
test			            fn test(a: Rational, b: Rational, c: Rational) 
test			        fn test(r: Rational, s: ~str) 
test			        fn test(r: Rational, s: ~str, n: uint) 
test			        fn test(s: &str) 
test			        fn test<T: Float>(given: T, (numer, denom): (&str, &str)) 
test			mod test 
test16			        fn test16(r: Rational, s: ~str) { test(r, s, 16) }
test3			        fn test3(r: Rational, s: ~str) { test(r, s, 3) }
test_abs_sub			    fn test_abs_sub() 
test_add			    fn test_add() 
test_add			        fn test_add() 
test_add			        fn test_add() 
test_arg			    fn test_arg() 
test_bitand			    fn test_bitand() 
test_bitor			    fn test_bitor() 
test_bits			    fn test_bits() 
test_bitxor			    fn test_bitxor() 
test_checked_add			    fn test_checked_add() 
test_checked_div			    fn test_checked_div() 
test_checked_mul			    fn test_checked_mul() 
test_checked_sub			    fn test_checked_sub() 
test_cmp			    fn test_cmp() 
test_cmp			    fn test_cmp() 
test_conj			    fn test_conj() 
test_consts			    fn test_consts() 
test_convert_i64			    fn test_convert_i64() 
test_convert_to_bigint			    fn test_convert_to_bigint() 
test_convert_to_biguint			    fn test_convert_to_biguint() 
test_convert_u64			    fn test_convert_u64() 
test_denom			    fn test_denom() 
test_div			        fn test_div() 
test_div			        fn test_div() 
test_div_0			        fn test_div_0() 
test_div_mod_floor			    fn test_div_mod_floor() 
test_div_mod_floor			            fn test_div_mod_floor() 
test_div_rem			    fn test_div_rem() 
test_div_rem			            fn test_div_rem() 
test_divides			            fn test_divides() 
test_division_rule			            fn test_division_rule((n,d): ($T,$T), (q,r): ($T,$T)) 
test_even			            fn test_even() 
test_factor			    fn test_factor() 
test_fract			    fn test_fract() 
test_from_biguint			    fn test_from_biguint() 
test_from_float			    fn test_from_float() 
test_from_float_fail			    fn test_from_float_fail() 
test_from_slice			    fn test_from_slice() 
test_from_str_fail			    fn test_from_str_fail() 
test_from_str_radix			    fn test_from_str_radix() 
test_from_str_radix_fail			    fn test_from_str_radix_fail() 
test_gcd			    fn test_gcd() 
test_gcd			            fn test_gcd() 
test_inv			    fn test_inv() 
test_inv_zero			    fn test_inv_zero() 
test_is_even			    fn test_is_even() 
test_is_integer			    fn test_is_integer() 
test_lcm			    fn test_lcm() 
test_lcm			            fn test_lcm() 
test_mul			    fn test_mul() 
test_mul			        fn test_mul() 
test_mul			        fn test_mul() 
test_nd_dm			                fn test_nd_dm(nd: ($T,$T), dm: ($T,$T)) 
test_nd_dr			                fn test_nd_dr(nd: ($T,$T), qr: ($T,$T)) 
test_neg			    fn test_neg() 
test_neg			        fn test_neg() 
test_neg			        fn test_neg() 
test_negative_rand_range			    fn test_negative_rand_range() 
test_new_reduce			    fn test_new_reduce() 
test_new_zero			    fn test_new_zero() 
test_norm			    fn test_norm() 
test_numer			    fn test_numer() 
test_odd			            fn test_odd() 
test_polar_conv			    fn test_polar_conv() 
test_rand			    fn test_rand() 
test_rand_range			    fn test_rand_range() 
test_recip			    fn test_recip() 
test_rem			        fn test_rem() 
test_round			    fn test_round() 
test_scale_unscale			    fn test_scale_unscale() 
test_shl			    fn test_shl() 
test_shr			    fn test_shr() 
test_sub			    fn test_sub() 
test_sub			        fn test_sub() 
test_sub			        fn test_sub() 
test_test_constants			    fn test_test_constants() 
test_to_from_str			    fn test_to_from_str() 
test_to_from_str_radix			    fn test_to_from_str_radix() 
test_to_integer			    fn test_to_integer() 
test_to_str			    fn test_to_str() 
test_to_str_radix			    fn test_to_str_radix() 
test_zero			        fn test_zero() 
test_zero_rand_range			    fn test_zero_rand_range() 
to_big			    pub fn to_big(n: Rational) -> BigRational 
to_bigint			            fn to_bigint(&self) -> Option<BigInt> 
to_bigint			    fn to_bigint(&self) -> Option<BigInt> 
to_bigint			    fn to_bigint(&self) -> Option<BigInt>;
to_biguint			            fn to_biguint(&self) -> Option<BigUint> 
to_biguint			    fn to_biguint(&self) -> Option<BigUint> 
to_biguint			    fn to_biguint(&self) -> Option<BigUint>;
to_biguint			    pub fn to_biguint(&self) -> Option<BigUint> 
to_i64			    fn to_i64(&self) -> Option<i64> 
to_integer			    pub fn to_integer(&self) -> T 
to_polar			    pub fn to_polar(&self) -> (T, T) 
to_str			    fn to_str(bh: &mut BenchHarness) 
to_str_pairs			    fn to_str_pairs() -> Vec<(BigUint, Vec<(uint, ~str)>)> 
to_str_radix			    fn to_str_radix(&self, radix: uint) -> ~str 
to_str_radix			    fn to_str_radix(&self, radix: uint) -> ~str 
to_str_radix			    fn to_str_radix(&self, radix: uint) -> ~str 
to_u64			    fn to_u64(&self) -> Option<u64> 
to_uint			    pub fn to_uint(hi: BigDigit, lo: BigDigit) -> uint 
trunc			    fn trunc(&self) -> Ratio<T> 
unscale			    pub fn unscale(&self, t: T) -> Cmplx<T> 
zero			    fn zero() -> BigInt 
zero			    fn zero() -> BigUint { BigUint::new(Vec::new()) }
zero			    fn zero() -> Cmplx<T> 
zero			    fn zero() -> Ratio<T> 
