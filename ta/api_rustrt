AddrinfoHint			pub struct AddrinfoHint 
AddrinfoInfo			pub struct AddrinfoInfo 
AllocHeader			impl AllocHeader 
AllocHeader			struct AllocHeader;
BlockedTask			impl BlockedTask 
BlockedTask			pub enum BlockedTask 
BlockedTasks			pub struct BlockedTasks 
Borrowed			pub struct Borrowed<T> 
BufWriter			    struct BufWriter<'a> 
CChars			pub struct CChars<'a> 
CString			impl CString 
CString			pub struct CString 
Callback			pub trait Callback 
Clone			impl Clone for CString 
CloseBehavior			pub enum CloseBehavior 
Collection			impl Collection for CString 
CreateEventA			        fn CreateEventA(lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
CreateThread			        fn CreateThread(lpThreadAttributes: LPSECURITY_ATTRIBUTES,
Death			impl Death 
Death			pub struct Death 
DeleteCriticalSection			        fn DeleteCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);
Drop			impl Drop for CString 
Drop			impl Drop for LocalHeap 
Drop			impl Drop for MemoryRegion 
Drop			impl Drop for NativeMutex 
Drop			impl Drop for Task 
EnterCriticalSection			        fn EnterCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);
EventLoop			pub trait EventLoop 
Exception			struct Exception 
Exclusive			pub struct Exclusive<T> 
ExclusiveGuard			pub struct ExclusiveGuard<'a, T> 
FileAccess			pub enum FileAccess 
FileMode			pub enum FileMode 
FileStat			pub struct FileStat 
GarbageCollector			pub struct GarbageCollector;
InitializeCriticalSectionAndSpinCount			        fn InitializeCriticalSectionAndSpinCount(
IoError			pub struct IoError 
IoFactory			pub trait IoFactory 
IpAddr			pub enum IpAddr 
Iterator			impl Iterator<BlockedTask> for BlockedTasks 
KeyValue			pub enum KeyValue<T> { Key }
LeaveCriticalSection			        fn LeaveCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);
List			        struct List 
Local			impl Local<local_ptr::Borrowed<Task>> for Task 
Local			pub trait Local<Borrowed> 
LocalData			trait LocalData {}
LocalHeap			impl LocalHeap 
LocalHeap			pub struct LocalHeap 
LocalIo			pub struct LocalIo<'a> 
LocalStorage			pub struct LocalStorage(pub Option<local_data::Map>);
LockGuard			pub struct LockGuard<'a> 
MemoryRegion			impl MemoryRegion 
MemoryRegion			pub struct MemoryRegion 
Mutex			    impl Mutex 
Mutex			    pub struct Mutex 
NativeMutex			impl NativeMutex 
NativeMutex			pub struct NativeMutex 
PartialEq			impl PartialEq for CString 
PausableIdleCallback			pub trait PausableIdleCallback 
ProcessConfig			pub struct ProcessConfig<'a> 
ProcessExit			pub enum ProcessExit 
Ref			pub struct Ref<T> 
RemoteCallback			pub trait RemoteCallback 
RtioFileStream			pub trait RtioFileStream 
RtioPipe			pub trait RtioPipe 
RtioProcess			pub trait RtioProcess 
RtioSignal			pub trait RtioSignal {}
RtioSocket			pub trait RtioSocket 
RtioTTY			pub trait RtioTTY 
RtioTcpAcceptor			pub trait RtioTcpAcceptor : RtioSocket 
RtioTcpListener			pub trait RtioTcpListener : RtioSocket 
RtioTcpStream			pub trait RtioTcpStream : RtioSocket 
RtioTimer			pub trait RtioTimer 
RtioUdpSocket			pub trait RtioUdpSocket : RtioSocket 
RtioUnixAcceptor			pub trait RtioUnixAcceptor 
RtioUnixListener			pub trait RtioUnixListener 
Runtime			pub trait Runtime 
SeekStyle			pub enum SeekStyle 
SetEvent			        fn SetEvent(hEvent: HANDLE) -> BOOL;
SocketAddr			pub struct SocketAddr 
StaticNativeMutex			impl StaticNativeMutex 
StaticNativeMutex			pub struct StaticNativeMutex 
Stdio			pub struct Stdio(libc::c_int);
StdioContainer			pub enum StdioContainer 
SwitchToThread			        fn SwitchToThread() -> BOOL;
Task			impl Task 
Task			pub struct Task 
TaskOpts			impl TaskOpts 
TaskOpts			pub struct TaskOpts 
Thread			impl Thread<()> 
Thread			pub struct Thread<T> 
TlsAlloc			    fn TlsAlloc() -> DWORD;
TlsFree			    fn TlsFree(dwTlsIndex: DWORD) -> BOOL;
TlsGetValue			    fn TlsGetValue(dwTlsIndex: DWORD) -> LPVOID;
TlsSetValue			    fn TlsSetValue(dwTlsIndex: DWORD, lpTlsvalue: LPVOID) -> BOOL;
ToCStr			impl ToCStr for String 
ToCStr			pub trait ToCStr 
TryEnterCriticalSection			        fn TryEnterCriticalSection(lpCriticalSection: LPCRITICAL_SECTION) -> BOOL;
Unwinder			impl Unwinder 
Unwinder			pub struct Unwinder 
VecWriter			    struct VecWriter<'a> { v: &'a mut Vec<u8> }
WaitForSingleObject			        fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;
WaitForSingleObject			        fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;
_Unwind_Action			pub enum _Unwind_Action 
_Unwind_Context			pub enum _Unwind_Context {}
_Unwind_DeleteException			    pub fn _Unwind_DeleteException(exception: *mut _Unwind_Exception);
_Unwind_Exception			pub struct _Unwind_Exception 
_Unwind_RaiseException			    pub fn _Unwind_RaiseException(exception: *mut _Unwind_Exception)
_Unwind_RaiseException			pub unsafe fn _Unwind_RaiseException(exc: *mut _Unwind_Exception)
_Unwind_Reason_Code			pub enum _Unwind_Reason_Code 
_Unwind_SjLj_RaiseException			    fn _Unwind_SjLj_RaiseException(e: *mut _Unwind_Exception)
_Unwind_State			pub enum _Unwind_State 
__gcc_personality_sj0			        fn __gcc_personality_sj0(version: c_int,
__gcc_personality_v0			        fn __gcc_personality_v0(state: uw::_Unwind_State,
__gcc_personality_v0			        fn __gcc_personality_v0(version: c_int,
abort			pub fn abort(args: &fmt::Arguments) -> ! 
accept			    fn accept(&mut self) -> IoResult<Box<RtioPipe + Send>>;
accept			    fn accept(&mut self) -> IoResult<Box<RtioTcpStream + Send>>;
accept_simultaneously			    fn accept_simultaneously(&mut self) -> IoResult<()>;
alloc			    pub fn alloc(&mut self,
alloc_managed_big			    fn alloc_managed_big(b: &mut Bencher) 
alloc_managed_small			    fn alloc_managed_small(b: &mut Bencher) 
annihilate			    unsafe fn annihilate(&mut self) 
args			pub mod args;
as_box			    fn as_box(&mut self) -> *mut Box 
as_bytes			    pub fn as_bytes<'a>(&'a self) -> &'a [u8] 
as_bytes_no_nul			    pub fn as_bytes_no_nul<'a>(&'a self) -> &'a [u8] 
as_mut_ptr			    pub fn as_mut_ptr(&mut self) -> *mut libc::c_char 
as_ptr			    pub fn as_ptr(&self) -> *const libc::c_char 
as_str			    pub fn as_str<'a>(&'a self) -> Option<&'a str> 
assert_sane			    fn assert_sane(&self) {}
at_exit			pub fn at_exit(f: proc():Send) 
at_exit_imp			mod at_exit_imp;
begin_unwind			pub fn begin_unwind<M: Any + Send>(msg: M, file: &'static str, line: uint) -> ! 
begin_unwind_fmt			pub fn begin_unwind_fmt(msg: &fmt::Arguments, file: &'static str,
begin_unwind_inner			fn begin_unwind_inner(msg: Box<Any + Send>,
bench			mod bench 
bench			mod bench 
bench_to_c_str_long			    fn bench_to_c_str_long(b: &mut Bencher) 
bench_to_c_str_medium			    fn bench_to_c_str_medium(b: &mut Bencher) 
bench_to_c_str_short			    fn bench_to_c_str_short(b: &mut Bencher) 
bench_to_c_str_unchecked			    fn bench_to_c_str_unchecked(b: &mut Bencher, s: &str) 
bench_to_c_str_unchecked_long			    fn bench_to_c_str_unchecked_long(b: &mut Bencher) 
bench_to_c_str_unchecked_medium			    fn bench_to_c_str_unchecked_medium(b: &mut Bencher) 
bench_to_c_str_unchecked_short			    fn bench_to_c_str_unchecked_short(b: &mut Bencher) 
bench_to_str			    fn bench_to_str(b: &mut Bencher, s: &str) 
bench_with_c_str			    fn bench_with_c_str(b: &mut Bencher, s: &str) 
bench_with_c_str_long			    fn bench_with_c_str_long(b: &mut Bencher) 
bench_with_c_str_medium			    fn bench_with_c_str_medium(b: &mut Bencher) 
bench_with_c_str_short			    fn bench_with_c_str_short(b: &mut Bencher) 
bench_with_c_str_unchecked			    fn bench_with_c_str_unchecked(b: &mut Bencher, s: &str) 
bench_with_c_str_unchecked_long			    fn bench_with_c_str_unchecked_long(b: &mut Bencher) 
bench_with_c_str_unchecked_medium			    fn bench_with_c_str_unchecked_medium(b: &mut Bencher) 
bench_with_c_str_unchecked_short			    fn bench_with_c_str_unchecked_short(b: &mut Bencher) 
block			    pub fn block(task: Box<Task>) -> BlockedTask 
block_and_wake			    fn block_and_wake() 
bookkeeping			pub mod bookkeeping;
borrow			    fn borrow(_: Option<Task>) -> local_ptr::Borrowed<Task> 
borrow			    fn borrow(unused_value: Option<Self>) -> Borrowed;
borrow			pub unsafe fn borrow<T>() -> Borrowed<T> 
borrow			    pub fn borrow() -> Option<LocalIo> 
borrow_smoke_test			    fn borrow_smoke_test() 
borrow_with_return			    fn borrow_with_return() 
c_str			pub mod c_str;
call			    fn call(&mut self);
callback			    fn callback(&mut self, arg: proc(): Send);
can_block			    fn can_block(&self) -> bool;
can_block			    pub fn can_block(&self) -> bool 
cast_from_uint			    pub unsafe fn cast_from_uint(blocked_task_ptr: uint) -> BlockedTask 
cast_to_uint			    pub unsafe fn cast_to_uint(self) -> uint 
check			    fn check(s: &str, c_str: *const libc::c_char) 
check_for_null			fn check_for_null(v: &[u8], buf: *mut libc::c_char) 
claim			    fn claim(&mut self, _alloc: &mut AllocHeader) {}
cleanup			    pub fn cleanup() 
cleanup			    pub unsafe fn cleanup() 
cleanup			pub unsafe fn cleanup() { imp::cleanup() }
cleanup			pub unsafe fn cleanup() 
cleanup			    pub unsafe fn cleanup() 
cleanup			    pub unsafe fn cleanup() {}
cleanup			    fn cleanup(~self, result: Result) -> Box<Task> 
cleanup_task			    fn cleanup_task(mut t: Box<Task>) 
clone			    pub fn clone() -> Option<Vec<Vec<u8>>> 
clone			pub fn clone() -> Option<Vec<Vec<u8>>> { imp::clone() }
clone			    fn clone(&self) -> CString 
clone			    fn clone(&self) -> Box<RtioPipe + Send>;
clone			    fn clone(&self) -> Box<RtioTcpStream + Send>;
clone			    fn clone(&self) -> Box<RtioUdpSocket + Send>;
close_read			    fn close_read(&mut self) -> IoResult<()>;
close_write			    fn close_write(&mut self) -> IoResult<()>;
comm_shared_chan			    fn comm_shared_chan() 
comm_stream			    fn comm_stream() 
compiled			pub mod compiled 
control_congestion			    fn control_congestion(&mut self) -> IoResult<()>;
create			    pub unsafe fn create(stack: uint, p: Box<proc():Send>) -> rust_thread 
create			pub unsafe fn create(key: &mut Key) 
data			    fn data() { assert_eq!(Thread::start(proc () { 1i }).join(), 1); }
datasync			    fn datasync(&mut self) -> IoResult<()>;
debug_mem			fn debug_mem() -> bool 
decrement			pub fn decrement() 
deref			    fn deref<'a>(&'a self) -> &'a T { &*self._data }
deref			    fn deref<'a>(&'a self) -> &'a T { self._ptr }
deref			    fn deref<'a>(&'a self) -> &'a T 
deref_mut			    fn deref_mut<'a>(&'a mut self) -> &'a mut T { &mut *self._data }
deref_mut			    fn deref_mut<'a>(&'a mut self) -> &'a mut T 
deschedule			    fn deschedule(~self, times: uint, cur_task: Box<Task>,
deschedule			    pub fn deschedule(mut ~self, amt: uint,
destroy			        pub unsafe fn destroy(&self) 
destroy			    pub unsafe fn destroy(&self) { self.inner.destroy() }
destroy			    pub fn destroy(~self) -> Box<Task> 
destroy			pub unsafe fn destroy(key: Key) 
destroy_immediately			    fn destroy_immediately() 
detach			    pub unsafe fn detach(native: rust_thread) 
detached			    fn detached() { Thread::spawn(proc () {}) }
dont_accept_simultaneously			    fn dont_accept_simultaneously(&mut self) -> IoResult<()>;
dont_loop_multicast_locally			    fn dont_loop_multicast_locally(&mut self) -> IoResult<()>;
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
dumb_print			pub fn dumb_print(args: &fmt::Arguments) 
eabi			pub mod eabi 
each_live_alloc			    unsafe fn each_live_alloc(&mut self, read_next_before: bool,
eh_personality			    extern "C" fn eh_personality(
eh_personality			    extern fn eh_personality(
eq			    fn eq(&self, other: &CString) -> bool 
exception_cleanup			    extern fn exception_cleanup(_unwind_code: uw::_Unwind_Reason_Code,
exclusive			pub mod exclusive;
exclusive_new_arc			    fn exclusive_new_arc() 
exists			    fn exists(_: Option<Task>) -> bool { local_ptr::exists() }
exists			    fn exists(unused_value: Option<Self>) -> bool;
exists			    pub fn exists() -> bool 
find			    fn find<'a>(&'static self,
fire			    fn fire(&mut self);
fmt			    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result 
fmt			impl fmt::Show for IpAddr 
fmt			impl fmt::FormatWriter for Stdio 
foo			        fn foo(f: |c: &CString|) 
free			    fn free(&mut self, alloc: *mut Box) 
free			    pub fn free(&mut self, alloc: *mut Box) 
free_cond			    pub unsafe fn free_cond(h: uint) 
free_lock			    pub unsafe fn free_lock(h: uint) 
from			    fn from(a_box: *mut Box) -> *mut AllocHeader 
from_c_multistring			pub unsafe fn from_c_multistring(buf: *const libc::c_char,
fs_chmod			    fn fs_chmod(&mut self, path: &CString, mode: uint) -> IoResult<()>;
fs_chown			    fn fs_chown(&mut self, path: &CString, uid: int, gid: int) ->
fs_from_raw_fd			    fn fs_from_raw_fd(&mut self, fd: c_int, close: CloseBehavior)
fs_link			    fn fs_link(&mut self, src: &CString, dst: &CString) -> IoResult<()>;
fs_lstat			    fn fs_lstat(&mut self, path: &CString) -> IoResult<FileStat>;
fs_mkdir			    fn fs_mkdir(&mut self, path: &CString, mode: uint) -> IoResult<()>;
fs_open			    fn fs_open(&mut self, path: &CString, fm: FileMode, fa: FileAccess)
fs_readdir			    fn fs_readdir(&mut self, path: &CString, flags: c_int) ->
fs_readlink			    fn fs_readlink(&mut self, path: &CString) -> IoResult<CString>;
fs_rename			    fn fs_rename(&mut self, path: &CString, to: &CString) -> IoResult<()>;
fs_rmdir			    fn fs_rmdir(&mut self, path: &CString) -> IoResult<()>;
fs_stat			    fn fs_stat(&mut self, path: &CString) -> IoResult<FileStat>;
fs_symlink			    fn fs_symlink(&mut self, src: &CString, dst: &CString) -> IoResult<()>;
fs_unlink			    fn fs_unlink(&mut self, path: &CString) -> IoResult<()>;
fs_utime			    fn fs_utime(&mut self, src: &CString, atime: u64, mtime: u64) ->
fstat			    fn fstat(&mut self) -> IoResult<FileStat>;
fsync			    fn fsync(&mut self) -> IoResult<()>;
get			    pub fn get(&'static self) -> Option<Ref<T>> 
get			    pub fn get<'a>(&'a mut self) -> &'a mut IoFactory 
get			pub unsafe fn get(key: Key) -> *mut u8 
get_global_ptr			    fn get_global_ptr() -> *mut Option<Box<Vec<Vec<u8>>>> 
get_host_addresses			    fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,
get_local_map			unsafe fn get_local_map() -> Option<&mut Map> 
get_sp_limit			            fn get_sp_limit() -> *const c_void;
get_sp_limit			pub unsafe fn get_sp_limit() -> uint 
get_winsize			    fn get_winsize(&mut self) -> IoResult<(int, int)>;
getcond			        unsafe fn getcond(&self) -> *mut c_void 
getlock			        unsafe fn getlock(&self) -> *mut c_void 
has_active_io			    fn has_active_io(&self) -> bool;
heap_cycles			    fn heap_cycles() 
hear_broadcasts			    fn hear_broadcasts(&mut self) -> IoResult<()>;
id			    fn id(&self) -> libc::pid_t;
ignore_broadcasts			    fn ignore_broadcasts(&mut self) -> IoResult<()>;
immortalize			    pub unsafe fn immortalize(&mut self) 
imp			mod imp 
imp			mod imp 
imp			mod imp 
increment			pub fn increment() 
init			    pub unsafe fn init(_argc: int, _argv: *const *const u8) 
init			    pub unsafe fn init(argc: int, argv: *const *const u8) 
init			pub unsafe fn init(argc: int, argv: *const *const u8) { imp::init(argc, argv) }
init			pub fn init() 
init			pub fn init(argc: int, argv: *const *const u8) 
init			    fn init(&mut self, _size: u32) {}
init			    pub fn init() 
init			    pub fn init() {}
init_cond			    pub unsafe fn init_cond() -> uint 
init_lock			    pub unsafe fn init_lock() -> uint 
io			    fn io<'a>(&'a mut self) -> Option<&'a mut IoFactory>;
is_destroyed			    pub fn is_destroyed(&self) -> bool { self.destroyed }
is_not_null			    pub fn is_not_null(&self) -> bool 
is_null			    pub fn is_null(&self) -> bool 
isatty			    fn isatty(&self) -> bool;
iter			    pub fn iter<'a>(&'a self) -> CChars<'a> 
join			    pub fn join(mut self) -> T 
join			    pub unsafe fn join(native: rust_thread) 
join_multicast			    fn join_multicast(&mut self, multi: IpAddr) -> IoResult<()>;
keepalive			    fn keepalive(&mut self, delay_in_seconds: uint) -> IoResult<()>;
key_to_key_value			fn key_to_key_value<T: 'static>(key: Key<T>) -> *const u8 
kill			    fn kill(&mut self, pid: libc::pid_t, signal: int) -> IoResult<()>;
kill			    fn kill(&mut self, signal: int) -> IoResult<()>;
leave_multicast			    fn leave_multicast(&mut self, multi: IpAddr) -> IoResult<()>;
len			    fn len(&self) -> uint 
letdie			    fn letdie(&mut self) -> IoResult<()>;
libunwind			mod libunwind;
listen			    fn listen(~self) -> IoResult<Box<RtioTcpAcceptor + Send>>;
listen			    fn listen(~self) -> IoResult<Box<RtioUnixAcceptor + Send>>;
load_argc_and_argv			    unsafe fn load_argc_and_argv(argc: int, argv: *const *const u8) -> Vec<Vec<u8>> 
local			pub mod local;
local_data			pub mod local_data;
local_free			pub unsafe fn local_free(ptr: *mut u8) 
local_free_			pub unsafe fn local_free_(ptr: *mut u8) 
local_heap			pub mod local_heap;
local_heap			    fn local_heap() 
local_io			    fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>>;
local_io			    pub fn local_io<'a>(&'a mut self) -> Option<LocalIo<'a>> 
local_malloc			pub unsafe fn local_malloc(drop_glue: fn(*mut u8), size: uint,
local_malloc_			pub unsafe fn local_malloc_(drop_glue: fn(*mut u8), size: uint,
local_ptr			mod local_ptr;
lock			    pub unsafe fn lock<'a>(&'a self) -> ExclusiveGuard<'a, T> 
lock			        pub unsafe fn lock(&self) { pthread_mutex_lock(self.lock.get()); }
lock			        pub unsafe fn lock(&self) 
lock			    pub unsafe fn lock<'a>(&'a self) -> LockGuard<'a> 
lock_noguard			    pub unsafe fn lock_noguard(&self) { self.inner.lock() }
lock_noguard			    pub unsafe fn lock_noguard(&self) { self.inner.lock_noguard() }
loop_multicast_locally			    fn loop_multicast_locally(&mut self) -> IoResult<()>;
macros			mod macros;
main			fn main() 
make_selectable			    pub fn make_selectable(self, num_handles: uint) -> Take<BlockedTasks> 
malloc			    fn malloc(&mut self, size: uint) -> *mut Box 
maybe_raise			    pub fn maybe_raise<T>(f: |io: &mut IoFactory| -> IoResult<T>)
maybe_take_runtime			    pub fn maybe_take_runtime<T: 'static>(&mut self) -> Option<Box<T>> 
maybe_tls_key			    pub fn maybe_tls_key() -> Option<tls::Key> 
maybe_yield			    fn maybe_yield(~self, cur_task: Box<Task>);
maybe_yield			    pub fn maybe_yield(mut ~self) 
min_stack_size			    fn min_stack_size(_: *const libc::pthread_attr_t) -> libc::size_t 
min_stack_size			    fn min_stack_size(attr: *const libc::pthread_attr_t) -> libc::size_t 
multicast_time_to_live			    fn multicast_time_to_live(&mut self, ttl: int) -> IoResult<()>;
mutex			pub mod mutex;
native			pub mod native 
new			    pub unsafe fn new(buf: *const libc::c_char, owns_buffer: bool) -> CString 
new			    pub fn new(user_data: T) -> Exclusive<T> 
new			    pub fn new() -> LocalHeap 
new			        pub unsafe fn new() -> Mutex 
new			    pub unsafe fn new() -> NativeMutex 
new			    pub unsafe fn new() -> StaticNativeMutex 
new			    pub fn new<'a>(io: &'a mut IoFactory) -> LocalIo<'a> 
new			    pub fn new() -> Death 
new			    pub fn new() -> Task 
new			    pub fn new() -> TaskOpts 
new			    pub fn new() -> Unwinder 
next			    fn next(&mut self) -> Option<libc::c_char> 
next			    fn next(&mut self) -> Option<BlockedTask> 
nodelay			    fn nodelay(&mut self) -> IoResult<()>;
oneshot			    fn oneshot(&mut self, msecs: u64, cb: Box<Callback + Send>);
os			    mod os 
owns_buffer			    pub fn owns_buffer(&self) -> bool 
pausable_idle_callback			    fn pausable_idle_callback(&mut self, Box<Callback + Send>)
pause			    fn pause(&mut self);
peer_name			    fn peer_name(&mut self) -> IoResult<SocketAddr>;
period			    fn period(&mut self, msecs: u64, cb: Box<Callback + Send>);
pipe_open			    fn pipe_open(&mut self, fd: c_int) -> IoResult<Box<RtioPipe + Send>>;
pread			    fn pread(&mut self, buf: &mut [u8], offset: u64) -> IoResult<int>;
pthread_attr_destroy			        fn pthread_attr_destroy(attr: *mut libc::pthread_attr_t) -> libc::c_int;
pthread_attr_init			        fn pthread_attr_init(attr: *mut libc::pthread_attr_t) -> libc::c_int;
pthread_attr_setdetachstate			        fn pthread_attr_setdetachstate(attr: *mut libc::pthread_attr_t,
pthread_attr_setstacksize			        fn pthread_attr_setstacksize(attr: *mut libc::pthread_attr_t,
pthread_cond_destroy			        fn pthread_cond_destroy(cond: *mut pthread_cond_t) -> libc::c_int;
pthread_cond_signal			        fn pthread_cond_signal(cond: *mut pthread_cond_t) -> libc::c_int;
pthread_cond_t			        pub struct pthread_cond_t { value: libc::c_int }
pthread_cond_t			        pub struct pthread_cond_t 
pthread_cond_wait			        fn pthread_cond_wait(cond: *mut pthread_cond_t,
pthread_create			        fn pthread_create(native: *mut libc::pthread_t,
pthread_detach			        fn pthread_detach(thread: libc::pthread_t) -> libc::c_int;
pthread_getspecific			    fn pthread_getspecific(key: pthread_key_t) -> *mut u8;
pthread_join			        fn pthread_join(native: libc::pthread_t,
pthread_key_create			    fn pthread_key_create(key: *mut pthread_key_t, dtor: *const u8) -> c_int;
pthread_key_delete			    fn pthread_key_delete(key: pthread_key_t) -> c_int;
pthread_mutex_destroy			        fn pthread_mutex_destroy(lock: *mut pthread_mutex_t) -> libc::c_int;
pthread_mutex_lock			        fn pthread_mutex_lock(lock: *mut pthread_mutex_t) -> libc::c_int;
pthread_mutex_t			        pub struct pthread_mutex_t { value: libc::c_int }
pthread_mutex_t			        pub struct pthread_mutex_t 
pthread_mutex_trylock			        fn pthread_mutex_trylock(lock: *mut pthread_mutex_t) -> libc::c_int;
pthread_mutex_unlock			        fn pthread_mutex_unlock(lock: *mut pthread_mutex_t) -> libc::c_int;
pthread_setspecific			    fn pthread_setspecific(key: pthread_key_t, value: *mut u8) -> c_int;
push			pub fn push(f: proc():Send) 
put			    pub fn put(_args: Vec<Vec<u8>>) 
put			    pub fn put(args: Vec<Vec<u8>>) 
put			pub fn put(args: Vec<Vec<u8>>) { imp::put(args) }
put			    fn put(value: Box<Self>);
put			    fn put(value: Box<Task>) { unsafe { local_ptr::put(value) } }
put			    pub unsafe fn put<T>(sched: Box<T>) 
put_runtime			    pub fn put_runtime(&mut self, ops: Box<Runtime + Send>) 
puts			    fn puts(s: *const libc::c_char);
pwrite			    fn pwrite(&mut self, buf: &[u8], offset: u64) -> IoResult<()>;
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<int>;
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint>;
realloc			    fn realloc(&mut self, alloc: *mut Box, size: uint) -> *mut Box 
realloc			    pub fn realloc(&mut self, ptr: *mut Box, size: uint) -> *mut Box 
reawaken			    fn reawaken(~self, to_wake: Box<Task>);
reawaken			    pub fn reawaken(mut ~self) 
reawaken			    pub fn reawaken(self) 
record_sp_limit			            fn record_sp_limit(limit: *const c_void);
record_sp_limit			pub unsafe fn record_sp_limit(limit: uint) 
record_stack_bounds			pub unsafe fn record_stack_bounds(stack_lo: uint, stack_hi: uint) 
recv_from			    fn recv_from(&mut self, buf: &mut [u8]) -> IoResult<(uint, SocketAddr)>;
register			pub unsafe fn register(f: Callback) -> bool 
release			    fn release(&mut self, _alloc: &AllocHeader) {}
remote_callback			    fn remote_callback(&mut self, Box<Callback + Send>)
replace			    pub fn replace(&'static self, data: Option<T>) -> Option<T> 
resume			    fn resume(&mut self);
rng			    fn rng() 
rtio			pub mod rtio;
run			pub fn run() 
run			    fn run(&mut self);
run			    pub fn run(~self, f: ||) -> Box<Task> 
rust_begin_unwind			pub extern fn rust_begin_unwind(msg: &fmt::Arguments,
rust_eh_personality			    pub extern "C" fn rust_eh_personality(
rust_eh_personality_catch			    pub extern "C" fn rust_eh_personality_catch(
rust_exception_class			fn rust_exception_class() -> uw::_Unwind_Exception_Class 
rust_fail			fn rust_fail(cause: Box<Any + Send>) -> ! 
rust_try			        fn rust_try(f: extern "C" fn(*mut c_void, *mut c_void),
sched_yield			        fn sched_yield() -> libc::c_int;
seek			    fn seek(&mut self, pos: i64, whence: SeekStyle) -> IoResult<u64>;
send_to			    fn send_to(&mut self, buf: &[u8], dst: SocketAddr) -> IoResult<()>;
set			pub unsafe fn set(key: Key, value: *mut u8) 
set_raw			    fn set_raw(&mut self, raw: bool) -> IoResult<()>;
set_read_timeout			    fn set_read_timeout(&mut self, timeout_ms: Option<u64>);
set_timeout			    fn set_timeout(&mut self, timeout: Option<u64>);
set_timeout			    fn set_timeout(&mut self, timeout_ms: Option<u64>);
set_write_timeout			    fn set_write_timeout(&mut self, timeout_ms: Option<u64>);
shouldnt_be_public			pub mod shouldnt_be_public 
signal			    pub fn signal(&self) 
signal			        pub unsafe fn signal(&self) { pthread_cond_signal(self.cond.get()); }
signal			        pub unsafe fn signal(&self) 
signal			    pub unsafe fn signal(&self) 
signal			    fn signal(&mut self, signal: int, cb: Box<Callback + Send>)
signal_noguard			    pub unsafe fn signal_noguard(&self) { self.inner.signal() }
signal_noguard			    pub unsafe fn signal_noguard(&self) { self.inner.signal_noguard() }
size			    fn size() -> uint 
sleep			    fn sleep(&mut self, msecs: u64);
small_stacks			    fn small_stacks() 
smoke			    fn smoke() { Thread::start(proc (){}).join(); }
smoke_cond			    fn smoke_cond() 
smoke_cond_noguard			    fn smoke_cond_noguard() 
smoke_lock			    fn smoke_lock() 
smoke_lock_noguard			    fn smoke_lock_noguard() 
smoke_test			        fn smoke_test() 
socket_name			    fn socket_name(&mut self) -> IoResult<SocketAddr>;
spawn			    fn spawn(&mut self, cfg: ProcessConfig)
spawn			    pub fn spawn(main: proc():Send) 
spawn_sibling			    fn spawn_sibling(~self,
spawn_sibling			    pub fn spawn_sibling(mut ~self, opts: TaskOpts, f: proc(): Send) 
spawn_stack			    pub fn spawn_stack(stack: uint, main: proc():Send) 
stack			pub mod stack;
stack_bounds			    fn stack_bounds(&self) -> (uint, uint); \/\/ (lo, hi)
stack_bounds			    pub fn stack_bounds(&self) -> (uint, uint) 
stack_exhausted			extern fn stack_exhausted() 
start			    pub fn start<T: Send>(main: proc():Send -> T) -> Thread<T> 
start_stack			    pub fn start_stack<T: Send>(stack: uint, main: proc():Send -> T) -> Thread<T> 
std			mod std 
take			    pub fn take() -> Option<Vec<Vec<u8>>> 
take			pub fn take() -> Option<Vec<Vec<u8>>> { imp::take() }
take			    fn take() -> Box<Self>;
take			    fn take() -> Box<Task> { unsafe { local_ptr::take() } }
take			    pub unsafe fn take<T>() -> Box<T> 
take_runtime			    pub fn take_runtime(&mut self) -> Box<Runtime + Send> 
target_get_sp_limit			    unsafe fn target_get_sp_limit() -> uint 
target_record_sp_limit			    unsafe fn target_record_sp_limit(_: uint) 
target_record_sp_limit			    unsafe fn target_record_sp_limit(limit: uint) 
target_record_stack_bounds			    unsafe fn target_record_stack_bounds(_stack_lo: uint, _stack_hi: uint) {}
target_record_stack_bounds			    unsafe fn target_record_stack_bounds(stack_lo: uint, stack_hi: uint) 
task			pub mod task;
tcp_bind			    fn tcp_bind(&mut self, addr: SocketAddr)
tcp_connect			    fn tcp_connect(&mut self, addr: SocketAddr,
tell			    fn tell(&self) -> IoResult<u64>;
test			mod test 
test			mod test 
test			mod test 
test			mod test 
tests			    mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
thread			pub mod thread;
thread_local_storage			mod thread_local_storage;
thread_local_task_smoke_test			    fn thread_local_task_smoke_test() 
thread_local_task_two_instances			    fn thread_local_task_two_instances() 
thread_start			extern fn thread_start(main: *mut libc::c_void) -> imp::rust_thread_return 
time_to_live			    fn time_to_live(&mut self, ttl: int) -> IoResult<()>;
timer_init			    fn timer_init(&mut self) -> IoResult<Box<RtioTimer + Send>>;
tls			    fn tls() 
tls_key			    fn tls_key() -> tls::Key 
tls_smoke_test			    fn tls_smoke_test() 
to_c_str			    fn to_c_str(&self) -> CString 
to_c_str			    fn to_c_str(&self) -> CString;
to_c_str_unchecked			    unsafe fn to_c_str_unchecked(&self) -> CString 
to_c_str_unchecked			    unsafe fn to_c_str_unchecked(&self) -> CString;
truncate			    fn truncate(&mut self, offset: i64) -> IoResult<()>;
try			pub unsafe fn try(f: ||) -> ::core::result::Result<(), Box<Any + Send>> 
try_fn			    extern fn try_fn(code: *mut c_void, env: *mut c_void) 
try_take			    fn try_take() -> Option<Box<Self>>;
try_take			    fn try_take() -> Option<Box<Task>> { unsafe { local_ptr::try_take() } }
try_take			    fn try_take() 
try_take			    pub unsafe fn try_take<T>() -> Option<Box<T>> 
try_unsafe_borrow			    unsafe fn try_unsafe_borrow() -> Option<*mut Self>;
try_unsafe_borrow			    unsafe fn try_unsafe_borrow() -> Option<*mut Task> 
try_unsafe_borrow			    pub unsafe fn try_unsafe_borrow<T>() -> Option<*mut T> 
trylock			        pub unsafe fn trylock(&self) -> bool 
trylock			    pub unsafe fn trylock<'a>(&'a self) -> Option<LockGuard<'a>> 
trylock_noguard			    pub unsafe fn trylock_noguard(&self) -> bool 
tty_open			    fn tty_open(&mut self, fd: c_int, readable: bool)
udp_bind			    fn udp_bind(&mut self, addr: SocketAddr)
unix_bind			    fn unix_bind(&mut self, path: &CString)
unix_connect			    fn unix_connect(&mut self, path: &CString,
unlock			        pub unsafe fn unlock(&self) { pthread_mutex_unlock(self.lock.get()); }
unlock			        pub unsafe fn unlock(&self) 
unlock_noguard			    pub unsafe fn unlock_noguard(&self) { self.inner.unlock() }
unlock_noguard			    pub unsafe fn unlock_noguard(&self) { self.inner.unlock_noguard() }
unsafe_borrow			    unsafe fn unsafe_borrow() -> *mut Self;
unsafe_borrow			    unsafe fn unsafe_borrow() -> *mut Task { local_ptr::unsafe_borrow() }
unsafe_borrow			    pub unsafe fn unsafe_borrow<T>() -> *mut T 
unsafe_take			    unsafe fn unsafe_take() -> Box<Self>;
unsafe_take			    unsafe fn unsafe_take() -> Box<Task> { local_ptr::unsafe_take() }
unsafe_take			    pub unsafe fn unsafe_take<T>() -> Box<T> 
unwind			pub mod unwind;
unwind			    fn unwind() 
unwinding			    pub fn unwinding(&self) -> bool 
unwrap			    pub unsafe fn unwrap(mut self) -> *const libc::c_char 
update			    fn update(&mut self, _alloc: &mut AllocHeader, _orig: *mut AllocHeader) {}
update_size			    fn update_size(&mut self, _size: u32) {}
util			mod util;
wait			    pub fn wait(&self) 
wait			        pub unsafe fn wait(&self) 
wait			    pub unsafe fn wait(&self) 
wait			    fn wait(&mut self) -> IoResult<ProcessExit>;
wait_for_other_tasks			pub fn wait_for_other_tasks() 
wait_noguard			    pub unsafe fn wait_noguard(&self) { self.inner.wait() }
wait_noguard			    pub unsafe fn wait_noguard(&self) { self.inner.wait_noguard() }
wake			    pub fn wake(self) -> Option<Box<Task>> 
with_c_str			    fn with_c_str<T>(&self, f: |*const libc::c_char| -> T) -> T 
with_c_str			unsafe fn with_c_str<T>(v: &[u8], checked: bool,
with_c_str_unchecked			    unsafe fn with_c_str_unchecked<T>(&self, f: |*const libc::c_char| -> T) -> T 
with_lock			    fn with_lock<T>(f: || -> T) -> T 
with_mut_ref			    pub fn with_mut_ref<T>(&mut self, f: |*mut libc::c_char| -> T) -> T 
with_ref			    pub fn with_ref<T>(&self, f: |*const libc::c_char| -> T) -> T 
wrap			    fn wrap(~self) -> Box<Any>;
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()>;
write			        fn write(&mut self, buf: &[u8]) -> fmt::Result 
write			        fn write(&mut self, bytes: &[u8]) -> fmt::Result 
write			    fn write(&mut self, data: &[u8]) -> fmt::Result 
yield_now			    fn yield_now(~self, cur_task: Box<Task>);
yield_now			    pub fn yield_now(mut ~self) 
yield_now			    pub fn yield_now() 
yield_now			    pub unsafe fn yield_now() { assert_eq!(sched_yield(), 0); }
yield_now			    pub unsafe fn yield_now() 
