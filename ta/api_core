Adapter			        struct Adapter<'a,T: ?Sized +'a>(&'a mut T);
Adapter			        struct Adapter<Iter> 
Adapter			        struct Adapter<Iter, E> 
Add			        impl Add for 
Add			pub trait Add<RHS=Self> 
AdditiveIterator			pub trait AdditiveIterator<A> 
Alignment			pub enum Alignment 
Any			impl Any 
Any			pub trait Any: 'static 
Any for T			impl<T: 'static> Any for T 
Argument			impl<'a> Argument<'a> 
Argument			pub struct Argument<'a> 
Argument			pub struct Argument<'a> 
Arguments			impl<'a> Arguments<'a> 
Arguments			pub struct Arguments<'a> 
AsSlice			impl<T> AsSlice<T> for [T] 
AsSlice			pub trait AsSlice<T> 
AsSlice for Option			impl<T> AsSlice<T> for Option<T> 
AsSlice for Result			impl<T, E> AsSlice<T> for Result<T, E> 
AtomicBool			impl AtomicBool 
AtomicBool			pub struct AtomicBool 
AtomicInt			impl AtomicInt 
AtomicInt			pub struct AtomicInt 
AtomicPtr			impl<T> AtomicPtr<T> 
AtomicPtr			pub struct AtomicPtr<T> 
AtomicUint			impl AtomicUint 
AtomicUint			pub struct AtomicUint 
Binary			pub trait Binary 
Binary			struct Binary;
BitAnd			        impl BitAnd for 
BitAnd			pub trait BitAnd<RHS=Self> 
BitOr			        impl BitOr for 
BitOr			pub trait BitOr<RHS=Self> 
BitXor			        impl BitXor for 
BitXor			pub trait BitXor<RHS=Self> 
BorrowFrom			impl<'a, T, B: ?Sized> BorrowFrom<Cow<'a, T, B>> for B where B: ToOwned<T> 
BorrowFrom			pub trait BorrowFrom<Owned: ?Sized> 
BorrowFrom for T			impl<'a, T: ?Sized> BorrowFrom<&'a T> for T 
BorrowFrom for T			impl<'a, T: ?Sized> BorrowFrom<&'a mut T> for T 
BorrowFrom for T			impl<T: ?Sized> BorrowFrom<T> for T 
BorrowFromMut			pub trait BorrowFromMut<Owned: ?Sized> : BorrowFrom<Owned> 
BorrowFromMut for T			impl<'a, T: ?Sized> BorrowFromMut<&'a mut T> for T 
BorrowFromMut for T			impl<T: ?Sized> BorrowFromMut<T> for T 
BorrowRef			impl<'b> BorrowRef<'b> 
BorrowRef			struct BorrowRef<'b> 
BorrowRefMut			impl<'b> BorrowRefMut<'b> 
BorrowRefMut			struct BorrowRefMut<'b> 
ByRef			pub struct ByRef<'a, I:'a> 
Bytes			    struct Bytes<'a>(&'a [u8]);
Bytes			pub struct Bytes<'a>(Map<&'a u8, u8, slice::Iter<'a, u8>, BytesDeref>);
BytesDeref			struct BytesDeref;
Cell			impl<T:Copy> Cell<T> 
Cell			pub struct Cell<T> 
Chain			pub struct Chain<A, B> 
CharEq			impl<'a> CharEq for &'a [char] 
CharEq			pub trait CharEq 
CharEq for F			impl<F> CharEq for F where F: FnMut(char) -> bool 
CharEq for char			impl CharEq for char 
CharExt			pub trait CharExt 
CharExt for char			impl CharExt for char 
CharIndices			pub struct CharIndices<'a> 
CharRange			pub struct CharRange 
CharSplits			impl<'a, Sep> CharSplits<'a, Sep> 
CharSplits			struct CharSplits<'a, Sep> 
CharSplitsN			struct CharSplitsN<'a, Sep> 
Chars			pub struct Chars<'a> 
Chunks			pub struct Chunks<'a, T:'a> 
ChunksMut			pub struct ChunksMut<'a, T:'a> 
Clone			            impl<T:Copy> Clone for [T; 
Clone			        impl Clone for 
Clone			impl<'a, T: ?Sized> Clone for &'a T 
Clone			pub trait Clone : Sized 
Clone			impl<T> Clone for *const T 
Clone			impl<T> Clone for *mut T 
Clone			            impl<
Clone for BorrowRef			impl<'b> Clone for BorrowRef<'b> 
Clone for Cell			impl<T:Copy> Clone for Cell<T> 
Clone for ContravariantType			impl<T: ?Sized> Clone for ContravariantType<T> 
Clone for CovariantType			impl<T: ?Sized> Clone for CovariantType<T> 
Clone for Cow			impl<'a, T, B: ?Sized> Clone for Cow<'a, T, B> where B: ToOwned<T> 
Clone for Filter			impl<A, I, P> Clone for Filter<A, I, P> where
Clone for FilterMap			impl<A, B, I, F> Clone for FilterMap<A, B, I, F> where
Clone for FlatMap			impl<A, B, I, U, F> Clone for FlatMap<A, B, I, U, F> where
Clone for Inspect			impl<A, I, F> Clone for Inspect<A, I, F> where
Clone for InvariantType			impl<T: ?Sized> Clone for InvariantType<T> 
Clone for Iter			impl<'a, A> Clone for Iter<'a, A> 
Clone for Iter			impl<'a, T> Clone for Iter<'a, T> 
Clone for Iter			impl<'a, T> Clone for Iter<'a, T> 
Clone for Map			impl<A, B, I, F> Clone for Map<A, B, I, F> where
Clone for RefCell			impl<T: Clone> Clone for RefCell<T> 
Clone for Scan			impl<A, B, I, St, F> Clone for Scan<A, B, I, St, F> where
Clone for SipState			impl Clone for SipState 
Clone for SkipWhile			impl<A, I, P> Clone for SkipWhile<A, I, P> where
Clone for Split			impl<'a, T, P> Clone for Split<'a, T, P> where P: Clone + FnMut(&T) -> bool 
Clone for TakeWhile			impl<A, I, P> Clone for TakeWhile<A, I, P> where
Clone for Unfold			impl<A, St, F> Clone for Unfold<A, St, F> where
Clone for extern			        impl<
Cloned			pub struct Cloned<I> 
Closure			pub struct Closure 
ContravariantLifetime			pub struct ContravariantLifetime<'a>;
ContravariantType			pub struct ContravariantType<T: ?Sized>;
Copy			pub trait Copy 
Copy for ContravariantType			impl<T: ?Sized> Copy for ContravariantType<T> {}
Copy for CovariantType			impl<T: ?Sized> Copy for CovariantType<T> {}
Copy for InvariantType			impl<T: ?Sized> Copy for InvariantType<T> {}
Copy for Iter			impl<'a,T> Copy for Iter<'a,T> {}
Copy for Slice			impl<T> Copy for Slice<T> {}
Count			pub enum Count 
Counter			pub struct Counter<A> 
CovariantLifetime			pub struct CovariantLifetime<'a>;
CovariantType			pub struct CovariantType<T: ?Sized>;
Cow			impl<'a, T, B: ?Sized> Cow<'a, T, B> where B: ToOwned<T> 
Cow			pub enum Cow<'a, T, B: ?Sized + 'a> where B: ToOwned<T> 
Cycle			pub struct Cycle<I> 
Decimal			struct Decimal;
Default			        impl Default for 
Default			pub trait Default 
Default			impl<'a, T> Default for &'a [T] 
Default			impl<'a> Default for &'a str 
Default			            impl<
Default for Cell			impl<T:Default + Copy> Default for Cell<T> 
Default for Option			impl<T> Default for Option<T> 
Default for RefCell			impl<T:Default> Default for RefCell<T> 
Default for SipHasher			impl Default for SipHasher 
Default for SipState			impl Default for SipState 
Deref			impl<'a, T: ?Sized> Deref for &'a T 
Deref			impl<'a, T: ?Sized> Deref for &'a mut T 
Deref			pub trait Deref 
Deref for Cow			impl<'a, T, B: ?Sized> Deref for Cow<'a, T, B> where B: ToOwned<T>  
Deref for NonZero			impl<T: Zeroable> Deref for NonZero<T> 
Deref for Ref			impl<'b, T> Deref for Ref<'b, T> 
Deref for RefMut			impl<'b, T> Deref for RefMut<'b, T> 
DerefMut			impl<'a, T: ?Sized> DerefMut for &'a mut T 
DerefMut			pub trait DerefMut: Deref 
DerefMut for RefMut			impl<'b, T> DerefMut for RefMut<'b, T> 
Div			        impl Div for 
Div			pub trait Div<RHS=Self> 
DoubleEndedIterator			pub trait DoubleEndedIterator: Iterator 
DoubleEndedIterator			        impl<'a, T> DoubleEndedIterator for 
DoubleEndedIterator			        impl<'a, P: CharEq> DoubleEndedIterator for 
DoubleEndedIterator			        impl<'a> DoubleEndedIterator for 
DoubleEndedIterator for ByRef			impl<'a, I> DoubleEndedIterator for ByRef<'a, I> where I: 'a + DoubleEndedIterator 
DoubleEndedIterator for Chain			impl<T, A, B> DoubleEndedIterator for Chain<A, B> where
DoubleEndedIterator for CharIndices			impl<'a> DoubleEndedIterator for CharIndices<'a> 
DoubleEndedIterator for CharSplits			impl<'a, Sep: CharEq> DoubleEndedIterator for CharSplits<'a, Sep> 
DoubleEndedIterator for Chars			impl<'a> DoubleEndedIterator for Chars<'a> 
DoubleEndedIterator for Chunks			impl<'a, T> DoubleEndedIterator for Chunks<'a, T> 
DoubleEndedIterator for ChunksMut			impl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> 
DoubleEndedIterator for Cloned			impl<T, D, I> DoubleEndedIterator for Cloned<I> where
DoubleEndedIterator for Enumerate			impl<I> DoubleEndedIterator for Enumerate<I> where
DoubleEndedIterator for Filter			impl<A, I, P> DoubleEndedIterator for Filter<A, I, P> where
DoubleEndedIterator for FilterMap			impl<A, B, I, F> DoubleEndedIterator for FilterMap<A, B, I, F> where
DoubleEndedIterator for FlatMap			impl<A, B, I, U, F> DoubleEndedIterator for FlatMap<A, B, I, U, F> where
DoubleEndedIterator for Fuse			impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator 
DoubleEndedIterator for Inspect			impl<A, I, F> DoubleEndedIterator for Inspect<A, I, F> where
DoubleEndedIterator for IntoIter			impl<A> DoubleEndedIterator for IntoIter<A> 
DoubleEndedIterator for IntoIter			impl<T> DoubleEndedIterator for IntoIter<T> 
DoubleEndedIterator for Item			impl<A> DoubleEndedIterator for Item<A> 
DoubleEndedIterator for Iter			impl<'a, A> DoubleEndedIterator for Iter<'a, A> 
DoubleEndedIterator for Iter			impl<'a, T> DoubleEndedIterator for Iter<'a, T> 
DoubleEndedIterator for IterMut			impl<'a, A> DoubleEndedIterator for IterMut<'a, A> 
DoubleEndedIterator for IterMut			impl<'a, T> DoubleEndedIterator for IterMut<'a, T> 
DoubleEndedIterator for Lines			impl<'a> DoubleEndedIterator for Lines<'a> 
DoubleEndedIterator for LinesAny			impl<'a> DoubleEndedIterator for LinesAny<'a> 
DoubleEndedIterator for Map			impl<A, B, I, F> DoubleEndedIterator for Map<A, B, I, F> where
DoubleEndedIterator for Range			impl<A: Int + ToPrimitive> DoubleEndedIterator for Range<A> 
DoubleEndedIterator for Range			impl<Idx: Clone + Step> DoubleEndedIterator for Range<Idx> 
DoubleEndedIterator for RangeInclusive			impl<A: Int + ToPrimitive> DoubleEndedIterator for RangeInclusive<A> 
DoubleEndedIterator for Repeat			impl<A: Clone> DoubleEndedIterator for Repeat<A> 
DoubleEndedIterator for Rev			impl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator 
DoubleEndedIterator for Split			impl<'a, T, P> DoubleEndedIterator for Split<'a, T, P> where P: FnMut(&T) -> bool 
DoubleEndedIterator for SplitMut			impl<'a, T, P> DoubleEndedIterator for SplitMut<'a, T, P> where
DoubleEndedIterator for Zip			impl<T, U, A, B> DoubleEndedIterator for Zip<A, B> where
Drop			pub trait Drop 
Drop for BorrowRef			impl<'b> Drop for BorrowRef<'b> 
Drop for BorrowRefMut			impl<'b> Drop for BorrowRefMut<'b> 
Drop for Finallyalizer			impl<'a, A, F> Drop for Finallyalizer<'a, A, F> where F: FnMut(&mut A) 
Enumerate			pub struct Enumerate<I> 
Eq			            impl<T:Eq> Eq for [T; 
Eq			            impl Eq for 
Eq			    impl<'a, A: ?Sized> Eq for &'a A where A: Eq {}
Eq			    impl<'a, A: ?Sized> Eq for &'a mut A where A: Eq {}
Eq			pub trait Eq: PartialEq<Self> 
Eq			impl<T> Eq for *const T {}
Eq			impl<T> Eq for *mut T {}
Eq			impl<T: Eq> Eq for [T] {}
Eq			            impl<
Eq for Cow			impl<'a, T, B: ?Sized> Eq for Cow<'a, T, B> where B: Eq + ToOwned<T> {}
Eq for Ordering			impl Eq for Ordering {}
Eq for str			    impl Eq for str {}
Error			pub struct Error;
EscapeDefault			pub struct EscapeDefault 
EscapeDefaultState			enum EscapeDefaultState 
EscapeUnicode			pub struct EscapeUnicode 
EscapeUnicodeState			enum EscapeUnicodeState 
ExactSizeIterator			pub trait ExactSizeIterator: Iterator 
ExactSizeIterator			        impl<'a> ExactSizeIterator for 
ExactSizeIterator for Cloned			impl<T, D, I> ExactSizeIterator for Cloned<I> where
ExactSizeIterator for Enumerate			impl<I> ExactSizeIterator for Enumerate<I> where I: ExactSizeIterator {}
ExactSizeIterator for Inspect			impl<A, I, F> ExactSizeIterator for Inspect<A, I, F> where
ExactSizeIterator for IntoIter			impl<A> ExactSizeIterator for IntoIter<A> {}
ExactSizeIterator for IntoIter			impl<T> ExactSizeIterator for IntoIter<T> {}
ExactSizeIterator for Item			impl<A> ExactSizeIterator for Item<A> {}
ExactSizeIterator for Iter			impl<'a, A> ExactSizeIterator for Iter<'a, A> {}
ExactSizeIterator for Iter			impl<'a, T> ExactSizeIterator for Iter<'a, T> {}
ExactSizeIterator for Iter			impl<'a, T> ExactSizeIterator for Iter<'a, T> {}
ExactSizeIterator for IterMut			impl<'a, A> ExactSizeIterator for IterMut<'a, A> {}
ExactSizeIterator for IterMut			impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}
ExactSizeIterator for IterMut			impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}
ExactSizeIterator for Map			impl<A, B, I, F> ExactSizeIterator for Map<A, B, I, F> where
ExactSizeIterator for Range			impl<Idx: Clone + Step> ExactSizeIterator for Range<Idx> {}
ExactSizeIterator for Rev			impl<I> ExactSizeIterator for Rev<I> where I: ExactSizeIterator + DoubleEndedIterator {}
ExactSizeIterator for Zip			impl<A, B> ExactSizeIterator for Zip<A, B> where A: ExactSizeIterator, B: ExactSizeIterator {}
ExponentFormat			pub enum ExponentFormat 
Extend			pub trait Extend<A> 
Filler			            struct Filler<'a> 
Filter			pub struct Filter<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool 
FilterMap			pub struct FilterMap<A, B, I, F> where I: Iterator<Item=A>, F: FnMut(A) -> Option<B> 
Finally			pub trait Finally<T> 
Finally for F			impl<T, F> Finally<T> for F where F: FnMut() -> T 
Finallyalizer			struct Finallyalizer<'a, A:'a, F> where F: FnMut(&mut A) 
Flag			pub enum Flag 
FlatMap			pub struct FlatMap<A, B, I, U, F> where
Float			pub trait Float
Float for f32			impl Float for f32 
Float for f64			impl Float for f64 
Fn			pub trait Fn<Args,Result> 
Fn			impl<'a> Fn(&'a u8) -> u8 for BytesDeref 
FnMut			pub trait FnMut<Args,Result> 
FnMut for F			impl<F: ?Sized, A, R> FnMut<A, R> for F
FnOnce			pub trait FnOnce<Args,Result> 
FnOnce for F			impl<F,A,R> FnOnce<A,R> for F
FormatSpec			pub struct FormatSpec 
Formatter			impl<'a> Formatter<'a> 
Formatter			pub struct Formatter<'a> 
FpCategory			pub enum FpCategory 
FromIterator			pub trait FromIterator<A> 
FromPrimitive			        impl FromPrimitive for 
FromPrimitive			pub trait FromPrimitive : ::marker::Sized 
FromStr			        impl FromStr for 
FromStr			pub trait FromStr 
FromStr for bool			impl FromStr for bool 
FromStrRadix			        impl FromStrRadix for 
FromStrRadix			pub trait FromStrRadix 
FullRange			pub struct FullRange;
Fuse			impl<I> Fuse<I> 
Fuse			pub struct Fuse<I> 
GenericRadix			        impl GenericRadix for 
GenericRadix			trait GenericRadix 
GenericRadix for Radix			impl GenericRadix for Radix 
GenericSplitN			struct GenericSplitN<I> 
Hash			        impl<S: Writer> Hash<S> for 
Hash			        impl<S: Writer> Hash<S> for () 
Hash			impl<S: Writer, T> Hash<S> for *const T 
Hash			impl<S: Writer, T> Hash<S> for *mut T 
Hash			pub trait Hash<S = sip::SipState> 
Hash for Bytes			    impl<'a, S: Writer> Hash<S> for Bytes<'a> 
Hash for Cow			impl<'a, T, B: ?Sized, S> Hash<S> for Cow<'a, T, B> where B: Hash<S> + ToOwned<T> 
Hash for TypeId			impl<S: Writer> Hash<S> for TypeId 
Hash for bool			impl<S: Writer> Hash<S> for bool 
Hash for char			impl<S: Writer> Hash<S> for char 
Hash for str			impl<S: Writer> Hash<S> for str 
Hasher			pub trait Hasher<S> 
Hasher for SipHasher			impl Hasher<SipState> for SipHasher 
Index			pub trait Index<Index: ?Sized> 
IndexMut			pub trait IndexMut<Index: ?Sized> 
Inspect			impl<A, I, F> Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) 
Inspect			pub struct Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) 
Int			        impl Int for 
Int			pub trait Int
IntSliceExt			        impl IntSliceExt<
IntSliceExt			pub trait IntSliceExt<U, S> 
IntoCow			pub trait IntoCow<'a, T, B: ?Sized> 
IntoCow for Cow			impl<'a, T, B: ?Sized> IntoCow<'a, T, B> for Cow<'a, T, B> where B: ToOwned<T> 
IntoIter			pub struct IntoIter<A> { inner: Item<A> }
IntoIter			pub struct IntoIter<T> { inner: Option<T> }
InvariantLifetime			pub struct InvariantLifetime<'a>;
InvariantType			pub struct InvariantType<T: ?Sized>;
Item			struct Item<A> 
Iter			pub struct Iter<'a, A: 'a> { inner: Item<&'a A> }
Iter			pub struct Iter<'a, T: 'a> { inner: Option<&'a T> }
Iter			impl<'a, T> Iter<'a, T> 
Iter			pub struct Iter<'a, T: 'a> 
IterMut			pub struct IterMut<'a, A: 'a> { inner: Item<&'a mut A> }
IterMut			pub struct IterMut<'a, T: 'a> { inner: Option<&'a mut T> }
IterMut			impl<'a, T> IterMut<'a, T> 
IterMut			pub struct IterMut<'a, T: 'a> 
Iterator			pub trait Iterator 
Iterator			        impl<'a, 
Iterator			        impl<'a, T> Iterator for 
Iterator			        impl<'a, P: CharEq> Iterator for 
Iterator			        impl<'a> Iterator for 
Iterator for ByRef			impl<'a, I> Iterator for ByRef<'a, I> where I: 'a + Iterator 
Iterator for Chain			impl<T, A, B> Iterator for Chain<A, B> where A: Iterator<Item=T>, B: Iterator<Item=T> 
Iterator for CharIndices			impl<'a> Iterator for CharIndices<'a> 
Iterator for CharSplits			impl<'a, Sep: CharEq> Iterator for CharSplits<'a, Sep> 
Iterator for CharSplitsN			impl<'a, Sep: CharEq> Iterator for CharSplitsN<'a, Sep> 
Iterator for Chars			impl<'a> Iterator for Chars<'a> 
Iterator for Chunks			impl<'a, T> Iterator for Chunks<'a, T> 
Iterator for ChunksMut			impl<'a, T> Iterator for ChunksMut<'a, T> 
Iterator for Cloned			impl<T, D, I> Iterator for Cloned<I> where
Iterator for Cycle			impl<I> Iterator for Cycle<I> where I: Clone + Iterator 
Iterator for Enumerate			impl<I> Iterator for Enumerate<I> where I: Iterator 
Iterator for EscapeDefault			impl Iterator for EscapeDefault 
Iterator for EscapeUnicode			impl Iterator for EscapeUnicode 
Iterator for Filter			impl<A, I, P> Iterator for Filter<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool 
Iterator for FilterMap			impl<A, B, I, F> Iterator for FilterMap<A, B, I, F> where
Iterator for FlatMap			impl<A, B, I, U, F> Iterator for FlatMap<A, B, I, U, F> where
Iterator for Fuse			impl<I> Iterator for Fuse<I> where I: Iterator 
Iterator for Inspect			impl<A, I, F> Iterator for Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) 
Iterator for IntoIter			impl<A> Iterator for IntoIter<A> 
Iterator for IntoIter			impl<T> Iterator for IntoIter<T> 
Iterator for Item			impl<A> Iterator for Item<A> 
Iterator for Iter			impl<'a, A> Iterator for Iter<'a, A> 
Iterator for Iter			impl<'a, T> Iterator for Iter<'a, T> 
Iterator for IterMut			impl<'a, A> Iterator for IterMut<'a, A> 
Iterator for IterMut			impl<'a, T> Iterator for IterMut<'a, T> 
Iterator for Lines			impl<'a> Iterator for Lines<'a> 
Iterator for LinesAny			impl<'a> Iterator for LinesAny<'a> 
Iterator for Map			impl<A, B, I, F> Iterator for Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMut(A) -> B 
Iterator for MatchIndices			impl<'a> Iterator for MatchIndices<'a> 
Iterator for Peekable			impl<T, I> Iterator for Peekable<T, I> where I: Iterator<Item=T> 
Iterator for Range			impl<A: Int + ToPrimitive> Iterator for Range<A> 
Iterator for Range			impl<Idx: Clone + Step> Iterator for Range<Idx> 
Iterator for RangeFrom			impl<Idx: Clone + Step> Iterator for RangeFrom<Idx> 
Iterator for RangeInclusive			impl<A: Int + ToPrimitive> Iterator for RangeInclusive<A> 
Iterator for RangeStep			impl<A: Int> Iterator for RangeStep<A> 
Iterator for RangeStepInclusive			impl<A: Int> Iterator for RangeStepInclusive<A> 
Iterator for Repeat			impl<A: Clone> Iterator for Repeat<A> 
Iterator for Rev			impl<I> Iterator for Rev<I> where I: DoubleEndedIterator 
Iterator for Scan			impl<A, B, I, St, F> Iterator for Scan<A, B, I, St, F> where
Iterator for SizeHint			        impl<A> Iterator for SizeHint<A> 
Iterator for Skip			impl<I> Iterator for Skip<I> where I: Iterator 
Iterator for SkipWhile			impl<A, I, P> Iterator for SkipWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool 
Iterator for Split			impl<'a, T, P> Iterator for Split<'a, T, P> where P: FnMut(&T) -> bool 
Iterator for SplitMut			impl<'a, T, P> Iterator for SplitMut<'a, T, P> where P: FnMut(&T) -> bool 
Iterator for SplitStr			impl<'a> Iterator for SplitStr<'a> 
Iterator for Take			impl<I> Iterator for Take<I> where I: Iterator
Iterator for TakeWhile			impl<A, I, P> Iterator for TakeWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool 
Iterator for Unfold			impl<A, St, F> Iterator for Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> 
Iterator for Windows			impl<'a, T> Iterator for Windows<'a, T> 
Iterator for Zip			impl<T, U, A, B> Iterator for Zip<A, B> where
IteratorExt			pub trait IteratorExt: Iterator + Sized 
IteratorExt for I			impl<I> IteratorExt for I where I: Iterator {}
Lines			pub struct Lines<'a> 
LinesAny			pub struct LinesAny<'a> 
LowerExp			    impl LowerExp for 
LowerExp			pub trait LowerExp 
LowerHex			pub trait LowerHex 
LowerHex			struct LowerHex;
Managed			pub struct Managed;
Map			impl<A, B, I, F> Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMut(A) -> B 
Map			pub struct Map<A, B, I: Iterator<Item=A>, F: FnMut(A) -> B> 
MatchIndices			pub struct MatchIndices<'a> 
MinMaxResult			impl<T: Clone> MinMaxResult<T> 
MinMaxResult			pub enum MinMaxResult<T> 
Mul			        impl Mul for 
Mul			pub trait Mul<RHS=Self> 
MultiplicativeIterator			pub trait MultiplicativeIterator<A> 
MutPtrExt			impl<T> MutPtrExt for *mut T 
MutPtrExt			pub trait MutPtrExt 
MutableByteVector			    impl MutableByteVector for [u8] 
MutableByteVector			    pub trait MutableByteVector 
NaiveSearcher			impl NaiveSearcher 
NaiveSearcher			struct NaiveSearcher 
Neg			        impl Neg for 
Neg			pub trait Neg 
NoCopy			pub struct NoCopy;
NoSend			pub struct NoSend;
NoSync			pub struct NoSync;
NonZero			impl<T: Zeroable> NonZero<T> 
NonZero			pub struct NonZero<T: Zeroable>(T);
Not			        impl Not for 
Not			pub trait Not 
NumCast			        impl NumCast for 
NumCast			pub trait NumCast: ToPrimitive 
Octal			pub trait Octal 
Octal			struct Octal;
Option			impl<T: Default> Option<T> 
Option			impl<T> Option<T> 
Option			pub enum Option<T> 
Ord			            impl<T:Ord> Ord for [T; 
Ord			            impl Ord for 
Ord			    impl Ord for () 
Ord			    impl<'a, A: ?Sized> Ord for &'a A where A: Ord 
Ord			    impl<'a, A: ?Sized> Ord for &'a mut A where A: Ord 
Ord			pub trait Ord: Eq + PartialOrd<Self> 
Ord			impl<T> Ord for *const T 
Ord			impl<T> Ord for *mut T 
Ord			impl<T: Ord> Ord for [T] 
Ord			            impl<
Ord for Cow			impl<'a, T, B: ?Sized> Ord for Cow<'a, T, B> where B: Ord + ToOwned<T> 
Ord for Ordering			impl Ord for Ordering 
Ord for bool			    impl Ord for bool 
Ord for str			    impl Ord for str 
Ordering			pub enum Ordering 
Ordering			impl Ordering 
Ordering			pub enum Ordering 
PartialEq			            impl<'a, A, B, Rhs> PartialEq<Rhs> for [A; 
PartialEq			            impl<A, B> PartialEq<[B; 
PartialEq			impl<'a, 'b, T, U, B: ?Sized, C: ?Sized> PartialEq<Cow<'b, U, C>> for Cow<'a, T, B> where
PartialEq			            impl PartialEq for 
PartialEq			    impl PartialEq for () 
PartialEq			    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b B> for &'a A where A: PartialEq<B> 
PartialEq			    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b B> for &'a mut A where A: PartialEq<B> 
PartialEq			    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b mut B> for &'a A where A: PartialEq<B> 
PartialEq			    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b mut B> for &'a mut A where A: PartialEq<B> 
PartialEq			pub trait PartialEq<Rhs: ?Sized = Self> 
PartialEq			impl<T> PartialEq for *const T 
PartialEq			impl<T> PartialEq for *mut T 
PartialEq			impl<A, B> PartialEq<[B]> for [A] where A: PartialEq<B> 
PartialEq			            impl<
PartialEq for Cell			impl<T:PartialEq + Copy> PartialEq for Cell<T> 
PartialEq for Lhs			            impl<'a, A, B, Lhs> PartialEq<[B; 
PartialEq for RefCell			impl<T: PartialEq> PartialEq for RefCell<T> 
PartialEq for extern			            impl<_R,
PartialEq for extern			    impl<_R> PartialEq for extern "C" fn() -> _R 
PartialEq for str			    impl PartialEq for str 
PartialOrd			            impl<T:PartialOrd> PartialOrd for [T; 
PartialOrd			            impl PartialOrd for 
PartialOrd			    impl PartialOrd for () 
PartialOrd			    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialOrd<&'b B> for &'a A where A: PartialOrd<B> 
PartialOrd			    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialOrd<&'b mut B> for &'a mut A where A: PartialOrd<B> 
PartialOrd			pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> 
PartialOrd			impl<T> PartialOrd for *const T 
PartialOrd			impl<T> PartialOrd for *mut T 
PartialOrd			impl<T: PartialOrd> PartialOrd for [T] 
PartialOrd			            impl<
PartialOrd for Cow			impl<'a, T, B: ?Sized> PartialOrd for Cow<'a, T, B> where B: PartialOrd + ToOwned<T> 
PartialOrd for Ordering			impl PartialOrd for Ordering 
PartialOrd for bool			    impl PartialOrd for bool 
PartialOrd for str			    impl PartialOrd for str 
Peekable			impl<T, I> Peekable<T, I> where I: Iterator<Item=T> 
Peekable			pub struct Peekable<T, I> where I: Iterator<Item=T> 
Pointer			impl<'a, T> Pointer for &'a T 
Pointer			impl<'a, T> Pointer for &'a mut T 
Pointer			impl<T> Pointer for *const T 
Pointer			impl<T> Pointer for *mut T 
Pointer			pub trait Pointer 
Position			pub enum Position 
PtrExt			impl<T> PtrExt for *const T 
PtrExt			impl<T> PtrExt for *mut T 
PtrExt			pub trait PtrExt: Sized 
RSplitN			pub struct RSplitN<'a, T: 'a, P> where P: FnMut(&T) -> bool 
RSplitN			pub struct RSplitN<'a, P>(CharSplitsN<'a, P>);
RSplitNMut			pub struct RSplitNMut<'a, T: 'a, P> where P: FnMut(&T) -> bool 
Radix			impl Radix 
Radix			pub struct Radix 
RadixFmt			pub struct RadixFmt<T, R>(T, R);
RandomAccessIterator			pub trait RandomAccessIterator: Iterator 
RandomAccessIterator for Chain			impl<T, A, B> RandomAccessIterator for Chain<A, B> where
RandomAccessIterator for Chunks			impl<'a, T> RandomAccessIterator for Chunks<'a, T> 
RandomAccessIterator for Cycle			impl<I> RandomAccessIterator for Cycle<I> where
RandomAccessIterator for Enumerate			impl<I> RandomAccessIterator for Enumerate<I> where I: RandomAccessIterator 
RandomAccessIterator for Fuse			impl<I> RandomAccessIterator for Fuse<I> where I: RandomAccessIterator 
RandomAccessIterator for Inspect			impl<A, I, F> RandomAccessIterator for Inspect<A, I, F> where
RandomAccessIterator for Iter			impl<'a, T> RandomAccessIterator for Iter<'a, T> 
RandomAccessIterator for Map			impl<A, B, I, F> RandomAccessIterator for Map<A, B, I, F> where
RandomAccessIterator for Repeat			impl<A: Clone> RandomAccessIterator for Repeat<A> 
RandomAccessIterator for Rev			impl<I> RandomAccessIterator for Rev<I> where I: DoubleEndedIterator + RandomAccessIterator 
RandomAccessIterator for Skip			impl<I> RandomAccessIterator for Skip<I> where I: RandomAccessIterator
RandomAccessIterator for Take			impl<I> RandomAccessIterator for Take<I> where I: RandomAccessIterator
RandomAccessIterator for Zip			impl<T, U, A, B> RandomAccessIterator for Zip<A, B> where
Range			pub struct Range<A> 
Range			pub struct Range<Idx> 
RangeFrom			pub struct RangeFrom<Idx> 
RangeInclusive			pub struct RangeInclusive<A> 
RangeStep			pub struct RangeStep<A> 
RangeStepInclusive			pub struct RangeStepInclusive<A> 
RangeTo			pub struct RangeTo<Idx> 
Ref			pub struct Ref<'b, T:'b> 
RefCell			impl<T> RefCell<T> 
RefCell			pub struct RefCell<T> 
RefMut			pub struct RefMut<'b, T:'b> 
Rem			        impl Rem for 
Rem			pub trait Rem<RHS=Self> 
Repeat			pub struct Repeat<A> 
Repr			impl Repr<Slice<u8>> for str {}
Repr			impl<T> Repr<Slice<T>> for [T] {}
Repr			pub trait Repr<T> 
Result			impl<T, E: Show> Result<T, E> 
Result			impl<T, E> Result<T, E> 
Result			impl<T: Show, E> Result<T, E> 
Result			pub enum Result<T, E> 
Rev			pub struct Rev<T> 
Scan			pub struct Scan<A, B, I, St, F> where I: Iterator, F: FnMut(&mut St, A) -> Option<B> 
Searcher			enum Searcher 
Searcher			impl Searcher 
Shl			        impl Shl<uint> for 
Shl			pub trait Shl<RHS> 
Show			        impl<
Show			    impl Show for 
Show			impl Show for () 
Show			impl<'a> Show for &'a (any::Any+'a) 
Show			impl<T: Show> Show for [T] 
Show			impl<T> Show for *const T 
Show			impl<T> Show for *mut T 
Show			pub trait Show 
Show for Arguments			impl<'a> Show for Arguments<'a> 
Show for Cell			impl<T: Copy + Show> Show for Cell<T> 
Show for Error			impl Show for Error 
Show for Ref			impl<'b, T: Show> Show for Ref<'b, T> 
Show for RefCell			impl<T: Show> Show for RefCell<T> 
Show for RefMut			impl<'b, T: Show> Show for RefMut<'b, T> 
Show for bool			impl Show for bool 
Show for char			impl Show for char 
Show for str			impl Show for str 
Shr			        impl Shr<uint> for 
Shr			pub trait Shr<RHS> 
SignFormat			pub enum SignFormat 
SignedInt			        impl SignedInt for 
SignedInt			pub trait SignedInt
SignificantDigits			pub enum SignificantDigits 
SipHasher			impl SipHasher 
SipHasher			pub struct SipHasher 
SipState			impl SipState 
SipState			pub struct SipState 
SizeHint			        struct SizeHint<A>(uint, Option<uint>);
Sized			pub trait Sized 
Skip			pub struct Skip<I> 
SkipWhile			pub struct SkipWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool 
Slice			pub struct Slice<T> 
SliceExt			impl<T> SliceExt for [T] 
SliceExt			pub trait SliceExt 
Split			pub struct Split<'a, T:'a, P> where P: FnMut(&T) -> bool 
Split			pub struct Split<'a, P>(CharSplits<'a, P>);
SplitIter			trait SplitIter: DoubleEndedIterator 
SplitIter for Split			impl<'a, T, P> SplitIter for Split<'a, T, P> where P: FnMut(&T) -> bool 
SplitIter for SplitMut			impl<'a, T, P> SplitIter for SplitMut<'a, T, P> where P: FnMut(&T) -> bool 
SplitMut			pub struct SplitMut<'a, T:'a, P> where P: FnMut(&T) -> bool 
SplitN			pub struct SplitN<'a, T: 'a, P> where P: FnMut(&T) -> bool 
SplitN			pub struct SplitN<'a, P>(CharSplitsN<'a, P>);
SplitNMut			pub struct SplitNMut<'a, T: 'a, P> where P: FnMut(&T) -> bool 
SplitStr			pub struct SplitStr<'a> 
SplitTerminator			pub struct SplitTerminator<'a, P>(CharSplits<'a, P>);
Step			        impl Step for 
Step			pub trait Step: Ord 
Str			impl<'a, S: ?Sized> Str for &'a S where S: Str 
Str			pub trait Str 
Str for str			impl Str for str 
StrExt			pub trait StrExt 
StrExt for str			impl StrExt for str 
String			    impl String for 
String			impl String for () 
String			impl<T: Show> String for [T] 
String			impl<T: String> String for [T] 
String			impl<T> String for *const T 
String			impl<T> String for *mut T 
String			pub trait String 
String for Arguments			impl<'a> String for Arguments<'a> 
String for Utf8Error			impl String for Utf8Error 
String for bool			impl String for bool 
String for char			impl String for char 
String for str			impl String for str 
Sub			        impl Sub for 
Sub			pub trait Sub<RHS=Self> 
Take			pub struct Take<I> 
TakeWhile			pub struct TakeWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool 
ToOwned			pub trait ToOwned<Owned>: BorrowFrom<Owned> 
ToOwned for T			impl<T> ToOwned<T> for T where T: Clone 
ToPrimitive			        impl ToPrimitive for 
ToPrimitive			pub trait ToPrimitive 
TraitObject			pub struct TraitObject 
TwoWaySearcher			impl TwoWaySearcher 
TwoWaySearcher			struct TwoWaySearcher 
TyDesc			pub struct TyDesc 
TypeId			impl TypeId 
TypeId			pub struct TypeId 
Unfold			impl<A, St, F> Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> 
Unfold			pub struct Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> 
Unique			impl<T> Unique<T> 
Unique			pub struct Unique<T>(pub *mut T);
UnsafeCell			impl<T> UnsafeCell<T> 
UnsafeCell			pub struct UnsafeCell<T> 
UnsignedInt			pub trait UnsignedInt: Int 
UnsignedInt for u16			impl UnsignedInt for u16 {}
UnsignedInt for u32			impl UnsignedInt for u32 {}
UnsignedInt for u64			impl UnsignedInt for u64 {}
UnsignedInt for u8			impl UnsignedInt for u8 {}
UnsignedInt for uint			impl UnsignedInt for uint {}
UpperExp			    impl UpperExp for 
UpperExp			pub trait UpperExp 
UpperHex			pub trait UpperHex 
UpperHex			pub struct UpperHex;
Utf8Error			pub enum Utf8Error 
Void			enum Void {}
Windows			pub struct Windows<'a, T:'a> 
Writer			pub trait Writer 
Writer			pub trait Writer 
Writer for Adapter			        impl<'a, T: ?Sized> Writer for Adapter<'a, T>
Writer for SipState			impl Writer for SipState 
Zip			pub struct Zip<A, B> 
abort			    pub fn abort() -> !;
abs			    fn abs(self) -> f32 
abs			    fn abs(self) -> f64 
abs			            fn abs(self) -> 
abs			    fn abs(self) -> Self;
add			            fn add(self, other: 
add			    fn add(self, rhs: RHS) -> Self::Output;
align			    pub fn align(&self) -> rt::Alignment { self.align }
align_of			pub fn align_of<T>() -> uint 
align_of_val			pub fn align_of_val<T>(_val: &T) -> uint 
all			    fn all<F>(mut self, mut f: F) -> bool where F: FnMut(Self::Item) -> bool 
and			    pub fn and<U>(self, optb: Option<U>) -> Option<U> 
and			    pub fn and<U>(self, res: Result<U, E>) -> Result<U, E> 
and_then			    pub fn and_then<U, F: FnOnce(T) -> Option<U>>(self, f: F) -> Option<U> 
and_then			    pub fn and_then<U, F: FnOnce(T) -> Result<U, E>>(self, op: F) -> Result<U, E> 
any			    fn any<F>(&mut self, mut f: F) -> bool where F: FnMut(Self::Item) -> bool 
any			pub mod any;
argument			pub fn argument<'a, T>(f: fn(&T, &mut Formatter) -> Result,
argumentuint			pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> 
array			mod array;
as_bytes			    fn as_bytes(&self) -> &[u8] 
as_bytes			    fn as_bytes<'a>(&'a self) -> &'a [u8];
as_mut			    pub fn as_mut<'r>(&'r mut self) -> Option<&'r mut T> 
as_mut			    unsafe fn as_mut<'a>(&self) -> Option<&'a mut Self::Target>;
as_mut			    unsafe fn as_mut<'a>(&self) -> Option<&'a mut T> 
as_mut			    pub fn as_mut(&mut self) -> Result<&mut T, &mut E> 
as_mut_ptr			    fn as_mut_ptr(&mut self) -> *mut Self::Item;
as_mut_ptr			    fn as_mut_ptr(&mut self) -> *mut T 
as_mut_slice			    pub fn as_mut_slice<'r>(&'r mut self) -> &'r mut [T] 
as_mut_slice			    pub fn as_mut_slice(&mut self) -> &mut [T] 
as_mut_slice			    fn as_mut_slice(&mut self) -> &mut [T] { self }
as_mut_slice			    fn as_mut_slice<'a>(&'a mut self) -> &'a mut [Self::Item];
as_ptr			    fn as_ptr(&self) -> *const Self::Item;
as_ptr			    fn as_ptr(&self) -> *const T 
as_ptr			    fn as_ptr(&self) -> *const u8 
as_ptr			    fn as_ptr(&self) -> *const u8;
as_ref			    pub fn as_ref<'r>(&'r self) -> Option<&'r T> 
as_ref			    unsafe fn as_ref<'a>(&self) -> Option<&'a Self::Target>;
as_ref			    unsafe fn as_ref<'a>(&self) -> Option<&'a T> 
as_ref			    pub fn as_ref(&self) -> Result<&T, &E> 
as_signed			            fn as_signed(&self) -> &[
as_signed			    fn as_signed<'a>(&'a self) -> &'a [S];
as_signed_mut			            fn as_signed_mut(&mut self) -> &mut [
as_signed_mut			    fn as_signed_mut<'a>(&'a mut self) -> &'a mut [S];
as_slice			    fn as_slice<'a>(&'a self) -> &'a [T] 
as_slice			    fn as_slice<'a>(&'a self) -> &'a [T] 
as_slice			    fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }
as_slice			    fn as_slice<'a>(&'a self) -> &'a [T] { self }
as_slice			    fn as_slice<'a>(&'a self) -> &'a [T];
as_slice			    pub fn as_slice(&self) -> &'a [T] 
as_slice			    fn as_slice(&self) -> &str { Str::as_slice(*self) }
as_slice			    fn as_slice<'a>(&'a self) -> &'a str { self }
as_slice			    fn as_slice<'a>(&'a self) -> &'a str;
as_uint			    fn as_uint(&self) -> Option<uint> 
as_unsafe_cell			    pub unsafe fn as_unsafe_cell<'a>(&'a self) -> &'a UnsafeCell<T> 
as_unsigned			            fn as_unsigned(&self) -> &[
as_unsigned			    fn as_unsigned<'a>(&'a self) -> &'a [U];
as_unsigned_mut			            fn as_unsigned_mut(&mut self) -> &mut [
as_unsigned_mut			    fn as_unsigned_mut<'a>(&'a mut self) -> &'a mut [U];
assert_receiver_is_total_eq			    fn assert_receiver_is_total_eq(&self) {}
assume			    pub fn assume(b: bool);
atomic			pub mod atomic;
atomic_add			unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T 
atomic_and			unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T 
atomic_and			    pub fn atomic_and<T>(dst: *mut T, src: T) -> T;
atomic_and_acq			    pub fn atomic_and_acq<T>(dst: *mut T, src: T) -> T;
atomic_and_acqrel			    pub fn atomic_and_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_and_rel			    pub fn atomic_and_rel<T>(dst: *mut T, src: T) -> T;
atomic_and_relaxed			    pub fn atomic_and_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_compare_and_swap			unsafe fn atomic_compare_and_swap<T>(dst: *mut T, old:T, new:T, order: Ordering) -> T 
atomic_cxchg			    pub fn atomic_cxchg<T>(dst: *mut T, old: T, src: T) -> T;
atomic_cxchg_acq			    pub fn atomic_cxchg_acq<T>(dst: *mut T, old: T, src: T) -> T;
atomic_cxchg_acqrel			    pub fn atomic_cxchg_acqrel<T>(dst: *mut T, old: T, src: T) -> T;
atomic_cxchg_rel			    pub fn atomic_cxchg_rel<T>(dst: *mut T, old: T, src: T) -> T;
atomic_cxchg_relaxed			    pub fn atomic_cxchg_relaxed<T>(dst: *mut T, old: T, src: T) -> T;
atomic_fence			    pub fn atomic_fence();
atomic_fence_acq			    pub fn atomic_fence_acq();
atomic_fence_acqrel			    pub fn atomic_fence_acqrel();
atomic_fence_rel			    pub fn atomic_fence_rel();
atomic_load			unsafe fn atomic_load<T>(dst: *const T, order:Ordering) -> T 
atomic_load			    pub fn atomic_load<T>(src: *const T) -> T;
atomic_load_acq			    pub fn atomic_load_acq<T>(src: *const T) -> T;
atomic_load_relaxed			    pub fn atomic_load_relaxed<T>(src: *const T) -> T;
atomic_load_unordered			    pub fn atomic_load_unordered<T>(src: *const T) -> T;
atomic_max			    pub fn atomic_max<T>(dst: *mut T, src: T) -> T;
atomic_max_acq			    pub fn atomic_max_acq<T>(dst: *mut T, src: T) -> T;
atomic_max_acqrel			    pub fn atomic_max_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_max_rel			    pub fn atomic_max_rel<T>(dst: *mut T, src: T) -> T;
atomic_max_relaxed			    pub fn atomic_max_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_min			    pub fn atomic_min<T>(dst: *mut T, src: T) -> T;
atomic_min_acq			    pub fn atomic_min_acq<T>(dst: *mut T, src: T) -> T;
atomic_min_acqrel			    pub fn atomic_min_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_min_rel			    pub fn atomic_min_rel<T>(dst: *mut T, src: T) -> T;
atomic_min_relaxed			    pub fn atomic_min_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_nand			unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T 
atomic_nand			    pub fn atomic_nand<T>(dst: *mut T, src: T) -> T;
atomic_nand_acq			    pub fn atomic_nand_acq<T>(dst: *mut T, src: T) -> T;
atomic_nand_acqrel			    pub fn atomic_nand_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_nand_rel			    pub fn atomic_nand_rel<T>(dst: *mut T, src: T) -> T;
atomic_nand_relaxed			    pub fn atomic_nand_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_or			unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T 
atomic_or			    pub fn atomic_or<T>(dst: *mut T, src: T) -> T;
atomic_or_acq			    pub fn atomic_or_acq<T>(dst: *mut T, src: T) -> T;
atomic_or_acqrel			    pub fn atomic_or_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_or_rel			    pub fn atomic_or_rel<T>(dst: *mut T, src: T) -> T;
atomic_or_relaxed			    pub fn atomic_or_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_store			unsafe fn atomic_store<T>(dst: *mut T, val: T, order:Ordering) 
atomic_store			    pub fn atomic_store<T>(dst: *mut T, val: T);
atomic_store_rel			    pub fn atomic_store_rel<T>(dst: *mut T, val: T);
atomic_store_relaxed			    pub fn atomic_store_relaxed<T>(dst: *mut T, val: T);
atomic_store_unordered			    pub fn atomic_store_unordered<T>(dst: *mut T, val: T);
atomic_sub			unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T 
atomic_swap			unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T 
atomic_umax			    pub fn atomic_umax<T>(dst: *mut T, src: T) -> T;
atomic_umax_acq			    pub fn atomic_umax_acq<T>(dst: *mut T, src: T) -> T;
atomic_umax_acqrel			    pub fn atomic_umax_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_umax_rel			    pub fn atomic_umax_rel<T>(dst: *mut T, src: T) -> T;
atomic_umax_relaxed			    pub fn atomic_umax_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_umin			    pub fn atomic_umin<T>(dst: *mut T, src: T) -> T;
atomic_umin_acq			    pub fn atomic_umin_acq<T>(dst: *mut T, src: T) -> T;
atomic_umin_acqrel			    pub fn atomic_umin_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_umin_rel			    pub fn atomic_umin_rel<T>(dst: *mut T, src: T) -> T;
atomic_umin_relaxed			    pub fn atomic_umin_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_xadd			    pub fn atomic_xadd<T>(dst: *mut T, src: T) -> T;
atomic_xadd_acq			    pub fn atomic_xadd_acq<T>(dst: *mut T, src: T) -> T;
atomic_xadd_acqrel			    pub fn atomic_xadd_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_xadd_rel			    pub fn atomic_xadd_rel<T>(dst: *mut T, src: T) -> T;
atomic_xadd_relaxed			    pub fn atomic_xadd_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_xchg			    pub fn atomic_xchg<T>(dst: *mut T, src: T) -> T;
atomic_xchg_acq			    pub fn atomic_xchg_acq<T>(dst: *mut T, src: T) -> T;
atomic_xchg_acqrel			    pub fn atomic_xchg_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_xchg_rel			    pub fn atomic_xchg_rel<T>(dst: *mut T, src: T) -> T;
atomic_xchg_relaxed			    pub fn atomic_xchg_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_xor			unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T 
atomic_xor			    pub fn atomic_xor<T>(dst: *mut T, src: T) -> T;
atomic_xor_acq			    pub fn atomic_xor_acq<T>(dst: *mut T, src: T) -> T;
atomic_xor_acqrel			    pub fn atomic_xor_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_xor_rel			    pub fn atomic_xor_rel<T>(dst: *mut T, src: T) -> T;
atomic_xor_relaxed			    pub fn atomic_xor_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_xsub			    pub fn atomic_xsub<T>(dst: *mut T, src: T) -> T;
atomic_xsub_acq			    pub fn atomic_xsub_acq<T>(dst: *mut T, src: T) -> T;
atomic_xsub_acqrel			    pub fn atomic_xsub_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_xsub_rel			    pub fn atomic_xsub_rel<T>(dst: *mut T, src: T) -> T;
atomic_xsub_relaxed			    pub fn atomic_xsub_relaxed<T>(dst: *mut T, src: T) -> T;
base			            fn base(&self) -> u8 { 
base			    fn base(&self) -> u8 { self.base }
base			    fn base(&self) -> u8;
bench_long_str			    fn bench_long_str(b: &mut Bencher) 
bench_str_of_8_bytes			    fn bench_str_of_8_bytes(b: &mut Bencher) 
bench_str_over_8_bytes			    fn bench_str_over_8_bytes(b: &mut Bencher) 
bench_str_under_8_bytes			    fn bench_str_under_8_bytes(b: &mut Bencher) 
bench_u64			    fn bench_u64(b: &mut Bencher) 
binary_search			    fn binary_search(&self, x: &Self::Item) -> Result<uint, uint> where Self::Item: Ord;
binary_search			    fn binary_search(&self, x: &T) -> Result<uint, uint> where T: Ord 
binary_search_by			    fn binary_search_by<F>(&self, f: F) -> Result<uint, uint> where
binary_search_by			    fn binary_search_by<F>(&self, mut f: F) -> Result<uint, uint> where
bitand			            fn bitand(self, rhs: 
bitand			    fn bitand(self, rhs: RHS) -> Self::Output;
bitor			            fn bitor(self, rhs: 
bitor			    fn bitor(self, rhs: RHS) -> Self::Output;
bitxor			            fn bitxor(self, other: 
bitxor			    fn bitxor(self, rhs: RHS) -> Self::Output;
borrow			    pub fn borrow<'a>(&'a self) -> Ref<'a, T> 
borrow			pub mod borrow;
borrow_from			    fn borrow_from(owned: &Owned) -> &Self;
borrow_from			    fn borrow_from(owned: &T) -> &T { owned }
borrow_from			    fn borrow_from<'b>(owned: &'b &'a T) -> &'b T { &**owned }
borrow_from			    fn borrow_from<'b>(owned: &'b &'a mut T) -> &'b T { &**owned }
borrow_from			    fn borrow_from<'b>(owned: &'b Cow<'a, T, B>) -> &'b B 
borrow_from_mut			    fn borrow_from_mut(owned: &mut Owned) -> &mut Self;
borrow_from_mut			    fn borrow_from_mut(owned: &mut T) -> &mut T { owned }
borrow_from_mut			    fn borrow_from_mut<'b>(owned: &'b mut &'a mut T) -> &'b mut T { &mut **owned }
borrow_mut			    pub fn borrow_mut<'a>(&'a self) -> RefMut<'a, T> 
breakpoint			    pub fn breakpoint();
bswap16			    pub fn bswap16(x: u16) -> u16;
bswap32			    pub fn bswap32(x: u32) -> u32;
bswap64			    pub fn bswap64(x: u64) -> u64;
bswap8			unsafe fn bswap8(x: u8) -> u8 { x }
by_ref			    fn by_ref<'r>(&'r mut self) -> ByRef<'r, Self> 
bytes			pub mod bytes 
bytes			    fn bytes(&self) -> Bytes 
bytes			    fn bytes<'a>(&'a self) -> Bytes<'a>;
call			    extern "rust-call" fn call(&self, args: Args) -> Result;
call			    extern "rust-call" fn call(&self, (ptr,): (&'a u8,)) -> u8 
call_mut			    extern "rust-call" fn call_mut(&mut self, args: A) -> R 
call_mut			    extern "rust-call" fn call_mut(&mut self, args: Args) -> Result;
call_once			    extern "rust-call" fn call_once(mut self, args: A) -> R 
call_once			    extern "rust-call" fn call_once(self, args: Args) -> Result;
cast			pub fn cast<T: NumCast,U: NumCast>(n: T) -> Option<U> 
ceil			    fn ceil(self) -> f32 
ceil			    fn ceil(self) -> f64 
ceil			    fn ceil(self) -> Self;
ceilf32			    pub fn ceilf32(x: f32) -> f32;
ceilf64			    pub fn ceilf64(x: f64) -> f64;
cell			pub mod cell;
chain			    fn chain<U>(self, other: U) -> Chain<Self, U> where
char			pub mod char;
char_at			    fn char_at(&self, i: uint) -> char 
char_at			    fn char_at(&self, i: uint) -> char;
char_at_reverse			    fn char_at_reverse(&self, i: uint) -> char 
char_at_reverse			    fn char_at_reverse(&self, i: uint) -> char;
char_indices			    fn char_indices(&self) -> CharIndices 
char_indices			    fn char_indices<'a>(&'a self) -> CharIndices<'a>;
char_len			    fn char_len(&self) -> uint { self.chars().count() }
char_len			    fn char_len(&self) -> uint;
char_range_at			    fn char_range_at(&self, i: uint) -> CharRange 
char_range_at			    fn char_range_at(&self, start: uint) -> CharRange;
char_range_at_reverse			    fn char_range_at_reverse(&self, start: uint) -> CharRange 
char_range_at_reverse			    fn char_range_at_reverse(&self, start: uint) -> CharRange;
chars			    fn chars(&self) -> Chars 
chars			    fn chars<'a>(&'a self) -> Chars<'a>;
checked_add			            fn checked_add(self, other: 
checked_add			    fn checked_add(self, other: Self) -> Option<Self>;
checked_div			            fn checked_div(self, v: 
checked_div			    fn checked_div(self, other: Self) -> Option<Self>;
checked_mul			            fn checked_mul(self, other: 
checked_mul			    fn checked_mul(self, other: Self) -> Option<Self>;
checked_next_power_of_two			    fn checked_next_power_of_two(self) -> Option<Self> 
checked_sub			            fn checked_sub(self, other: 
checked_sub			    fn checked_sub(self, other: Self) -> Option<Self>;
chunks			    fn chunks(&self, size: uint) -> Chunks<T> 
chunks			    fn chunks<'a>(&'a self, size: uint) -> Chunks<'a, Self::Item>;
chunks_mut			    fn chunks_mut(&mut self, chunk_size: uint) -> ChunksMut<T> 
chunks_mut			    fn chunks_mut<'a>(&'a mut self, chunk_size: uint) -> ChunksMut<'a, Self::Item>;
classify			    fn classify(self) -> Fp 
classify			    fn classify(self) -> Fp 
classify			    fn classify(self) -> FpCategory;
clone			                fn clone(&self) -> [T; 
clone			    fn clone(&self) -> Cow<'a, T, B> 
clone			    fn clone(&self) -> BorrowRef<'b> 
clone			    fn clone(&self) -> Cell<T> 
clone			    fn clone(&self) -> RefCell<T> 
clone			            fn clone(&self) -> 
clone			            fn clone(&self) -> extern "Rust" fn(
clone			    fn clone(&self) -> &'a T { *self }
clone			    fn clone(&self) -> Self;
clone			    fn clone(&self) -> SipState 
clone			    fn clone(&self) -> Filter<A, I, P> 
clone			    fn clone(&self) -> FilterMap<A, B, I, F> 
clone			    fn clone(&self) -> FlatMap<A, B, I, U, F> 
clone			    fn clone(&self) -> Inspect<A, I, F> 
clone			    fn clone(&self) -> Map<A, B, I, F> 
clone			    fn clone(&self) -> Scan<A, B, I, St, F> 
clone			    fn clone(&self) -> SkipWhile<A, I, P> 
clone			    fn clone(&self) -> TakeWhile<A, I, P> 
clone			    fn clone(&self) -> Unfold<A, St, F> 
clone			pub mod clone;
clone			    fn clone(&self) -> ContravariantType<T> { *self }
clone			    fn clone(&self) -> CovariantType<T> { *self }
clone			    fn clone(&self) -> InvariantType<T> { *self }
clone			    fn clone(&self) -> Iter<'a, A> 
clone			    fn clone(&self) -> *const T 
clone			    fn clone(&self) -> *mut T 
clone			    fn clone(&self) -> Iter<'a, T> { Iter { inner: self.inner } }
clone			    fn clone(&self) -> Iter<'a, T> { *self }
clone			    fn clone(&self) -> Split<'a, T, P> 
clone			                fn clone(&self) -> (
clone_from			    fn clone_from(&mut self, source: &Self) 
clone_from_slice			    fn clone_from_slice(&mut self, &[Self::Item]) -> uint where Self::Item: Clone;
clone_from_slice			    fn clone_from_slice(&mut self, src: &[T]) -> uint where T: Clone 
clone_ref			pub fn clone_ref<'b, T:Clone>(orig: &Ref<'b, T>) -> Ref<'b, T> 
cloned			    fn cloned<T, D>(self) -> Cloned<Self> where
cloned			    pub fn cloned(self) -> Option<T> 
cmp			                fn cmp(&self, other: &[T; 
cmp			    fn cmp(&self, other: &Cow<'a, T, B>) -> Ordering 
cmp			                fn cmp(&self, other: &
cmp			        fn cmp(&self, _other: &()) -> Ordering { Equal }
cmp			        fn cmp(&self, other: & &'a A) -> Ordering { Ord::cmp(*self, *other) }
cmp			        fn cmp(&self, other: &&'a mut A) -> Ordering { Ord::cmp(*self, *other) }
cmp			        fn cmp(&self, other: &bool) -> Ordering 
cmp			    fn cmp(&self, other: &Ordering) -> Ordering 
cmp			    fn cmp(&self, other: &Self) -> Ordering;
cmp			    pub fn cmp<A, T, S>(mut a: T, mut b: S) -> cmp::Ordering where
cmp			pub mod cmp;
cmp			    fn cmp(&self, other: &*const T) -> Ordering 
cmp			    fn cmp(&self, other: &*mut T) -> Ordering 
cmp			    fn cmp(&self, other: &[T]) -> Ordering 
cmp			        fn cmp(&self, other: &str) -> Ordering 
cmp			                fn cmp(&self, other: &(
collect			    fn collect<B: FromIterator<Self::Item>>(self) -> B 
compare_and_swap			    pub fn compare_and_swap(&self, old: *mut T, new: *mut T, order: Ordering) -> *mut T 
compare_and_swap			    pub fn compare_and_swap(&self, old: bool, new: bool, order: Ordering) -> bool 
compare_and_swap			    pub fn compare_and_swap(&self, old: int, new: int, order: Ordering) -> int 
compare_and_swap			    pub fn compare_and_swap(&self, old: uint, new: uint, order: Ordering) -> uint 
consts			pub mod consts 
consts			pub mod consts 
contains			    fn contains(&self, x: &Self::Item) -> bool where Self::Item: PartialEq;
contains			    fn contains(&self, x: &T) -> bool where T: PartialEq 
contains			    fn contains(&self, needle: &str) -> bool 
contains			    fn contains(&self, pat: &str) -> bool;
contains_char			    fn contains_char<P: CharEq>(&self, pat: P) -> bool 
contains_char			    fn contains_char<P: CharEq>(&self, pat: P) -> bool;
copy_lifetime			pub unsafe fn copy_lifetime<'a, S: ?Sized, T: ?Sized + 'a>(_ptr: &'a S,
copy_memory			    pub fn copy_memory<T>(dst: *mut T, src: *const T, count: uint);
copy_memory			    pub fn copy_memory(dst: &mut [u8], src: &[u8]) 
copy_mut_lifetime			pub unsafe fn copy_mut_lifetime<'a, S: ?Sized, T: ?Sized + 'a>(_ptr: &'a mut S,
copy_nonoverlapping_memory			    pub fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint);
copysignf32			    pub fn copysignf32(x: f32, y: f32) -> f32;
copysignf64			    pub fn copysignf64(x: f64, y: f64) -> f64;
core			mod core 
cosf32			    pub fn cosf32(x: f32) -> f32;
cosf64			    pub fn cosf64(x: f64) -> f64;
count			    fn count(self) -> uint 
count			pub fn count<A>(start: A, step: A) -> Counter<A> 
count_ones			            fn count_ones(self) -> uint { (self as 
count_ones			            fn count_ones(self) -> uint { unsafe { 
count_ones			    fn count_ones(self) -> uint;
count_zeros			    fn count_zeros(self) -> uint 
ctlz16			    pub fn ctlz16(x: u16) -> u16;
ctlz32			    pub fn ctlz32(x: u32) -> u32;
ctlz64			    pub fn ctlz64(x: u64) -> u64;
ctlz8			    pub fn ctlz8(x: u8) -> u8;
ctpop16			    pub fn ctpop16(x: u16) -> u16;
ctpop32			    pub fn ctpop32(x: u32) -> u32;
ctpop64			    pub fn ctpop64(x: u64) -> u64;
ctpop8			    pub fn ctpop8(x: u8) -> u8;
cttz16			    pub fn cttz16(x: u16) -> u16;
cttz32			    pub fn cttz32(x: u32) -> u32;
cttz64			    pub fn cttz64(x: u64) -> u64;
cttz8			    pub fn cttz8(x: u8) -> u8;
cycle			    fn cycle(self) -> Cycle<Self> where Self: Clone 
default			    fn default() -> Cell<T> 
default			    fn default() -> RefCell<T> 
default			            fn default() -> 
default			    fn default() -> Self;
default			    fn default() -> SipHasher 
default			    fn default() -> SipState 
default			pub mod default;
default			    fn default() -> Option<T> { None }
default			    fn default() -> &'a [T] { &[] }
default			    fn default() -> &'a str { "" }
default			                fn default() -> (
deref			    fn deref(&self) -> &B 
deref			    fn deref<'a>(&'a self) -> &'a T 
deref			    fn deref<'a>(&'a self) -> &'a T 
deref			    fn deref(&self) -> &T { *self }
deref			    fn deref<'a>(&'a self) -> &'a Self::Target;
deref_mut			    fn deref_mut<'a>(&'a mut self) -> &'a mut T 
deref_mut			    fn deref_mut(&mut self) -> &mut T { *self }
deref_mut			    fn deref_mut<'a>(&'a mut self) -> &'a mut Self::Target;
digit			            fn digit(&self, x: u8) -> u8 
digit			    fn digit(&self, x: u8) -> u8 
digit			    fn digit(&self, x: u8) -> u8;
digits			    fn digits(_: Option<f32>) -> uint { DIGITS }
digits			    fn digits(_: Option<f64>) -> uint { DIGITS }
digits			    fn digits(unused_self: Option<Self>) -> uint;
div			            fn div(self, other: 
div			    fn div(self, rhs: RHS) -> Self::Output;
do_inspect			    fn do_inspect(&mut self, elt: Option<A>) -> Option<A> 
do_map			    fn do_map(&mut self, elt: Option<A>) -> Option<B> 
downcast_mut			    pub fn downcast_mut<'a, T: 'static>(&'a mut self) -> Option<&'a mut T> 
downcast_ref			    pub fn downcast_ref<'a, T: 'static>(&'a self) -> Option<&'a T> 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			pub fn drop<T>(_x: T) { }
drop			    fn drop(&mut self);
encode_utf16			    fn encode_utf16(self, dst: &mut [u16]) -> Option<uint> 
encode_utf16			    fn encode_utf16(self, dst: &mut [u16]) -> Option<uint>;
encode_utf8			    fn encode_utf8(self, dst: &mut [u8]) -> Option<uint> 
encode_utf8			    fn encode_utf8(self, dst: &mut [u8]) -> Option<uint>;
ends_with			    fn ends_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;
ends_with			    fn ends_with(&self, needle: &[T]) -> bool where T: PartialEq 
ends_with			    fn ends_with(&self, needle: &str) -> bool 
ends_with			    fn ends_with(&self, pat: &str) -> bool;
enumerate			    fn enumerate(self) -> Enumerate<Self> 
epsilon			    fn epsilon() -> f32 { EPSILON }
epsilon			    fn epsilon() -> f64 { EPSILON }
epsilon			    fn epsilon() -> Self;
eq			                fn eq(&self, other: &Rhs) -> bool 
eq			                fn eq(&self, other: &[B; 
eq			    fn eq(&self, other: &Cow<'b, U, C>) -> bool 
eq			    fn eq(&self, other: &Cell<T>) -> bool 
eq			    fn eq(&self, other: &RefCell<T>) -> bool 
eq			                fn eq(&self, other: &
eq			        fn eq(&self, _other: &()) -> bool { true }
eq			        fn eq(&self, other: & &'b B) -> bool { PartialEq::eq(*self, *other) }
eq			        fn eq(&self, other: &&'b B) -> bool { PartialEq::eq(*self, *other) }
eq			        fn eq(&self, other: &&'b mut B) -> bool { PartialEq::eq(*self, *other) }
eq			    fn eq(&self, other: &Rhs) -> bool;
eq			    pub fn eq<A, B, L, R>(mut a: L, mut b: R) -> bool where
eq			                fn eq(&self, other: &extern "C" fn(
eq			        fn eq(&self, other: &extern "C" fn() -> _R) -> bool 
eq			    fn eq(&self, other: &*const T) -> bool 
eq			    fn eq(&self, other: &*mut T) -> bool 
eq			    fn eq(&self, other: &[B]) -> bool 
eq			        fn eq(&self, other: &str) -> bool 
eq			                fn eq(&self, other: &(
eq_slice			fn eq_slice(a: &str, b: &str) -> bool 
eq_slice_			fn eq_slice_(a: &str, b: &str) -> bool 
equals			    pub fn equals<A, T, S>(mut a: T, mut b: S) -> bool where
err			    pub fn err(self) -> Option<E> 
escape_default			    fn escape_default(self) -> EscapeDefault 
escape_default			    fn escape_default(self) -> EscapeDefault;
escape_unicode			    fn escape_unicode(self) -> EscapeUnicode 
escape_unicode			    fn escape_unicode(self) -> EscapeUnicode;
exp			    fn exp(self) -> f32 
exp			    fn exp(self) -> f64 
exp			    fn exp(self) -> Self;
exp2			    fn exp2(self) -> f32 
exp2			    fn exp2(self) -> f64 
exp2			    fn exp2(self) -> Self;
exp2f32			    pub fn exp2f32(x: f32) -> f32;
exp2f64			    pub fn exp2f64(x: f64) -> f64;
expect			    pub fn expect(self, msg: &str) -> T 
expf32			    pub fn expf32(x: f32) -> f32;
expf64			    pub fn expf64(x: f64) -> f64;
extend			    fn extend<T: Iterator<Item=A>>(&mut self, iterator: T);
externfnpointers			mod externfnpointers 
f			        fn f(line: &str) -> &str 
f32x4			pub struct f32x4(pub f32, pub f32, pub f32, pub f32);
f64x2			pub struct f64x2(pub f64, pub f64);
fabsf32			    pub fn fabsf32(x: f32) -> f32;
fabsf64			    pub fn fabsf64(x: f64) -> f64;
fence			pub fn fence(order: Ordering) 
fetch_add			    pub fn fetch_add(&self, val: int, order: Ordering) -> int 
fetch_add			    pub fn fetch_add(&self, val: uint, order: Ordering) -> uint 
fetch_and			    pub fn fetch_and(&self, val: bool, order: Ordering) -> bool 
fetch_and			    pub fn fetch_and(&self, val: int, order: Ordering) -> int 
fetch_and			    pub fn fetch_and(&self, val: uint, order: Ordering) -> uint 
fetch_nand			    pub fn fetch_nand(&self, val: bool, order: Ordering) -> bool 
fetch_or			    pub fn fetch_or(&self, val: bool, order: Ordering) -> bool 
fetch_or			    pub fn fetch_or(&self, val: int, order: Ordering) -> int 
fetch_or			    pub fn fetch_or(&self, val: uint, order: Ordering) -> uint 
fetch_sub			    pub fn fetch_sub(&self, val: int, order: Ordering) -> int 
fetch_sub			    pub fn fetch_sub(&self, val: uint, order: Ordering) -> uint 
fetch_xor			    pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool 
fetch_xor			    pub fn fetch_xor(&self, val: int, order: Ordering) -> int 
fetch_xor			    pub fn fetch_xor(&self, val: uint, order: Ordering) -> uint 
fill			    pub fn fill(&self) -> char { self.fill }
filter			    fn filter<P>(self, predicate: P) -> Filter<Self::Item, Self, P> where
filter_map			    fn filter_map<B, F>(self, f: F) -> FilterMap<Self::Item, B, Self, F> where
finally			    fn finally<F>(&mut self, dtor: F) -> T where F: FnMut();
finally			    fn finally<G>(&mut self, mut dtor: G) -> T where G: FnMut() 
finally			pub mod finally;
find			    fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item> where
find			    fn find<P: CharEq>(&self, mut pat: P) -> Option<uint> 
find			    fn find<P: CharEq>(&self, pat: P) -> Option<uint>;
find_str			    fn find_str(&self, needle: &str) -> Option<uint> 
find_str			    fn find_str(&self, pat: &str) -> Option<uint>;
finish			    fn finish(&mut self) -> Option<&'a [T]> 
finish			    fn finish(&mut self) -> Option<&'a mut [T]> 
finish			    fn finish(&mut self) -> Option<Self::Item>;
first			    fn first(&self) -> Option<&T> 
first			    fn first<'a>(&'a self) -> Option<&'a Self::Item>;
first_mut			    fn first_mut(&mut self) -> Option<&mut T> 
first_mut			    fn first_mut<'a>(&'a mut self) -> Option<&'a mut Self::Item>;
flags			    pub fn flags(&self) -> uint { self.flags }
flat_map			    fn flat_map<B, U, F>(self, f: F) -> FlatMap<Self::Item, B, Self, U, F> where
float			mod float;
float_macros			mod float_macros;
float_to_str_bytes_common			pub fn float_to_str_bytes_common<T: Float, U, F>(
floor			    fn floor(self) -> f32 
floor			    fn floor(self) -> f64 
floor			    fn floor(self) -> Self;
floorf32			    pub fn floorf32(x: f32) -> f32;
floorf64			    pub fn floorf64(x: f64) -> f64;
fmaf32			    pub fn fmaf32(a: f32, b: f32, c: f32) -> f32;
fmaf64			    pub fn fmaf64(a: f64, b: f64, c: f64) -> f64;
fmt			                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			            impl<T:fmt::Show> fmt::Show for [T; 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			            fn fmt(&self, f: &mut Formatter) -> Result { 
fmt			            fn fmt(&self, f: &mut Formatter) -> Result 
fmt			        fn fmt(&self, fmt: &mut Formatter) -> Result 
fmt			    fn fmt(&self, &mut Formatter) -> Result;
fmt			    fn fmt(&self, f: &mut Formatter) -> Result { Pointer::fmt(self, f) }
fmt			    fn fmt(&self, f: &mut Formatter) -> Result { f.pad("&Any") }
fmt			    fn fmt(&self, f: &mut Formatter) -> Result 
fmt			    fn fmt(&self, fmt: &mut Formatter) -> Result 
fmt			            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			        impl fmt::
fmt			        impl fmt::Show for 
fmt			pub mod fmt;
fmt::Show for Cow			impl<'a, T, B: ?Sized> fmt::Show for Cow<'a, T, B> where
fmt::Show for RadixFmt			        impl fmt::Show for RadixFmt<
fmt::String for Cow			impl<'a, T, B: ?Sized> fmt::String for Cow<'a, T, B> where
fmt::String for RadixFmt			        impl fmt::String for RadixFmt<
fmt::Writer for Filler			            impl<'a> fmt::Writer for Filler<'a> 
fmt_int			    fn fmt_int<T: Int>(&self, mut x: T, f: &mut fmt::Formatter) -> fmt::Result 
fold			    fn fold<B, F>(mut self, init: B, mut f: F) -> B where
fold			pub fn fold<T,
forget			    pub fn forget<T>(_: T) -> ();
fract			    fn fract(self) -> f32 { self - self.trunc() }
fract			    fn fract(self) -> f64 { self - self.trunc() }
fract			    fn fract(self) -> Self;
from			            fn from<N: ToPrimitive>(n: N) -> Option<
from			    fn from<T: ToPrimitive>(n: T) -> Option<Self>;
from_be			    fn from_be(x: Self) -> Self 
from_c_str			pub unsafe fn from_c_str(s: *const i8) -> &'static str 
from_digit			pub fn from_digit(num: uint, radix: uint) -> Option<char> 
from_f32			    fn from_f32(n: f32) -> Option<Self> 
from_f32			pub fn from_f32<A: FromPrimitive>(n: f32) -> Option<A> 
from_f64			    fn from_f64(n: f64) -> Option<Self> 
from_f64			pub fn from_f64<A: FromPrimitive>(n: f64) -> Option<A> 
from_i16			    fn from_i16(n: i16) -> Option<Self> 
from_i16			pub fn from_i16<A: FromPrimitive>(n: i16) -> Option<A> 
from_i32			    fn from_i32(n: i32) -> Option<Self> 
from_i32			pub fn from_i32<A: FromPrimitive>(n: i32) -> Option<A> 
from_i64			    fn from_i64(n: i64) -> Option<Self>;
from_i64			pub fn from_i64<A: FromPrimitive>(n: i64) -> Option<A> 
from_i8			    fn from_i8(n: i8) -> Option<Self> 
from_i8			pub fn from_i8<A: FromPrimitive>(n: i8) -> Option<A> 
from_int			    fn from_int(n: int) -> Option<Self> 
from_int			pub fn from_int<A: FromPrimitive>(n: int) -> Option<A> 
from_iter			    fn from_iter<T: Iterator<Item=A>>(iterator: T) -> Self;
from_iter			    fn from_iter<I: Iterator<Item=Option<A>>>(iter: I) -> Option<V> 
from_iter			    fn from_iter<I: Iterator<Item=Result<A, E>>>(iter: I) -> Result<V, E> 
from_le			    fn from_le(x: Self) -> Self 
from_raw_buf			pub unsafe fn from_raw_buf<'a, T>(p: &'a *const T, len: uint) -> &'a [T] 
from_raw_mut_buf			pub unsafe fn from_raw_mut_buf<'a, T>(p: &'a *mut T, len: uint) -> &'a mut [T] 
from_str			            fn from_str(src: &str) -> Option<
from_str			    fn from_str(s: &str) -> Option<Self>;
from_str			    fn from_str(s: &str) -> Option<bool> 
from_str_radix			            fn from_str_radix(src: &str, radix: uint) -> Option<
from_str_radix			    fn from_str_radix(str: &str, radix: uint) -> Option<Self>;
from_str_radix			pub fn from_str_radix<T: FromStrRadix>(str: &str, radix: uint) -> Option<T> 
from_u16			    fn from_u16(n: u16) -> Option<Self> 
from_u16			pub fn from_u16<A: FromPrimitive>(n: u16) -> Option<A> 
from_u32			pub fn from_u32(i: u32) -> Option<char> 
from_u32			    fn from_u32(n: u32) -> Option<Self> 
from_u32			pub fn from_u32<A: FromPrimitive>(n: u32) -> Option<A> 
from_u64			    fn from_u64(n: u64) -> Option<Self>;
from_u64			pub fn from_u64<A: FromPrimitive>(n: u64) -> Option<A> 
from_u8			    fn from_u8(n: u8) -> Option<Self> 
from_u8			pub fn from_u8<A: FromPrimitive>(n: u8) -> Option<A> 
from_uint			    fn from_uint(x: &uint) -> Argument 
from_uint			    fn from_uint(n: uint) -> Option<Self> 
from_uint			pub fn from_uint<A: FromPrimitive>(n: uint) -> Option<A> 
from_utf8			pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> 
from_utf8_unchecked			pub unsafe fn from_utf8_unchecked<'a>(v: &'a [u8]) -> &'a str 
fuse			    fn fuse(self) -> Fuse<Self> 
ge			                fn ge(&self, other: &[T; 
ge			                fn ge(&self, other: &
ge			        fn ge(&self, other: & &'b B) -> bool { PartialOrd::ge(*self, *other) }
ge			        fn ge(&self, other: &&'b mut B) -> bool { PartialOrd::ge(*self, *other) }
ge			    fn ge(&self, other: &Rhs) -> bool 
ge			    pub fn ge<A, T, S>(mut a: T, mut b: S) -> bool where
ge			    fn ge(&self, other: &*const T) -> bool { *self >= *other }
ge			    fn ge(&self, other: &*mut T) -> bool { *self >= *other }
ge			    fn ge(&self, other: &[T]) -> bool 
ge			                fn ge(&self, other: &(
get			    pub fn get(&self) -> *mut T { &self.value as *const T as *mut T }
get			    pub fn get(&self) -> T 
get			    fn get(&self, index: uint) -> Option<&T> 
get			    fn get<'a>(&'a self, index: uint) -> Option<&'a Self::Item>;
get_end			    fn get_end(&mut self) -> Option<&'a str> 
get_mut			    fn get_mut(&mut self, index: uint) -> Option<&mut T> 
get_mut			    fn get_mut<'a>(&'a mut self, index: uint) -> Option<&'a mut Self::Item>;
get_tydesc			    pub fn get_tydesc<T>() -> *const TyDesc;
get_type_id			    fn get_type_id(&self) -> TypeId { TypeId::of::<T>() }
get_type_id			    fn get_type_id(&self) -> TypeId;
get_unchecked			    unsafe fn get_unchecked(&self, index: uint) -> &T 
get_unchecked			    unsafe fn get_unchecked<'a>(&'a self, index: uint) -> &'a Self::Item;
get_unchecked_mut			    unsafe fn get_unchecked_mut(&mut self, index: uint) -> &mut T 
get_unchecked_mut			    unsafe fn get_unchecked_mut<'a>(&'a mut self, index: uint) -> &'a mut Self::Item;
getcount			    fn getcount(&mut self, cnt: &rt::Count) -> Option<uint> 
gt			                fn gt(&self, other: &[T; 
gt			                fn gt(&self, other: &
gt			        fn gt(&self, other: & &'b B) -> bool { PartialOrd::gt(*self, *other) }
gt			        fn gt(&self, other: &&'b mut B) -> bool { PartialOrd::gt(*self, *other) }
gt			    fn gt(&self, other: &Rhs) -> bool 
gt			    pub fn gt<A, T, S>(mut a: T, mut b: S) -> bool where
gt			    fn gt(&self, other: &*const T) -> bool { *self > *other }
gt			    fn gt(&self, other: &*mut T) -> bool { *self > *other }
gt			    fn gt(&self, other: &[T]) -> bool 
gt			                fn gt(&self, other: &(
hash			            fn hash(&self, state: &mut S) 
hash			    fn hash(&self, state: &mut S) 
hash			    fn hash(&self, state: &mut S);
hash			    fn hash<T: ?Sized + Hash<S>>(&self, value: &T) -> u64;
hash			        fn hash(&self, state: &mut S) 
hash			    fn hash<T: ?Sized + Hash<SipState>>(&self, value: &T) -> u64 
hash			pub fn hash<T: ?Sized + Hash<SipState>>(value: &T) -> u64 
hash			    pub fn hash(&self) -> u64 { self.t }
hash			pub mod hash;
hash_with_keys			pub fn hash_with_keys<T: ?Sized + Hash<SipState>>(k0: u64, k1: u64, value: &T) -> u64 
i16_add_with_overflow			    pub fn i16_add_with_overflow(x: i16, y: i16) -> (i16, bool);
i16_mul_with_overflow			    pub fn i16_mul_with_overflow(x: i16, y: i16) -> (i16, bool);
i16_sub_with_overflow			    pub fn i16_sub_with_overflow(x: i16, y: i16) -> (i16, bool);
i16x8			pub struct i16x8(pub i16, pub i16, pub i16, pub i16,
i32_add_with_overflow			    pub fn i32_add_with_overflow(x: i32, y: i32) -> (i32, bool);
i32_mul_with_overflow			    pub fn i32_mul_with_overflow(x: i32, y: i32) -> (i32, bool);
i32_sub_with_overflow			    pub fn i32_sub_with_overflow(x: i32, y: i32) -> (i32, bool);
i32x4			pub struct i32x4(pub i32, pub i32, pub i32, pub i32);
i64_add_with_overflow			    pub fn i64_add_with_overflow(x: i64, y: i64) -> (i64, bool);
i64_mul_with_overflow			    pub fn i64_mul_with_overflow(x: i64, y: i64) -> (i64, bool);
i64_sub_with_overflow			    pub fn i64_sub_with_overflow(x: i64, y: i64) -> (i64, bool);
i64x2			pub struct i64x2(pub i64, pub i64);
i8_add_with_overflow			    pub fn i8_add_with_overflow(x: i8, y: i8) -> (i8, bool);
i8_mul_with_overflow			    pub fn i8_mul_with_overflow(x: i8, y: i8) -> (i8, bool);
i8_sub_with_overflow			    pub fn i8_sub_with_overflow(x: i8, y: i8) -> (i8, bool);
i8x16			pub struct i8x16(pub i8, pub i8, pub i8, pub i8,
idx			    fn idx(&mut self, _: uint) -> Option<A> { Some(self.element.clone()) }
idx			    fn idx(&mut self, index: uint) -> Option<(T, U)> 
idx			    fn idx(&mut self, index: uint) -> Option<(uint, <I as Iterator>::Item)> 
idx			    fn idx(&mut self, index: uint) -> Option<<I as Iterator>::Item> 
idx			    fn idx(&mut self, index: uint) -> Option<A> 
idx			    fn idx(&mut self, index: uint) -> Option<B> 
idx			    fn idx(&mut self, index: uint) -> Option<Self::Item>;
idx			    fn idx(&mut self, index: uint) -> Option<T> 
idx			    fn idx(&mut self, index: uint) -> Option<&'a T> 
idx			    fn idx(&mut self, index: uint) -> Option<&'a [T]> 
impls			mod impls 
index			    fn index<'a>(&'a self, index: &Index) -> &'a Self::Output;
index			    fn index(&self, &index: &uint) -> &T 
index			    fn index(&self, _index: &ops::FullRange) -> &[T] 
index			    fn index(&self, index: &ops::Range<uint>) -> &[T] 
index			    fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] 
index			    fn index(&self, index: &ops::RangeTo<uint>) -> &[T] 
index			        fn index(&self, _index: &ops::FullRange) -> &str 
index			        fn index(&self, index: &ops::Range<uint>) -> &str 
index			        fn index(&self, index: &ops::RangeFrom<uint>) -> &str 
index			        fn index(&self, index: &ops::RangeTo<uint>) -> &str 
index_mut			    fn index_mut<'a>(&'a mut self, index: &Index) -> &'a mut Self::Output;
index_mut			    fn index_mut(&mut self, &index: &uint) -> &mut T 
index_mut			    fn index_mut(&mut self, _index: &ops::FullRange) -> &mut [T] 
index_mut			    fn index_mut(&mut self, index: &ops::Range<uint>) -> &mut [T] 
index_mut			    fn index_mut(&mut self, index: &ops::RangeFrom<uint>) -> &mut [T] 
index_mut			    fn index_mut(&mut self, index: &ops::RangeTo<uint>) -> &mut [T] 
indexable			    fn indexable(&self) -> uint { self.iter.indexable() }
indexable			    fn indexable(&self) -> uint { uint::MAX }
indexable			    fn indexable(&self) -> uint 
indexable			    fn indexable(&self) -> uint;
indexable			    fn indexable(&self) -> uint 
infinity			    fn infinity() -> f32 { INFINITY }
infinity			    fn infinity() -> f64 { INFINITY }
infinity			    fn infinity() -> Self;
init			    pub fn init<T>() -> T;
init			    fn init(&self) -> &[T] 
init			    fn init<'a>(&'a self) -> &'a [Self::Item];
init_mut			    fn init_mut(&mut self) -> &mut [T] 
init_mut			    fn init_mut<'a>(&'a mut self) -> &'a mut [Self::Item];
inspect			    fn inspect<F>(self, f: F) -> Inspect<Self::Item, Self, F> where
int_macros			mod int_macros;
integer_decode			    fn integer_decode(self) -> (u64, i16, i8) 
integer_decode			    fn integer_decode(self) -> (u64, i16, i8) 
integer_decode			    fn integer_decode(self) -> (u64, i16, i8);
into_cow			    fn into_cow(self) -> Cow<'a, T, B> 
into_cow			    fn into_cow(self) -> Cow<'a, T, B>;
into_inner			    pub fn into_inner(self) -> T 
into_inner			    pub unsafe fn into_inner(self) -> T { self.value }
into_iter			    pub fn into_iter(self) -> IntoIter<T> 
into_iter			    pub fn into_iter(self) -> IntoIter<T> 
into_option			    pub fn into_option(self) -> Option<(T,T)> 
into_owned			    pub fn into_owned(self) -> T 
into_slice			    pub fn into_slice(self) -> &'a mut [T] 
intrinsics			pub mod intrinsics;
is			    pub fn is<T: 'static>(&self) -> bool 
is_borrowed			    pub fn is_borrowed(&self) -> bool 
is_char_boundary			    fn is_char_boundary(&self, index: uint) -> bool 
is_char_boundary			    fn is_char_boundary(&self, index: uint) -> bool;
is_digit			    fn is_digit(self, radix: uint) -> bool 
is_digit			    fn is_digit(self, radix: uint) -> bool;
is_empty			    pub fn is_empty(&mut self) -> bool 
is_empty			    fn is_empty(&self) -> bool { self.len() == 0 }
is_empty			    fn is_empty(&self) -> bool { self.len() == 0 }
is_empty			    fn is_empty(&self) -> bool;
is_err			    pub fn is_err(&self) -> bool 
is_finite			    fn is_finite(self) -> bool 
is_finite			    fn is_finite(self) -> bool 
is_finite			    fn is_finite(self) -> bool;
is_infinite			    fn is_infinite(self) -> bool 
is_infinite			    fn is_infinite(self) -> bool 
is_infinite			    fn is_infinite(self) -> bool;
is_nan			    fn is_nan(self) -> bool { self != self }
is_nan			    fn is_nan(self) -> bool { self != self }
is_nan			    fn is_nan(self) -> bool;
is_negative			    fn is_negative(self) -> bool 
is_negative			    fn is_negative(self) -> bool 
is_negative			            fn is_negative(self) -> bool { self < 0 }
is_negative			    fn is_negative(self) -> bool;
is_none			    pub fn is_none(&self) -> bool 
is_normal			    fn is_normal(self) -> bool 
is_normal			    fn is_normal(self) -> bool 
is_normal			    fn is_normal(self) -> bool;
is_null			    fn is_null(self) -> bool { self as uint == 0 }
is_null			    fn is_null(self) -> bool;
is_ok			    pub fn is_ok(&self) -> bool 
is_owned			    pub fn is_owned(&self) -> bool 
is_positive			    fn is_positive(self) -> bool 
is_positive			    fn is_positive(self) -> bool 
is_positive			            fn is_positive(self) -> bool { self > 0 }
is_positive			    fn is_positive(self) -> bool;
is_power_of_two			    fn is_power_of_two(self) -> bool 
is_some			    pub fn is_some(&self) -> bool 
iter			pub mod iter;
iter			    pub fn iter(&self) -> Iter<T> 
iter			    pub fn iter(&self) -> Iter<T> 
iter			    fn iter<'a>(&'a self) -> Iter<'a, Self::Item>;
iter			    fn iter<'a>(&'a self) -> Iter<'a, T> 
iter_mut			    pub fn iter_mut(&mut self) -> IterMut<T> 
iter_mut			    pub fn iter_mut(&mut self) -> IterMut<T> 
iter_mut			    fn iter_mut<'a>(&'a mut self) -> IterMut<'a, Self::Item>;
iter_mut			    fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> 
iterate			pub fn iterate<T, F>(seed: T, f: F) -> Iterate<T, F> where
last			    fn last(mut self) -> Option<Self::Item> 
last			    fn last(&self) -> Option<&T> 
last			    fn last<'a>(&'a self) -> Option<&'a Self::Item>;
last_mut			    fn last_mut(&mut self) -> Option<&mut T> 
last_mut			    fn last_mut<'a>(&'a mut self) -> Option<&'a mut Self::Item>;
le			                fn le(&self, other: &[T; 
le			                fn le(&self, other: &
le			        fn le(&self, other: & &'b B) -> bool { PartialOrd::le(*self, *other) }
le			        fn le(&self, other: &&'b mut B) -> bool { PartialOrd::le(*self, *other) }
le			    fn le(&self, other: &Rhs) -> bool 
le			    pub fn le<A, T, S>(mut a: T, mut b: S) -> bool where
le			    fn le(&self, other: &*const T) -> bool { *self <= *other }
le			    fn le(&self, other: &*mut T) -> bool { *self <= *other }
le			    fn le(&self, other: &[T]) -> bool 
le			                fn le(&self, other: &(
leading_zeros			            fn leading_zeros(self) -> uint { (self as 
leading_zeros			            fn leading_zeros(self) -> uint { unsafe { 
leading_zeros			    fn leading_zeros(self) -> uint;
len			    fn len(&self) -> uint 
len			    fn len(&self) -> uint { self.repr().len }
len			    fn len(&self) -> uint;
len			            fn len(&self) -> uint 
len			    fn len(&self) -> uint { self.repr().len }
len			    fn len(&self) -> uint;
len_utf16			    fn len_utf16(self) -> uint 
len_utf16			    fn len_utf16(self) -> uint;
len_utf8			    fn len_utf8(self) -> uint 
len_utf8			    fn len_utf8(self) -> uint;
lines			    fn lines(&self) -> Lines 
lines			    fn lines<'a>(&'a self) -> Lines<'a>;
lines_any			    fn lines_any(&self) -> LinesAny 
lines_any			    fn lines_any<'a>(&'a self) -> LinesAny<'a>;
ln			    fn ln(self) -> f32 
ln			    fn ln(self) -> f64 
ln			    fn ln(self) -> Self;
load			    pub fn load(&self, order: Ordering) -> *mut T 
load			    pub fn load(&self, order: Ordering) -> bool 
load			    pub fn load(&self, order: Ordering) -> int 
load			    pub fn load(&self, order: Ordering) -> uint 
log			    fn log(self, base: f32) -> f32 { self.ln() \/ base.ln() }
log			    fn log(self, base: f64) -> f64 { self.ln() \/ base.ln() }
log			    fn log(self, base: Self) -> Self;
log10			    fn log10(self) -> f32 
log10			    fn log10(self) -> f64 
log10			    fn log10(self) -> Self;
log10f32			    pub fn log10f32(x: f32) -> f32;
log10f64			    pub fn log10f64(x: f64) -> f64;
log2			    fn log2(self) -> f32 
log2			    fn log2(self) -> f64 
log2			    fn log2(self) -> Self;
log2f32			    pub fn log2f32(x: f32) -> f32;
log2f64			    pub fn log2f64(x: f64) -> f64;
logf32			    pub fn logf32(x: f32) -> f32;
logf64			    pub fn logf64(x: f64) -> f64;
lt			                fn lt(&self, other: &[T; 
lt			                fn lt(&self, other: &
lt			        fn lt(&self, other: & &'b B) -> bool { PartialOrd::lt(*self, *other) }
lt			        fn lt(&self, other: &&'b mut B) -> bool { PartialOrd::lt(*self, *other) }
lt			    fn lt(&self, other: &Rhs) -> bool 
lt			    pub fn lt<A, T, S>(mut a: T, mut b: S) -> bool where
lt			    fn lt(&self, other: &*const T) -> bool { *self < *other }
lt			    fn lt(&self, other: &*mut T) -> bool { *self < *other }
lt			    fn lt(&self, other: &[T]) -> bool 
lt			                fn lt(&self, other: &(
macros			mod macros;
mantissa_digits			    fn mantissa_digits(_: Option<f32>) -> uint { MANTISSA_DIGITS }
mantissa_digits			    fn mantissa_digits(_: Option<f64>) -> uint { MANTISSA_DIGITS }
mantissa_digits			    fn mantissa_digits(unused_self: Option<Self>) -> uint;
map			    fn map<B, F>(self, f: F) -> Map<Self::Item, B, Self, F> where
map			    pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Option<U> 
map			    pub fn map<U, F: FnOnce(T) -> U>(self, op: F) -> Result<U,E> 
map_err			    pub fn map_err<F, O: FnOnce(E) -> F>(self, op: O) -> Result<T,F> 
map_or			    pub fn map_or<U, F: FnOnce(T) -> U>(self, def: U, f: F) -> U 
map_or_else			    pub fn map_or_else<U, D: FnOnce() -> U, F: FnOnce(T) -> U>(self, def: D, f: F) -> U 
marker			pub mod marker;
match_indices			    fn match_indices<'a>(&'a self, sep: &'a str) -> MatchIndices<'a> 
match_indices			    fn match_indices<'a>(&'a self, sep: &'a str) -> MatchIndices<'a>;
matches			    fn matches(&mut self, c: char) -> bool { (*self)(c) }
matches			    fn matches(&mut self, c: char) -> bool { *self == c }
matches			    fn matches(&mut self, c: char) -> bool 
matches			    fn matches(&mut self, char) -> bool;
max			pub fn max<T: Ord>(v1: T, v2: T) -> T 
max			    fn max(self) -> Option<Self::Item> where Self::Item: Ord
max_10_exp			    fn max_10_exp(_: Option<f32>) -> int { MAX_10_EXP }
max_10_exp			    fn max_10_exp(_: Option<f64>) -> int { MAX_10_EXP }
max_10_exp			    fn max_10_exp(unused_self: Option<Self>) -> int;
max_by			    fn max_by<B: Ord, F>(self, mut f: F) -> Option<Self::Item> where
max_exp			    fn max_exp(_: Option<f32>) -> int { MAX_EXP }
max_exp			    fn max_exp(_: Option<f64>) -> int { MAX_EXP }
max_exp			    fn max_exp(unused_self: Option<Self>) -> int;
max_value			    fn max_value() -> f32 { MAX_VALUE }
max_value			    fn max_value() -> f64 { MAX_VALUE }
max_value			            fn max_value() -> 
max_value			            fn max_value() -> 
max_value			    fn max_value() -> Self;
maximal_suffix			    fn maximal_suffix(arr: &[u8], reversed: bool) -> (uint, uint) 
mem			pub mod mem;
min			pub fn min<T: Ord>(v1: T, v2: T) -> T 
min			    fn min(self) -> Option<Self::Item> where Self::Item: Ord
min_10_exp			    fn min_10_exp(_: Option<f32>) -> int { MIN_10_EXP }
min_10_exp			    fn min_10_exp(_: Option<f64>) -> int { MIN_10_EXP }
min_10_exp			    fn min_10_exp(unused_self: Option<Self>) -> int;
min_align_of			    pub fn min_align_of<T>() -> uint;
min_align_of			pub fn min_align_of<T>() -> uint 
min_align_of_val			pub fn min_align_of_val<T>(_val: &T) -> uint 
min_by			    fn min_by<B: Ord, F>(self, mut f: F) -> Option<Self::Item> where
min_exp			    fn min_exp(_: Option<f32>) -> int { MIN_EXP }
min_exp			    fn min_exp(_: Option<f64>) -> int { MIN_EXP }
min_exp			    fn min_exp(unused_self: Option<Self>) -> int;
min_max			    fn min_max(mut self) -> MinMaxResult<Self::Item> where Self::Item: Ord
min_pos_value			    fn min_pos_value(_: Option<f32>) -> f32 { MIN_POS_VALUE }
min_pos_value			    fn min_pos_value(_: Option<f64>) -> f64 { MIN_POS_VALUE }
min_pos_value			    fn min_pos_value(unused_self: Option<Self>) -> Self;
min_value			    fn min_value() -> f32 { MIN_VALUE }
min_value			    fn min_value() -> f64 { MIN_VALUE }
min_value			            fn min_value() -> 
min_value			            fn min_value() -> 
min_value			    fn min_value() -> Self;
move_val_init			    pub fn move_val_init<T>(dst: &mut T, src: T);
mul			            fn mul(self, other: 
mul			    fn mul(self, rhs: RHS) -> Self::Output;
mul_add			    fn mul_add(self, a: f32, b: f32) -> f32 
mul_add			    fn mul_add(self, a: f64, b: f64) -> f64 
mul_add			    fn mul_add(self, a: Self, b: Self) -> Self;
multibyte_char_range_at			        fn multibyte_char_range_at(s: &str, i: uint) -> CharRange 
multibyte_char_range_at_reverse			        fn multibyte_char_range_at_reverse(s: &str, mut i: uint) -> CharRange 
mut_ref_slice			pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] 
nan			    fn nan() -> f32 { NAN }
nan			    fn nan() -> f64 { NAN }
nan			    fn nan() -> Self;
ne			                fn ne(&self, other: &Rhs) -> bool 
ne			                fn ne(&self, other: &[B; 
ne			                fn ne(&self, other: &
ne			        fn ne(&self, _other: &()) -> bool { false }
ne			        fn ne(&self, other: & &'b B) -> bool { PartialEq::ne(*self, *other) }
ne			        fn ne(&self, other: &&'b B) -> bool { PartialEq::ne(*self, *other) }
ne			        fn ne(&self, other: &&'b mut B) -> bool { PartialEq::ne(*self, *other) }
ne			    fn ne(&self, other: &Rhs) -> bool { !self.eq(other) }
ne			    pub fn ne<A, B, L, R>(mut a: L, mut b: R) -> bool where
ne			    fn ne(&self, other: &*const T) -> bool { !self.eq(other) }
ne			    fn ne(&self, other: &*mut T) -> bool { !self.eq(other) }
ne			    fn ne(&self, other: &[B]) -> bool 
ne			        fn ne(&self, other: &str) -> bool { !(*self).eq(other) }
ne			                fn ne(&self, other: &(
nearbyintf32			    pub fn nearbyintf32(x: f32) -> f32;
nearbyintf64			    pub fn nearbyintf64(x: f64) -> f64;
needs_drop			    pub fn needs_drop<T>() -> bool;
neg			            fn neg(self) -> 
neg			            fn neg(self) -> 
neg			    fn neg(self) -> Self::Output;
neg_infinity			    fn neg_infinity() -> f32 { NEG_INFINITY }
neg_infinity			    fn neg_infinity() -> f64 { NEG_INFINITY }
neg_infinity			    fn neg_infinity() -> Self;
neg_zero			    fn neg_zero() -> f32 { -0.0 }
neg_zero			    fn neg_zero() -> f64 { -0.0 }
neg_zero			    fn neg_zero() -> Self;
new			    pub fn new(p: *mut T) -> AtomicPtr<T> 
new			    pub fn new(v: bool) -> AtomicBool 
new			    pub fn new(v: int) -> AtomicInt 
new			    pub fn new(v: uint) -> AtomicUint 
new			    fn new(borrow: &'b Cell<BorrowFlag>) -> Option<BorrowRef<'b>> 
new			    fn new(borrow: &'b Cell<BorrowFlag>) -> Option<BorrowRefMut<'b>> 
new			    pub fn new(value: T) -> Cell<T> 
new			    pub fn new(value: T) -> RefCell<T> 
new			    pub fn new(value: T) -> UnsafeCell<T> 
new			    fn new<'b, T>(x: &'b T, f: fn(&T, &mut Formatter) -> Result) -> Argument<'b> 
new			    pub fn new(pieces: &'a [&'a str],
new			    fn new(base: u8) -> Radix 
new			    pub fn new() -> SipHasher 
new			    pub fn new() -> SipState 
new			    pub fn new(initial_state: St, f: F) -> Unfold<A, St, F> 
new			    pub unsafe fn new(inner: T) -> NonZero<T> 
new			    fn new() -> NaiveSearcher 
new			    fn new(haystack: &[u8], needle: &[u8]) -> Searcher 
new			    fn new(needle: &[u8]) -> TwoWaySearcher 
new_with_keys			    pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher 
new_with_keys			    pub fn new_with_keys(key0: u64, key1: u64) -> SipState 
next			    fn next(&mut self) -> Option<char> 
next			            fn next(&mut self) -> Option<A> { None }
next			    fn next(&mut self) -> Option<(T, U)> 
next			    fn next(&mut self) -> Option<(uint, <I as Iterator>::Item)> 
next			    fn next(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next() }
next			    fn next(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next_back() }
next			    fn next(&mut self) -> Option<<I as Iterator>::Item> 
next			    fn next(&mut self) -> Option<A> { self.idx(0) }
next			    fn next(&mut self) -> Option<A> 
next			    fn next(&mut self) -> Option<B> 
next			    fn next(&mut self) -> Option<Self::Item>;
next			    fn next(&mut self) -> Option<T> 
next			    fn next<T, F>(st: &mut IterateState<T, F>) -> Option<T> where
next			    fn next(&mut self) -> Option<Idx> 
next			            fn next(&mut self) -> Option<T> 
next			    fn next(&mut self) -> Option<&'a A> { self.inner.next() }
next			    fn next(&mut self) -> Option<&'a mut A> { self.inner.next() }
next			    fn next(&mut self) -> Option<A> { self.inner.next() }
next			    fn next(&mut self) -> Option<A> 
next			            fn next(&mut self) -> Option<T> 
next			    fn next(&mut self) -> Option<&'a T> { self.inner.take() }
next			    fn next(&mut self) -> Option<&'a mut T> { self.inner.take() }
next			    fn next(&mut self) -> Option<T> { self.inner.take() }
next			            fn next(&mut self) -> Option<
next			            fn next(&mut self) -> Option<
next			    fn next(&mut self) -> Option<&'a [T]> 
next			    fn next(&mut self) -> Option<&'a mut [T]> 
next			    fn next(&mut self) -> Option<T> 
next			            fn next(&mut self) -> Option<
next			    fn next(&mut self) -> Option<&'a str> { self.inner.next() }
next			    fn next(&mut self) -> Option<&'a str> 
next			    fn next(&mut self) -> Option<(uint, char)> 
next			    fn next(&mut self) -> Option<(uint, uint)> 
next			    fn next(&mut self) -> Option<char> 
next			    fn next(&mut self, haystack: &[u8], needle: &[u8]) -> Option<(uint, uint)> 
next			    fn next(&mut self, haystack: &[u8], needle: &[u8], long_period: bool) -> Option<(uint, uint)> 
next_back			    fn next_back(&mut self) -> Option<(T, U)> 
next_back			    fn next_back(&mut self) -> Option<(uint, <I as Iterator>::Item)> 
next_back			    fn next_back(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next() }
next_back			    fn next_back(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next_back() }
next_back			    fn next_back(&mut self) -> Option<<I as Iterator>::Item> 
next_back			    fn next_back(&mut self) -> Option<A> { self.idx(0) }
next_back			    fn next_back(&mut self) -> Option<A> 
next_back			    fn next_back(&mut self) -> Option<B> 
next_back			    fn next_back(&mut self) -> Option<Self::Item>;
next_back			    fn next_back(&mut self) -> Option<T> 
next_back			    fn next_back(&mut self) -> Option<Idx> 
next_back			    fn next_back(&mut self) -> Option<&'a A> { self.inner.next_back() }
next_back			    fn next_back(&mut self) -> Option<&'a mut A> { self.inner.next_back() }
next_back			    fn next_back(&mut self) -> Option<A> { self.inner.next_back() }
next_back			    fn next_back(&mut self) -> Option<A> 
next_back			    fn next_back(&mut self) -> Option<&'a T> { self.inner.take() }
next_back			    fn next_back(&mut self) -> Option<&'a mut T> { self.inner.take() }
next_back			    fn next_back(&mut self) -> Option<T> { self.inner.take() }
next_back			            fn next_back(&mut self) -> Option<
next_back			    fn next_back(&mut self) -> Option<&'a [T]> 
next_back			    fn next_back(&mut self) -> Option<&'a mut [T]> 
next_back			            fn next_back(&mut self) -> Option<
next_back			    fn next_back(&mut self) -> Option<&'a str> { self.inner.next_back() }
next_back			    fn next_back(&mut self) -> Option<&'a str> 
next_back			    fn next_back(&mut self) -> Option<(uint, char)> 
next_back			    fn next_back(&mut self) -> Option<char> 
next_permutation			    fn next_permutation(&mut self) -> bool where Self::Item: Ord;
next_permutation			    fn next_permutation(&mut self) -> bool where T: Ord 
next_power_of_two			    fn next_power_of_two(self) -> Self 
nonzero			pub mod nonzero;
not			            fn not(self) -> 
not			    fn not(self) -> Self::Output;
nth			    fn nth(&mut self, mut n: uint) -> Option<Self::Item> 
null			    pub fn null() -> Unique<T> 
null			pub fn null<T>() -> *const T { 0 as *const T }
null_mut			pub fn null_mut<T>() -> *mut T { 0 as *mut T }
num			mod num;
num			pub mod num;
of			    pub fn of<T: 'static>() -> TypeId 
offset			    pub fn offset<T>(dst: *const T, offset: int) -> *const T;
offset			    pub unsafe fn offset(self, offset: int) -> *mut T 
offset			    unsafe fn offset(self, count: int) -> *const T 
offset			    unsafe fn offset(self, count: int) -> *mut T 
offset			    unsafe fn offset(self, count: int) -> Self;
ok			    pub fn ok(self) -> Option<T> 
ok_or			    pub fn ok_or<E>(self, err: E) -> Result<T, E> 
ok_or_else			    pub fn ok_or_else<E, F: FnOnce() -> E>(self, err: F) -> Result<T, E> 
one			    fn one() -> f32 { 1.0 }
one			    fn one() -> f64 { 1.0 }
one			            fn one() -> 
one			    fn one() -> Self;
only_ascii			    fn only_ascii(&self) -> bool { (*self as uint) < 128 }
only_ascii			    fn only_ascii(&self) -> bool { false }
only_ascii			    fn only_ascii(&self) -> bool 
only_ascii			    fn only_ascii(&self) -> bool;
ops			pub mod ops;
ops			impl<'a, T> ops::Index<ops::Range<uint>> for Iter<'a, T> 
ops			impl<'a, T> ops::Index<ops::Range<uint>> for IterMut<'a, T> 
ops			impl<'a, T> ops::Index<ops::RangeFrom<uint>> for Iter<'a, T> 
ops			impl<'a, T> ops::Index<ops::RangeFrom<uint>> for IterMut<'a, T> 
ops			impl<'a, T> ops::Index<ops::RangeTo<uint>> for Iter<'a, T> 
ops			impl<'a, T> ops::Index<ops::RangeTo<uint>> for IterMut<'a, T> 
ops			impl<'a, T> ops::IndexMut<ops::Range<uint>> for IterMut<'a, T> 
ops			impl<'a, T> ops::IndexMut<ops::RangeFrom<uint>> for IterMut<'a, T> 
ops			impl<'a, T> ops::IndexMut<ops::RangeTo<uint>> for IterMut<'a, T> 
ops			impl<T> ops::Index<ops::FullRange> for [T] 
ops			impl<T> ops::Index<ops::Range<uint>> for [T] 
ops			impl<T> ops::Index<ops::RangeFrom<uint>> for [T] 
ops			impl<T> ops::Index<ops::RangeTo<uint>> for [T] 
ops			impl<T> ops::Index<uint> for [T] 
ops			impl<T> ops::IndexMut<ops::FullRange> for [T] 
ops			impl<T> ops::IndexMut<ops::Range<uint>> for [T] 
ops			impl<T> ops::IndexMut<ops::RangeFrom<uint>> for [T] 
ops			impl<T> ops::IndexMut<ops::RangeTo<uint>> for [T] 
ops			impl<T> ops::IndexMut<uint> for [T] 
ops			    impl ops::Index<ops::Range<uint>> for str 
ops			    impl ops::Index<ops::RangeFrom<uint>> for str 
ops			    impl ops::Index<ops::RangeTo<uint>> for str 
ops::Index for Iter			impl<'a, T> ops::Index<ops::FullRange> for Iter<'a, T> 
ops::Index for IterMut			impl<'a, T> ops::Index<ops::FullRange> for IterMut<'a, T> 
ops::Index for str			    impl ops::Index<ops::FullRange> for str 
ops::IndexMut for IterMut			impl<'a, T> ops::IndexMut<ops::FullRange> for IterMut<'a, T> 
option			pub mod option;
or			    pub fn or(self, optb: Option<T>) -> Option<T> 
or			    pub fn or(self, res: Result<T, E>) -> Result<T, E> 
or_else			    pub fn or_else<F: FnOnce() -> Option<T>>(self, f: F) -> Option<T> 
or_else			    pub fn or_else<F, O: FnOnce(E) -> Result<T, F>>(self, op: O) -> Result<T, F> 
order			pub mod order 
owns_managed			    pub fn owns_managed<T>() -> bool;
pad			    pub fn pad(&mut self, s: &str) -> Result 
pad_integral			    pub fn pad_integral(&mut self,
panic			pub fn panic(expr_file_line: &(&'static str, &'static str, uint)) -> ! 
panic_bounds_check			fn panic_bounds_check(file_line: &(&'static str, uint),
panic_fmt			pub fn panic_fmt(fmt: fmt::Arguments, file_line: &(&'static str, uint)) -> ! 
panic_impl			        fn panic_impl(fmt: fmt::Arguments, file: &'static str, line: uint) -> !;
panicking			pub mod panicking;
parse			    fn parse<T: FromStr>(&self) -> Option<T> { FromStr::from_str(self) }
parse			    fn parse<T: FromStr>(&self) -> Option<T>;
partial_cmp			                fn partial_cmp(&self, other: &[T; 
partial_cmp			    fn partial_cmp(&self, other: &Cow<'a, T, B>) -> Option<Ordering> 
partial_cmp			                fn partial_cmp(&self, other: &
partial_cmp			        fn partial_cmp(&self, _: &()) -> Option<Ordering> 
partial_cmp			        fn partial_cmp(&self, other: &&'b B) -> Option<Ordering> 
partial_cmp			        fn partial_cmp(&self, other: &&'b mut B) -> Option<Ordering> 
partial_cmp			        fn partial_cmp(&self, other: &bool) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &Ordering) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &Rhs) -> Option<Ordering>;
partial_cmp			    pub fn partial_cmp<A, T, S>(mut a: T, mut b: S) -> Option<cmp::Ordering> where
partial_cmp			    fn partial_cmp(&self, other: &*const T) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &*mut T) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &[T]) -> Option<Ordering> 
partial_cmp			        fn partial_cmp(&self, other: &str) -> Option<Ordering> 
partial_cmp			                fn partial_cmp(&self, other: &(
partial_max			pub fn partial_max<T: PartialOrd>(v1: T, v2: T) -> Option<T> 
partial_min			pub fn partial_min<T: PartialOrd>(v1: T, v2: T) -> Option<T> 
partition			    fn partition<B, F>(mut self, mut f: F) -> (B, B) where
peek			    pub fn peek(&mut self) -> Option<&T> 
peekable			    fn peekable(self) -> Peekable<Self::Item, Self> 
position			    fn position<P>(&mut self, mut predicate: P) -> Option<uint> where
position_elem			    fn position_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;
position_elem			    fn position_elem(&self, x: &T) -> Option<uint> where T: PartialEq 
pow			    fn pow(self, mut exp: uint) -> Self 
powf			    fn powf(self, n: f32) -> f32 
powf			    fn powf(self, n: f64) -> f64 
powf			    fn powf(self, n: Self) -> Self;
powf32			    pub fn powf32(a: f32, x: f32) -> f32;
powf64			    pub fn powf64(a: f64, x: f64) -> f64;
powi			    fn powi(self, n: i32) -> f32 
powi			    fn powi(self, n: i32) -> f64 
powi			    fn powi(self, n: i32) -> Self;
powif32			    pub fn powif32(a: f32, x: i32) -> f32;
powif64			    pub fn powif64(a: f64, x: i32) -> f64;
precision			    pub fn precision(&self) -> Option<uint> { self.precision }
pref_align_of			    pub fn pref_align_of<T>() -> uint;
prefix			            fn prefix(&self) -> &'static str { 
prefix			    fn prefix(&self) -> &'static str { "" }
prelude			pub mod prelude;
prev_permutation			    fn prev_permutation(&mut self) -> bool where Self::Item: Ord;
prev_permutation			    fn prev_permutation(&mut self) -> bool where T: Ord 
product			            fn product(self) -> 
product			    fn product(self) -> A;
ptr			pub mod ptr;
radix			pub fn radix<T>(x: T, base: u8) -> RadixFmt<T, Radix> 
range			pub fn range<A: Int>(start: A, stop: A) -> Range<A> 
range_inclusive			pub fn range_inclusive<A: Int>(start: A, stop: A) -> RangeInclusive<A> 
range_step			pub fn range_step<A: Int>(start: A, stop: A, step: A) -> RangeStep<A> 
range_step_inclusive			pub fn range_step_inclusive<A: Int>(start: A, stop: A, step: A) -> RangeStepInclusive<A> 
raw			pub mod raw;
read			pub unsafe fn read<T>(src: *const T) -> T 
read_and_zero			pub unsafe fn read_and_zero<T>(dest: *mut T) -> T 
recip			    fn recip(self) -> f32 { 1.0 \/ self }
recip			    fn recip(self) -> f64 { 1.0 \/ self }
recip			    fn recip(self) -> Self;
ref_slice			pub fn ref_slice<'a, A>(s: &'a A) -> &'a [A] 
rem			            fn rem(self, other: 
rem			            fn rem(self, other: 
rem			    fn rem(self, rhs: RHS) -> Self::Output;
repeat			pub fn repeat<T: Clone>(elt: T) -> Repeat<T> 
replace			pub fn replace<T>(dest: &mut T, mut src: T) -> T 
replace			pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T 
repr			    fn repr(&self) -> T { unsafe { mem::transmute_copy(&self) } }
reset			    pub fn reset(&mut self) 
reset_fuse			    pub fn reset_fuse(&mut self) 
result			    pub fn result(&self) -> u64 
result			pub mod result;
result_bytes			        fn result_bytes(h: u64) -> Vec<u8> 
result_str			        fn result_str(h: u64) -> String 
return_address			    pub fn return_address() -> *const u8;
rev			    fn rev(self) -> Rev<Self> 
reverse			    pub fn reverse(self) -> Ordering 
reverse			    fn reverse(&mut self) 
reverse			    fn reverse(&mut self);
reverse_in_place			    fn reverse_in_place<'a, T: 'a>(&mut self) where
rfind			    fn rfind<P: CharEq>(&self, mut pat: P) -> Option<uint> 
rfind			    fn rfind<P: CharEq>(&self, pat: P) -> Option<uint>;
rintf32			    pub fn rintf32(x: f32) -> f32;
rintf64			    pub fn rintf64(x: f64) -> f64;
rotate_left			            fn rotate_left(self, n: uint) -> 
rotate_left			            fn rotate_left(self, n: uint) -> 
rotate_left			    fn rotate_left(self, n: uint) -> Self;
rotate_right			            fn rotate_right(self, n: uint) -> 
rotate_right			            fn rotate_right(self, n: uint) -> 
rotate_right			    fn rotate_right(self, n: uint) -> Self;
round			    fn round(self) -> f32 
round			    fn round(self) -> f64 
round			    fn round(self) -> Self;
roundf32			    pub fn roundf32(x: f32) -> f32;
roundf64			    pub fn roundf64(x: f64) -> f64;
rposition			    fn rposition<P>(&mut self, mut predicate: P) -> Option<uint> where
rposition_elem			    fn rposition_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;
rposition_elem			    fn rposition_elem(&self, t: &T) -> Option<uint> where T: PartialEq 
rsplitn			    fn rsplitn<'a, P>(&'a self,  n: uint, pred: P) -> RSplitN<'a, Self::Item, P>
rsplitn			    fn rsplitn<'a, P>(&'a self, n: uint, pred: P) -> RSplitN<'a, T, P> where
rsplitn			    fn rsplitn<'a, P: CharEq>(&'a self, count: uint, pat: P) -> RSplitN<'a, P>;
rsplitn			    fn rsplitn<P: CharEq>(&self, count: uint, pat: P) -> RSplitN<P> 
rsplitn_mut			    fn rsplitn_mut<'a, P>(&'a mut self, n: uint, pred: P) -> RSplitNMut<'a, T, P> where
rsplitn_mut			    fn rsplitn_mut<P>(&mut self,  n: uint, pred: P) -> RSplitNMut<Self::Item, P>
rsqrt			    fn rsqrt(self) -> f32 { self.sqrt().recip() }
rsqrt			    fn rsqrt(self) -> f64 { self.sqrt().recip() }
rsqrt			    fn rsqrt(self) -> Self;
rt			pub mod rt;
run			    fn run(&mut self, arg: &rt::Argument) -> Result 
run_utf8_validation_iterator			fn run_utf8_validation_iterator(iter: &mut slice::Iter<u8>)
saturating_add			    fn saturating_add(self, other: Self) -> Self 
saturating_sub			    fn saturating_sub(self, other: Self) -> Self 
scan			    fn scan<St, B, F>(
set			    pub fn set(&self, value: T) 
set_memory			    pub fn set_memory<T>(dst: *mut T, val: u8, count: uint);
set_memory			        fn set_memory(&mut self, value: u8) 
set_memory			        fn set_memory(&mut self, value: u8);
shl			            fn shl(self, other: uint) -> 
shl			    fn shl(self, rhs: RHS) -> Self::Output;
show_uint			    fn show_uint(x: &uint, f: &mut Formatter) -> Result 
shr			            fn shr(self, other: uint) -> 
shr			    fn shr(self, rhs: RHS) -> Self::Output;
signum			    fn signum(self) -> f32 
signum			    fn signum(self) -> f64 
signum			            fn signum(self) -> 
signum			    fn signum(self) -> Self;
simd			pub mod simd;
sinf32			    pub fn sinf32(x: f32) -> f32;
sinf64			    pub fn sinf64(x: f64) -> f64;
sip			pub mod sip;
size_hint			            fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) { (0, None) }
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) { (uint::MAX, None) }
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			            fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			            fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_of			    pub fn size_of<T>() -> uint;
size_of			pub fn size_of<T>() -> uint 
size_of_val			pub fn size_of_val<T>(_val: &T) -> uint 
skip			    fn skip(self, n: uint) -> Skip<Self> 
skip_while			    fn skip_while<P>(self, predicate: P) -> SkipWhile<Self::Item, Self, P> where
slice			pub mod slice;
slice			    fn slice(&self, start: uint, end: uint) -> &[T] 
slice			    fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [Self::Item];
slice			    fn slice(&self, begin: uint, end: uint) -> &str 
slice			    fn slice<'a>(&'a self, begin: uint, end: uint) -> &'a str;
slice_chars			    fn slice_chars(&self, begin: uint, end: uint) -> &str 
slice_chars			    fn slice_chars<'a>(&'a self, begin: uint, end: uint) -> &'a str;
slice_error_fail			fn slice_error_fail(s: &str, begin: uint, end: uint) -> ! 
slice_from			    fn slice_from(&self, start: uint) -> &[T] 
slice_from			    fn slice_from<'a>(&'a self, start: uint) -> &'a [Self::Item];
slice_from			    fn slice_from(&self, begin: uint) -> &str 
slice_from			    fn slice_from<'a>(&'a self, begin: uint) -> &'a str;
slice_from_mut			    fn slice_from_mut(&mut self, start: uint) -> &mut [T] 
slice_from_mut			    fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [Self::Item];
slice_mut			    fn slice_mut(&mut self, start: uint, end: uint) -> &mut [T] 
slice_mut			    fn slice_mut<'a>(&'a mut self, start: uint, end: uint) -> &'a mut [Self::Item];
slice_shift_char			    fn slice_shift_char(&self) -> Option<(char, &str)> 
slice_shift_char			    fn slice_shift_char<'a>(&'a self) -> Option<(char, &'a str)>;
slice_to			    fn slice_to(&self, end: uint) -> &[T] 
slice_to			    fn slice_to<'a>(&'a self, end: uint) -> &'a [Self::Item];
slice_to			    fn slice_to(&self, end: uint) -> &str 
slice_to			    fn slice_to<'a>(&'a self, end: uint) -> &'a str;
slice_to_mut			    fn slice_to_mut(&mut self, end: uint) -> &mut [T] 
slice_to_mut			    fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [Self::Item];
slice_unchecked			    unsafe fn slice_unchecked(&self, begin: uint, end: uint) -> &str 
slice_unchecked			    unsafe fn slice_unchecked<'a>(&'a self, begin: uint, end: uint) -> &'a str;
split			    fn split<'a, P>(&'a self, pred: P) -> Split<'a, Self::Item, P>
split			    fn split<'a, P>(&'a self, pred: P) -> Split<'a, T, P> where P: FnMut(&T) -> bool 
split			    fn split<'a, P: CharEq>(&'a self, pat: P) -> Split<'a, P>;
split			    fn split<P: CharEq>(&self, pat: P) -> Split<P> 
split_at			    fn split_at(&self, mid: uint) -> (&[T], &[T]) 
split_at			    fn split_at<'a>(&'a self, mid: uint) -> (&'a [Self::Item], &'a [Self::Item]);
split_at_mut			    fn split_at_mut(&mut self, mid: uint) -> (&mut [T], &mut [T]) 
split_at_mut			    fn split_at_mut<'a>(&'a mut self, mid: uint) -> (&'a mut [Self::Item], &'a mut [Self::Item]);
split_mut			    fn split_mut<'a, P>(&'a mut self, pred: P) -> SplitMut<'a, Self::Item, P>
split_mut			    fn split_mut<'a, P>(&'a mut self, pred: P) -> SplitMut<'a, T, P> where P: FnMut(&T) -> bool 
split_str			    fn split_str<'a>(&'a self, pat: &'a str) -> SplitStr<'a>;
split_str			    fn split_str<'a>(&'a self, sep: &'a str) -> SplitStr<'a> 
split_terminator			    fn split_terminator<'a, P: CharEq>(&'a self, pat: P) -> SplitTerminator<'a, P>;
split_terminator			    fn split_terminator<P: CharEq>(&self, pat: P) -> SplitTerminator<P> 
splitn			    fn splitn<'a, P>(&'a self, n: uint, pred: P) -> SplitN<'a, Self::Item, P>
splitn			    fn splitn<'a, P>(&'a self, n: uint, pred: P) -> SplitN<'a, T, P> where
splitn			    fn splitn<'a, P: CharEq>(&'a self, count: uint, pat: P) -> SplitN<'a, P>;
splitn			    fn splitn<P: CharEq>(&self, count: uint, pat: P) -> SplitN<P> 
splitn_mut			    fn splitn_mut<'a, P>(&'a mut self, n: uint, pred: P) -> SplitNMut<'a, T, P> where
splitn_mut			    fn splitn_mut<P>(&mut self, n: uint, pred: P) -> SplitNMut<Self::Item, P>
sqrt			    fn sqrt(self) -> f32 
sqrt			    fn sqrt(self) -> f64 
sqrt			    fn sqrt(self) -> Self;
sqrtf32			    pub fn sqrtf32(x: f32) -> f32;
sqrtf64			    pub fn sqrtf64(x: f64) -> f64;
starts_with			    fn starts_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;
starts_with			    fn starts_with(&self, needle: &[T]) -> bool where T: PartialEq 
starts_with			    fn starts_with(&self, needle: &str) -> bool 
starts_with			    fn starts_with(&self, pat: &str) -> bool;
std			mod std 
step			            fn step(&mut self) { *self += 1; }
step			    fn step(&mut self);
step_back			            fn step_back(&mut self) { *self -= 1; }
step_back			    fn step_back(&mut self);
steps_between			            fn steps_between(_start: &
steps_between			            fn steps_between(start: &
steps_between			    fn steps_between(start: &Self, end: &Self) -> Option<uint>;
store			    pub fn store(&self, ptr: *mut T, order: Ordering) 
store			    pub fn store(&self, val: bool, order: Ordering) 
store			    pub fn store(&self, val: int, order: Ordering) 
store			    pub fn store(&self, val: uint, order: Ordering) 
str			pub mod str;
sub			            fn sub(self, other: 
sub			    fn sub(self, rhs: RHS) -> Self::Output;
subslice_offset			    fn subslice_offset(&self, inner: &str) -> uint 
subslice_offset			    fn subslice_offset(&self, inner: &str) -> uint;
sum			            fn sum(self) -> 
sum			    fn sum(self) -> A;
swap			    pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T 
swap			    pub fn swap(&self, val: bool, order: Ordering) -> bool 
swap			    pub fn swap(&self, val: int, order: Ordering) -> int 
swap			    pub fn swap(&self, val: uint, order: Ordering) -> uint 
swap			pub fn swap<T>(x: &mut T, y: &mut T) 
swap			pub unsafe fn swap<T>(x: *mut T, y: *mut T) 
swap			    fn swap(&mut self, a: uint, b: uint) 
swap			    fn swap(&mut self, a: uint, b: uint);
swap_bytes			            fn swap_bytes(self) -> 
swap_bytes			            fn swap_bytes(self) -> 
swap_bytes			    fn swap_bytes(self) -> Self;
tail			    fn tail(&self) -> &[T] { self.index(&(1..)) }
tail			    fn tail<'a>(&'a self) -> &'a [Self::Item];
tail_mut			    fn tail_mut(&mut self) -> &mut [T] 
tail_mut			    fn tail_mut<'a>(&'a mut self) -> &'a mut [Self::Item];
take			    fn take(self, n: uint) -> Take<Self> 
take			    pub fn take(&mut self) -> Option<T> 
take_while			    fn take_while<P>(self, predicate: P) -> TakeWhile<Self::Item, Self, P> where
tests			mod tests 
to_be			    fn to_be(self) -> Self { \/\/ or not to be?
to_degrees			    fn to_degrees(self) -> f32 { self * (180.0f32 \/ consts::PI) }
to_degrees			    fn to_degrees(self) -> f64 { self * (180.0f64 \/ consts::PI) }
to_degrees			    fn to_degrees(self) -> Self;
to_digit			    fn to_digit(self, radix: uint) -> Option<uint> 
to_digit			    fn to_digit(self, radix: uint) -> Option<uint>;
to_f32			            fn to_f32(&self) -> Option<f32> { Some(*self as f32) }
to_f32			            fn to_f32(&self) -> Option<f32> { impl_to_primitive_float_to_float!(
to_f32			    fn to_f32(&self) -> Option<f32> 
to_f64			            fn to_f64(&self) -> Option<f64> { Some(*self as f64) }
to_f64			            fn to_f64(&self) -> Option<f64> { impl_to_primitive_float_to_float!(
to_f64			    fn to_f64(&self) -> Option<f64> 
to_hex_str			        fn to_hex_str(r: &[u8; 8]) -> String 
to_i16			            fn to_i16(&self) -> Option<i16> { Some(*self as i16) }
to_i16			            fn to_i16(&self) -> Option<i16> { impl_to_primitive_int_to_int!(
to_i16			            fn to_i16(&self) -> Option<i16> { impl_to_primitive_uint_to_int!(i16, *self) }
to_i16			    fn to_i16(&self) -> Option<i16> 
to_i32			            fn to_i32(&self) -> Option<i32> { Some(*self as i32) }
to_i32			            fn to_i32(&self) -> Option<i32> { impl_to_primitive_int_to_int!(
to_i32			            fn to_i32(&self) -> Option<i32> { impl_to_primitive_uint_to_int!(i32, *self) }
to_i32			    fn to_i32(&self) -> Option<i32> 
to_i64			            fn to_i64(&self) -> Option<i64> { Some(*self as i64) }
to_i64			            fn to_i64(&self) -> Option<i64> { impl_to_primitive_int_to_int!(
to_i64			            fn to_i64(&self) -> Option<i64> { impl_to_primitive_uint_to_int!(i64, *self) }
to_i64			    fn to_i64(&self) -> Option<i64>;
to_i8			            fn to_i8(&self) -> Option<i8> { Some(*self as i8) }
to_i8			            fn to_i8(&self) -> Option<i8> { impl_to_primitive_int_to_int!(
to_i8			            fn to_i8(&self) -> Option<i8> { impl_to_primitive_uint_to_int!(i8, *self) }
to_i8			    fn to_i8(&self) -> Option<i8> 
to_int			            fn to_int(&self) -> Option<int> { Some(*self as int) }
to_int			            fn to_int(&self) -> Option<int> { impl_to_primitive_int_to_int!(
to_int			            fn to_int(&self) -> Option<int> { impl_to_primitive_uint_to_int!(int, *self) }
to_int			    fn to_int(&self) -> Option<int> 
to_le			    fn to_le(self) -> Self 
to_mut			    pub fn to_mut(&mut self) -> &mut T 
to_owned			    fn to_owned(&self) -> Owned;
to_owned			    fn to_owned(&self) -> T { self.clone() }
to_radians			    fn to_radians(self) -> f32 
to_radians			    fn to_radians(self) -> f64 
to_radians			    fn to_radians(self) -> Self;
to_u16			            fn to_u16(&self) -> Option<u16> { Some(*self as u16) }
to_u16			            fn to_u16(&self) -> Option<u16> { impl_to_primitive_int_to_uint!(
to_u16			            fn to_u16(&self) -> Option<u16> { impl_to_primitive_uint_to_uint!(
to_u16			    fn to_u16(&self) -> Option<u16> 
to_u32			            fn to_u32(&self) -> Option<u32> { Some(*self as u32) }
to_u32			            fn to_u32(&self) -> Option<u32> { impl_to_primitive_int_to_uint!(
to_u32			            fn to_u32(&self) -> Option<u32> { impl_to_primitive_uint_to_uint!(
to_u32			    fn to_u32(&self) -> Option<u32> 
to_u64			            fn to_u64(&self) -> Option<u64> { Some(*self as u64) }
to_u64			            fn to_u64(&self) -> Option<u64> { impl_to_primitive_int_to_uint!(
to_u64			            fn to_u64(&self) -> Option<u64> { impl_to_primitive_uint_to_uint!(
to_u64			    fn to_u64(&self) -> Option<u64>;
to_u8			            fn to_u8(&self) -> Option<u8> { Some(*self as u8) }
to_u8			            fn to_u8(&self) -> Option<u8> { impl_to_primitive_int_to_uint!(
to_u8			            fn to_u8(&self) -> Option<u8> { impl_to_primitive_uint_to_uint!(
to_u8			    fn to_u8(&self) -> Option<u8> 
to_uint			            fn to_uint(&self) -> Option<uint> { Some(*self as uint) }
to_uint			            fn to_uint(&self) -> Option<uint> { impl_to_primitive_int_to_uint!(
to_uint			            fn to_uint(&self) -> Option<uint> { impl_to_primitive_uint_to_uint!(
to_uint			    fn to_uint(&self) -> Option<uint> 
trailing_zeros			            fn trailing_zeros(self) -> uint { (self as 
trailing_zeros			            fn trailing_zeros(self) -> uint { unsafe { 
trailing_zeros			    fn trailing_zeros(self) -> uint;
traits			mod traits 
transmute			    pub fn transmute<T,U>(e: T) -> U;
transmute_copy			pub unsafe fn transmute_copy<T, U>(src: &T) -> U 
trim_left_matches			    fn trim_left_matches<'a, P: CharEq>(&'a self, pat: P) -> &'a str;
trim_left_matches			    fn trim_left_matches<P: CharEq>(&self, mut pat: P) -> &str 
trim_matches			    fn trim_matches<'a, P: CharEq>(&'a self, pat: P) -> &'a str;
trim_matches			    fn trim_matches<P: CharEq>(&self, mut pat: P) -> &str 
trim_right_matches			    fn trim_right_matches<'a, P: CharEq>(&'a self, pat: P) -> &'a str;
trim_right_matches			    fn trim_right_matches<P: CharEq>(&self, mut pat: P) -> &str 
trunc			    fn trunc(self) -> f32 
trunc			    fn trunc(self) -> f64 
trunc			    fn trunc(self) -> Self;
truncf32			    pub fn truncf32(x: f32) -> f32;
truncf64			    pub fn truncf64(x: f64) -> f64;
try_borrow			    pub fn try_borrow<'a>(&'a self) -> Option<Ref<'a, T>> 
try_borrow_mut			    pub fn try_borrow_mut<'a>(&'a self) -> Option<RefMut<'a, T>> 
try_finally			pub fn try_finally<T, U, R, F, G>(mutate: &mut T, drop: U, try_fn: F, finally_fn: G) -> R where
tuple			mod tuple;
type_id			    pub fn type_id<T: 'static>() -> TypeId;
u16_add_with_overflow			    pub fn u16_add_with_overflow(x: u16, y: u16) -> (u16, bool);
u16_mul_with_overflow			    pub fn u16_mul_with_overflow(x: u16, y: u16) -> (u16, bool);
u16_sub_with_overflow			    pub fn u16_sub_with_overflow(x: u16, y: u16) -> (u16, bool);
u16x8			pub struct u16x8(pub u16, pub u16, pub u16, pub u16,
u32_add_with_overflow			    pub fn u32_add_with_overflow(x: u32, y: u32) -> (u32, bool);
u32_mul_with_overflow			    pub fn u32_mul_with_overflow(x: u32, y: u32) -> (u32, bool);
u32_sub_with_overflow			    pub fn u32_sub_with_overflow(x: u32, y: u32) -> (u32, bool);
u32x4			pub struct u32x4(pub u32, pub u32, pub u32, pub u32);
u64_add_with_overflow			    pub fn u64_add_with_overflow(x: u64, y: u64) -> (u64, bool);
u64_mul_with_overflow			    pub fn u64_mul_with_overflow(x: u64, y: u64) -> (u64, bool);
u64_sub_with_overflow			    pub fn u64_sub_with_overflow(x: u64, y: u64) -> (u64, bool);
u64x2			pub struct u64x2(pub u64, pub u64);
u8_add_with_overflow			    pub fn u8_add_with_overflow(x: u8, y: u8) -> (u8, bool);
u8_mul_with_overflow			    pub fn u8_mul_with_overflow(x: u8, y: u8) -> (u8, bool);
u8_sub_with_overflow			    pub fn u8_sub_with_overflow(x: u8, y: u8) -> (u8, bool);
u8x16			pub struct u8x16(pub u8, pub u8, pub u8, pub u8,
uint_macros			mod uint_macros;
uninit			    pub fn uninit<T>() -> T;
uninitialized			pub unsafe fn uninitialized<T>() -> T 
unreachable			    pub fn unreachable() -> !;
unwrap			    pub fn unwrap(self) -> T 
unwrap			    pub fn unwrap(self) -> T 
unwrap_err			    pub fn unwrap_err(self) -> E 
unwrap_or			    pub fn unwrap_or(self, def: T) -> T 
unwrap_or			    pub fn unwrap_or(self, optb: T) -> T 
unwrap_or_0			fn unwrap_or_0(opt: Option<&u8>) -> u8 
unwrap_or_default			    pub fn unwrap_or_default(self) -> T 
unwrap_or_else			    pub fn unwrap_or_else<F: FnOnce() -> T>(self, f: F) -> T 
unwrap_or_else			    pub fn unwrap_or_else<F: FnOnce(E) -> T>(self, op: F) -> T 
unzip			    fn unzip<A, B, FromA, FromB>(mut self) -> (FromA, FromB) where
volatile_copy_memory			    pub fn volatile_copy_memory<T>(dst: *mut T, src: *const T, count: uint);
volatile_copy_nonoverlapping_memory			    pub fn volatile_copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T,
volatile_load			    pub fn volatile_load<T>(src: *const T) -> T;
volatile_set_memory			    pub fn volatile_set_memory<T>(dst: *mut T, val: u8, count: uint);
volatile_store			    pub fn volatile_store<T>(dst: *mut T, val: T);
width			    pub fn width(&self) -> Option<uint> { self.width }
windows			    fn windows(&self, size: uint) -> Windows<T> 
windows			    fn windows<'a>(&'a self, size: uint) -> Windows<'a, Self::Item>;
with_padding			    fn with_padding<F>(&mut self, padding: uint, default: rt::Alignment, f: F) -> Result where
with_placeholders			    pub fn with_placeholders(pieces: &'a [&'a str],
write			pub fn write(output: &mut Writer, args: Arguments) -> Result 
write			    fn write(&mut self, bytes: &[u8]);
write			    fn write(&mut self, msg: &[u8]) 
write			pub unsafe fn write<T>(dst: *mut T, src: T) 
write_fmt			            fn write_fmt(&mut self, args: Arguments) -> Result 
write_fmt			    fn write_fmt(&mut self, args: Arguments) -> Result 
write_fmt			    pub fn write_fmt(&mut self, fmt: Arguments) -> Result 
write_str			                fn write_str(&mut self, s: &str) -> fmt::Result 
write_str			            fn write_str(&mut self, s: &str) -> Result 
write_str			    fn write_str(&mut self, s: &str) -> Result;
write_str			    pub fn write_str(&mut self, data: &str) -> Result 
zero			    fn zero() -> f32 { 0.0 }
zero			    fn zero() -> f64 { 0.0 }
zero			            fn zero() -> 
zero			    fn zero() -> Self;
zero_byte			        fn zero_byte(val: u32, byte: uint) -> u32 
zero_byte			        fn zero_byte(val: u64, byte: uint) -> u64 
zero_memory			pub unsafe fn zero_memory<T>(dst: *mut T, count: uint) 
zeroed			pub unsafe fn zeroed<T>() -> T 
zip			    fn zip<B, U>(self, other: U) -> Zip<Self, U> where
