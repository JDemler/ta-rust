Adapter			    struct Adapter<Iter> 
Adapter			    struct Adapter<Iter, E> 
Add			        impl Add<
Add			pub trait Add<RHS,Result> 
AdditiveIterator			pub trait AdditiveIterator<A> 
Alignment			pub enum Alignment 
Alphabetic			    pub fn Alphabetic(c: char) -> bool 
Any			pub trait Any 
AnyMutRefExt			pub trait AnyMutRefExt<'a> 
AnyRefExt			pub trait AnyRefExt<'a> 
Argument			pub struct Argument<'a> 
Argument			pub struct Argument<'a> 
Arguments			pub struct Arguments<'a> 
AtomicBool			impl AtomicBool 
AtomicBool			pub struct AtomicBool 
AtomicInt			impl AtomicInt 
AtomicInt			pub struct AtomicInt 
AtomicPtr			pub struct AtomicPtr<T> 
AtomicUint			impl AtomicUint 
AtomicUint			pub struct AtomicUint 
Binary			pub trait Binary 
Binary			struct Binary;
BitAnd			        impl BitAnd<
BitAnd			pub trait BitAnd<RHS,Result> 
BitOr			        impl BitOr<
BitOr			pub trait BitOr<RHS,Result> 
BitXor			        impl BitXor<
BitXor			pub trait BitXor<RHS,Result> 
Bool			impl Bool for bool 
Bool			pub trait Bool 
Bounded			        impl Bounded for 
Bounded			pub trait Bounded 
Box			pub struct Box<T> 
ByRef			pub struct ByRef<'a, T> 
Cc			    pub fn Cc(c: char) -> bool 
Cell			pub struct Cell<T> 
Chain			pub struct Chain<T, U> 
Char			impl Char for char 
Char			pub trait Char 
Char			impl Char for char 
Char			pub trait Char 
CharEq			impl CharEq for char 
CharEq			impl CharEq for extern "Rust" fn(char) -> bool 
CharEq			pub trait CharEq 
CharOffsets			pub struct CharOffsets<'a> 
CharRange			pub struct CharRange 
CharSplits			pub struct CharSplits<'a, Sep> 
CharSplitsN			pub struct CharSplitsN<'a, Sep> 
Chars			pub struct Chars<'a> 
CheckedAdd			pub trait CheckedAdd: Add<Self, Self> 
CheckedDiv			        impl CheckedDiv for 
CheckedDiv			pub trait CheckedDiv: Div<Self, Self> 
CheckedMul			pub trait CheckedMul: Mul<Self, Self> 
CheckedSub			pub trait CheckedSub: Sub<Self, Self> 
Chunks			pub struct Chunks<'a, T> 
Clone			        impl Clone for 
Clone			pub trait Clone 
CloneableIterator			pub trait CloneableIterator 
Closure			pub struct Closure 
Collection			pub trait Collection 
ContravariantLifetime			    pub struct ContravariantLifetime<'a>;
ContravariantType			    pub struct ContravariantType<T>;
Copy			pub trait Copy 
Count			pub enum Count 
Counter			pub struct Counter<A> 
CovariantLifetime			    pub struct CovariantLifetime<'a>;
CovariantType			    pub struct CovariantType<T>;
Cycle			pub struct Cycle<T> 
Decimal			struct Decimal;
Default			        impl Default for 
Default			pub trait Default 
Deref			pub trait Deref<Result> 
DerefMut			pub trait DerefMut<Result>: Deref<Result> 
Div			        impl Div<
Div			pub trait Div<RHS,Result> 
DoubleEndedIterator			pub trait DoubleEndedIterator<A>: Iterator<A> 
Drop			pub trait Drop 
Enumerate			pub struct Enumerate<T> 
Eq			            impl Eq for 
Eq			impl Eq for Ordering {}
Eq			pub trait Eq: PartialEq 
Equiv			pub trait Equiv<T> 
ExactSize			pub trait ExactSize<A> : DoubleEndedIterator<A> 
ExponentFormat			pub enum ExponentFormat 
Extendable			pub trait Extendable<A>: FromIterator<A> 
FPCategory			pub enum FPCategory 
Filler			            struct Filler<'a> 
Filter			pub struct Filter<'a, A, T> 
FilterMap			pub struct FilterMap<'a, A, B, T> 
Finally			pub trait Finally<T> 
Finallyalizer			struct Finallyalizer<'a,A> 
Flag			pub enum Flag 
FlatMap			pub struct FlatMap<'a, A, T, U> 
Float			    impl Float for 
Float			pub trait Float 
Float			impl Float for f32 
Float			impl Float for f64 
Float			pub trait Float: Signed + Primitive 
Fn			pub trait Fn<Args,Result> 
FnMut			pub trait FnMut<Args,Result> 
FnOnce			pub trait FnOnce<Args,Result> 
FormatError			pub enum FormatError 
FormatSpec			pub struct FormatSpec 
FormatWriter			pub trait FormatWriter 
Formatter			pub struct Formatter<'a> 
FromIterator			pub trait FromIterator<A> 
FromPrimitive			        impl FromPrimitive for 
FromPrimitive			pub trait FromPrimitive 
Fuse			pub struct Fuse<T> 
GenericRadix			        impl GenericRadix for 
GenericRadix			impl GenericRadix for Radix 
GenericRadix			trait GenericRadix 
ImmutableEqVector			pub trait ImmutableEqVector<T:PartialEq> 
ImmutableOrdVector			pub trait ImmutableOrdVector<T: Ord> 
ImmutableVector			pub trait ImmutableVector<'a, T> 
Index			pub trait Index<Index,Result> 
Inspect			pub struct Inspect<'a, A, T> 
Int			        impl Int for 
Int			pub trait Int: Primitive
InvariantLifetime			    pub struct InvariantLifetime<'a>;
InvariantType			    pub struct InvariantType<T>;
Item			pub struct Item<A> 
Items			pub struct Items<'a, T> 
Iterator			pub trait Iterator<A> 
LowerExp			    impl LowerExp for 
LowerExp			pub trait LowerExp 
LowerHex			pub trait LowerHex 
LowerHex			struct LowerHex;
Lowercase			    pub fn Lowercase(c: char) -> bool 
Managed			    pub struct Managed;
Map			pub struct Map<'a, A, B, T> 
MatchIndices			pub struct MatchIndices<'a> 
MinMaxResult			pub enum MinMaxResult<T> 
Mul			        impl Mul<
Mul			pub trait Mul<RHS,Result> 
MultiplicativeIterator			pub trait MultiplicativeIterator<A> 
MutChunks			pub struct MutChunks<'a, T> 
MutItems			pub struct MutItems<'a, T> 
MutSplits			pub struct MutSplits<'a, T> 
MutableByteVector			    pub trait MutableByteVector 
MutableCloneableVector			pub trait MutableCloneableVector<T> 
MutableDoubleEndedIterator			pub trait MutableDoubleEndedIterator 
MutableVector			pub trait MutableVector<'a, T> 
NaiveSearcher			impl NaiveSearcher 
NaiveSearcher			struct NaiveSearcher 
Nd			    pub fn Nd(c: char) -> bool 
Neg			        impl Neg<
Neg			pub trait Neg<Result> 
Nl			    pub fn Nl(c: char) -> bool 
No			    pub fn No(c: char) -> bool 
NoCopy			    pub struct NoCopy;
NoSend			    pub struct NoSend;
NoShare			    pub struct NoShare;
Not			        impl Not<
Not			pub trait Not<Result> 
Num			pub trait Num: PartialEq + Zero + One
NumCast			        impl NumCast for 
NumCast			pub trait NumCast: ToPrimitive 
Octal			pub trait Octal 
Octal			struct Octal;
One			        impl One for 
One			pub trait One: Mul<Self, Self> 
Opaque			pub enum Opaque { }
Option			pub enum Option<T> 
Ord			            impl Ord for 
Ord			    impl Ord for () 
Ord			    impl Ord for bool 
Ord			impl Ord for Ordering 
Ord			pub trait Ord: Eq + PartialOrd 
OrdIterator			pub trait OrdIterator<A> 
Ordering			pub enum Ordering 
Ordering			pub enum Ordering 
PartialEq			            impl PartialEq for 
PartialEq			    impl PartialEq for () 
PartialEq			pub trait PartialEq 
PartialOrd			            impl PartialOrd for 
PartialOrd			    impl PartialOrd for () 
PartialOrd			    impl PartialOrd for bool 
PartialOrd			impl PartialOrd for Ordering 
PartialOrd			pub trait PartialOrd: PartialEq 
Peekable			pub struct Peekable<A, T> 
Piece			pub enum Piece<'a> 
Pointer			pub trait Pointer 
Position			pub enum Position 
Primitive			pub trait Primitive: Copy
Procedure			pub struct Procedure 
Radix			impl Radix 
Radix			pub struct Radix 
RadixFmt			pub struct RadixFmt<T, R>(T, R);
RandomAccessIterator			pub trait RandomAccessIterator<A>: Iterator<A> 
Range			pub struct Range<A> 
RangeInclusive			pub struct RangeInclusive<A> 
RangeStep			pub struct RangeStep<A> 
RangeStepInclusive			pub struct RangeStepInclusive<A> 
RawPtr			pub trait RawPtr<T> 
Ref			pub struct Ref<'b, T> 
RefCell			pub struct RefCell<T> 
RefMut			pub struct RefMut<'b, T> 
Rem			        impl Rem<
Rem			pub trait Rem<RHS,Result> 
Repeat			pub struct Repeat<A> 
Repr			pub trait Repr<T> 
Result			pub enum Result<T, E> 
Rev			pub struct Rev<T> 
Saturating			pub trait Saturating 
Scan			pub struct Scan<'a, A, B, T, St> 
Searcher			enum Searcher 
Searcher			impl Searcher 
Send			pub trait Send 
Share			pub trait Share 
Shl			        impl Shl<
Shl			pub trait Shl<RHS,Result> 
Show			impl Show for () 
Show			pub trait Show 
Shr			        impl Shr<
Shr			pub trait Shr<RHS,Result> 
SignFormat			pub enum SignFormat 
Signed			pub trait Signed 
Signed			        impl Signed for 
Signed			pub trait Signed: Num + Neg<Self> 
SignificantDigits			pub enum SignificantDigits 
Sized			pub trait Sized 
Skip			pub struct Skip<T> 
SkipWhile			pub struct SkipWhile<'a, A, T> 
Slice			pub struct Slice<T> 
Splits			pub struct Splits<'a, T> 
SplitsN			pub struct SplitsN<'a, T> 
Str			pub trait Str 
StrSlice			pub trait StrSlice<'a> 
StrSplits			pub struct StrSplits<'a> 
String			pub trait String 
Sub			        impl Sub<
Sub			pub trait Sub<RHS,Result> 
Take			pub struct Take<T> 
TakeWhile			pub struct TakeWhile<'a, A, T> 
ToPrimitive			        impl ToPrimitive for 
ToPrimitive			pub trait ToPrimitive 
TraitObject			pub struct TraitObject 
TwoWaySearcher			impl TwoWaySearcher 
TwoWaySearcher			struct TwoWaySearcher 
TyDesc			pub struct TyDesc 
TyVisitor			pub trait TyVisitor 
TypeId			impl TypeId 
TypeId			pub struct TypeId 
Unfold			pub struct Unfold<'a, A, St> 
Unsafe			pub struct Unsafe<T> 
Unsigned			pub trait Unsigned 
Unsigned			pub trait Unsigned: Num {}
UpperExp			    impl UpperExp for 
UpperExp			pub trait UpperExp 
UpperHex			pub trait UpperHex 
UpperHex			pub struct UpperHex;
Uppercase			    pub fn Uppercase(c: char) -> bool 
Utf16CodeUnits			pub struct Utf16CodeUnits<'a> 
Utf16Item			impl Utf16Item 
Utf16Item			pub enum Utf16Item 
Utf16Items			pub struct Utf16Items<'a> 
Vector			pub trait Vector<T> 
Void			pub enum Void { }
White_Space			    pub fn White_Space(c: char) -> bool 
Windows			pub struct Windows<'a, T> 
XID_Continue			    pub fn XID_Continue(c: char) -> bool 
XID_Start			    pub fn XID_Start(c: char) -> bool 
Zero			        impl Zero for 
Zero			pub trait Zero: Add<Self, Self> 
Zip			pub struct Zip<T, U> 
abort			    pub fn abort() -> !;
abs			            fn abs(&self) -> 
abs			    fn abs(&self) -> Self;
abs			pub fn abs<T: Signed>(value: T) -> T 
abs_sub			            fn abs_sub(&self, other: &
abs_sub			    fn abs_sub(&self, other: &Self) -> Self;
abs_sub			pub fn abs_sub<T: Signed>(x: T, y: T) -> T 
add			            fn add(&self, other: &
add			    fn add(&self, rhs: &RHS) -> Result;
advance			    fn advance(&mut self, f: |A| -> bool) -> bool 
align_of			pub fn align_of<T>() -> uint 
align_of_val			pub fn align_of_val<T>(_val: &T) -> uint 
all			    fn all(&mut self, f: |A| -> bool) -> bool 
alloc			unsafe fn alloc(cap: uint) -> *mut Vec<()> 
and			    pub fn and<U>(self, optb: Option<U>) -> Option<U> 
and			    pub fn and<U>(self, res: Result<U, E>) -> Result<U, E> 
and_then			    pub fn and_then<U>(self, f: |T| -> Option<U>) -> Option<U> 
and_then			    pub fn and_then<U>(self, op: |T| -> Result<U, E>) -> Result<U, E> 
any			    fn any(&mut self, f: |A| -> bool) -> bool 
any			pub mod any;
argument			pub fn argument<'a, T>(f: extern "Rust" fn(&T, &mut Formatter) -> Result,
argumentstr			pub fn argumentstr<'a>(s: &'a &str) -> Argument<'a> 
argumentuint			pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> 
array_each			pub unsafe fn array_each<T>(arr: *const  *const T, cb: |*const T|) 
array_each_with_len			pub unsafe fn array_each_with_len<T>(arr: *const *const T, len: uint,
as_bytes			    fn as_bytes(&self) -> &'a [u8] 
as_bytes			    fn as_bytes(&self) -> &'a [u8];
as_mut			    fn as_mut<T: 'static>(self) -> Option<&'a mut T> 
as_mut			    fn as_mut<T: 'static>(self) -> Option<&'a mut T>;
as_mut			    pub fn as_mut<'r>(&'r mut self) -> Option<&'r mut T> 
as_mut			    pub fn as_mut<'r>(&'r mut self) -> Result<&'r mut T, &'r mut E> 
as_mut_ptr			    fn as_mut_ptr(self) -> *mut T 
as_mut_ptr			    fn as_mut_ptr(self) -> *mut T;
as_mut_slice			    pub fn as_mut_slice<'r>(&'r mut self) -> &'r mut [T] 
as_mut_slice			    fn as_mut_slice(self) -> &'a mut [T] { self }
as_mut_slice			    fn as_mut_slice(self) -> &'a mut [T];
as_ptr			    fn as_ptr(&self) -> *const T 
as_ptr			    fn as_ptr(&self) -> *const T;
as_ptr			    fn as_ptr(&self) -> *const u8 
as_ptr			    fn as_ptr(&self) -> *const u8;
as_ref			    fn as_ref<T: 'static>(self) -> Option<&'a T> 
as_ref			    fn as_ref<T: 'static>(self) -> Option<&'a T>;
as_ref			    pub fn as_ref<'r>(&'r self) -> Option<&'r T> 
as_ref			    pub fn as_ref<'r>(&'r self) -> Result<&'r T, &'r E> 
as_slice			    pub fn as_slice<'r>(&'r self) -> &'r [T] 
as_slice			    fn as_slice<'a>(&'a self) -> &'a [T] { *self }
as_slice			    fn as_slice<'a>(&'a self) -> &'a [T];
as_slice			    fn as_slice<'a>(&'a self) -> &'a str { *self }
as_slice			    fn as_slice<'a>(&'a self) -> &'a str;
assert_receiver_is_total_eq			    fn assert_receiver_is_total_eq(&self) {}
atomic_add			unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T 
atomic_and			unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T 
atomic_and			    pub fn atomic_and<T>(dst: *mut T, src: T) -> T;
atomic_and_acq			    pub fn atomic_and_acq<T>(dst: *mut T, src: T) -> T;
atomic_and_acqrel			    pub fn atomic_and_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_and_rel			    pub fn atomic_and_rel<T>(dst: *mut T, src: T) -> T;
atomic_and_relaxed			    pub fn atomic_and_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_compare_and_swap			unsafe fn atomic_compare_and_swap<T>(dst: *mut T, old:T, new:T, order: Ordering) -> T 
atomic_cxchg			    pub fn atomic_cxchg<T>(dst: *mut T, old: T, src: T) -> T;
atomic_cxchg_acq			    pub fn atomic_cxchg_acq<T>(dst: *mut T, old: T, src: T) -> T;
atomic_cxchg_acqrel			    pub fn atomic_cxchg_acqrel<T>(dst: *mut T, old: T, src: T) -> T;
atomic_cxchg_rel			    pub fn atomic_cxchg_rel<T>(dst: *mut T, old: T, src: T) -> T;
atomic_cxchg_relaxed			    pub fn atomic_cxchg_relaxed<T>(dst: *mut T, old: T, src: T) -> T;
atomic_fence			    pub fn atomic_fence();
atomic_fence_acq			    pub fn atomic_fence_acq();
atomic_fence_acqrel			    pub fn atomic_fence_acqrel();
atomic_fence_rel			    pub fn atomic_fence_rel();
atomic_load			unsafe fn atomic_load<T>(dst: *const T, order:Ordering) -> T 
atomic_load			    pub fn atomic_load<T>(src: *const T) -> T;
atomic_load_acq			    pub fn atomic_load_acq<T>(src: *const T) -> T;
atomic_load_relaxed			    pub fn atomic_load_relaxed<T>(src: *const T) -> T;
atomic_max			    pub fn atomic_max<T>(dst: *mut T, src: T) -> T;
atomic_max_acq			    pub fn atomic_max_acq<T>(dst: *mut T, src: T) -> T;
atomic_max_acqrel			    pub fn atomic_max_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_max_rel			    pub fn atomic_max_rel<T>(dst: *mut T, src: T) -> T;
atomic_max_relaxed			    pub fn atomic_max_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_min			    pub fn atomic_min<T>(dst: *mut T, src: T) -> T;
atomic_min_acq			    pub fn atomic_min_acq<T>(dst: *mut T, src: T) -> T;
atomic_min_acqrel			    pub fn atomic_min_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_min_rel			    pub fn atomic_min_rel<T>(dst: *mut T, src: T) -> T;
atomic_min_relaxed			    pub fn atomic_min_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_nand			unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T 
atomic_nand			    pub fn atomic_nand<T>(dst: *mut T, src: T) -> T;
atomic_nand_acq			    pub fn atomic_nand_acq<T>(dst: *mut T, src: T) -> T;
atomic_nand_acqrel			    pub fn atomic_nand_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_nand_rel			    pub fn atomic_nand_rel<T>(dst: *mut T, src: T) -> T;
atomic_nand_relaxed			    pub fn atomic_nand_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_or			unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T 
atomic_or			    pub fn atomic_or<T>(dst: *mut T, src: T) -> T;
atomic_or_acq			    pub fn atomic_or_acq<T>(dst: *mut T, src: T) -> T;
atomic_or_acqrel			    pub fn atomic_or_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_or_rel			    pub fn atomic_or_rel<T>(dst: *mut T, src: T) -> T;
atomic_or_relaxed			    pub fn atomic_or_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_store			unsafe fn atomic_store<T>(dst: *mut T, val: T, order:Ordering) 
atomic_store			    pub fn atomic_store<T>(dst: *mut T, val: T);
atomic_store_rel			    pub fn atomic_store_rel<T>(dst: *mut T, val: T);
atomic_store_relaxed			    pub fn atomic_store_relaxed<T>(dst: *mut T, val: T);
atomic_sub			unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T 
atomic_swap			unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T 
atomic_umax			    pub fn atomic_umax<T>(dst: *mut T, src: T) -> T;
atomic_umax_acq			    pub fn atomic_umax_acq<T>(dst: *mut T, src: T) -> T;
atomic_umax_acqrel			    pub fn atomic_umax_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_umax_rel			    pub fn atomic_umax_rel<T>(dst: *mut T, src: T) -> T;
atomic_umax_relaxed			    pub fn atomic_umax_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_umin			    pub fn atomic_umin<T>(dst: *mut T, src: T) -> T;
atomic_umin_acq			    pub fn atomic_umin_acq<T>(dst: *mut T, src: T) -> T;
atomic_umin_acqrel			    pub fn atomic_umin_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_umin_rel			    pub fn atomic_umin_rel<T>(dst: *mut T, src: T) -> T;
atomic_umin_relaxed			    pub fn atomic_umin_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_xadd			    pub fn atomic_xadd<T>(dst: *mut T, src: T) -> T;
atomic_xadd_acq			    pub fn atomic_xadd_acq<T>(dst: *mut T, src: T) -> T;
atomic_xadd_acqrel			    pub fn atomic_xadd_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_xadd_rel			    pub fn atomic_xadd_rel<T>(dst: *mut T, src: T) -> T;
atomic_xadd_relaxed			    pub fn atomic_xadd_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_xchg			    pub fn atomic_xchg<T>(dst: *mut T, src: T) -> T;
atomic_xchg_acq			    pub fn atomic_xchg_acq<T>(dst: *mut T, src: T) -> T;
atomic_xchg_acqrel			    pub fn atomic_xchg_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_xchg_rel			    pub fn atomic_xchg_rel<T>(dst: *mut T, src: T) -> T;
atomic_xchg_relaxed			    pub fn atomic_xchg_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_xor			unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T 
atomic_xor			    pub fn atomic_xor<T>(dst: *mut T, src: T) -> T;
atomic_xor_acq			    pub fn atomic_xor_acq<T>(dst: *mut T, src: T) -> T;
atomic_xor_acqrel			    pub fn atomic_xor_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_xor_rel			    pub fn atomic_xor_rel<T>(dst: *mut T, src: T) -> T;
atomic_xor_relaxed			    pub fn atomic_xor_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_xsub			    pub fn atomic_xsub<T>(dst: *mut T, src: T) -> T;
atomic_xsub_acq			    pub fn atomic_xsub_acq<T>(dst: *mut T, src: T) -> T;
atomic_xsub_acqrel			    pub fn atomic_xsub_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_xsub_rel			    pub fn atomic_xsub_rel<T>(dst: *mut T, src: T) -> T;
atomic_xsub_relaxed			    pub fn atomic_xsub_relaxed<T>(dst: *mut T, src: T) -> T;
atomics			pub mod atomics;
base			            fn base(&self) -> u8 { 
base			    fn base(&self) -> u8 { self.base }
base			    fn base(&self) -> u8;
begin_unwind			        fn begin_unwind(fmt: &fmt::Arguments, file: &'static str,
begin_unwind			pub fn begin_unwind(fmt: &fmt::Arguments, file: &'static str, line: uint) -> ! 
bitand			            fn bitand(&self, rhs: &
bitand			    fn bitand(&self, rhs: &RHS) -> Result;
bitor			            fn bitor(&self, rhs: &
bitor			    fn bitor(&self, rhs: &RHS) -> Result;
bitxor			            fn bitxor(&self, other: &
bitxor			    fn bitxor(&self, rhs: &RHS) -> Result;
bool			pub mod bool;
borrow			    pub fn borrow<'a>(&'a self) -> Ref<'a, T> 
borrow_mut			    pub fn borrow_mut<'a>(&'a self) -> RefMut<'a, T> 
breakpoint			    pub fn breakpoint();
bsearch			    fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint> 
bsearch			    fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint>;
bsearch_case_table			    fn bsearch_case_table(c: char, table: &'static [(char, char)]) -> Option<uint> 
bsearch_elem			    fn bsearch_elem(&self, x: &T) -> Option<uint> 
bsearch_elem			    fn bsearch_elem(&self, x: &T) -> Option<uint>;
bsearch_range_table			fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool 
bsearch_table			    fn bsearch_table(c: char, r: &'static [(char, &'static [char])]) -> Option<&'static [char]> 
bswap16			    pub fn bswap16(x: u16) -> u16;
bswap32			    pub fn bswap32(x: u32) -> u32;
bswap64			    pub fn bswap64(x: u64) -> u64;
bswap8			unsafe fn bswap8(x: u8) -> u8 { x }
buf_as_slice			    pub unsafe fn buf_as_slice<T,U>(p: *const T, len: uint, f: |v: &[T]| -> U)
buf_len			pub unsafe fn buf_len<T>(buf: *const *const T) -> uint 
by_ref			    fn by_ref<'r>(&'r mut self) -> ByRef<'r, Self> 
bytes			pub mod bytes 
bytes			    fn bytes(&self) -> Bytes<'a> 
bytes			    fn bytes(&self) -> Bytes<'a>;
c_str_to_static_slice			    pub unsafe fn c_str_to_static_slice(s: *const i8) -> &'static str 
call			    fn call(&self, args: Args) -> Result;
call_mut			    fn call_mut(&mut self, args: Args) -> Result;
call_once			    fn call_once(self, args: Args) -> Result;
cast			pub fn cast<T: NumCast,U: NumCast>(n: T) -> Option<U> 
ceil			    fn ceil(self) -> f32 
ceil			    fn ceil(self) -> f64 
ceil			    fn ceil(self) -> Self;
ceilf32			    pub fn ceilf32(x: f32) -> f32;
ceilf64			    pub fn ceilf64(x: f64) -> f64;
cell			pub mod cell;
chain			    fn chain<U: Iterator<A>>(self, other: U) -> Chain<Self, U> 
char			pub mod char;
char_at			    fn char_at(&self, i: uint) -> char 
char_at			    fn char_at(&self, i: uint) -> char;
char_at_reverse			    fn char_at_reverse(&self, i: uint) -> char 
char_at_reverse			    fn char_at_reverse(&self, i: uint) -> char;
char_indices			    fn char_indices(&self) -> CharOffsets<'a> 
char_indices			    fn char_indices(&self) -> CharOffsets<'a>;
char_len			    fn char_len(&self) -> uint { self.chars().count() }
char_len			    fn char_len(&self) -> uint;
char_range_at			    fn char_range_at(&self, i: uint) -> CharRange 
char_range_at			    fn char_range_at(&self, start: uint) -> CharRange;
char_range_at_reverse			    fn char_range_at_reverse(&self, start: uint) -> CharRange 
char_range_at_reverse			    fn char_range_at_reverse(&self, start: uint) -> CharRange;
chars			    fn chars(&self) -> Chars<'a> 
chars			    fn chars(&self) -> Chars<'a>;
checked_add			    fn checked_add(&self, v: &Self) -> Option<Self>;
checked_div			            fn checked_div(&self, v: &
checked_div			    fn checked_div(&self, v: &Self) -> Option<Self>;
checked_mul			    fn checked_mul(&self, v: &Self) -> Option<Self>;
checked_next_power_of_two			pub fn checked_next_power_of_two<T: Unsigned + Int>(n: T) -> Option<T> 
checked_sub			    fn checked_sub(&self, v: &Self) -> Option<Self>;
chunks			    fn chunks(self, size: uint) -> Chunks<'a, T> 
chunks			    fn chunks(self, size: uint) -> Chunks<'a, T>;
classify			    fn classify(self) -> FPCategory 
classify			    fn classify(self) -> FPCategory 
classify			    fn classify(self) -> FPCategory;
clone			    fn clone(&self) -> Cell<T> 
clone			    fn clone(&self) -> RefCell<T> 
clone			            fn clone(&self) -> 
clone			            fn clone(&self) -> extern "Rust" fn(
clone			    fn clone(&self) -> &'a T { *self }
clone			    fn clone(&self) -> &'a [T] { *self }
clone			    fn clone(&self) -> &'a str { *self }
clone			    fn clone(&self) -> Self;
clone			pub mod clone;
clone			    fn clone(&self) -> *const T 
clone			    fn clone(&self) -> *mut T 
clone			    fn clone(&self) -> ~[A] 
clone			    fn clone(&self) -> Items<'a, T> { *self }
clone			                fn clone(&self) -> (
clone_from			    fn clone_from(&mut self, source: &Self) 
clone_ref			pub fn clone_ref<'b, T>(orig: &Ref<'b, T>) -> Ref<'b, T> 
cmp			                fn cmp(&self, other: &
cmp			        fn cmp(&self, _other: &()) -> Ordering { Equal }
cmp			        fn cmp(&self, other: & &'a T) -> Ordering { (**self).cmp(*other) }
cmp			        fn cmp(&self, other: &&'a mut T) -> Ordering { (**self).cmp(*other) }
cmp			        fn cmp(&self, other: &bool) -> Ordering 
cmp			    fn cmp(&self, other: &Ordering) -> Ordering 
cmp			    fn cmp(&self, other: &Self) -> Ordering;
cmp			    pub fn cmp<A: Ord, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> cmp::Ordering 
cmp			pub mod cmp;
cmp			    fn cmp(&self, other: & &'a [T]) -> Ordering 
cmp			        fn cmp(&self, other: & &'a str) -> Ordering 
cmp			                fn cmp(&self, other: &(
collect			    fn collect<B: FromIterator<A>>(&mut self) -> B 
collect			pub fn collect<T, Iter: Iterator<Option<T>>, V: FromIterator<T>>(iter: Iter) -> Option<V> 
collect			pub fn collect<T, E, Iter: Iterator<Result<T, E>>, V: FromIterator<T>>(iter: Iter) -> Result<V, E> 
collections			pub mod collections;
compare_and_swap			    pub fn compare_and_swap(&self, old: *mut T, new: *mut T, order: Ordering) -> *mut T 
compare_and_swap			    pub fn compare_and_swap(&self, old: bool, new: bool, order: Ordering) -> bool 
compare_and_swap			    pub fn compare_and_swap(&self, old: int, new: int, order: Ordering) -> int 
compare_and_swap			    pub fn compare_and_swap(&self, old: uint, new: uint, order: Ordering) -> uint 
consts			pub mod consts 
consts			pub mod consts 
contains			    fn contains(&self, x: &T) -> bool 
contains			    fn contains(&self, x: &T) -> bool;
contains			    fn contains<'a>(&self, needle: &'a str) -> bool 
contains			    fn contains<'a>(&self, needle: &'a str) -> bool;
contains_char			    fn contains_char(&self, needle: char) -> bool 
contains_char			    fn contains_char(&self, needle: char) -> bool;
conversions			pub mod conversions 
copy_from			    fn copy_from(self, &[T]) -> uint;
copy_from			    fn copy_from(self, src: &[T]) -> uint 
copy_lifetime			pub unsafe fn copy_lifetime<'a, S, T>(_ptr: &'a S, ptr: &T) -> &'a T 
copy_memory			    pub fn copy_memory<T>(dst: *mut T, src: *const T, count: uint);
copy_memory			pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) 
copy_memory			    pub fn copy_memory(dst: &mut [u8], src: &[u8]) 
copy_memory			    unsafe fn copy_memory(self, src: &[T]) 
copy_memory			    unsafe fn copy_memory(self, src: &[T]);
copy_mut_lifetime			pub unsafe fn copy_mut_lifetime<'a, S, T>(_ptr: &'a mut S,
copy_nonoverlapping_memory			    pub fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint);
copy_nonoverlapping_memory			pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T,
copysignf32			    pub fn copysignf32(x: f32, y: f32) -> f32;
copysignf64			    pub fn copysignf64(x: f64, y: f64) -> f64;
core			mod core 
cosf32			    pub fn cosf32(x: f32) -> f32;
cosf64			    pub fn cosf64(x: f64) -> f64;
count			    fn count(&mut self) -> uint 
count			pub fn count<A>(start: A, step: A) -> Counter<A> 
count_ones			            fn count_ones(self) -> 
count_ones			            fn count_ones(self) -> 
count_ones			    fn count_ones(self) -> Self;
count_zeros			    fn count_zeros(self) -> Self 
ctlz16			    pub fn ctlz16(x: u16) -> u16;
ctlz32			    pub fn ctlz32(x: u32) -> u32;
ctlz64			    pub fn ctlz64(x: u64) -> u64;
ctlz8			    pub fn ctlz8(x: u8) -> u8;
ctpop16			    pub fn ctpop16(x: u16) -> u16;
ctpop32			    pub fn ctpop32(x: u32) -> u32;
ctpop64			    pub fn ctpop64(x: u64) -> u64;
ctpop8			    pub fn ctpop8(x: u8) -> u8;
cttz16			    pub fn cttz16(x: u16) -> u16;
cttz32			    pub fn cttz32(x: u32) -> u32;
cttz64			    pub fn cttz64(x: u64) -> u64;
cttz8			    pub fn cttz8(x: u8) -> u8;
cycle			    fn cycle(self) -> Cycle<Self>;
cycle			    fn cycle(self) -> Cycle<T> 
d			    fn d(c: char, i: |char|, k: bool) 
decompose_canonical			    pub fn decompose_canonical(c: char, i: |char|) { d(c, i, false); }
decompose_compatible			    pub fn decompose_compatible(c: char, i: |char|) { d(c, i, true); }
decompose_hangul			    fn decompose_hangul(s: char, f: |char|) 
default			            fn default() -> 
default			    fn default() -> Self;
default			pub mod default;
default			    fn default() -> Option<T> { None }
default			    fn default() -> &'a [T] { &[] }
default			    fn default() -> &'a str { "" }
default			                fn default() -> (
defined			trait defined in this module. For loops can be viewed as a syntactical expansion
deref			    fn deref<'a>(&'a self) -> &'a T 
deref			    fn deref<'a>(&'a self) -> &'a Result;
deref_mut			    fn deref_mut<'a>(&'a mut self) -> &'a mut T 
deref_mut			    fn deref_mut<'a>(&'a mut self) -> &'a mut Result;
derived_property			pub mod derived_property 
digit			            fn digit(&self, x: u8) -> u8 
digit			    fn digit(&self, x: u8) -> u8 
digit			    fn digit(&self, x: u8) -> u8;
digits			    fn digits(_: Option<f32>) -> uint { DIGITS }
digits			    fn digits(_: Option<f64>) -> uint { DIGITS }
digits			    fn digits(unused_self: Option<Self>) -> uint;
div			            fn div(&self, other: &
div			    fn div(&self, rhs: &RHS) -> Result;
div_rem			pub fn div_rem<T: Div<T, T> + Rem<T, T>>(x: T, y: T) -> (T, T) 
do_inspect			    fn do_inspect(&mut self, elt: Option<A>) -> Option<A> 
do_map			    fn do_map(&mut self, elt: Option<A>) -> Option<B> 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			pub fn drop<T>(_x: T) { }
drop			    fn drop(&mut self);
e			    fn e() -> f32 { consts::E }
e			    fn e() -> f64 { consts::E }
e			    fn e() -> Self;
encode_utf16			    fn encode_utf16(&self, dst: &mut [u16]) -> uint 
encode_utf16			    fn encode_utf16(&self, dst: &mut [u16]) -> uint;
encode_utf8			    fn encode_utf8(&self, dst: &mut [u8]) -> uint;
encode_utf8			    fn encode_utf8<'a>(&self, dst: &'a mut [u8]) -> uint 
ends_with			    fn ends_with(&self, needle: &[T]) -> bool 
ends_with			    fn ends_with(&self, needle: &[T]) -> bool;
ends_with			    fn ends_with(&self, needle: &str) -> bool 
ends_with			    fn ends_with(&self, needle: &str) -> bool;
enumerate			    fn enumerate(self) -> Enumerate<Self> 
epsilon			    fn epsilon() -> f32 { EPSILON }
epsilon			    fn epsilon() -> f64 { EPSILON }
epsilon			    fn epsilon() -> Self;
eq			    fn eq(&self, other: &Cell<T>) -> bool 
eq			    fn eq(&self, other: &RefCell<T>) -> bool 
eq			                fn eq(&self, other: &
eq			        fn eq(&self, _other: &()) -> bool { true }
eq			        fn eq(&self, other: & &'a T) -> bool { *(*self) == *(*other) }
eq			        fn eq(&self, other: &&'a mut T) -> bool { **self == *(*other) }
eq			    fn eq(&self, other: &Self) -> bool;
eq			    pub fn eq<A: PartialEq, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool 
eq			                fn eq(&self, other: &extern "C" fn(
eq			        fn eq(&self, other: &extern "C" fn() -> _R) -> bool 
eq			    fn eq(&self, other: &*const T) -> bool 
eq			    fn eq(&self, other: &*mut T) -> bool 
eq			    fn eq(&self, other: & &'a [T]) -> bool 
eq			        fn eq(&self, other: & &'a str) -> bool 
eq			                fn eq(&self, other: &(
eq_slice			pub fn eq_slice(a: &str, b: &str) -> bool 
eq_slice_			fn eq_slice_(a: &str, b: &str) -> bool 
equals			    pub fn equals<A: Eq, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool 
equiv			    fn equiv(&self, other: &T) -> bool;
equiv			    fn equiv(&self, other: &*const T) -> bool 
equiv			    fn equiv(&self, other: &*mut T) -> bool 
equiv			    fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }
equiv			        fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }
err			    pub fn err(self) -> Option<E> 
escape_default			    fn escape_default(&self, f: |char|) { escape_default(*self, f) }
escape_default			    fn escape_default(&self, f: |char|);
escape_default			pub fn escape_default(c: char, f: |char|) 
escape_unicode			    fn escape_unicode(&self, f: |char|) { escape_unicode(*self, f) }
escape_unicode			    fn escape_unicode(&self, f: |char|);
escape_unicode			pub fn escape_unicode(c: char, f: |char|) 
exp			    fn exp(self) -> f32 
exp			    fn exp(self) -> f64 
exp			    fn exp(self) -> Self;
exp2			    fn exp2(self) -> f32 
exp2			    fn exp2(self) -> f64 
exp2			    fn exp2(self) -> Self;
exp2f32			    pub fn exp2f32(x: f32) -> f32;
exp2f64			    pub fn exp2f64(x: f64) -> f64;
expect			    pub fn expect(self, msg: &str) -> T 
expf32			    pub fn expf32(x: f32) -> f32;
expf64			    pub fn expf64(x: f64) -> f64;
extend			    fn extend<T: Iterator<A>>(&mut self, iterator: T);
externfnpointers			mod externfnpointers 
f32x4			pub struct f32x4(pub f32, pub f32, pub f32, pub f32);
f64x2			pub struct f64x2(pub f64, pub f64);
fabsf32			    pub fn fabsf32(x: f32) -> f32;
fabsf64			    pub fn fabsf64(x: f64) -> f64;
fail_			fn fail_(expr: &'static str, file: &'static str, line: uint) -> ! 
fail_bounds_check			fn fail_bounds_check(file: &'static str, line: uint,
failure			pub mod failure;
fence			pub fn fence(order: Ordering) 
fetch_add			    pub fn fetch_add(&self, val: int, order: Ordering) -> int 
fetch_add			    pub fn fetch_add(&self, val: uint, order: Ordering) -> uint 
fetch_and			    pub fn fetch_and(&self, val: bool, order: Ordering) -> bool 
fetch_and			    pub fn fetch_and(&self, val: int, order: Ordering) -> int 
fetch_and			    pub fn fetch_and(&self, val: uint, order: Ordering) -> uint 
fetch_nand			    pub fn fetch_nand(&self, val: bool, order: Ordering) -> bool 
fetch_or			    pub fn fetch_or(&self, val: bool, order: Ordering) -> bool 
fetch_or			    pub fn fetch_or(&self, val: int, order: Ordering) -> int 
fetch_or			    pub fn fetch_or(&self, val: uint, order: Ordering) -> uint 
fetch_sub			    pub fn fetch_sub(&self, val: int, order: Ordering) -> int 
fetch_sub			    pub fn fetch_sub(&self, val: uint, order: Ordering) -> uint 
fetch_xor			    pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool 
fetch_xor			    pub fn fetch_xor(&self, val: int, order: Ordering) -> int 
fetch_xor			    pub fn fetch_xor(&self, val: uint, order: Ordering) -> uint 
filter			    fn filter<'r>(self, predicate: |&A|: 'r -> bool) -> Filter<'r, A, Self> 
filter_map			    fn filter_map<'r, B>(self, f: |A|: 'r -> Option<B>) -> FilterMap<'r, A, B, Self> 
filtered			    pub fn filtered(self, f: |t: &T| -> bool) -> Option<T> 
finally			    fn finally(&mut self, dtor: ||) -> T 
finally			    fn finally(&mut self, dtor: ||) -> T;
finally			pub mod finally;
find			    fn find(&mut self, predicate: |&A| -> bool) -> Option<A> 
find			    fn find<C: CharEq>(&self, mut search: C) -> Option<uint> 
find			    fn find<C: CharEq>(&self, search: C) -> Option<uint>;
find_str			    fn find_str(&self, &str) -> Option<uint>;
find_str			    fn find_str(&self, needle: &str) -> Option<uint> 
flat_map			    fn flat_map<'r, B, U: Iterator<B>>(self, f: |A|: 'r -> U)
float			mod float;
float_to_str_bytes_common			pub fn float_to_str_bytes_common<T: Primitive + Float, U>(
floor			    fn floor(self) -> f32 
floor			    fn floor(self) -> f64 
floor			    fn floor(self) -> Self;
floorf32			    pub fn floorf32(x: f32) -> f32;
floorf64			    pub fn floorf64(x: f64) -> f64;
fmaf32			    pub fn fmaf32(a: f32, b: f32, c: f32) -> f32;
fmaf64			    pub fn fmaf64(a: f64, b: f64, c: f64) -> f64;
fmt			            fn fmt(&self, f: &mut Formatter) -> Result 
fmt			        fn fmt(&self, f: &mut Formatter) -> Result 
fmt			        fn fmt(&self, fmt: &mut Formatter) -> Result 
fmt			    fn fmt(&self, &mut Formatter) -> Result;
fmt			    fn fmt(&self, f: &mut Formatter) -> Result { (*self).fmt(f) }
fmt			    fn fmt(&self, f: &mut Formatter) -> Result { f.pad("&Any") }
fmt			    fn fmt(&self, f: &mut Formatter) -> Result { secret_pointer(self, f) }
fmt			    fn fmt(&self, f: &mut Formatter) -> Result { secret_show(&**self, f) }
fmt			    fn fmt(&self, f: &mut Formatter) -> Result { secret_show(*self, f) }
fmt			    fn fmt(&self, f: &mut Formatter) -> Result 
fmt			    fn fmt(&self, fmt: &mut Formatter) -> Result 
fmt			            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			        impl fmt::
fmt			        impl fmt::Show for RadixFmt<
fmt			pub mod fmt;
fmt_int			    fn fmt_int<T: Int>(&self, mut x: T, f: &mut fmt::Formatter) -> fmt::Result 
fold			    fn fold<B>(&mut self, init: B, f: |B, A| -> B) -> B 
fold			pub fn fold<T,
fold_			pub fn fold_<T,E,Iter:Iterator<Result<T,E>>>(iterator: Iter) -> Result<(),E> 
forget			    pub fn forget<T>(_: T) -> ();
forget			pub unsafe fn forget<T>(thing: T) { intrinsics::forget(thing) }
frac_1_pi			    fn frac_1_pi() -> f32 { consts::FRAC_1_PI }
frac_1_pi			    fn frac_1_pi() -> f64 { consts::FRAC_1_PI }
frac_1_pi			    fn frac_1_pi() -> Self;
frac_1_sqrt2			    fn frac_1_sqrt2() -> f32 { consts::FRAC_1_SQRT2 }
frac_1_sqrt2			    fn frac_1_sqrt2() -> f64 { consts::FRAC_1_SQRT2 }
frac_1_sqrt2			    fn frac_1_sqrt2() -> Self;
frac_2_pi			    fn frac_2_pi() -> f32 { consts::FRAC_2_PI }
frac_2_pi			    fn frac_2_pi() -> f64 { consts::FRAC_2_PI }
frac_2_pi			    fn frac_2_pi() -> Self;
frac_2_sqrtpi			    fn frac_2_sqrtpi() -> f32 { consts::FRAC_2_SQRTPI }
frac_2_sqrtpi			    fn frac_2_sqrtpi() -> f64 { consts::FRAC_2_SQRTPI }
frac_2_sqrtpi			    fn frac_2_sqrtpi() -> Self;
frac_pi_2			    fn frac_pi_2() -> f32 { consts::FRAC_PI_2 }
frac_pi_2			    fn frac_pi_2() -> f64 { consts::FRAC_PI_2 }
frac_pi_2			    fn frac_pi_2() -> Self;
frac_pi_3			    fn frac_pi_3() -> f32 { consts::FRAC_PI_3 }
frac_pi_3			    fn frac_pi_3() -> f64 { consts::FRAC_PI_3 }
frac_pi_3			    fn frac_pi_3() -> Self;
frac_pi_4			    fn frac_pi_4() -> f32 { consts::FRAC_PI_4 }
frac_pi_4			    fn frac_pi_4() -> f64 { consts::FRAC_PI_4 }
frac_pi_4			    fn frac_pi_4() -> Self;
frac_pi_6			    fn frac_pi_6() -> f32 { consts::FRAC_PI_6 }
frac_pi_6			    fn frac_pi_6() -> f64 { consts::FRAC_PI_6 }
frac_pi_6			    fn frac_pi_6() -> Self;
frac_pi_8			    fn frac_pi_8() -> f32 { consts::FRAC_PI_8 }
frac_pi_8			    fn frac_pi_8() -> f64 { consts::FRAC_PI_8 }
frac_pi_8			    fn frac_pi_8() -> Self;
fract			    fn fract(self) -> f32 { self - self.trunc() }
fract			    fn fract(self) -> f64 { self - self.trunc() }
fract			    fn fract(self) -> Self;
from			            fn from<N: ToPrimitive>(n: N) -> Option<
from			    fn from<T: ToPrimitive>(n: T) -> Option<Self>;
from_be			    fn from_be(x: Self) -> Self 
from_be16			pub fn from_be16(x: u16) -> u16 { Int::from_be(x) }
from_be32			pub fn from_be32(x: u32) -> u32 { Int::from_be(x) }
from_be64			pub fn from_be64(x: u64) -> u64 { Int::from_be(x) }
from_digit			    fn from_digit(num: uint, radix: uint) -> Option<char> { from_digit(num, radix) }
from_digit			    fn from_digit(num: uint, radix: uint) -> Option<char>;
from_digit			pub fn from_digit(num: uint, radix: uint) -> Option<char> 
from_f32			    fn from_f32(n: f32) -> Option<Self> 
from_f32			pub fn from_f32<A: FromPrimitive>(n: f32) -> Option<A> 
from_f64			    fn from_f64(n: f64) -> Option<Self> 
from_f64			pub fn from_f64<A: FromPrimitive>(n: f64) -> Option<A> 
from_i16			    fn from_i16(n: i16) -> Option<Self> 
from_i16			pub fn from_i16<A: FromPrimitive>(n: i16) -> Option<A> 
from_i32			    fn from_i32(n: i32) -> Option<Self> 
from_i32			pub fn from_i32<A: FromPrimitive>(n: i32) -> Option<A> 
from_i64			    fn from_i64(n: i64) -> Option<Self>;
from_i64			pub fn from_i64<A: FromPrimitive>(n: i64) -> Option<A> 
from_i8			    fn from_i8(n: i8) -> Option<Self> 
from_i8			pub fn from_i8<A: FromPrimitive>(n: i8) -> Option<A> 
from_int			    fn from_int(n: int) -> Option<Self> 
from_int			pub fn from_int<A: FromPrimitive>(n: int) -> Option<A> 
from_iter			    fn from_iter<T: Iterator<A>>(iterator: T) -> Self;
from_le			    fn from_le(x: Self) -> Self 
from_le16			pub fn from_le16(x: u16) -> u16 { Int::from_le(x) }
from_le32			pub fn from_le32(x: u32) -> u32 { Int::from_le(x) }
from_le64			pub fn from_le64(x: u64) -> u64 { Int::from_le(x) }
from_u16			    fn from_u16(n: u16) -> Option<Self> 
from_u16			pub fn from_u16<A: FromPrimitive>(n: u16) -> Option<A> 
from_u32			pub fn from_u32(i: u32) -> Option<char> 
from_u32			    fn from_u32(n: u32) -> Option<Self> 
from_u32			pub fn from_u32<A: FromPrimitive>(n: u32) -> Option<A> 
from_u64			    fn from_u64(n: u64) -> Option<Self>;
from_u64			pub fn from_u64<A: FromPrimitive>(n: u64) -> Option<A> 
from_u8			    fn from_u8(n: u8) -> Option<Self> 
from_u8			pub fn from_u8<A: FromPrimitive>(n: u8) -> Option<A> 
from_uint			    fn from_uint(n: uint) -> Option<Self> 
from_uint			pub fn from_uint<A: FromPrimitive>(n: uint) -> Option<A> 
from_utf8			    pub unsafe fn from_utf8<'a>(v: &'a [u8]) -> &'a str 
from_utf8			pub fn from_utf8<'a>(v: &'a [u8]) -> Option<&'a str> 
fuse			    fn fuse(self) -> Fuse<Self> 
ge			                fn ge(&self, other: &
ge			        fn ge(&self, other: & &'a T) -> bool { *(*self) >= *(*other) }
ge			        fn ge(&self, other: &&'a mut T) -> bool { **self >= **other }
ge			    fn ge(&self, other: &Self) -> bool 
ge			    pub fn ge<A: PartialOrd, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool 
ge			    fn ge(&self, other: &*const T) -> bool { *self >= *other }
ge			    fn ge(&self, other: &*mut T) -> bool { *self >= *other }
ge			    fn ge(&self, other: & &'a [T]) -> bool 
ge			                fn ge(&self, other: &(
general_category			pub mod general_category 
get			    pub fn get(&self) -> T 
get			    fn get(&self, index: uint) -> Option<&'a T> 
get			    fn get(&self, index: uint) -> Option<&'a T>;
get			    pub unsafe fn get(&self) -> *mut T { &self.value as *const T as *mut T }
get_end			    fn get_end(&mut self) -> Option<&'a str> 
get_mut			    fn get_mut(self, index: uint) -> Option<&'a mut T> 
get_mut			    fn get_mut(self, index: uint) -> Option<&'a mut T>;
get_mut_ref			    pub fn get_mut_ref<'a>(&'a mut self) -> &'a mut T 
get_ref			    pub fn get_ref<'a>(&'a self) -> &'a T 
get_tydesc			    pub fn get_tydesc<T>() -> *const TyDesc;
get_type_id			    fn get_type_id(&self) -> TypeId 
get_type_id			    fn get_type_id(&self) -> TypeId;
getcount			    fn getcount(&mut self, cnt: &rt::Count) -> Option<uint> 
gt			                fn gt(&self, other: &
gt			        fn gt(&self, other: & &'a T) -> bool { *(*self) > *(*other) }
gt			        fn gt(&self, other: &&'a mut T) -> bool { **self > **other }
gt			    fn gt(&self, other: &Self) -> bool 
gt			    pub fn gt<A: PartialOrd, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool 
gt			    fn gt(&self, other: &*const T) -> bool { *self > *other }
gt			    fn gt(&self, other: &*mut T) -> bool { *self > *other }
gt			    fn gt(&self, other: & &'a [T]) -> bool 
gt			                fn gt(&self, other: &(
hash			    pub fn hash(&self) -> u64 { self.t }
head			    fn head(&self) -> Option<&'a T> 
head			    fn head(&self) -> Option<&'a T>;
i16_add_with_overflow			    pub fn i16_add_with_overflow(x: i16, y: i16) -> (i16, bool);
i16_mul_with_overflow			    pub fn i16_mul_with_overflow(x: i16, y: i16) -> (i16, bool);
i16_sub_with_overflow			    pub fn i16_sub_with_overflow(x: i16, y: i16) -> (i16, bool);
i16x8			pub struct i16x8(pub i16, pub i16, pub i16, pub i16,
i32_add_with_overflow			    pub fn i32_add_with_overflow(x: i32, y: i32) -> (i32, bool);
i32_mul_with_overflow			    pub fn i32_mul_with_overflow(x: i32, y: i32) -> (i32, bool);
i32_sub_with_overflow			    pub fn i32_sub_with_overflow(x: i32, y: i32) -> (i32, bool);
i32x4			pub struct i32x4(pub i32, pub i32, pub i32, pub i32);
i64_add_with_overflow			    pub fn i64_add_with_overflow(x: i64, y: i64) -> (i64, bool);
i64_mul_with_overflow			    pub fn i64_mul_with_overflow(x: i64, y: i64) -> (i64, bool);
i64_sub_with_overflow			    pub fn i64_sub_with_overflow(x: i64, y: i64) -> (i64, bool);
i64x2			pub struct i64x2(pub i64, pub i64);
i8_add_with_overflow			    pub fn i8_add_with_overflow(x: i8, y: i8) -> (i8, bool);
i8_mul_with_overflow			    pub fn i8_mul_with_overflow(x: i8, y: i8) -> (i8, bool);
i8_sub_with_overflow			    pub fn i8_sub_with_overflow(x: i8, y: i8) -> (i8, bool);
i8x16			pub struct i8x16(pub i8, pub i8, pub i8, pub i8,
idx			    fn idx(&mut self, _: uint) -> Option<A> { Some(self.element.clone()) }
idx			    fn idx(&mut self, index: uint) -> Option<(A, B)> 
idx			    fn idx(&mut self, index: uint) -> Option<(uint, A)> 
idx			    fn idx(&mut self, index: uint) -> Option<A> 
idx			    fn idx(&mut self, index: uint) -> Option<A>;
idx			    fn idx(&mut self, index: uint) -> Option<B> 
idx			    fn idx(&mut self, index: uint) -> Option<&'a T> 
idx			    fn idx(&mut self, index: uint) -> Option<&'a [T]> 
impls			mod impls 
index			    fn index(&self, index: &Index) -> Result;
indexable			    fn indexable(&self) -> uint { self.iter.indexable() }
indexable			    fn indexable(&self) -> uint { uint::MAX }
indexable			    fn indexable(&self) -> uint 
indexable			    fn indexable(&self) -> uint;
indexable			    fn indexable(&self) -> uint 
infinity			    fn infinity() -> f32 { INFINITY }
infinity			    fn infinity() -> f64 { INFINITY }
infinity			    fn infinity() -> Self;
init			    pub fn init<T>() -> T;
init			pub unsafe fn init<T>() -> T { zeroed() }
init			    fn init(&self) -> &'a [T] 
init			    fn init(&self) -> &'a [T];
init_elem			    unsafe fn init_elem(self, i: uint, val: T) 
init_elem			    unsafe fn init_elem(self, i: uint, val: T);
initn			    fn initn(&self, n: uint) -> &'a [T] 
initn			    fn initn(&self, n: uint) -> &'a [T];
inspect			    fn inspect<'r>(self, f: |&A|: 'r) -> Inspect<'r, A, Self> 
integer_decode			    fn integer_decode(self) -> (u64, i16, i8) 
integer_decode			    fn integer_decode(self) -> (u64, i16, i8) 
integer_decode			    fn integer_decode(self) -> (u64, i16, i8);
into_option			    pub fn into_option(self) -> Option<(T,T)> 
intrinsics			pub mod intrinsics;
is			    fn is<T: 'static>(self) -> bool 
is			    fn is<T: 'static>(self) -> bool;
is_XID_continue			    fn is_XID_continue(&self) -> bool { is_XID_continue(*self) }
is_XID_continue			    fn is_XID_continue(&self) -> bool;
is_XID_continue			pub fn is_XID_continue(c: char) -> bool { derived_property::XID_Continue(c) }
is_XID_start			    fn is_XID_start(&self) -> bool { is_XID_start(*self) }
is_XID_start			    fn is_XID_start(&self) -> bool;
is_XID_start			pub fn is_XID_start(c: char) -> bool    { derived_property::XID_Start(c) }
is_alphabetic			    fn is_alphabetic(&self) -> bool { is_alphabetic(*self) }
is_alphabetic			    fn is_alphabetic(&self) -> bool;
is_alphabetic			pub fn is_alphabetic(c: char) -> bool   { derived_property::Alphabetic(c) }
is_alphanumeric			    fn is_alphanumeric(&self) -> bool { is_alphanumeric(*self) }
is_alphanumeric			    fn is_alphanumeric(&self) -> bool;
is_alphanumeric			pub fn is_alphanumeric(c: char) -> bool 
is_alphanumeric			    fn is_alphanumeric(&self) -> bool { self.chars().all(char::is_alphanumeric) }
is_alphanumeric			    fn is_alphanumeric(&self) -> bool;
is_char_boundary			    fn is_char_boundary(&self, index: uint) -> bool 
is_char_boundary			    fn is_char_boundary(&self, index: uint) -> bool;
is_control			    fn is_control(&self) -> bool { is_control(*self) }
is_control			    fn is_control(&self) -> bool;
is_control			pub fn is_control(c: char) -> bool { general_category::Cc(c) }
is_digit			    fn is_digit(&self) -> bool { is_digit(*self) }
is_digit			    fn is_digit(&self) -> bool;
is_digit			pub fn is_digit(c: char) -> bool 
is_digit_radix			    fn is_digit_radix(&self, radix: uint) -> bool { is_digit_radix(*self, radix) }
is_digit_radix			    fn is_digit_radix(&self, radix: uint) -> bool;
is_digit_radix			pub fn is_digit_radix(c: char, radix: uint) -> bool 
is_empty			    fn is_empty(&self) -> bool 
is_empty			    pub fn is_empty(&mut self) -> bool 
is_err			    pub fn is_err(&self) -> bool 
is_finite			    fn is_finite(self) -> bool 
is_finite			    fn is_finite(self) -> bool 
is_finite			    fn is_finite(self) -> bool;
is_infinite			    fn is_infinite(self) -> bool 
is_infinite			    fn is_infinite(self) -> bool 
is_infinite			    fn is_infinite(self) -> bool;
is_lowercase			    fn is_lowercase(&self) -> bool { is_lowercase(*self) }
is_lowercase			    fn is_lowercase(&self) -> bool;
is_lowercase			pub fn is_lowercase(c: char) -> bool { derived_property::Lowercase(c) }
is_nan			    fn is_nan(self) -> bool { self != self }
is_nan			    fn is_nan(self) -> bool { self != self }
is_nan			    fn is_nan(self) -> bool;
is_negative			            fn is_negative(&self) -> bool { *self < 0 }
is_negative			            fn is_negative(&self) -> bool { *self < 0.0 || (1.0 \/ *self) == 
is_negative			    fn is_negative(&self) -> bool;
is_none			    pub fn is_none(&self) -> bool 
is_normal			    fn is_normal(self) -> bool 
is_normal			    fn is_normal(self) -> bool 
is_normal			    fn is_normal(self) -> bool;
is_not_null			    fn is_not_null(&self) -> bool { !self.is_null() }
is_null			    fn is_null(&self) -> bool { *self == RawPtr::null() }
is_null			    fn is_null(&self) -> bool;
is_ok			    pub fn is_ok(&self) -> bool 
is_positive			            fn is_positive(&self) -> bool { *self > 0 }
is_positive			            fn is_positive(&self) -> bool { *self > 0.0 || (1.0 \/ *self) == 
is_positive			    fn is_positive(&self) -> bool;
is_power_of_two			pub fn is_power_of_two<T: Unsigned + Int>(n: T) -> bool 
is_some			    pub fn is_some(&self) -> bool 
is_uppercase			    fn is_uppercase(&self) -> bool { is_uppercase(*self) }
is_uppercase			    fn is_uppercase(&self) -> bool;
is_uppercase			pub fn is_uppercase(c: char) -> bool { derived_property::Uppercase(c) }
is_utf16			pub fn is_utf16(v: &[u16]) -> bool 
is_utf8			pub fn is_utf8(v: &[u8]) -> bool 
is_whitespace			    fn is_whitespace(&self) -> bool { is_whitespace(*self) }
is_whitespace			    fn is_whitespace(&self) -> bool;
is_whitespace			pub fn is_whitespace(c: char) -> bool 
is_whitespace			    fn is_whitespace(&self) -> bool { self.chars().all(char::is_whitespace) }
is_whitespace			    fn is_whitespace(&self) -> bool;
is_zero			            fn is_zero(&self) -> bool { *self == 
is_zero			            fn is_zero(&self) -> bool { *self == 
is_zero			    fn is_zero(&self) -> bool;
iter			pub mod iter;
iter			    pub fn iter<'r>(&'r self) -> Item<&'r T> 
iter			    fn iter(self) -> Items<'a, T> 
iter			    fn iter(self) -> Items<'a, T>;
kinds			pub mod kinds;
last			    fn last(&mut self) -> Option<A> 
last			    fn last(&self) -> Option<&'a T> 
last			    fn last(&self) -> Option<&'a T>;
le			                fn le(&self, other: &
le			        fn le(&self, other: & &'a T) -> bool { *(*self) <= *(*other) }
le			        fn le(&self, other: &&'a mut T) -> bool { **self <= **other }
le			    fn le(&self, other: &Self) -> bool 
le			    pub fn le<A: PartialOrd, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool 
le			    fn le(&self, other: &*const T) -> bool { *self <= *other }
le			    fn le(&self, other: &*mut T) -> bool { *self <= *other }
le			    fn le(&self, other: & &'a [T]) -> bool 
le			                fn le(&self, other: &(
leading_zeros			            fn leading_zeros(self) -> 
leading_zeros			            fn leading_zeros(self) -> 
leading_zeros			    fn leading_zeros(self) -> Self;
len			    fn len(&self) -> uint;
len			    fn len(&self) -> uint 
len			    fn len(&self) -> uint 
len			    fn len(&self) -> uint 
len_utf8_bytes			    fn len_utf8_bytes(&self) -> uint { len_utf8_bytes(*self) }
len_utf8_bytes			    fn len_utf8_bytes(&self) -> uint;
len_utf8_bytes			pub fn len_utf8_bytes(c: char) -> uint 
lexical_ordering			pub fn lexical_ordering(o1: Ordering, o2: Ordering) -> Ordering 
lines			    fn lines(&self) -> CharSplits<'a, char> 
lines			    fn lines(&self) -> CharSplits<'a, char>;
lines_any			    fn lines_any(&self) -> AnyLines<'a> 
lines_any			    fn lines_any(&self) -> AnyLines<'a>;
ln			    fn ln(self) -> f32 
ln			    fn ln(self) -> f64 
ln			    fn ln(self) -> Self;
ln_10			    fn ln_10() -> f32 { consts::LN_10 }
ln_10			    fn ln_10() -> f64 { consts::LN_10 }
ln_10			    fn ln_10() -> Self;
ln_2			    fn ln_2() -> f32 { consts::LN_2 }
ln_2			    fn ln_2() -> f64 { consts::LN_2 }
ln_2			    fn ln_2() -> Self;
load			    pub fn load(&self, order: Ordering) -> *mut T 
load			    pub fn load(&self, order: Ordering) -> bool 
load			    pub fn load(&self, order: Ordering) -> int 
load			    pub fn load(&self, order: Ordering) -> uint 
log			    fn log(self, base: f32) -> f32 { self.ln() \/ base.ln() }
log			    fn log(self, base: f64) -> f64 { self.ln() \/ base.ln() }
log			    fn log(self, base: Self) -> Self;
log10			    fn log10(self) -> f32 
log10			    fn log10(self) -> f64 
log10			    fn log10(self) -> Self;
log10_e			    fn log10_e() -> f32 { consts::LOG10_E }
log10_e			    fn log10_e() -> f64 { consts::LOG10_E }
log10_e			    fn log10_e() -> Self;
log10f32			    pub fn log10f32(x: f32) -> f32;
log10f64			    pub fn log10f64(x: f64) -> f64;
log2			    fn log2(self) -> f32 
log2			    fn log2(self) -> f64 
log2			    fn log2(self) -> Self;
log2_e			    fn log2_e() -> f32 { consts::LOG2_E }
log2_e			    fn log2_e() -> f64 { consts::LOG2_E }
log2_e			    fn log2_e() -> Self;
log2f32			    pub fn log2f32(x: f32) -> f32;
log2f64			    pub fn log2f64(x: f64) -> f64;
logf32			    pub fn logf32(x: f32) -> f32;
logf64			    pub fn logf64(x: f64) -> f64;
lt			                fn lt(&self, other: &
lt			        fn lt(&self, other: & &'a T) -> bool { *(*self) < *(*other) }
lt			        fn lt(&self, other: &&'a mut T) -> bool { **self < **other }
lt			    fn lt(&self, other: &Self) -> bool 
lt			    pub fn lt<A: PartialOrd, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool 
lt			    fn lt(&self, other: &*const T) -> bool { *self < *other }
lt			    fn lt(&self, other: &*mut T) -> bool { *self < *other }
lt			    fn lt(&self, other: & &'a [T]) -> bool 
lt			                fn lt(&self, other: &(
macros			mod macros;
mantissa_digits			    fn mantissa_digits(_: Option<f32>) -> uint { MANTISSA_DIGITS }
mantissa_digits			    fn mantissa_digits(_: Option<f64>) -> uint { MANTISSA_DIGITS }
mantissa_digits			    fn mantissa_digits(unused_self: Option<Self>) -> uint;
map			    fn map<'r, B>(self, f: |A|: 'r -> B) -> Map<'r, A, B, Self> 
map			    pub fn map<U>(self, f: |T| -> U) -> Option<U> 
map			    pub fn map<U>(self, op: |T| -> U) -> Result<U,E> 
map_err			    pub fn map_err<F>(self, op: |E| -> F) -> Result<T,F> 
map_or			    pub fn map_or<U>(self, def: U, f: |T| -> U) -> U 
marker			pub mod marker 
match_indices			    fn match_indices(&self, sep: &'a str) -> MatchIndices<'a> 
match_indices			    fn match_indices(&self, sep: &'a str) -> MatchIndices<'a>;
matches			    fn matches(&mut self, c: char) -> bool { (*self)(c) }
matches			    fn matches(&mut self, c: char) -> bool { *self == c }
matches			    fn matches(&mut self, c: char) -> bool 
matches			    fn matches(&mut self, char) -> bool;
max			pub fn max<T: Ord>(v1: T, v2: T) -> T 
max			    fn max(&mut self) -> Option<A> 
max			    fn max(&mut self) -> Option<A>;
max_10_exp			    fn max_10_exp(_: Option<f32>) -> int { MAX_10_EXP }
max_10_exp			    fn max_10_exp(_: Option<f64>) -> int { MAX_10_EXP }
max_10_exp			    fn max_10_exp(unused_self: Option<Self>) -> int;
max_by			    fn max_by<B: Ord>(&mut self, f: |&A| -> B) -> Option<A> 
max_exp			    fn max_exp(_: Option<f32>) -> int { MAX_EXP }
max_exp			    fn max_exp(_: Option<f64>) -> int { MAX_EXP }
max_exp			    fn max_exp(unused_self: Option<Self>) -> int;
max_value			            fn max_value() -> 
max_value			    fn max_value() -> Self;
maximal_suffix			    fn maximal_suffix(arr: &[u8], reversed: bool) -> (uint, uint) 
mem			pub mod mem;
min			pub fn min<T: Ord>(v1: T, v2: T) -> T 
min			    fn min(&mut self) -> Option<A> 
min			    fn min(&mut self) -> Option<A>;
min_10_exp			    fn min_10_exp(_: Option<f32>) -> int { MIN_10_EXP }
min_10_exp			    fn min_10_exp(_: Option<f64>) -> int { MIN_10_EXP }
min_10_exp			    fn min_10_exp(unused_self: Option<Self>) -> int;
min_align_of			    pub fn min_align_of<T>() -> uint;
min_align_of			pub fn min_align_of<T>() -> uint 
min_align_of_val			pub fn min_align_of_val<T>(_val: &T) -> uint 
min_by			    fn min_by<B: Ord>(&mut self, f: |&A| -> B) -> Option<A> 
min_exp			    fn min_exp(_: Option<f32>) -> int { MIN_EXP }
min_exp			    fn min_exp(_: Option<f64>) -> int { MIN_EXP }
min_exp			    fn min_exp(unused_self: Option<Self>) -> int;
min_max			    fn min_max(&mut self) -> MinMaxResult<A> 
min_max			    fn min_max(&mut self) -> MinMaxResult<A>;
min_pos_value			    fn min_pos_value(_: Option<f32>) -> f32 { MIN_POS_VALUE }
min_pos_value			    fn min_pos_value(_: Option<f64>) -> f64 { MIN_POS_VALUE }
min_pos_value			    fn min_pos_value(unused_self: Option<Self>) -> Self;
min_value			            fn min_value() -> 
min_value			    fn min_value() -> Self;
move_iter			    pub fn move_iter(self) -> Item<T> 
move_val_init			    pub fn move_val_init<T>(dst: &mut T, src: T);
move_val_init			pub unsafe fn move_val_init<T>(dst: &mut T, src: T) 
mul			            fn mul(&self, other: &
mul			    fn mul(&self, rhs: &RHS) -> Result;
mul_add			    fn mul_add(self, a: f32, b: f32) -> f32 
mul_add			    fn mul_add(self, a: f64, b: f64) -> f64 
mul_add			    fn mul_add(self, a: Self, b: Self) -> Self;
multibyte_char_range_at			        fn multibyte_char_range_at(s: &str, i: uint) -> CharRange 
multibyte_char_range_at_reverse			        fn multibyte_char_range_at_reverse(s: &str, mut i: uint) -> CharRange 
mut_buf_as_slice			    pub unsafe fn mut_buf_as_slice<T,
mut_chunks			    fn mut_chunks(self, chunk_size: uint) -> MutChunks<'a, T> 
mut_chunks			    fn mut_chunks(self, chunk_size: uint) -> MutChunks<'a, T>;
mut_iter			    pub fn mut_iter<'r>(&'r mut self) -> Item<&'r mut T> 
mut_iter			    fn mut_iter(self) -> MutItems<'a, T> 
mut_iter			    fn mut_iter(self) -> MutItems<'a, T>;
mut_last			    fn mut_last(self) -> Option<&'a mut T> 
mut_last			    fn mut_last(self) -> Option<&'a mut T>;
mut_null			pub fn mut_null<T>() -> *mut T { 0 as *mut T }
mut_pop_ref			    fn mut_pop_ref(&mut self) -> Option<&'a mut T> 
mut_pop_ref			    fn mut_pop_ref(&mut self) -> Option<&'a mut T>;
mut_ref_slice			pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] 
mut_shift_ref			    fn mut_shift_ref(&mut self) -> Option<&'a mut T> 
mut_shift_ref			    fn mut_shift_ref(&mut self) -> Option<&'a mut T>;
mut_slice			    fn mut_slice(self, start: uint, end: uint) -> &'a mut [T] 
mut_slice			    fn mut_slice(self, start: uint, end: uint) -> &'a mut [T];
mut_slice_from			    fn mut_slice_from(self, start: uint) -> &'a mut [T] 
mut_slice_from			    fn mut_slice_from(self, start: uint) -> &'a mut [T];
mut_slice_to			    fn mut_slice_to(self, end: uint) -> &'a mut [T] 
mut_slice_to			    fn mut_slice_to(self, end: uint) -> &'a mut [T];
mut_split			    fn mut_split(self, pred: |&T|: 'a -> bool) -> MutSplits<'a, T> 
mut_split			    fn mut_split(self, pred: |&T|: 'a -> bool) -> MutSplits<'a, T>;
mut_split_at			    fn mut_split_at(self, mid: uint) -> (&'a mut [T], &'a mut [T]) 
mut_split_at			    fn mut_split_at(self, mid: uint) -> (&'a mut [T], &'a mut [T]);
mutate			    pub fn mutate(&mut self, f: |T| -> T) -> bool 
mutate_or_set			    pub fn mutate_or_set(&mut self, def: T, f: |T| -> T) -> bool 
nan			    fn nan() -> f32 { NAN }
nan			    fn nan() -> f64 { NAN }
nan			    fn nan() -> Self;
ne			                fn ne(&self, other: &
ne			        fn ne(&self, _other: &()) -> bool { false }
ne			        fn ne(&self, other: & &'a T) -> bool { *(*self) != *(*other) }
ne			        fn ne(&self, other: &&'a mut T) -> bool { **self != *(*other) }
ne			    fn ne(&self, other: &Self) -> bool { !self.eq(other) }
ne			    pub fn ne<A: PartialEq, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool 
ne			    fn ne(&self, other: &*const T) -> bool { !self.eq(other) }
ne			    fn ne(&self, other: &*mut T) -> bool { !self.eq(other) }
ne			    fn ne(&self, other: & &'a [T]) -> bool 
ne			        fn ne(&self, other: & &'a str) -> bool { !(*self).eq(other) }
ne			                fn ne(&self, other: &(
nearbyintf32			    pub fn nearbyintf32(x: f32) -> f32;
nearbyintf64			    pub fn nearbyintf64(x: f64) -> f64;
needs_drop			    pub fn needs_drop<T>() -> bool;
neg			            fn neg(&self) -> 
neg			            fn neg(&self) -> 
neg			    fn neg(&self) -> Result;
neg_infinity			    fn neg_infinity() -> f32 { NEG_INFINITY }
neg_infinity			    fn neg_infinity() -> f64 { NEG_INFINITY }
neg_infinity			    fn neg_infinity() -> Self;
neg_zero			    fn neg_zero() -> f32 { -0.0 }
neg_zero			    fn neg_zero() -> f64 { -0.0 }
neg_zero			    fn neg_zero() -> Self;
new			    pub fn new(p: *mut T) -> AtomicPtr<T> 
new			    pub fn new(v: bool) -> AtomicBool 
new			    pub fn new(v: int) -> AtomicInt 
new			    pub fn new(v: uint) -> AtomicUint 
new			    pub fn new(value: T) -> Cell<T> 
new			    pub fn new(value: T) -> RefCell<T> 
new			    pub unsafe fn new<'a>(fmt: &'static [rt::Piece<'static>],
new			    fn new(base: u8) -> Radix 
new			    pub fn new(elt: A) -> Repeat<A> 
new			    pub fn new<'a>(initial_state: St, f: |&mut St|: 'a -> Option<A>)
new			    fn new() -> NaiveSearcher 
new			    fn new(haystack: &[u8], needle: &[u8]) -> Searcher 
new			    fn new(needle: &[u8]) -> TwoWaySearcher 
new			    pub fn new(value: T) -> Unsafe<T> 
next			    fn next(&mut self) -> Option<(A, B)> 
next			    fn next(&mut self) -> Option<(uint, A)> 
next			    fn next(&mut self) -> Option<A> { self.idx(0) }
next			    fn next(&mut self) -> Option<A> { self.iter.next() }
next			    fn next(&mut self) -> Option<A> { self.iter.next_back() }
next			    fn next(&mut self) -> Option<A> 
next			    fn next(&mut self) -> Option<A>;
next			    fn next(&mut self) -> Option<B> 
next			        fn next(&mut self) -> Option<T> 
next			    fn next(&mut self) -> Option<A> 
next			        fn next(&mut self) -> Option<T> 
next			            fn next(&mut self) -> Option<
next			    fn next(&mut self) -> Option<&'a [T]> 
next			    fn next(&mut self) -> Option<&'a mut [T]> 
next			    fn next(&mut self) -> Option<&'a str> 
next			    fn next(&mut self) -> Option<(uint, char)> 
next			    fn next(&mut self) -> Option<(uint, uint)> 
next			    fn next(&mut self) -> Option<Utf16Item> 
next			    fn next(&mut self) -> Option<char> 
next			    fn next(&mut self) -> Option<u16> 
next			    fn next(&mut self, haystack: &[u8], needle: &[u8]) -> Option<(uint, uint)> 
next			    fn next(&mut self, haystack: &[u8], needle: &[u8], longPeriod: bool) -> Option<(uint, uint)> 
next_back			    fn next_back(&mut self) -> Option<(A, B)> 
next_back			    fn next_back(&mut self) -> Option<(uint, A)> 
next_back			    fn next_back(&mut self) -> Option<A> { self.idx(0) }
next_back			    fn next_back(&mut self) -> Option<A> { self.iter.next() }
next_back			    fn next_back(&mut self) -> Option<A> { self.iter.next_back() }
next_back			    fn next_back(&mut self) -> Option<A> 
next_back			    fn next_back(&mut self) -> Option<A>;
next_back			    fn next_back(&mut self) -> Option<B> 
next_back			    fn next_back(&mut self) -> Option<A> 
next_back			            fn next_back(&mut self) -> Option<
next_back			    fn next_back(&mut self) -> Option<&'a [T]> 
next_back			    fn next_back(&mut self) -> Option<&'a mut [T]> 
next_back			    fn next_back(&mut self) -> Option<&'a str> 
next_back			    fn next_back(&mut self) -> Option<(uint, char)> 
next_back			    fn next_back(&mut self) -> Option<char> 
next_power_of_two			pub fn next_power_of_two<T: Unsigned + Int>(n: T) -> T 
nonzero_size_of			pub fn nonzero_size_of<T>() -> uint 
nonzero_size_of_val			pub fn nonzero_size_of_val<T>(val: &T) -> uint 
normalization			pub mod normalization 
not			            fn not(&self) -> 
not			    fn not(&self) -> Result;
nth			    fn nth(&mut self, mut n: uint) -> Option<A> 
null			    fn null() -> *const T { null() }
null			    fn null() -> *mut T { mut_null() }
null			    fn null() -> Self;
null			pub fn null<T>() -> *const T { 0 as *const T }
num			mod num;
num			pub mod num;
of			    pub fn of<T: 'static>() -> TypeId 
offset			    pub fn offset<T>(dst: *const T, offset: int) -> *const T;
offset			    unsafe fn offset(self, count: int) -> *const T 
offset			    unsafe fn offset(self, count: int) -> *mut T 
offset			    unsafe fn offset(self, count: int) -> Self;
ok			    pub fn ok(self) -> Option<T> 
one			            fn one() -> 
one			    fn one() -> Self;
only_ascii			    fn only_ascii(&self) -> bool { (*self as uint) < 128 }
only_ascii			    fn only_ascii(&self) -> bool { false }
only_ascii			    fn only_ascii(&self) -> bool 
only_ascii			    fn only_ascii(&self) -> bool;
ops			pub mod ops;
option			pub mod option;
or			    pub fn or(self, optb: Option<T>) -> Option<T> 
or			    pub fn or(self, res: Result<T, E>) -> Result<T, E> 
or_else			    pub fn or_else(self, f: || -> Option<T>) -> Option<T> 
or_else			    pub fn or_else<F>(self, op: |E| -> Result<T, F>) -> Result<T, F> 
order			pub mod order 
overwrite			pub unsafe fn overwrite<T>(dst: *mut T, src: T) 
owns_managed			    pub fn owns_managed<T>() -> bool;
pad			    pub fn pad(&mut self, s: &str) -> Result 
pad_integral			    pub fn pad_integral(&mut self, is_positive: bool, prefix: &str,
partial_cmp			                fn partial_cmp(&self, other: &
partial_cmp			        fn partial_cmp(&self, _: &()) -> Option<Ordering> 
partial_cmp			        fn partial_cmp(&self, other: &&'a T) -> Option<Ordering> 
partial_cmp			        fn partial_cmp(&self, other: &&'a mut T) -> Option<Ordering> 
partial_cmp			        fn partial_cmp(&self, other: &bool) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &Ordering) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &Self) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &Self) -> Option<Ordering>;
partial_cmp			    pub fn partial_cmp<A: PartialOrd, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S)
partial_cmp			    fn partial_cmp(&self, other: &*const T) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &*mut T) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &&'a [T]) -> Option<Ordering> 
partial_cmp			        fn partial_cmp(&self, other: &&'a str) -> Option<Ordering> 
partial_cmp			                fn partial_cmp(&self, other: &(
peek			    pub fn peek(&'a mut self) -> Option<&'a A> 
peekable			    fn peekable(self) -> Peekable<A, Self> 
pi			    fn pi() -> f32 { consts::PI }
pi			    fn pi() -> f64 { consts::PI }
pi			    fn pi() -> Self;
pop_ptr			    pub unsafe fn pop_ptr<T>(slice: &mut Slice<T>) -> Option<*const T> 
pop_ref			    fn pop_ref(&mut self) -> Option<&'a T> 
pop_ref			    fn pop_ref(&mut self) -> Option<&'a T>;
position			    fn position(&mut self, predicate: |A| -> bool) -> Option<uint> 
position			pub unsafe fn position<T>(buf: *const T, f: |&T| -> bool) -> uint 
position_elem			    fn position_elem(&self, t: &T) -> Option<uint>;
position_elem			    fn position_elem(&self, x: &T) -> Option<uint> 
pow			pub fn pow<T: One + Mul<T, T>>(mut base: T, mut exp: uint) -> T 
powf			    fn powf(self, n: f32) -> f32 
powf			    fn powf(self, n: f64) -> f64 
powf			    fn powf(self, n: Self) -> Self;
powf32			    pub fn powf32(a: f32, x: f32) -> f32;
powf64			    pub fn powf64(a: f64, x: f64) -> f64;
powi			    fn powi(self, n: i32) -> f32 
powi			    fn powi(self, n: i32) -> f64 
powi			    fn powi(self, n: i32) -> Self;
powif32			    pub fn powif32(a: f32, x: i32) -> f32;
powif64			    pub fn powif64(a: f64, x: i32) -> f64;
pref_align_of			    pub fn pref_align_of<T>() -> uint;
pref_align_of			pub fn pref_align_of<T>() -> uint { align_of::<T>() }
pref_align_of_val			pub fn pref_align_of_val<T>(val: &T) -> uint { align_of_val(val) }
prefix			            fn prefix(&self) -> &'static str { 
prefix			    fn prefix(&self) -> &'static str { "" }
prelude			pub mod prelude;
product			    fn product(&mut self) -> A 
product			    fn product(&mut self) -> A;
property			pub mod property 
ptr			pub mod ptr;
radix			pub fn radix<T>(x: T, base: u8) -> RadixFmt<T, Radix> 
range			pub fn range<A: Add<A, A> + PartialOrd + Clone + One>(start: A, stop: A) -> Range<A> 
range_inclusive			pub fn range_inclusive<A: Add<A, A> + PartialOrd + Clone + One>(start: A, stop: A)
range_step			pub fn range_step<A: CheckedAdd + PartialOrd +
range_step_inclusive			pub fn range_step_inclusive<A: CheckedAdd + PartialOrd + Clone + Zero>(start: A, stop: A,
raw			pub mod raw;
raw			pub mod raw 
raw			pub mod raw 
read			pub unsafe fn read<T>(src: *const T) -> T 
read_and_zero			pub unsafe fn read_and_zero<T>(dest: *mut T) -> T 
recip			    fn recip(self) -> f32 { 1.0 \/ self }
recip			    fn recip(self) -> f64 { 1.0 \/ self }
recip			    fn recip(self) -> Self;
ref_slice			pub fn ref_slice<'a, A>(s: &'a A) -> &'a [A] 
rem			            fn rem(&self, other: &
rem			            fn rem(&self, other: &
rem			    fn rem(&self, rhs: &RHS) -> Result;
replace			pub fn replace<T>(dest: &mut T, mut src: T) -> T 
replace			pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T 
repr			    fn repr(&self) -> T { unsafe { mem::transmute_copy(self) } }
reset_fuse			    pub fn reset_fuse(&mut self) 
result			pub mod result;
rev			    fn rev(self) -> Rev<Self> 
reverse			    fn reverse(self) 
reverse			    fn reverse(self);
reverse_			    fn reverse_(&mut self) 
reverse_			    fn reverse_(&mut self);
rfind			    fn rfind<C: CharEq>(&self, mut search: C) -> Option<uint> 
rfind			    fn rfind<C: CharEq>(&self, search: C) -> Option<uint>;
rintf32			    pub fn rintf32(x: f32) -> f32;
rintf64			    pub fn rintf64(x: f64) -> f64;
rotate_left			            fn rotate_left(self, n: uint) -> 
rotate_left			            fn rotate_left(self, n: uint) -> 
rotate_left			    fn rotate_left(self, n: uint) -> Self;
rotate_right			            fn rotate_right(self, n: uint) -> 
rotate_right			            fn rotate_right(self, n: uint) -> 
rotate_right			    fn rotate_right(self, n: uint) -> Self;
round			    fn round(self) -> f32 
round			    fn round(self) -> f64 
round			    fn round(self) -> Self;
roundf32			    pub fn roundf32(x: f32) -> f32;
roundf64			    pub fn roundf64(x: f64) -> f64;
rposition			    fn rposition(&mut self, predicate: |A| -> bool) -> Option<uint> 
rposition_elem			    fn rposition_elem(&self, t: &T) -> Option<uint> 
rposition_elem			    fn rposition_elem(&self, t: &T) -> Option<uint>;
rsplitn			    fn rsplitn(self,  n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T>;
rsplitn			    fn rsplitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T> 
rsplitn			    fn rsplitn<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitsN<'a, Sep>;
rsplitn			    fn rsplitn<Sep: CharEq>(&self, sep: Sep, count: uint)
rsqrt			    fn rsqrt(self) -> f32 { self.sqrt().recip() }
rsqrt			    fn rsqrt(self) -> f64 { self.sqrt().recip() }
rsqrt			    fn rsqrt(self) -> Self;
rt			pub mod rt;
run			    fn run(&mut self, piece: &rt::Piece) -> Result 
run_fmt			        fn run_fmt(fmt: &::std::fmt::Arguments) -> ! 
run_utf8_validation_iterator			fn run_utf8_validation_iterator(iter: &mut slice::Items<u8>) -> bool 
rust_allocate			    fn rust_allocate(size: uint, align: uint) -> *u8;
rust_deallocate			    fn rust_deallocate(ptr: *u8, size: uint, align: uint);
saturating_add			    fn saturating_add(self, v: Self) -> Self;
saturating_add			    fn saturating_add(self, v: T) -> T 
saturating_sub			    fn saturating_sub(self, v: Self) -> Self;
saturating_sub			    fn saturating_sub(self, v: T) -> T 
scan			    fn scan<'r, St, B>(self, initial_state: St, f: |&mut St, A|: 'r -> Option<B>)
set			    pub fn set(&self, value: T) 
set_memory			    pub fn set_memory<T>(dst: *mut T, val: u8, count: uint);
set_memory			pub unsafe fn set_memory<T>(dst: *mut T, c: u8, count: uint) 
set_memory			        fn set_memory(self, value: u8) 
set_memory			        fn set_memory(self, value: u8);
shift_ptr			    pub unsafe fn shift_ptr<T>(slice: &mut Slice<T>) -> Option<*const T> 
shift_ref			    fn shift_ref(&mut self) -> Option<&'a T> 
shift_ref			    fn shift_ref(&mut self) -> Option<&'a T>;
shl			            fn shl(&self, other: &
shl			    fn shl(&self, rhs: &RHS) -> Result;
shr			            fn shr(&self, other: &
shr			    fn shr(&self, rhs: &RHS) -> Result;
signum			            fn signum(&self) -> 
signum			    fn signum(&self) -> Self;
simd			pub mod simd;
sinf32			    pub fn sinf32(x: f32) -> f32;
sinf64			    pub fn sinf64(x: f64) -> f64;
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) { (0, None) }
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) { (uint::MAX, None) }
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			            fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_of			    pub fn size_of<T>() -> uint;
size_of			pub fn size_of<T>() -> uint 
size_of_val			pub fn size_of_val<T>(_val: &T) -> uint 
skip			    fn skip(self, n: uint) -> Skip<Self> 
skip_while			    fn skip_while<'r>(self, predicate: |&A|: 'r -> bool) -> SkipWhile<'r, A, Self> 
slice			pub mod slice;
slice			    fn slice(&self, start: uint, end: uint) -> &'a [T] 
slice			    fn slice(&self, start: uint, end: uint) -> &'a [T];
slice			    fn slice(&self, begin: uint, end: uint) -> &'a str 
slice			    fn slice(&self, begin: uint, end: uint) -> &'a str;
slice_bytes			    pub unsafe fn slice_bytes<'a>(s: &'a str, begin: uint, end: uint) -> &'a str 
slice_chars			    fn slice_chars(&self, begin: uint, end: uint) -> &'a str 
slice_chars			    fn slice_chars(&self, begin: uint, end: uint) -> &'a str;
slice_from			    fn slice_from(&self, start: uint) -> &'a [T] 
slice_from			    fn slice_from(&self, start: uint) -> &'a [T];
slice_from			    fn slice_from(&self, begin: uint) -> &'a str 
slice_from			    fn slice_from(&self, begin: uint) -> &'a str;
slice_shift_char			    fn slice_shift_char(&self) -> (Option<char>, &'a str) 
slice_shift_char			    fn slice_shift_char(&self) -> (Option<char>, &'a str);
slice_to			    fn slice_to(&self, end: uint) -> &'a [T] 
slice_to			    fn slice_to(&self, end: uint) -> &'a [T];
slice_to			    fn slice_to(&self, end: uint) -> &'a str 
slice_to			    fn slice_to(&self, end: uint) -> &'a str;
slice_unchecked			    pub unsafe fn slice_unchecked<'a>(s: &'a str, begin: uint, end: uint) -> &'a str 
split			    fn split(self, pred: |&T|: 'a -> bool) -> Splits<'a, T> 
split			    fn split(self, pred: |&T|: 'a -> bool) -> Splits<'a, T>;
split			    fn split<Sep: CharEq>(&self, sep: Sep) -> CharSplits<'a, Sep> 
split			    fn split<Sep: CharEq>(&self, sep: Sep) -> CharSplits<'a, Sep>;
split_str			    fn split_str(&self, &'a str) -> StrSplits<'a>;
split_str			    fn split_str(&self, sep: &'a str) -> StrSplits<'a> 
split_terminator			    fn split_terminator<Sep: CharEq>(&self, sep: Sep) -> CharSplits<'a, Sep>;
split_terminator			    fn split_terminator<Sep: CharEq>(&self, sep: Sep)
splitn			    fn splitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T> 
splitn			    fn splitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T>;
splitn			    fn splitn<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitsN<'a, Sep>;
splitn			    fn splitn<Sep: CharEq>(&self, sep: Sep, count: uint)
sqrt			    fn sqrt(self) -> f32 
sqrt			    fn sqrt(self) -> f64 
sqrt			    fn sqrt(self) -> Self;
sqrt2			    fn sqrt2() -> f32 { consts::SQRT2 }
sqrt2			    fn sqrt2() -> f64 { consts::SQRT2 }
sqrt2			    fn sqrt2() -> Self;
sqrtf32			    pub fn sqrtf32(x: f32) -> f32;
sqrtf64			    pub fn sqrtf64(x: f64) -> f64;
starts_with			    fn starts_with(&self, needle: &[T]) -> bool 
starts_with			    fn starts_with(&self, needle: &[T]) -> bool;
starts_with			    fn starts_with(&self, needle: &str) -> bool;
starts_with			    fn starts_with<'a>(&self, needle: &'a str) -> bool 
std			mod std 
store			    pub fn store(&self, ptr: *mut T, order: Ordering) 
store			    pub fn store(&self, val: bool, order: Ordering) 
store			    pub fn store(&self, val: int, order: Ordering) 
store			    pub fn store(&self, val: uint, order: Ordering) 
str			pub mod str;
sub			            fn sub(&self, other: &
sub			    fn sub(&self, rhs: &RHS) -> Result;
subslice_offset			    fn subslice_offset(&self, inner: &str) -> uint 
subslice_offset			    fn subslice_offset(&self, inner: &str) -> uint;
sum			    fn sum(&mut self) -> A 
sum			    fn sum(&mut self) -> A;
swap			    pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T 
swap			    pub fn swap(&self, val: bool, order: Ordering) -> bool 
swap			    pub fn swap(&self, val: int, order: Ordering) -> int 
swap			    pub fn swap(&self, val: uint, order: Ordering) -> uint 
swap			pub fn swap<T>(x: &mut T, y: &mut T) 
swap			pub unsafe fn swap<T>(x: *mut T, y: *mut T) 
swap			    fn swap(self, a: uint, b: uint) 
swap			    fn swap(self, a: uint, b: uint);
swap_bytes			            fn swap_bytes(self) -> 
swap_bytes			            fn swap_bytes(self) -> 
swap_bytes			    fn swap_bytes(self) -> Self;
tail			    fn tail(&self) -> &'a [T] { self.slice(1, self.len()) }
tail			    fn tail(&self) -> &'a [T];
tailn			    fn tailn(&self, n: uint) -> &'a [T] { self.slice(n, self.len()) }
tailn			    fn tailn(&self, n: uint) -> &'a [T];
take			    fn take(self, n: uint) -> Take<Self> 
take			    pub fn take(&mut self) -> Option<T> 
take_unwrap			    pub fn take_unwrap(&mut self) -> T 
take_while			    fn take_while<'r>(self, predicate: |&A|: 'r -> bool) -> TakeWhile<'r, A, Self> 
to_be			    fn to_be(self) -> Self { \/\/ or not to be?
to_be16			pub fn to_be16(x: u16) -> u16 { x.to_be() }
to_be32			pub fn to_be32(x: u32) -> u32 { x.to_be() }
to_be64			pub fn to_be64(x: u64) -> u64 { x.to_be() }
to_char_lossy			    pub fn to_char_lossy(&self) -> char 
to_degrees			    fn to_degrees(self) -> f32 { self * (180.0f32 \/ Float::pi()) }
to_degrees			    fn to_degrees(self) -> f64 { self * (180.0f64 \/ Float::pi()) }
to_degrees			    fn to_degrees(self) -> Self;
to_digit			    fn to_digit(&self, radix: uint) -> Option<uint> { to_digit(*self, radix) }
to_digit			    fn to_digit(&self, radix: uint) -> Option<uint>;
to_digit			pub fn to_digit(c: char, radix: uint) -> Option<uint> 
to_f32			            fn to_f32(&self) -> Option<f32> { Some(*self as f32) }
to_f32			            fn to_f32(&self) -> Option<f32> { impl_to_primitive_float_to_float!(
to_f32			    fn to_f32(&self) -> Option<f32> 
to_f64			            fn to_f64(&self) -> Option<f64> { Some(*self as f64) }
to_f64			            fn to_f64(&self) -> Option<f64> { impl_to_primitive_float_to_float!(
to_f64			    fn to_f64(&self) -> Option<f64> 
to_i16			            fn to_i16(&self) -> Option<i16> { Some(*self as i16) }
to_i16			            fn to_i16(&self) -> Option<i16> { impl_to_primitive_int_to_int!(
to_i16			            fn to_i16(&self) -> Option<i16> { impl_to_primitive_uint_to_int!(i16) }
to_i16			    fn to_i16(&self) -> Option<i16> 
to_i32			            fn to_i32(&self) -> Option<i32> { Some(*self as i32) }
to_i32			            fn to_i32(&self) -> Option<i32> { impl_to_primitive_int_to_int!(
to_i32			            fn to_i32(&self) -> Option<i32> { impl_to_primitive_uint_to_int!(i32) }
to_i32			    fn to_i32(&self) -> Option<i32> 
to_i64			            fn to_i64(&self) -> Option<i64> { Some(*self as i64) }
to_i64			            fn to_i64(&self) -> Option<i64> { impl_to_primitive_int_to_int!(
to_i64			            fn to_i64(&self) -> Option<i64> { impl_to_primitive_uint_to_int!(i64) }
to_i64			    fn to_i64(&self) -> Option<i64>;
to_i8			            fn to_i8(&self) -> Option<i8> { Some(*self as i8) }
to_i8			            fn to_i8(&self) -> Option<i8> { impl_to_primitive_int_to_int!(
to_i8			            fn to_i8(&self) -> Option<i8> { impl_to_primitive_uint_to_int!(i8) }
to_i8			    fn to_i8(&self) -> Option<i8> 
to_int			            fn to_int(&self) -> Option<int> { Some(*self as int) }
to_int			            fn to_int(&self) -> Option<int> { impl_to_primitive_int_to_int!(
to_int			            fn to_int(&self) -> Option<int> { impl_to_primitive_uint_to_int!(int) }
to_int			    fn to_int(&self) -> Option<int> 
to_le			    fn to_le(self) -> Self 
to_le16			pub fn to_le16(x: u16) -> u16 { x.to_le() }
to_le32			pub fn to_le32(x: u32) -> u32 { x.to_le() }
to_le64			pub fn to_le64(x: u64) -> u64 { x.to_le() }
to_lower			    pub fn to_lower(c: char) -> char 
to_lowercase			    fn to_lowercase(&self) -> char { to_lowercase(*self) }
to_lowercase			    fn to_lowercase(&self) -> char;
to_lowercase			pub fn to_lowercase(c: char) -> char 
to_option			    unsafe fn to_option(&self) -> Option<&T> 
to_option			    unsafe fn to_option(&self) -> Option<&T>;
to_radians			    fn to_radians(self) -> f32 
to_radians			    fn to_radians(self) -> f64 
to_radians			    fn to_radians(self) -> Self;
to_u16			            fn to_u16(&self) -> Option<u16> { Some(*self as u16) }
to_u16			            fn to_u16(&self) -> Option<u16> { impl_to_primitive_int_to_uint!(
to_u16			            fn to_u16(&self) -> Option<u16> { impl_to_primitive_uint_to_uint!(
to_u16			    fn to_u16(&self) -> Option<u16> 
to_u32			            fn to_u32(&self) -> Option<u32> { Some(*self as u32) }
to_u32			            fn to_u32(&self) -> Option<u32> { impl_to_primitive_int_to_uint!(
to_u32			            fn to_u32(&self) -> Option<u32> { impl_to_primitive_uint_to_uint!(
to_u32			    fn to_u32(&self) -> Option<u32> 
to_u64			            fn to_u64(&self) -> Option<u64> { Some(*self as u64) }
to_u64			            fn to_u64(&self) -> Option<u64> { impl_to_primitive_int_to_uint!(
to_u64			            fn to_u64(&self) -> Option<u64> { impl_to_primitive_uint_to_uint!(
to_u64			    fn to_u64(&self) -> Option<u64>;
to_u8			            fn to_u8(&self) -> Option<u8> { Some(*self as u8) }
to_u8			            fn to_u8(&self) -> Option<u8> { impl_to_primitive_int_to_uint!(
to_u8			            fn to_u8(&self) -> Option<u8> { impl_to_primitive_uint_to_uint!(
to_u8			    fn to_u8(&self) -> Option<u8> 
to_uint			            fn to_uint(&self) -> Option<uint> { Some(*self as uint) }
to_uint			            fn to_uint(&self) -> Option<uint> { impl_to_primitive_int_to_uint!(
to_uint			            fn to_uint(&self) -> Option<uint> { impl_to_primitive_uint_to_uint!(
to_uint			    fn to_uint(&self) -> Option<uint> 
to_uint			    fn to_uint(&self) -> uint { *self as uint }
to_uint			    fn to_uint(&self) -> uint;
to_upper			    pub fn to_upper(c: char) -> char 
to_uppercase			    fn to_uppercase(&self) -> char { to_uppercase(*self) }
to_uppercase			    fn to_uppercase(&self) -> char;
to_uppercase			pub fn to_uppercase(c: char) -> char 
trailing_zeros			            fn trailing_zeros(self) -> 
trailing_zeros			            fn trailing_zeros(self) -> 
trailing_zeros			    fn trailing_zeros(self) -> Self;
traits			pub mod traits 
transmute			    pub fn transmute<T,U>(e: T) -> U;
transmute_copy			pub unsafe fn transmute_copy<T, U>(src: &T) -> U 
trim			    fn trim(&self) -> &'a str 
trim			    fn trim(&self) -> &'a str;
trim_chars			    fn trim_chars<C: CharEq>(&self, mut to_trim: C) -> &'a str 
trim_chars			    fn trim_chars<C: CharEq>(&self, to_trim: C) -> &'a str;
trim_left			    fn trim_left(&self) -> &'a str 
trim_left			    fn trim_left(&self) -> &'a str;
trim_left_chars			    fn trim_left_chars<C: CharEq>(&self, mut to_trim: C) -> &'a str 
trim_left_chars			    fn trim_left_chars<C: CharEq>(&self, to_trim: C) -> &'a str;
trim_right			    fn trim_right(&self) -> &'a str 
trim_right			    fn trim_right(&self) -> &'a str;
trim_right_chars			    fn trim_right_chars<C: CharEq>(&self, mut to_trim: C) -> &'a str 
trim_right_chars			    fn trim_right_chars<C: CharEq>(&self, to_trim: C) -> &'a str;
trunc			    fn trunc(self) -> f32 
trunc			    fn trunc(self) -> f64 
trunc			    fn trunc(self) -> Self;
truncate_utf16_at_nul			pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] 
truncf32			    pub fn truncf32(x: f32) -> f32;
truncf64			    pub fn truncf64(x: f64) -> f64;
try_borrow			    pub fn try_borrow<'a>(&'a self) -> Option<Ref<'a, T>> 
try_borrow_mut			    pub fn try_borrow_mut<'a>(&'a self) -> Option<RefMut<'a, T>> 
try_finally			pub fn try_finally<T,U,R>(mutate: &mut T,
tuple			pub mod tuple;
two_pi			    fn two_pi() -> f32 { consts::PI_2 }
two_pi			    fn two_pi() -> f64 { consts::PI_2 }
two_pi			    fn two_pi() -> Self;
ty			pub mod ty;
type_id			    pub fn type_id<T: 'static>() -> TypeId;
u16_add_with_overflow			    pub fn u16_add_with_overflow(x: u16, y: u16) -> (u16, bool);
u16_mul_with_overflow			    pub fn u16_mul_with_overflow(x: u16, y: u16) -> (u16, bool);
u16_sub_with_overflow			    pub fn u16_sub_with_overflow(x: u16, y: u16) -> (u16, bool);
u16x8			pub struct u16x8(pub u16, pub u16, pub u16, pub u16,
u32_add_with_overflow			    pub fn u32_add_with_overflow(x: u32, y: u32) -> (u32, bool);
u32_mul_with_overflow			    pub fn u32_mul_with_overflow(x: u32, y: u32) -> (u32, bool);
u32_sub_with_overflow			    pub fn u32_sub_with_overflow(x: u32, y: u32) -> (u32, bool);
u32x4			pub struct u32x4(pub u32, pub u32, pub u32, pub u32);
u64_add_with_overflow			    pub fn u64_add_with_overflow(x: u64, y: u64) -> (u64, bool);
u64_mul_with_overflow			    pub fn u64_mul_with_overflow(x: u64, y: u64) -> (u64, bool);
u64_sub_with_overflow			    pub fn u64_sub_with_overflow(x: u64, y: u64) -> (u64, bool);
u64x2			pub struct u64x2(pub u64, pub u64);
u8_add_with_overflow			    pub fn u8_add_with_overflow(x: u8, y: u8) -> (u8, bool);
u8_mul_with_overflow			    pub fn u8_mul_with_overflow(x: u8, y: u8) -> (u8, bool);
u8_sub_with_overflow			    pub fn u8_sub_with_overflow(x: u8, y: u8) -> (u8, bool);
u8x16			pub struct u8x16(pub u8, pub u8, pub u8, pub u8,
unicode			mod unicode;
uninit			    pub fn uninit<T>() -> T;
uninit			pub unsafe fn uninit<T>() -> T 
uninitialized			pub unsafe fn uninitialized<T>() -> T 
unit			pub mod unit;
unsafe_mut_ref			    unsafe fn unsafe_mut_ref(self, index: uint) -> &'a mut T 
unsafe_mut_ref			    unsafe fn unsafe_mut_ref(self, index: uint) -> &'a mut T;
unsafe_ref			    unsafe fn unsafe_ref(self, index: uint) -> &'a T 
unsafe_ref			    unsafe fn unsafe_ref(self, index: uint) -> &'a T;
unsafe_set			    unsafe fn unsafe_set(self, index: uint, val: T) 
unsafe_set			    unsafe fn unsafe_set(self, index: uint, val: T);
unwrap			    pub fn unwrap(self) -> T 
unwrap			    pub fn unwrap(self) -> T 
unwrap			    pub fn unwrap(self) -> T 
unwrap			    pub unsafe fn unwrap(self) -> T { self.value }
unwrap_err			    pub fn unwrap_err(self) -> E 
unwrap_or			    pub fn unwrap_or(self, def: T) -> T 
unwrap_or			    pub fn unwrap_or(self, optb: T) -> T 
unwrap_or_default			    pub fn unwrap_or_default(self) -> T 
unwrap_or_else			    pub fn unwrap_or_else(self, f: || -> T) -> T 
unwrap_or_else			    pub fn unwrap_or_else(self, op: |E| -> T) -> T 
unwrap_or_handle			    pub fn unwrap_or_handle(self, op: |E| -> T) -> T 
utf16_items			pub fn utf16_items<'a>(v: &'a [u16]) -> Utf16Items<'a> 
utf16_units			    fn utf16_units(&self) -> Utf16CodeUnits<'a> 
utf16_units			    fn utf16_units(&self) -> Utf16CodeUnits<'a>;
utf8_char_width			pub fn utf8_char_width(b: u8) -> uint 
visit_bool			    fn visit_bool(&mut self) -> bool;
visit_bot			    fn visit_bot(&mut self) -> bool;
visit_box			    fn visit_box(&mut self, mtbl: uint, inner: *const TyDesc) -> bool;
visit_char			    fn visit_char(&mut self) -> bool;
visit_class_field			    fn visit_class_field(&mut self, i: uint, name: &str, named: bool,
visit_enter_class			    fn visit_enter_class(&mut self, name: &str, named_fields: bool, n_fields: uint,
visit_enter_enum			    fn visit_enter_enum(&mut self, n_variants: uint,
visit_enter_enum_variant			    fn visit_enter_enum_variant(&mut self, variant: uint,
visit_enter_fn			    fn visit_enter_fn(&mut self, purity: uint, proto: uint,
visit_enter_rec			    fn visit_enter_rec(&mut self, n_fields: uint,
visit_enter_tup			    fn visit_enter_tup(&mut self, n_fields: uint,
visit_enum_variant_field			    fn visit_enum_variant_field(&mut self, i: uint, offset: uint,
visit_estr_fixed			    fn visit_estr_fixed(&mut self, n: uint, sz: uint, align: uint) -> bool;
visit_estr_slice			    fn visit_estr_slice(&mut self) -> bool;
visit_evec_fixed			    fn visit_evec_fixed(&mut self, n: uint, sz: uint, align: uint,
visit_evec_slice			    fn visit_evec_slice(&mut self, mtbl: uint, inner: *const TyDesc) -> bool;
visit_f32			    fn visit_f32(&mut self) -> bool;
visit_f64			    fn visit_f64(&mut self) -> bool;
visit_fn_input			    fn visit_fn_input(&mut self, i: uint, mode: uint,
visit_fn_output			    fn visit_fn_output(&mut self, retstyle: uint, variadic: bool,
visit_i16			    fn visit_i16(&mut self) -> bool;
visit_i32			    fn visit_i32(&mut self) -> bool;
visit_i64			    fn visit_i64(&mut self) -> bool;
visit_i8			    fn visit_i8(&mut self) -> bool;
visit_int			    fn visit_int(&mut self) -> bool;
visit_leave_class			    fn visit_leave_class(&mut self, name: &str, named_fields: bool, n_fields: uint,
visit_leave_enum			    fn visit_leave_enum(&mut self, n_variants: uint,
visit_leave_enum_variant			    fn visit_leave_enum_variant(&mut self, variant: uint,
visit_leave_fn			    fn visit_leave_fn(&mut self, purity: uint, proto: uint,
visit_leave_rec			    fn visit_leave_rec(&mut self, n_fields: uint,
visit_leave_tup			    fn visit_leave_tup(&mut self, n_fields: uint,
visit_nil			    fn visit_nil(&mut self) -> bool;
visit_param			    fn visit_param(&mut self, i: uint) -> bool;
visit_ptr			    fn visit_ptr(&mut self, mtbl: uint, inner: *const TyDesc) -> bool;
visit_rec_field			    fn visit_rec_field(&mut self, i: uint, name: &str,
visit_rptr			    fn visit_rptr(&mut self, mtbl: uint, inner: *const TyDesc) -> bool;
visit_self			    fn visit_self(&mut self) -> bool;
visit_trait			    fn visit_trait(&mut self, name: &str) -> bool;
visit_tup_field			    fn visit_tup_field(&mut self, i: uint, inner: *const TyDesc) -> bool;
visit_tydesc			    pub fn visit_tydesc(td: *const TyDesc, tv: &mut TyVisitor);
visit_u16			    fn visit_u16(&mut self) -> bool;
visit_u32			    fn visit_u32(&mut self) -> bool;
visit_u64			    fn visit_u64(&mut self) -> bool;
visit_u8			    fn visit_u8(&mut self) -> bool;
visit_uint			    fn visit_uint(&mut self) -> bool;
visit_uniq			    fn visit_uniq(&mut self, mtbl: uint, inner: *const TyDesc) -> bool;
volatile_copy_memory			    pub fn volatile_copy_memory<T>(dst: *mut T, src: *const T, count: uint);
volatile_copy_nonoverlapping_memory			    pub fn volatile_copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T,
volatile_load			    pub fn volatile_load<T>(src: *const T) -> T;
volatile_set_memory			    pub fn volatile_set_memory<T>(dst: *mut T, val: u8, count: uint);
volatile_store			    pub fn volatile_store<T>(dst: *mut T, val: T);
while_some			    pub fn while_some(self, f: |v: T| -> Option<T>) 
windows			    fn windows(self, size: uint) -> Windows<'a, T> 
windows			    fn windows(self, size: uint) -> Windows<'a, T>;
with_padding			    fn with_padding(&mut self,
words			    fn words(&self) -> Words<'a> 
words			    fn words(&self) -> Words<'a>;
write			                fn write(&mut self, bytes: &[u8]) -> fmt::Result 
write			    fn write(&mut self, bytes: &[u8]) -> Result;
write			    pub fn write(&mut self, data: &[u8]) -> Result 
write			pub fn write(output: &mut FormatWriter, args: &Arguments) -> Result 
write			pub unsafe fn write<T>(dst: *mut T, src: T) 
write_fmt			    fn write_fmt(&mut self, args: &Arguments) -> Result { write(self, args) }
write_fmt			    pub fn write_fmt(&mut self, fmt: &Arguments) -> Result 
zero			            fn zero() -> 
zero			    fn zero() -> Self;
zero_memory			pub unsafe fn zero_memory<T>(dst: *mut T, count: uint) 
zeroed			pub unsafe fn zeroed<T>() -> T 
zip			    fn zip<B, U: Iterator<B>>(self, other: U) -> Zip<Self, U> 
