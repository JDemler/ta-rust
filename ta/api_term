Attr			    pub enum Attr 
Flags			impl Flags 
Flags			struct Flags 
FormatOp			enum FormatOp 
FormatOp			impl FormatOp 
FormatState			enum FormatState 
GetStdHandle			    fn GetStdHandle(which: libc::DWORD) -> libc::HANDLE;
Param			pub enum Param 
SetConsoleTextAttribute			    fn SetConsoleTextAttribute(handle: libc::HANDLE, attr: libc::WORD) -> libc::BOOL;
States			enum States 
TermInfo			pub struct TermInfo 
Terminal			pub trait Terminal<T: Writer>: Writer 
TerminfoTerminal			pub struct TerminfoTerminal<T> 
Variables			impl Variables 
Variables			pub struct Variables 
WinConsole			pub struct WinConsole<T> 
Writer			impl Writer for WriterWrapper 
WriterWrapper			pub struct WriterWrapper 
apply			    fn apply(&mut self) 
attr			    fn attr(&mut self, attr: attr::Attr) -> IoResult<bool>;
attr			pub mod attr 
attr			    fn attr(&mut self, attr: attr::Attr) -> IoResult<bool> 
attr			    fn attr(&mut self, attr: attr::Attr) -> IoResult<bool> 
bg			    fn bg(&mut self, color: color::Color) -> IoResult<bool>;
bg			    fn bg(&mut self, color: color::Color) -> IoResult<bool> 
bg			    fn bg(&mut self, color: color::Color) -> IoResult<bool> 
cap_for_attr			fn cap_for_attr(attr: attr::Attr) -> &'static str 
color			pub mod color 
color_to_bits			fn color_to_bits(color: color::Color) -> u16 
compiled			    pub mod compiled;
dim_if_necessary			    fn dim_if_necessary(&self, color: color::Color) -> color::Color 
expand			pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)
fg			    fn fg(&mut self, color: color::Color) -> IoResult<bool>;
fg			    fn fg(&mut self, color: color::Color) -> IoResult<bool> 
fg			    fn fg(&mut self, color: color::Color) -> IoResult<bool> 
flush			    fn flush(&mut self) -> IoResult<()> 
flush			    fn flush(&mut self) -> IoResult<()> 
flush			    fn flush(&mut self) -> IoResult<()> 
format			fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> 
from_char			    fn from_char(c: char) -> FormatOp 
get_dbpath_for_term			pub fn get_dbpath_for_term(term: &str) -> Option<Box<Path>> 
get_mut			    fn get_mut<'a>(&'a mut self) -> &'a mut T;
get_mut			    fn get_mut<'a>(&'a mut self) -> &'a mut T { &mut self.out }
get_mut			    fn get_mut<'a>(&'a mut self) -> &'a mut T { &mut self.buf }
get_ref			    fn get_ref<'a>(&'a self) -> &'a T;
get_ref			    fn get_ref<'a>(&'a self) -> &'a T { &self.out }
get_ref			    fn get_ref<'a>(&'a self) -> &'a T { &self.buf }
msys_terminfo			pub fn msys_terminfo() -> Box<TermInfo> 
new			    fn new(out: T) -> Option<Self>;
new			    fn new(out: T) -> Option<TerminfoTerminal<T>> 
new			    fn new() -> Flags 
new			    pub fn new() -> Variables 
new			    fn new(out: T) -> Option<WinConsole<T>> 
open			pub fn open(term: &str) -> Result<File, String> 
parm			pub mod parm;
parse			pub fn parse(file: &mut io::Reader, longnames: bool)
parser			pub mod parser 
reset			    fn reset(&mut self) -> IoResult<()>;
reset			    fn reset(&mut self) -> IoResult<()> 
reset			    fn reset(&mut self) -> IoResult<()> 
searcher			pub mod searcher;
stderr			pub fn stderr() -> Option<Box<Terminal<WriterWrapper> + Send> + Send> 
stdout			pub fn stdout() -> Option<Box<Terminal<WriterWrapper> + Send>> 
supports_attr			    fn supports_attr(&self, attr: attr::Attr) -> bool;
supports_attr			    fn supports_attr(&self, attr: attr::Attr) -> bool 
supports_attr			    fn supports_attr(&self, attr: attr::Attr) -> bool 
terminfo			pub mod terminfo;
test			mod test 
test			mod test 
to_char			    fn to_char(self) -> char 
unwrap			    fn unwrap(self) -> T;
unwrap			    fn unwrap(self) -> T { self.out }
unwrap			    fn unwrap(self) -> T { self.buf }
win			mod win;
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
x			    fn x(t: &str) -> String 
