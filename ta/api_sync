AtomicOption			pub struct AtomicOption<T> 
Barrier			impl Barrier 
Barrier			pub struct Barrier 
BarrierState			struct BarrierState 
Blocker			enum Blocker 
Buffer			struct Buffer<T> 
Buffer			struct Buffer<T> 
BufferPool			pub struct BufferPool<T> 
Condvar			pub struct Condvar<'a> 
Condvar			pub struct Condvar<'a> 
Deque			struct Deque<T> 
Drop			impl Drop for Select 
Drop			            impl Drop for Unwinder 
Drop			impl Drop for Mutex 
DummyNode			pub struct DummyNode 
DuplexStream			pub struct DuplexStream<S, R> 
Failure			pub enum Failure<T> 
Failure			pub enum Failure 
Failure			pub enum Failure<T> 
Failure			pub enum Failure 
Flavor			enum Flavor<T> 
Flavor			enum Flavor 
Guard			pub struct Guard<'a> 
Handle			pub struct Handle<'rx, T> 
Inner			enum Inner<'a> 
Iterator			impl Iterator<*mut Handle<'static, ()>> for Packets 
Message			enum Message<T> 
Messages			pub struct Messages<'a, T> 
Mutex			pub struct Mutex<T> 
Mutex			impl Mutex 
Mutex			pub struct Mutex 
Mutex			impl Mutex 
Mutex			pub struct Mutex 
MutexGuard			pub struct MutexGuard<'a, T> 
MutexGuard			pub struct MutexGuard<'a> 
MyUpgrade			enum MyUpgrade<T> 
Node			struct Node 
Node			struct Node<T> 
Node			pub struct Node<T> 
Node			struct Node<T> 
Node			struct Node<T> 
Once			impl Once 
Once			pub struct Once 
Packet			pub struct Packet<T> 
Packet			pub trait Packet 
Packet			pub struct Packet<T> 
Packet			pub struct Packet<T> 
Packet			pub struct Packet<T> 
Packets			struct Packets { cur: *mut Handle<'static, ()> }
PoisonOnFail			struct PoisonOnFail<'a> 
PopResult			pub enum PopResult<T> 
Queue			impl Queue 
Queue			struct Queue 
Queue			pub struct Queue<T> 
Queue			pub struct Queue<T> 
Queue			pub struct Queue<T> 
Queue			pub struct Queue<T> 
RWLock			pub struct RWLock<T> 
RWLock			impl RWLock 
RWLock			pub struct RWLock 
RWLockMode			    pub enum RWLockMode { Read, Write, Downgrade, DowngradeRead }
RWLockReadGuard			pub struct RWLockReadGuard<'a, T> 
RWLockReadGuard			pub struct RWLockReadGuard<'a> 
RWLockWriteGuard			pub struct RWLockWriteGuard<'a, T> 
RWLockWriteGuard			pub struct RWLockWriteGuard<'a> 
ReacquireOrderLock			enum ReacquireOrderLock<'a> 
Receiver			pub struct Receiver<T> 
Select			impl Select 
Select			pub struct Select 
SelectionResult			pub enum SelectionResult<T> 
SelectionResult			pub enum SelectionResult<T> 
Sem			impl Sem<Vec<WaitQueue>> 
Sem			struct Sem<Q> 
SemCondGuard			struct SemCondGuard<'a> 
SemGuard			struct SemGuard<'a, Q> 
SemInner			struct SemInner<Q> 
Semaphore			impl Semaphore 
Semaphore			pub struct Semaphore 
SemaphoreGuard			pub struct SemaphoreGuard<'a> 
Sender			pub struct Sender<T> 
State			struct State<T> 
State			struct State<T> 
StaticMutex			impl StaticMutex 
StaticMutex			pub struct StaticMutex 
Stealer			pub struct Stealer<T> 
Stolen			pub enum Stolen<T> 
SyncSender			pub struct SyncSender<T> 
TryRecvError			pub enum TryRecvError 
TrySendError			pub enum TrySendError<T> 
UnsafeFlavor			trait UnsafeFlavor<T> 
Unwinder			            struct Unwinder 
UpgradeResult			pub enum UpgradeResult 
UpgradeResult			pub enum UpgradeResult 
WaitQueue			impl WaitQueue 
WaitQueue			struct WaitQueue 
Worker			pub struct Worker<T> 
abort_selection			    fn abort_selection(&self) -> bool 
abort_selection			    pub fn abort_selection(&mut self) -> Result<bool, Receiver<T>> 
abort_selection			    fn abort_selection(&self) -> bool;
abort_selection			    pub fn abort_selection(&mut self, _was_upgrade: bool) -> bool 
abort_selection			    pub fn abort_selection(&mut self,
abort_selection			    pub fn abort_selection(&self) -> bool 
access			    pub fn access<'a>(&'a self) -> SemGuard<'a, Q> 
access			    pub fn access<'a>(&'a self) -> SemaphoreGuard<'a> 
access_cond			    pub fn access_cond<'a>(&'a self) -> SemCondGuard<'a> 
access_shared			        fn access_shared(sharedstate: &mut int, x: &Arc<RWLock>,
access_shared			        fn access_shared(sharedstate: *mut int, m: &Arc<Mutex>, n: uint) 
acquire			    pub fn acquire(&self) { self.sem.acquire() }
acquire			    pub fn acquire(&self) 
add			    pub unsafe fn add(&mut self) 
alloc			    fn alloc(&mut self, bits: uint) -> Box<Buffer<T>> 
alloc			    unsafe fn alloc(&self) -> *mut Node<T> 
atomics			pub mod atomics;
broadcast			    pub fn broadcast(&self) -> uint { self.broadcast_on(0) }
broadcast			    fn broadcast(&self) -> uint 
broadcast			    pub fn broadcast(&self) -> uint { self.broadcast_on(0) }
broadcast_on			    pub fn broadcast_on(&self, condvar_id: uint) -> uint 
broadcast_on			    pub fn broadcast_on(&self, condvar_id: uint) -> uint 
buffer_alloc_size			fn buffer_alloc_size<T>(log_size: uint) -> uint 
bump			    fn bump(&mut self, amt: int) -> int 
bump			    fn bump(&mut self, amt: int) -> int 
can_recv			    fn can_recv(&self) -> bool 
can_recv			    pub fn can_recv(&mut self) -> Result<bool, Receiver<T>> 
can_recv			    fn can_recv(&self) -> bool;
can_recv			    pub fn can_recv(&mut self) -> bool 
can_recv			    pub fn can_recv(&mut self) -> Result<bool, Receiver<T>> 
can_recv			    pub fn can_recv(&self) -> bool 
cap			    fn cap(&self) -> uint { self.buf.len() }
casual_pop			    pub fn casual_pop(&self) -> Option<T> 
channel			pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) 
check			    fn check(flag: bool, name: &str) 
check_cvar_bounds			fn check_cvar_bounds<U>(
clone			    fn clone(&self) -> Sender<T> 
clone			    fn clone(&self) -> SyncSender<T> 
clone			    fn clone(&self) -> BufferPool<T> { BufferPool { pool: self.pool.clone() } }
clone			    fn clone(&self) -> Stealer<T> 
clone			    fn clone(&self) -> Queue<T> 
clone_chan			    pub fn clone_chan(&mut self) 
clone_chan			    pub fn clone_chan(&self) 
comm			pub mod comm;
cond			    fn cond<'a>(&'a self) -> &'a raw::Condvar<'b> 
decrement			    fn decrement(&mut self, task: BlockedTask) -> Result<(), BlockedTask> 
decrement			    fn decrement(&mut self, task: BlockedTask) -> Result<(), BlockedTask> 
deque			    pub fn deque(&self) -> (Worker<T>, Stealer<T>) 
deque			pub mod deque;
dequeue			    fn dequeue(&mut self) -> Option<BlockedTask> 
dequeue			    fn dequeue(&mut self) -> T 
deref			    fn deref<'a>(&'a self) -> &'a T { &*self._data }
deref			    fn deref<'a>(&'a self) -> &'a T { self._data }
deref_mut			    fn deref_mut<'a>(&'a mut self) -> &'a mut T { &mut *self._data }
destroy			    pub unsafe fn destroy(&self) 
do_send			    fn do_send(&mut self, t: Message<T>) -> UpgradeResult 
doit			    pub fn doit(&self, f: ||) 
downgrade			    pub fn downgrade(self) -> RWLockReadGuard<'a, T> 
downgrade			    pub fn downgrade(self) -> RWLockReadGuard<'a> 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			                fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop_chan			    pub fn drop_chan(&mut self) 
drop_chan			    pub fn drop_chan(&mut self) 
drop_chan			    pub fn drop_chan(&mut self) 
drop_chan			    pub fn drop_chan(&self) 
drop_full			    fn drop_full() 
drop_port			    pub fn drop_port(&mut self) 
drop_port			    pub fn drop_port(&mut self) 
drop_port			    pub fn drop_port(&mut self) 
drop_port			    pub fn drop_port(&self) 
duplex			pub fn duplex<S: Send, R: Send>() -> (DuplexStream<S, R>, DuplexStream<R, S>) 
duplex			mod duplex;
duplex_stream_1			    pub fn duplex_stream_1() 
elem			    unsafe fn elem(&self, i: int) -> *const T 
empty			    pub fn empty() -> AtomicOption<T> { AtomicOption { p: AtomicUint::new(0) } }
enqueue			    fn enqueue(&mut self, lock: &NativeMutex) 
enqueue			    fn enqueue(&mut self, t: T) 
f			            fn f() 
failing			fn failing() -> bool 
fill			    pub fn fill(&self, val: Box<T>, order: Ordering) -> Option<Box<T>> 
free			    fn free(&self, buf: Box<Buffer<T>>) 
get			    unsafe fn get(&self, i: int) -> T 
green_lock			    fn green_lock(&self, t: Box<Task>) 
green_unlock			    fn green_unlock(&self) 
handle			    pub fn handle<'a, T: Send>(&'a self, rx: &'a Receiver<T>) -> Handle<'a, T> 
id			    pub fn id(&self) -> uint { self.id }
inc			        fn inc() 
inherit_blocker			    pub fn inherit_blocker(&mut self, task: Option<BlockedTask>) 
inner			    unsafe fn inner<'a>(&'a self) -> &'a Flavor<T> 
inner_unsafe			    fn inner_unsafe<'a>(&'a self) -> &'a Unsafe<Flavor<T>> 
inner_unsafe			    fn inner_unsafe<'a>(&'a self) -> &'a Unsafe<Flavor<T>>;
is_empty			    pub fn is_empty(&self, order: Ordering) -> bool 
iter			    pub fn iter<'a>(&'a self) -> Messages<'a, T> 
iter			    fn iter(&self) -> Packets { Packets { cur: self.head } }
lock			    fn lock<'a>(&'a self) -> (LockGuard<'a>, &'a mut State<T>) 
lock			mod lock;
lock			    pub fn lock<'a>(&'a self) -> MutexGuard<'a, T> 
lock			    pub fn lock<'a>(&'a self) -> Guard<'a> { self.lock.lock() }
lock			    pub fn lock<'a>(&'a self) -> Guard<'a> 
lock			    pub fn lock<'a>(&'a self) -> MutexGuard<'a> 
lock_cond			        fn lock_cond(x: &Arc<RWLock>, blk: |c: &Condvar|) 
lock_rwlock_in_mode			    fn lock_rwlock_in_mode(x: &Arc<RWLock>, mode: RWLockMode, blk: ||) 
lots_and_lots			    fn lots_and_lots() 
many_stampede			    fn many_stampede() 
mask			    fn mask(&self) -> int { (1 << self.log_size) - 1 }
maybe_shrink			    unsafe fn maybe_shrink(&self, b: int, t: int) 
mpmc_bounded_queue			pub mod mpmc_bounded_queue;
mpsc_intrusive			mod mpsc_intrusive;
mpsc_queue			pub mod mpsc_queue;
mut_inner			    unsafe fn mut_inner<'a>(&'a self) -> &'a mut Flavor<T> 
mutex			pub mod mutex;
native_lock			    fn native_lock(&self, t: Box<Task>) 
native_unlock			    fn native_unlock(&self) 
new			    pub fn new(p: Box<T>) -> AtomicOption<T> 
new			    fn new(inner: Arc<Unsafe<sync::Packet<T>>>) -> SyncSender<T> 
new			    fn new(inner: Flavor<T>) -> Receiver<T> 
new			    fn new(inner: Flavor<T>) -> Sender<T> 
new			    pub fn new() -> Packet<T> 
new			    pub fn new() -> Select 
new			    pub fn new() -> Packet<T> 
new			    pub fn new() -> Packet<T> 
new			    pub fn new(cap: uint) -> Packet<T> 
new			    fn new(mut pool: BufferPool<T>) -> Deque<T> 
new			    pub fn new() -> BufferPool<T> 
new			    unsafe fn new(log_size: uint) -> Buffer<T> 
new			    fn new<'a>(flag: &'a mut bool, name: &str) -> PoisonOnFail<'a> 
new			    pub fn new(num_tasks: uint) -> Barrier 
new			    pub fn new(user_data: T) -> Mutex<T> 
new			    pub fn new(user_data: T) -> RWLock<T> 
new			    pub fn new() -> Queue<T> 
new			    pub fn new(t: T) -> Node<T> 
new			    pub fn new() -> Queue<T> 
new			    unsafe fn new(v: Option<T>) -> *mut Node<T> 
new			    fn new<'b>(lock: &'b StaticMutex) -> Guard<'b> 
new			    pub fn new() -> Mutex 
new			    fn new() -> WaitQueue 
new			    fn new(count: int, q: Q) -> Sem<Q> 
new			    pub fn new() -> Mutex { Mutex::new_with_condvars(1) }
new			    pub fn new() -> RWLock { RWLock::new_with_condvars(1) }
new			    pub fn new(count: int) -> Semaphore 
new			    fn new() -> *mut Node<T> 
new			    pub fn new(bound: uint) -> Queue<T> 
new_and_signal			    fn new_and_signal(count: int, num_condvars: uint) -> Sem<Vec<WaitQueue>> 
new_with_condvars			    pub fn new_with_condvars(user_data: T, num_condvars: uint) -> Mutex<T> 
new_with_condvars			    pub fn new_with_condvars(user_data: T, num_condvars: uint) -> RWLock<T> 
new_with_condvars			    pub fn new_with_condvars(num_condvars: uint) -> Mutex 
new_with_condvars			    pub fn new_with_condvars(num_condvars: uint) -> RWLock 
next			    fn next(&mut self) -> Option<T> { self.rx.recv_opt().ok() }
next			    fn next(&mut self) -> Option<*mut Handle<'static, ()>> 
next			    pub unsafe fn next(&self, ord: atomics::Ordering) -> *mut Node<T> 
no_runtime			    fn no_runtime() 
no_starvation			    fn no_starvation() 
one			pub mod one;
oneshot			mod oneshot;
option_empty			    fn option_empty() 
option_fill			    fn option_fill() 
option_swap			    fn option_swap() 
option_take			    fn option_take() 
peek			    pub fn peek<'a>(&'a self) -> Option<&'a mut T> 
pool			    pub fn pool<'a>(&'a self) -> &'a BufferPool<T> 
pop			    pub fn pop(&self) -> Option<T> 
pop			    unsafe fn pop(&self) -> Option<T> 
pop			    fn pop(&self) -> Option<T> 
pop			    pub fn pop(&self) -> Option<T> 
pop			    pub unsafe fn pop(&self) -> Option<*mut Node<T>> 
pop			    pub fn pop(&self) -> PopResult<T> 
pop			    pub fn pop(&self) -> Option<T> 
postinit_lock			    pub fn postinit_lock(&mut self) 
push			    pub fn push(&self, t: T) 
push			    unsafe fn push(&self, data: T) 
push			    fn push(&self, value: T) -> bool 
push			    pub fn push(&self, value: T) -> bool 
push			    pub unsafe fn push(&self, node: *mut Node<T>) 
push			    pub fn push(&self, t: T) 
push			    pub fn push(&self, t: T) 
put			    unsafe fn put(&self, i: int, t: T) 
raw			pub mod raw;
read			    pub fn read<'a>(&'a self) -> RWLockReadGuard<'a, T> 
read			    pub fn read<'a>(&'a self) -> RWLockReadGuard<'a> 
recv			    pub fn recv(&self) -> R 
recv			            fn recv(rx: Receiver<Box<int>>, i: int) 
recv			    pub fn recv(&self) -> T 
recv			    pub fn recv(&mut self) -> Result<T, Failure<T>> 
recv			    pub fn recv(&mut self) -> T { self.rx.recv() }
recv			    pub fn recv(&mut self) -> Result<T, Failure> 
recv			    pub fn recv(&mut self) -> Result<T, Failure<T>> 
recv			    pub fn recv(&self) -> Result<T, ()> 
recv_from_outside_runtime			    fn recv_from_outside_runtime() 
recv_opt			    pub fn recv_opt(&self) -> Result<R, ()> 
recv_opt			    pub fn recv_opt(&self) -> Result<T, ()> 
recv_opt			    pub fn recv_opt(&mut self) -> Result<T, ()> { self.rx.recv_opt() }
release			    pub fn release(&self) { self.sem.release() }
release			    pub fn release(&self) 
remove			    pub unsafe fn remove(&mut self) 
resize			    unsafe fn resize(&self, b: int, t: int, delta: int) -> Buffer<T> 
run_stampede			    fn run_stampede() 
rwlock_kill_helper			    fn rwlock_kill_helper(mode1: RWLockMode, mode2: RWLockMode) 
select			mod select;
send			    pub fn send(&self, x: S) 
send			            fn send(tx: Sender<Box<int>>, i: int) 
send			            fn send(tx: SyncSender<Box<int>>, i: int) 
send			    pub fn send(&self, t: T) 
send			    pub fn send(&mut self, t: T) -> Result<(), T> 
send			    pub fn send(&mut self, t: T) -> Result<(), T> 
send			    pub fn send(&mut self, t: T) -> Result<(), T> 
send			    pub fn send(&self, t: T) -> Result<(), T> 
send_from_outside_runtime			    fn send_from_outside_runtime() 
send_opt			    pub fn send_opt(&self, x: S) -> Result<(), S> 
send_opt			    pub fn send_opt(&self, t: T) -> Result<(), T> 
sent			    pub fn sent(&self) -> bool 
shared			mod shared;
signal			    pub fn signal(&self) -> bool { self.signal_on(0) }
signal			    fn signal(&self) -> bool 
signal			    pub fn signal(&self) -> bool { self.signal_on(0) }
signal_on			    pub fn signal_on(&self, condvar_id: uint) -> bool 
signal_on			    pub fn signal_on(&self, condvar_id: uint) -> bool 
size			    fn size(&self) -> uint { self.size }
size			    fn size(&self) -> int { 1 << self.log_size }
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke_bound			    fn smoke_bound() 
smoke_once			    fn smoke_once() 
smoke_static			    fn smoke_static() 
spsc_queue			pub mod spsc_queue;
stampede			    fn stampede(w: Worker<Box<int>>, s: Stealer<Box<int>>,
stampede_once			    fn stampede_once() 
start_selection			    fn start_selection(&self, mut task: BlockedTask) -> Result<(), BlockedTask>
start_selection			    pub fn start_selection(&mut self, task: BlockedTask) -> SelectionResult<T> 
start_selection			    fn start_selection(&self, task: BlockedTask) -> Result<(), BlockedTask>;
start_selection			    pub fn start_selection(&mut self,
start_selection			    pub fn start_selection(&mut self, task: BlockedTask) -> SelectionResult<T> 
start_selection			    pub fn start_selection(&self, task: BlockedTask) -> Result<(), BlockedTask>
std			mod std 
steal			    pub fn steal(&self) -> Stolen<T> 
steal			    unsafe fn steal(&self) -> Stolen<T> 
stealpush			    fn stealpush() 
stealpush_large			    fn stealpush_large() 
stream			mod stream;
stress			    fn stress() 
stress			    fn stress() 
stress_bound			        fn stress_bound(bound: uint) 
stress_factor			    pub fn stress_factor() -> uint 
swap			    pub fn swap(&self, val: Box<T>, order: Ordering) -> Option<Box<T>> 
swap_buffer			    unsafe fn swap_buffer(&self, b: int, old: *mut Buffer<T>,
sync			mod sync;
sync_channel			pub fn sync_channel<T: Send>(bound: uint) -> (SyncSender<T>, Receiver<T>) 
sync_tests			mod sync_tests 
take			    pub fn take(&self, order: Ordering) -> Option<Box<T>> 
take_to_wake			    fn take_to_wake(&mut self) -> BlockedTask 
take_to_wake			    fn take_to_wake(&mut self) -> BlockedTask 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			    fn test() 
test			    fn test() 
test			mod test 
test			mod test 
test			mod test 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
try_lock			    pub fn try_lock<'a>(&'a self) -> Option<Guard<'a>> 
try_recv			    pub fn try_recv(&self) -> Result<R, comm::TryRecvError> 
try_recv			    pub fn try_recv(&self) -> Result<T, TryRecvError> 
try_recv			    pub fn try_recv(&mut self) -> Result<T, Failure<T>> 
try_recv			    pub fn try_recv(&mut self) -> Result<T, Failure> 
try_recv			    pub fn try_recv(&mut self) -> Result<T, Failure<T>> 
try_recv			    pub fn try_recv(&self) -> Result<T, Failure> 
try_send			    pub fn try_send(&self, t: T) -> Result<(), TrySendError<T>> 
try_send			    pub fn try_send(&self, t: T) -> Result<(), super::TrySendError<T>> 
trylock			    fn trylock() 
unlock			    fn unlock(&self) 
unset			    fn unset(&self, mut state: uint, bit: uint) 
upgrade			    pub fn upgrade(&mut self, up: Receiver<T>) -> UpgradeResult 
upgrade			    pub fn upgrade(&mut self, up: Receiver<T>) -> UpgradeResult 
wait			    pub fn wait(&self) -> uint 
wait			fn wait(slot: &mut Blocker, f: fn(BlockedTask) -> Blocker,
wait			    pub fn wait(&self) { self.wait_on(0) }
wait			    pub fn wait(&self) 
wait			    pub fn wait(&self) { self.wait_on(0) }
wait2			    fn wait2(&self, do_preflight_checks: bool) -> uint 
wait_end			    fn wait_end(&self) -> WaitEnd 
wait_on			    pub fn wait_on(&self, condvar_id: uint) 
wait_on			    pub fn wait_on(&self, condvar_id: uint) 
wakeup			fn wakeup(task: BlockedTask, guard: LockGuard) 
wakeup_senders			    fn wakeup_senders(&self, waited: bool,
with			    unsafe fn with(&self, f: |&mut SemInner<Q>|) 
with_capacity			    fn with_capacity(capacity: uint) -> State<T> 
with_capacity			    pub fn with_capacity(capacity: uint) -> Queue<T> 
write			    pub fn write<'a>(&'a self) -> RWLockWriteGuard<'a, T> 
write			    pub fn write<'a>(&'a self) -> RWLockWriteGuard<'a> 
