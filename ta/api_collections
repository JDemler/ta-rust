AbsIter			struct AbsIter<T> 
AbsTraversal			struct AbsTraversal<Impl> 
Add for String			impl<'a> Add<&'a str> for String 
Add for Vec			impl<'a, T: Clone> Add<&'a [T]> for Vec<T> 
AsSlice for Vec			impl<T> AsSlice<T> for Vec<T> 
BTreeMap			impl<K, V> BTreeMap<K, V> 
BTreeMap			impl<K: Ord, V> BTreeMap<K, V> 
BTreeMap			pub struct BTreeMap<K, V> 
BTreeSet			impl<T: Ord> BTreeSet<T> 
BTreeSet			impl<T> BTreeSet<T> 
BTreeSet			pub struct BTreeSet<T>
BadElem			        struct BadElem(int);
Bar			        enum Bar 
BinaryHeap			impl<T: Ord> BinaryHeap<T> 
BinaryHeap			pub struct BinaryHeap<T> 
BitAnd			impl<'a, 'b, T: Ord + Clone> BitAnd<&'b BTreeSet<T>> for &'a BTreeSet<T> 
BitAnd for EnumSet			impl<E:CLike> BitAnd for EnumSet<E> 
BitOr			impl<'a, 'b, T: Ord + Clone> BitOr<&'b BTreeSet<T>> for &'a BTreeSet<T> 
BitOr for EnumSet			impl<E:CLike> BitOr for EnumSet<E> 
BitXor			impl<'a, 'b, T: Ord + Clone> BitXor<&'b BTreeSet<T>> for &'a BTreeSet<T> 
BitXor for EnumSet			impl<E:CLike> BitXor for EnumSet<E> 
Bitv			impl Bitv 
Bitv			pub struct Bitv 
BitvSet			impl BitvSet 
BitvSet			pub struct BitvSet 
BorrowFrom			impl<T> BorrowFrom<Vec<T>> for [T] 
BorrowFrom for str			impl BorrowFrom<String> for str 
BorrowFromMut			impl<T> BorrowFromMut<Vec<T>> for [T] 
CLike			pub trait CLike 
CLike for Bar			        impl CLike for Bar 
CLike for Foo			    impl CLike for Foo 
CharEq for NotAscii			        impl CharEq for NotAscii 
Clone for Bitv			impl Clone for Bitv 
Clone for DList			impl<A: Clone> Clone for DList<A> 
Clone for Iter			impl<'a, T> Clone for Iter<'a, T> 
Clone for Iter			impl<'a, T> Clone for Iter<'a, T> 
Clone for Iter			impl<E> Clone for Iter<E> 
Clone for Iter			impl<'a, T> Clone for Iter<'a, T> 
Clone for Iter			impl<'a, V> Clone for Iter<'a, V> 
Clone for Keys			impl<'a, V> Clone for Keys<'a, V> 
Clone for Node			impl<K: Clone, V: Clone> Clone for Node<K, V> 
Clone for Rawlink			impl<T> Clone for Rawlink<T> 
Clone for RingBuf			impl<T: Clone> Clone for RingBuf<T> 
Clone for Values			impl<'a, V> Clone for Values<'a, V> 
Clone for Vec			impl<T:Clone> Clone for Vec<T> 
Clone for VecMap			impl<V:Clone> Clone for VecMap<V> 
Continuation			enum Continuation<A, B> 
Copy for EnumSet			impl<E> Copy for EnumSet<E> {}
Copy for Rawlink			impl<T> Copy for Rawlink<T> {}
Counter			    struct Counter<'a, 'b> 
DList			impl<T> DList<T> 
DList			pub struct DList<T> 
DecompositionType			enum DecompositionType 
Decompositions			pub struct Decompositions<'a> 
Default for BTreeMap			impl<K: Ord, V> Default for BTreeMap<K, V> 
Default for BTreeSet			impl<T: Ord> Default for BTreeSet<T> 
Default for BinaryHeap			impl<T: Ord> Default for BinaryHeap<T> 
Default for Bitv			impl Default for Bitv 
Default for BitvSet			impl Default for BitvSet 
Default for DList			impl<T> Default for DList<T> 
Default for RingBuf			impl<T> Default for RingBuf<T> 
Default for String			impl Default for String 
Default for Vec			impl<T> Default for Vec<T> 
Default for VecMap			impl<V> Default for VecMap<V> 
Deref for DerefString			impl<'a> Deref for DerefString<'a> 
Deref for DerefVec			impl<'a, T> Deref for DerefVec<'a, T> 
Deref for IdRef			    impl<'id, T> Deref for IdRef<'id, T> 
DerefMut for IdRef			    impl<'id, T> DerefMut for IdRef<'id, T> 
DerefString			pub struct DerefString<'a> 
DerefVec			pub struct DerefVec<'a, T> 
Difference			pub struct Difference<'a>(TwoBitPositions<'a>);
Difference			pub struct Difference<'a, T:'a> 
Direction			enum Direction { Pos, Neg }
DoubleEndedIterator			        impl<'a, V> DoubleEndedIterator for 
DoubleEndedIterator for AbsIter			impl<K, V, E, T> DoubleEndedIterator for AbsIter<T> where
DoubleEndedIterator for Drain			impl<'a, T: 'a> DoubleEndedIterator for Drain<'a, T> 
DoubleEndedIterator for Drain			impl<'a, T: 'a> DoubleEndedIterator for Drain<'a, T> 
DoubleEndedIterator for Drain			impl<'a, T> DoubleEndedIterator for Drain<'a, T> 
DoubleEndedIterator for IntoIter			impl<T> DoubleEndedIterator for IntoIter<T> 
DoubleEndedIterator for IntoIter			impl<K, V> DoubleEndedIterator for IntoIter<K, V> 
DoubleEndedIterator for IntoIter			impl<T> DoubleEndedIterator for IntoIter<T> 
DoubleEndedIterator for IntoIter			impl<A> DoubleEndedIterator for IntoIter<A> 
DoubleEndedIterator for IntoIter			impl<T> DoubleEndedIterator for IntoIter<T> 
DoubleEndedIterator for IntoIter			impl<T> DoubleEndedIterator for IntoIter<T> 
DoubleEndedIterator for IntoIter			impl<V> DoubleEndedIterator for IntoIter<V> 
DoubleEndedIterator for Iter			impl<'a, T> DoubleEndedIterator for Iter<'a, T> 
DoubleEndedIterator for Iter			impl<'a> DoubleEndedIterator for Iter<'a> 
DoubleEndedIterator for Iter			impl<'a, K, V> DoubleEndedIterator for Iter<'a, K, V> 
DoubleEndedIterator for Iter			impl<'a, T> DoubleEndedIterator for Iter<'a, T> 
DoubleEndedIterator for Iter			impl<'a, A> DoubleEndedIterator for Iter<'a, A> 
DoubleEndedIterator for Iter			impl<'a, T> DoubleEndedIterator for Iter<'a, T> 
DoubleEndedIterator for IterMut			impl<'a, K, V> DoubleEndedIterator for IterMut<'a, K, V> 
DoubleEndedIterator for IterMut			impl<'a, A> DoubleEndedIterator for IterMut<'a, A> 
DoubleEndedIterator for IterMut			impl<'a, T> DoubleEndedIterator for IterMut<'a, T> 
DoubleEndedIterator for Keys			impl<'a, K, V> DoubleEndedIterator for Keys<'a, K, V> 
DoubleEndedIterator for Keys			impl<'a, V> DoubleEndedIterator for Keys<'a, V> 
DoubleEndedIterator for RawItems			impl<T> DoubleEndedIterator for RawItems<T> 
DoubleEndedIterator for Values			impl<'a, K, V> DoubleEndedIterator for Values<'a, K, V> 
DoubleEndedIterator for Values			impl<'a, V> DoubleEndedIterator for Values<'a, V> 
Drain			pub struct Drain<'a, T: 'a> 
Drain			pub struct Drain<'a, T: 'a> 
Drain			pub struct Drain<'a, T> 
Drop for BadElem			        impl Drop for BadElem 
Drop for DList			impl<T> Drop for DList<T> 
Drop for DerefVec			impl<'a, T> Drop for DerefVec<'a, T> 
Drop for Drain			impl<'a, T: 'a> Drop for Drain<'a, T> 
Drop for Drain			impl<'a, T> Drop for Drain<'a, T> 
Drop for DropCounter			    impl<'a> Drop for DropCounter<'a> 
Drop for Elem			        impl Drop for Elem 
Drop for Elem			        impl Drop for Elem 
Drop for IntoIter			impl<T> Drop for IntoIter<T> 
Drop for MoveTraversalImpl			impl<K, V> Drop for MoveTraversalImpl<K, V> 
Drop for Node			impl<K, V> Drop for Node<K, V> 
Drop for Nothing			        impl Drop for Nothing { fn drop(&mut self) { } }
Drop for PartialVecNonZeroSized			impl<T,U> Drop for PartialVecNonZeroSized<T,U> 
Drop for PartialVecZeroSized			impl<T,U> Drop for PartialVecZeroSized<T,U> 
Drop for RawItems			impl<T> Drop for RawItems<T> 
Drop for RingBuf			impl<T> Drop for RingBuf<T> 
Drop for Vec			impl<T> Drop for Vec<T> 
Drop for ZeroSized			        impl Drop for ZeroSized 
DropCounter			    struct DropCounter<'a> 
Edge			    pub enum Edge {}
Elem			        struct Elem;
Elem			        struct Elem(int);
ElementSwaps			impl ElementSwaps 
ElementSwaps			pub struct ElementSwaps 
ElemsAndEdges			struct ElemsAndEdges<Elems, Edges>(Elems, Edges);
Entry			impl<'a, K: Ord, V> Entry<'a, K, V> 
Entry			pub enum Entry<'a, K:'a, V:'a> 
EnumSet			impl<E:CLike> EnumSet<E> 
EnumSet			pub struct EnumSet<E> 
Eq for BTreeMap			impl<K: Eq, V: Eq> Eq for BTreeMap<K, V> {}
Eq for DList			impl<A: Eq> Eq for DList<A> {}
Eq for RingBuf			impl<A: Eq> Eq for RingBuf<A> {}
Eq for Vec			impl<T: Eq> Eq for Vec<T> {}
Eq for VecMap			impl<V: Eq> Eq for VecMap<V> {}
ExactSizeIterator for Drain			impl<'a, T: 'a> ExactSizeIterator for Drain<'a, T> {}
ExactSizeIterator for Drain			impl<'a, T: 'a> ExactSizeIterator for Drain<'a, T> {}
ExactSizeIterator for Drain			impl<'a, T> ExactSizeIterator for Drain<'a, T> {}
ExactSizeIterator for IntoIter			impl<T> ExactSizeIterator for IntoIter<T> {}
ExactSizeIterator for IntoIter			impl<K, V> ExactSizeIterator for IntoIter<K, V> {}
ExactSizeIterator for IntoIter			impl<T> ExactSizeIterator for IntoIter<T> {}
ExactSizeIterator for IntoIter			impl<T> ExactSizeIterator for IntoIter<T> {}
ExactSizeIterator for IntoIter			impl<T> ExactSizeIterator for IntoIter<T> {}
ExactSizeIterator for Iter			impl<'a, T> ExactSizeIterator for Iter<'a, T> {}
ExactSizeIterator for Iter			impl<'a> ExactSizeIterator for Iter<'a> {}
ExactSizeIterator for Iter			impl<'a, K, V> ExactSizeIterator for Iter<'a, K, V> {}
ExactSizeIterator for Iter			impl<'a, T> ExactSizeIterator for Iter<'a, T> {}
ExactSizeIterator for Iter			impl<'a, A> ExactSizeIterator for Iter<'a, A> {}
ExactSizeIterator for Iter			impl<'a, T> ExactSizeIterator for Iter<'a, T> {}
ExactSizeIterator for IterMut			impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> {}
ExactSizeIterator for IterMut			impl<'a, A> ExactSizeIterator for IterMut<'a, A> {}
ExactSizeIterator for IterMut			impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}
ExactSizeIterator for Keys			impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> {}
ExactSizeIterator for Values			impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {}
Extend for BTreeMap			impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> 
Extend for BTreeSet			impl<T: Ord> Extend<T> for BTreeSet<T> 
Extend for BinaryHeap			impl<T: Ord> Extend<T> for BinaryHeap<T> 
Extend for Bitv			impl Extend<bool> for Bitv 
Extend for BitvSet			impl Extend<uint> for BitvSet 
Extend for DList			impl<A> Extend<A> for DList<A> 
Extend for EnumSet			impl<E:CLike> Extend<E> for EnumSet<E> 
Extend for RingBuf			impl<A> Extend<A> for RingBuf<A> 
Extend for String			impl Extend<char> for String 
Extend for String			impl<'a> Extend<&'a str> for String 
Extend for Vec			impl<T> Extend<T> for Vec<T> 
Extend for VecMap			impl<V> Extend<(uint, V)> for VecMap<V> 
FnMut			    impl<'a, 'b, 'c> FnMut(&'c int) -> bool for Counter<'a, 'b> 
Foo			    enum Foo 
Foo			    struct Foo;
ForceResult			pub enum ForceResult<NodeRef, Type> 
FromIterator for BTreeMap			impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> 
FromIterator for BTreeSet			impl<T: Ord> FromIterator<T> for BTreeSet<T> 
FromIterator for BinaryHeap			impl<T: Ord> FromIterator<T> for BinaryHeap<T> 
FromIterator for Bitv			impl FromIterator<bool> for Bitv 
FromIterator for BitvSet			impl FromIterator<uint> for BitvSet 
FromIterator for CowVec			impl<'a, T> FromIterator<T> for CowVec<'a, T> where T: Clone 
FromIterator for DList			impl<A> FromIterator<A> for DList<A> 
FromIterator for EnumSet			impl<E:CLike> FromIterator<E> for EnumSet<E> 
FromIterator for RingBuf			impl<A> FromIterator<A> for RingBuf<A> 
FromIterator for String			impl FromIterator<char> for String 
FromIterator for String			impl<'a> FromIterator<&'a str> for String 
FromIterator for Vec			impl<T> FromIterator<T> for Vec<T> 
FromIterator for VecMap			impl<V> FromIterator<(uint, V)> for VecMap<V> 
FromStr for String			impl FromStr for String 
FromUtf16Error			pub struct FromUtf16Error(());
FromUtf8Error			impl FromUtf8Error 
FromUtf8Error			pub struct FromUtf8Error 
Handle			impl<'a, K: 'a, V: 'a, NodeRef, NodeType> Handle<NodeRef, handle::KV, NodeType> where
Handle			impl<'a, K: 'a, V: 'a, NodeType> Handle<&'a Node<K, V>, handle::KV, NodeType> 
Handle			impl<'a, K: 'a, V: 'a, NodeType> Handle<&'a mut Node<K, V>, handle::KV, NodeType> 
Handle			impl<'a, K: 'a, V: 'a> Handle<&'a Node<K, V>, handle::Edge, handle::Internal> 
Handle			impl<'a, K: 'a, V: 'a> Handle<&'a mut Node<K, V>, handle::Edge, handle::Internal> 
Handle			impl<K, V, NodeRef, NodeType> Handle<NodeRef, handle::Edge, NodeType> where
Handle			impl<K, V, NodeRef, NodeType> Handle<NodeRef, handle::KV, NodeType> where
Handle			impl<K, V, NodeRef, Type, NodeType> Handle<NodeRef, Type, NodeType> where
Handle			impl<K, V, NodeRef> Handle<NodeRef, handle::Edge, handle::Internal> where
Handle			impl<K, V, NodeRef> Handle<NodeRef, handle::Edge, handle::Leaf> where
Handle			impl<K, V, NodeRef> Handle<NodeRef, handle::KV, handle::Internal> where
Handle			impl<K, V, NodeRef> Handle<NodeRef, handle::KV, handle::Leaf> where
Handle			impl<K, V, Type, NodeType> Handle<*mut Node<K, V>, Type, NodeType> 
Handle			pub struct Handle<NodeRef, Type, NodeType> 
IdRef			    pub struct IdRef<'id, T: 'id> 
Index for BTreeMap			impl<K: Ord, Q: ?Sized, V> Index<Q> for BTreeMap<K, V>
Index for Bitv			impl Index<uint> for Bitv 
Index for RingBuf			impl<A> Index<uint> for RingBuf<A> 
Index for Vec			impl<T> Index<uint> for Vec<T> 
Index for VecMap			impl<V> Index<uint> for VecMap<V> 
IndexMut for BTreeMap			impl<K: Ord, Q: ?Sized, V> IndexMut<Q> for BTreeMap<K, V>
IndexMut for RingBuf			impl<A> IndexMut<uint> for RingBuf<A> 
IndexMut for Vec			impl<T> IndexMut<uint> for Vec<T> 
IndexMut for VecMap			impl<V> IndexMut<uint> for VecMap<V> 
InsertionResult			pub enum InsertionResult<K, V> 
Internal			    pub enum Internal {}
Intersection			pub struct Intersection<'a>(Take<TwoBitPositions<'a>>);
Intersection			pub struct Intersection<'a, T:'a> 
IntoCow			impl<'a> IntoCow<'a, String, str> for &'a str 
IntoCow			impl<'a, T: 'a> IntoCow<'a, Vec<T>, [T]> for Vec<T> where T: Clone 
IntoCow			impl<'a, T> IntoCow<'a, Vec<T>, [T]> for &'a [T] where T: Clone 
IntoCow for String			impl IntoCow<'static, String, str> for String 
IntoIter			pub struct IntoIter<T> 
IntoIter			pub struct IntoIter<K, V> 
IntoIter			pub struct IntoIter<T> 
IntoIter			pub struct IntoIter<T> 
IntoIter			pub struct IntoIter<T> 
IntoIter			impl<T> IntoIter<T> 
IntoIter			pub struct IntoIter<T> 
IntoIter			pub struct IntoIter<V> 
Iter			pub struct Iter <'a, T: 'a> 
Iter			pub struct Iter<'a> 
Iter			pub struct Iter<'a, K: 'a, V: 'a> 
Iter			pub struct Iter<'a, T: 'a> 
Iter			pub struct Iter<'a, T:'a> 
Iter			impl<E:CLike> Iter<E> 
Iter			pub struct Iter<E> 
Iter			pub struct Iter<'a, T:'a> 
Iter			pub struct Iter<'a, V:'a> 
IterMut			pub struct IterMut<'a, K: 'a, V: 'a> 
IterMut			impl<'a, A> IterMut<'a, A> 
IterMut			pub struct IterMut<'a, T:'a> 
IterMut			pub struct IterMut<'a, T:'a> 
IterMut			pub struct IterMut<'a, V:'a> 
Iterator			        impl<'a, V> Iterator for 
Iterator for AbsIter			impl<K, V, E, T> Iterator for AbsIter<T> where
Iterator for Decompositions			impl<'a> Iterator for Decompositions<'a> 
Iterator for Difference			impl<'a> Iterator for Difference<'a> 
Iterator for Difference			impl<'a, T: Ord> Iterator for Difference<'a, T> 
Iterator for Drain			impl<'a, T: 'a> Iterator for Drain<'a, T> 
Iterator for Drain			impl<'a, T: 'a> Iterator for Drain<'a, T> 
Iterator for Drain			impl<'a, T> Iterator for Drain<'a, T> 
Iterator for ElementSwaps			impl Iterator for ElementSwaps 
Iterator for Intersection			impl<'a> Iterator for Intersection<'a> 
Iterator for Intersection			impl<'a, T: Ord> Iterator for Intersection<'a, T> 
Iterator for IntoIter			impl<T> Iterator for IntoIter<T> 
Iterator for IntoIter			impl<K, V> Iterator for IntoIter<K, V> 
Iterator for IntoIter			impl<T> Iterator for IntoIter<T> 
Iterator for IntoIter			impl<A> Iterator for IntoIter<A> 
Iterator for IntoIter			impl<T> Iterator for IntoIter<T> 
Iterator for IntoIter			impl<T> Iterator for IntoIter<T> 
Iterator for IntoIter			impl<V> Iterator for IntoIter<V> 
Iterator for Iter			impl<'a, T> Iterator for Iter<'a, T> 
Iterator for Iter			impl<'a> Iterator for Iter<'a> 
Iterator for Iter			impl<'a, K, V> Iterator for Iter<'a, K, V> 
Iterator for Iter			impl<'a, T> Iterator for Iter<'a, T> 
Iterator for Iter			impl<'a, A> Iterator for Iter<'a, A> 
Iterator for Iter			impl<E:CLike> Iterator for Iter<E> 
Iterator for Iter			impl<'a, T> Iterator for Iter<'a, T> 
Iterator for IterMut			impl<'a, K, V> Iterator for IterMut<'a, K, V> 
Iterator for IterMut			impl<'a, A> Iterator for IterMut<'a, A> 
Iterator for IterMut			impl<'a, T> Iterator for IterMut<'a, T> 
Iterator for Keys			impl<'a, K, V> Iterator for Keys<'a, K, V> 
Iterator for Keys			impl<'a, V> Iterator for Keys<'a, V> 
Iterator for Permutations			impl<T: Clone> Iterator for Permutations<T> 
Iterator for RawItems			impl<T> Iterator for RawItems<T> 
Iterator for Recompositions			impl<'a> Iterator for Recompositions<'a> 
Iterator for SetIter			impl<'a> Iterator for SetIter<'a> 
Iterator for SymmetricDifference			impl<'a> Iterator for SymmetricDifference<'a> 
Iterator for SymmetricDifference			impl<'a, T: Ord> Iterator for SymmetricDifference<'a, T> 
Iterator for TwoBitPositions			impl<'a> Iterator for TwoBitPositions<'a> 
Iterator for Union			impl<'a> Iterator for Union<'a> 
Iterator for Union			impl<'a, T: Ord> Iterator for Union<'a, T> 
Iterator for Utf16Units			impl<'a> Iterator for Utf16Units<'a> 
Iterator for Values			impl<'a, K, V> Iterator for Values<'a, K, V> 
Iterator for Values			impl<'a, V> Iterator for Values<'a, V> 
KV			    pub enum KV {}
Keys			pub struct Keys<'a, K: 'a, V: 'a> 
Keys			pub struct Keys<'a, V: 'a> 
Leaf			    pub enum Leaf {}
LeafOrInternal			    pub enum LeafOrInternal {}
MoveTraversalImpl			struct MoveTraversalImpl<K, V> 
Node			impl <K, V> Node<K, V> 
Node			impl<K, V> Node<K, V> 
Node			impl<K: Ord, V> Node<K, V> 
Node			pub struct Node<K, V> 
Node			impl<T> Node<T> 
Node			struct Node<T> 
NotAscii			        struct NotAscii(char);
Nothing			        struct Nothing;
OccupiedEntry			impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> 
OccupiedEntry			pub struct OccupiedEntry<'a, K:'a, V:'a> 
Ord for BTreeMap			impl<K: Ord, V: Ord> Ord for BTreeMap<K, V> 
Ord for Bitv			impl Ord for Bitv 
Ord for BitvSet			impl Ord for BitvSet 
Ord for DList			impl<A: Ord> Ord for DList<A> 
Ord for RingBuf			impl<A: Ord> Ord for RingBuf<A> 
Ord for Vec			impl<T: Ord> Ord for Vec<T> 
Ord for VecMap			impl<V: Ord> Ord for VecMap<V> 
PartialEq			        impl<'a> PartialEq<
PartialEq			        impl<'a> PartialEq<
PartialEq			impl<'a, 'b> PartialEq<CowString<'a>> for &'b str 
PartialEq			        impl<'a, 'b, A, B> PartialEq<CowVec<'a, A>> for 
PartialEq			        impl<'b, A, B> PartialEq<
PartialEq			        impl<'b, A, B> PartialEq<
PartialEq			impl<'a, A, B> PartialEq<CowVec<'a, A>> for Vec<B> where A: Clone, B: PartialEq<A> 
PartialEq			impl<'a, A, B> PartialEq<Vec<B>> for CowVec<'a, A> where A: PartialEq<B> + Clone 
PartialEq			impl<A, B> PartialEq<Vec<B>> for Vec<A> where A: PartialEq<B> 
PartialEq for BTreeMap			impl<K: PartialEq, V: PartialEq> PartialEq for BTreeMap<K, V> 
PartialEq for CowString			impl<'a, 'b> PartialEq<&'b str> for CowString<'a> 
PartialEq for CowVec			        impl<'a, 'b, A, B> PartialEq<
PartialEq for DList			impl<A: PartialEq> PartialEq for DList<A> 
PartialEq for RingBuf			impl<A: PartialEq> PartialEq for RingBuf<A> 
PartialEq for String			impl PartialEq for String 
PartialEq for VecMap			impl<V: PartialEq> PartialEq for VecMap<V> 
PartialOrd for BTreeMap			impl<K: PartialOrd, V: PartialOrd> PartialOrd for BTreeMap<K, V> 
PartialOrd for Bitv			impl PartialOrd for Bitv 
PartialOrd for BitvSet			impl PartialOrd for BitvSet 
PartialOrd for DList			impl<A: PartialOrd> PartialOrd for DList<A> 
PartialOrd for RingBuf			impl<A: PartialOrd> PartialOrd for RingBuf<A> 
PartialOrd for Vec			impl<T: PartialOrd> PartialOrd for Vec<T> 
PartialOrd for VecMap			impl<V: PartialOrd> PartialOrd for VecMap<V> 
PartialSearchStack			    impl<'a, K, V> PartialSearchStack<'a, K, V> 
PartialSearchStack			    pub struct PartialSearchStack<'a, K:'a, V:'a> 
PartialVecNonZeroSized			struct PartialVecNonZeroSized<T,U> 
PartialVecZeroSized			struct PartialVecZeroSized<T,U> 
Permutations			pub struct Permutations<T> 
Pusher			    impl<'id, 'a, K, V> Pusher<'id, 'a, K, V> 
Pusher			    pub struct Pusher<'id, 'a, K:'a, V:'a> 
RandomAccessIterator for Iter			impl<'a> RandomAccessIterator for Iter<'a> 
RandomAccessIterator for Iter			impl<'a, T> RandomAccessIterator for Iter<'a, T> 
RawItems			impl<T> RawItems<T> 
RawItems			struct RawItems<T> 
Rawlink			impl<T> Rawlink<T> 
Rawlink			struct Rawlink<T> 
RecCy			    struct RecCy 
RecompositionState			enum RecompositionState 
Recompositions			pub struct Recompositions<'a> 
RingBuf			impl<T: Clone> RingBuf<T> 
RingBuf			impl<T> RingBuf<T> 
RingBuf			pub struct RingBuf<T> 
SearchResult			pub enum SearchResult<NodeRef> 
SearchStack			    impl<'a, K, V, NodeType> SearchStack<'a, K, V, handle::KV, NodeType> 
SearchStack			    impl<'a, K, V> SearchStack<'a, K, V, handle::Edge, handle::Leaf> 
SearchStack			    impl<'a, K, V> SearchStack<'a, K, V, handle::KV, handle::Leaf> 
SearchStack			    impl<'a, K, V> SearchStack<'a, K, V, handle::KV, handle::LeafOrInternal> 
SearchStack			    pub struct SearchStack<'a, K:'a, V:'a, Type, NodeType> 
SetIter			pub struct SetIter<'a> 
Show for BTreeMap			impl<K: Show, V: Show> Show for BTreeMap<K, V> 
Show for BTreeSet			impl<T: Show> Show for BTreeSet<T> 
SizeDirection			struct SizeDirection 
SliceConcatExt			pub trait SliceConcatExt<T: ?Sized, U> 
SliceConcatExt			impl<S: Str> SliceConcatExt<str, String> for [S] 
SliceExt			impl<T> SliceExt for [T] 
SliceExt			pub trait SliceExt 
StackOp			enum StackOp<T> 
Str for CowString			impl<'a> Str for CowString<'a> 
Str for String			impl Str for String 
StrExt			pub trait StrExt: Index<FullRange, Output = str> 
StrExt for str			impl StrExt for str {}
String			impl String 
String			pub struct String 
Sub			impl<'a, 'b, T: Ord + Clone> Sub<&'b BTreeSet<T>> for &'a BTreeSet<T> 
Sub for EnumSet			impl<E:CLike> Sub for EnumSet<E> 
SymmetricDifference			pub struct SymmetricDifference<'a>(TwoBitPositions<'a>);
SymmetricDifference			pub struct SymmetricDifference<'a, T:'a> 
Taggy			    enum Taggy 
Taggypar			    enum Taggypar<T> 
ToOwned			impl<T: Clone> ToOwned<Vec<T>> for [T] 
ToOwned for str			impl ToOwned<String> for str 
ToString			pub trait ToString 
ToString for T			impl<T: fmt::String + ?Sized> ToString for T 
TraversalImpl			impl<K, V> TraversalImpl<K, V, Node<K, V>> for MoveTraversalImpl<K, V> 
TraversalImpl			trait TraversalImpl<K, V, E> 
TraversalItem			pub enum TraversalItem<K, V, E> 
Traverse			impl<'a, K, V> Traverse<&'a Node<K, V>> for Traversal<'a, K, V> 
Traverse			impl<'a, K, V> Traverse<&'a mut Node<K, V>> for MutTraversal<'a, K, V> 
Traverse			impl<K, V> Traverse<Node<K, V>> for MoveTraversal<K, V> 
Traverse			trait Traverse<N> 
TwoBitPositions			struct TwoBitPositions<'a> 
TwoVec			        struct TwoVec<T> 
Union			pub struct Union<'a>(TwoBitPositions<'a>);
Union			pub struct Union<'a, T:'a> 
Utf16Units			pub struct Utf16Units<'a> 
VacantEntry			impl<'a, K: Ord, V> VacantEntry<'a, K, V> 
VacantEntry			pub struct VacantEntry<'a, K:'a, V:'a> 
Values			pub struct Values<'a, K: 'a, V: 'a> 
Values			pub struct Values<'a, V: 'a> 
Vec			impl<T: Clone> Vec<T> 
Vec			impl<T: PartialEq> Vec<T> 
Vec			impl<T> Vec<T> 
Vec			pub struct Vec<T> 
VecMap			impl<V> VecMap<V> 
VecMap			pub struct VecMap<V> 
ZeroSized			        struct ZeroSized;
a_million_letter_a			        fn a_million_letter_a() -> String 
a_million_letter_x			        fn a_million_letter_x() -> String 
absorb			    fn absorb(&mut self, key: K, val: V, mut right: Node<K, V>) 
add			    fn add(mut self, other: &str) -> String 
add			    fn add(mut self, rhs: &[T]) -> Vec<T> 
all			    pub fn all(&self) -> bool 
alloc_or_realloc			unsafe fn alloc_or_realloc<T>(ptr: *mut T, old_size: uint, size: uint) -> *mut T 
any			    pub fn any(&self) -> bool 
append			    pub fn append(&mut self, other: &mut DList<T>) 
as_bytes			    fn as_bytes(&self) -> &[u8] 
as_bytes			    pub fn as_bytes<'a>(&'a self) -> &'a [u8] 
as_mut_ptr			    fn as_mut_ptr(&mut self) -> *mut Self::Item;
as_mut_ptr			    fn as_mut_ptr(&mut self) -> *mut T 
as_mut_slice			    fn as_mut_slice(&mut self) -> &mut [Self::Item];
as_mut_slice			    fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] 
as_mut_slice			    pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] 
as_mut_slices			    pub fn as_mut_slices<'a>(&'a mut self) -> (&'a mut [T], &'a mut [T]) 
as_mut_vec			    pub unsafe fn as_mut_vec<'a>(&'a mut self) -> &'a mut Vec<u8> 
as_ptr			    fn as_ptr(&self) -> *const Self::Item;
as_ptr			    fn as_ptr(&self) -> *const T 
as_ptr			    fn as_ptr(&self) -> *const u8 
as_raw			    pub fn as_raw(&mut self) -> Handle<*mut Node<K, V>, Type, NodeType> 
as_slice			    fn as_slice<'a>(&'a self) -> &'a str 
as_slice			    fn as_slice<'b>(&'b self) -> &'b str 
as_slice			    fn as_slice<'a>(&'a self) -> &'a [T] 
as_slices			    pub fn as_slices<'a>(&'a self) -> (&'a [K], &'a [V]) 
as_slices			    pub fn as_slices<'a>(&'a self) -> (&'a [T], &'a [T]) 
as_slices_internal			    pub fn as_slices_internal<'a>(&'a self) -> (&'a [K], &'a [V], &'a [Node<K, V>]) 
as_slices_internal_mut			    pub fn as_slices_internal_mut<'a>(&'a mut self) -> (&'a mut [K], &'a mut [V],
as_slices_mut			    pub fn as_slices_mut<'a>(&'a mut self) -> (&'a mut [K], &'a mut [V]) 
as_string			pub fn as_string<'a>(x: &'a str) -> DerefString<'a> 
as_vec			pub fn as_vec<'a, T>(x: &'a [T]) -> DerefVec<'a, T> 
back			    pub fn back(&self) -> Option<&T> 
back			    pub fn back(&self) -> Option<&T> 
back_mut			    pub fn back_mut(&mut self) -> Option<&mut T> 
back_mut			    pub fn back_mut(&mut self) -> Option<&mut T> 
bench			mod bench 
bench			mod bench 
bench			mod bench 
bench			mod bench 
bench_bitv_big_iter			    fn bench_bitv_big_iter(b: &mut Bencher) 
bench_bitv_big_union			    fn bench_bitv_big_union(b: &mut Bencher) 
bench_bitv_set_big_fixed			    fn bench_bitv_set_big_fixed(b: &mut Bencher) 
bench_bitv_set_big_variable			    fn bench_bitv_set_big_variable(b: &mut Bencher) 
bench_bitv_set_small			    fn bench_bitv_set_small(b: &mut Bencher) 
bench_bitv_small_iter			    fn bench_bitv_small_iter(b: &mut Bencher) 
bench_bitvset_big			    fn bench_bitvset_big(b: &mut Bencher) 
bench_bitvset_iter			    fn bench_bitvset_iter(b: &mut Bencher) 
bench_bitvset_small			    fn bench_bitvset_small(b: &mut Bencher) 
bench_clone_0000			    fn bench_clone_0000(b: &mut Bencher) 
bench_clone_0010			    fn bench_clone_0010(b: &mut Bencher) 
bench_clone_0100			    fn bench_clone_0100(b: &mut Bencher) 
bench_clone_1000			    fn bench_clone_1000(b: &mut Bencher) 
bench_clone_from_01_0000_0000			    fn bench_clone_from_01_0000_0000(b: &mut Bencher) 
bench_clone_from_01_0000_0010			    fn bench_clone_from_01_0000_0010(b: &mut Bencher) 
bench_clone_from_01_0000_0100			    fn bench_clone_from_01_0000_0100(b: &mut Bencher) 
bench_clone_from_01_0000_1000			    fn bench_clone_from_01_0000_1000(b: &mut Bencher) 
bench_clone_from_01_0010_0000			    fn bench_clone_from_01_0010_0000(b: &mut Bencher) 
bench_clone_from_01_0010_0010			    fn bench_clone_from_01_0010_0010(b: &mut Bencher) 
bench_clone_from_01_0010_0100			    fn bench_clone_from_01_0010_0100(b: &mut Bencher) 
bench_clone_from_01_0100_0010			    fn bench_clone_from_01_0100_0010(b: &mut Bencher) 
bench_clone_from_01_0100_0100			    fn bench_clone_from_01_0100_0100(b: &mut Bencher) 
bench_clone_from_01_0100_1000			    fn bench_clone_from_01_0100_1000(b: &mut Bencher) 
bench_clone_from_01_1000_0100			    fn bench_clone_from_01_1000_0100(b: &mut Bencher) 
bench_clone_from_01_1000_1000			    fn bench_clone_from_01_1000_1000(b: &mut Bencher) 
bench_clone_from_10_0000_0000			    fn bench_clone_from_10_0000_0000(b: &mut Bencher) 
bench_clone_from_10_0000_0010			    fn bench_clone_from_10_0000_0010(b: &mut Bencher) 
bench_clone_from_10_0000_0100			    fn bench_clone_from_10_0000_0100(b: &mut Bencher) 
bench_clone_from_10_0000_1000			    fn bench_clone_from_10_0000_1000(b: &mut Bencher) 
bench_clone_from_10_0010_0000			    fn bench_clone_from_10_0010_0000(b: &mut Bencher) 
bench_clone_from_10_0010_0010			    fn bench_clone_from_10_0010_0010(b: &mut Bencher) 
bench_clone_from_10_0010_0100			    fn bench_clone_from_10_0010_0100(b: &mut Bencher) 
bench_clone_from_10_0100_0010			    fn bench_clone_from_10_0100_0010(b: &mut Bencher) 
bench_clone_from_10_0100_0100			    fn bench_clone_from_10_0100_0100(b: &mut Bencher) 
bench_clone_from_10_0100_1000			    fn bench_clone_from_10_0100_1000(b: &mut Bencher) 
bench_clone_from_10_1000_0100			    fn bench_clone_from_10_1000_0100(b: &mut Bencher) 
bench_clone_from_10_1000_1000			    fn bench_clone_from_10_1000_1000(b: &mut Bencher) 
bench_collect_into			    fn bench_collect_into(b: &mut test::Bencher) 
bench_connect			    fn bench_connect(b: &mut Bencher) 
bench_contains_bad_naive			    fn bench_contains_bad_naive(b: &mut Bencher) 
bench_contains_equal			    fn bench_contains_equal(b: &mut Bencher) 
bench_contains_short_long			    fn bench_contains_short_long(b: &mut Bencher) 
bench_contains_short_short			    fn bench_contains_short_short(b: &mut Bencher) 
bench_extend_0000_0000			    fn bench_extend_0000_0000(b: &mut Bencher) 
bench_extend_0000_0010			    fn bench_extend_0000_0010(b: &mut Bencher) 
bench_extend_0000_0100			    fn bench_extend_0000_0100(b: &mut Bencher) 
bench_extend_0000_1000			    fn bench_extend_0000_1000(b: &mut Bencher) 
bench_extend_0010_0010			    fn bench_extend_0010_0010(b: &mut Bencher) 
bench_extend_0100_0100			    fn bench_extend_0100_0100(b: &mut Bencher) 
bench_extend_1000_1000			    fn bench_extend_1000_1000(b: &mut Bencher) 
bench_from_elem_0000			    fn bench_from_elem_0000(b: &mut Bencher) 
bench_from_elem_0010			    fn bench_from_elem_0010(b: &mut Bencher) 
bench_from_elem_0100			    fn bench_from_elem_0100(b: &mut Bencher) 
bench_from_elem_1000			    fn bench_from_elem_1000(b: &mut Bencher) 
bench_from_fn_0000			    fn bench_from_fn_0000(b: &mut Bencher) 
bench_from_fn_0010			    fn bench_from_fn_0010(b: &mut Bencher) 
bench_from_fn_0100			    fn bench_from_fn_0100(b: &mut Bencher) 
bench_from_fn_1000			    fn bench_from_fn_1000(b: &mut Bencher) 
bench_from_iter_0000			    fn bench_from_iter_0000(b: &mut Bencher) 
bench_from_iter_0010			    fn bench_from_iter_0010(b: &mut Bencher) 
bench_from_iter_0100			    fn bench_from_iter_0100(b: &mut Bencher) 
bench_from_iter_1000			    fn bench_from_iter_1000(b: &mut Bencher) 
bench_from_slice_0000			    fn bench_from_slice_0000(b: &mut Bencher) 
bench_from_slice_0010			    fn bench_from_slice_0010(b: &mut Bencher) 
bench_from_slice_0100			    fn bench_from_slice_0100(b: &mut Bencher) 
bench_from_slice_1000			    fn bench_from_slice_1000(b: &mut Bencher) 
bench_grow_1025			    fn bench_grow_1025(b: &mut test::Bencher) 
bench_iter			    fn bench_iter(b: &mut Bencher, size: uint) 
bench_iter			    fn bench_iter(b: &mut test::Bencher) 
bench_iter_1000			    fn bench_iter_1000(b: &mut test::Bencher) 
bench_iter_mut			    fn bench_iter_mut(b: &mut test::Bencher) 
bench_iter_mut_rev			    fn bench_iter_mut_rev(b: &mut test::Bencher) 
bench_iter_rev			    fn bench_iter_rev(b: &mut test::Bencher) 
bench_mut_iter_1000			    fn bench_mut_iter_1000(b: &mut test::Bencher) 
bench_new			    fn bench_new(b: &mut test::Bencher) 
bench_new			    fn bench_new(b: &mut Bencher) 
bench_pop_back_100			    fn bench_pop_back_100(b: &mut test::Bencher) 
bench_pop_front_100			    fn bench_pop_front_100(b: &mut test::Bencher) 
bench_push_all_0000_0000			    fn bench_push_all_0000_0000(b: &mut Bencher) 
bench_push_all_0000_0010			    fn bench_push_all_0000_0010(b: &mut Bencher) 
bench_push_all_0000_0100			    fn bench_push_all_0000_0100(b: &mut Bencher) 
bench_push_all_0000_1000			    fn bench_push_all_0000_1000(b: &mut Bencher) 
bench_push_all_0010_0010			    fn bench_push_all_0010_0010(b: &mut Bencher) 
bench_push_all_0100_0100			    fn bench_push_all_0100_0100(b: &mut Bencher) 
bench_push_all_1000_1000			    fn bench_push_all_1000_1000(b: &mut Bencher) 
bench_push_all_move_0000_0000			    fn bench_push_all_move_0000_0000(b: &mut Bencher) 
bench_push_all_move_0000_0010			    fn bench_push_all_move_0000_0010(b: &mut Bencher) 
bench_push_all_move_0000_0100			    fn bench_push_all_move_0000_0100(b: &mut Bencher) 
bench_push_all_move_0000_1000			    fn bench_push_all_move_0000_1000(b: &mut Bencher) 
bench_push_all_move_0010_0010			    fn bench_push_all_move_0010_0010(b: &mut Bencher) 
bench_push_all_move_0100_0100			    fn bench_push_all_move_0100_0100(b: &mut Bencher) 
bench_push_all_move_1000_1000			    fn bench_push_all_move_1000_1000(b: &mut Bencher) 
bench_push_back			    fn bench_push_back(b: &mut test::Bencher) 
bench_push_back_100			    fn bench_push_back_100(b: &mut test::Bencher) 
bench_push_back_pop_back			    fn bench_push_back_pop_back(b: &mut test::Bencher) 
bench_push_char_one_byte			    fn bench_push_char_one_byte(b: &mut Bencher) 
bench_push_char_two_bytes			    fn bench_push_char_two_bytes(b: &mut Bencher) 
bench_push_front			    fn bench_push_front(b: &mut test::Bencher) 
bench_push_front_100			    fn bench_push_front_100(b: &mut test::Bencher) 
bench_push_front_pop_front			    fn bench_push_front_pop_front(b: &mut test::Bencher) 
bench_push_str			    fn bench_push_str(b: &mut Bencher) 
bench_push_str_one_byte			    fn bench_push_str_one_byte(b: &mut Bencher) 
bench_uint_small			    fn bench_uint_small(b: &mut Bencher) 
bench_with_capacity			    fn bench_with_capacity(b: &mut Bencher) 
bench_with_capacity_0000			    fn bench_with_capacity_0000(b: &mut Bencher) 
bench_with_capacity_0010			    fn bench_with_capacity_0010(b: &mut Bencher) 
bench_with_capacity_0100			    fn bench_with_capacity_0100(b: &mut Bencher) 
bench_with_capacity_1000			    fn bench_with_capacity_1000(b: &mut Bencher) 
binary_heap			pub mod binary_heap;
binary_search			    fn binary_search(&self, x: &Self::Item) -> Result<uint, uint> where Self::Item: Ord;
binary_search			    fn binary_search(&self, x: &T) -> Result<uint, uint> where T: Ord 
binary_search_by			    fn binary_search_by<F>(&self, f: F) -> Result<uint, uint> where
binary_search_by			    fn binary_search_by<F>(&self, f: F) -> Result<uint, uint>
binary_search_elem			    fn binary_search_elem(&self, x: &Self::Item) -> Result<uint, uint> where Self::Item: Ord 
bit			        fn bit(bitv: &Bitv, byte: uint, bit: uint) -> u8 
bit			fn bit<E:CLike>(e: &E) -> uint 
bit			mod bit;
bitand			        fn bitand(w1: u32, w2: u32) -> u32 { w1 & w2 }
bitand			    fn bitand(self, rhs: &BTreeSet<T>) -> BTreeSet<T> 
bitand			    fn bitand(self, e: EnumSet<E>) -> EnumSet<E> 
bitor			    fn bitor(self, rhs: &BTreeSet<T>) -> BTreeSet<T> 
bitor			    fn bitor(self, e: EnumSet<E>) -> EnumSet<E> 
bitv			pub mod bitv 
bitv_bench			mod bitv_bench 
bitv_set			pub mod bitv_set 
bitv_set_bench			mod bitv_set_bench 
bitv_set_test			mod bitv_set_test 
bitxor			        fn bitxor(w1: u32, w2: u32) -> u32 { w1 ^ w2 }
bitxor			    fn bitxor(self, rhs: &BTreeSet<T>) -> BTreeSet<T> 
bitxor			    fn bitxor(self, e: EnumSet<E>) -> EnumSet<E> 
blocks			    fn blocks(&self) -> Blocks 
blocks_for_bits			fn blocks_for_bits(bits: uint) -> uint 
blocks_mut			    fn blocks_mut(&mut self) -> MutBlocks 
borrow_from			    fn borrow_from(owned: &Vec<T>) -> &[T] { &owned[] }
borrow_from			    fn borrow_from(owned: &String) -> &str { &owned[] }
borrow_from_mut			    fn borrow_from_mut(owned: &mut Vec<T>) -> &mut [T] { &mut owned[] }
btree			mod btree;
btree_map			pub mod btree_map 
btree_set			pub mod btree_set 
buffer_as_mut_slice			    unsafe fn buffer_as_mut_slice(&mut self) -> &mut [T] 
buffer_as_slice			    unsafe fn buffer_as_slice(&self) -> &[T] 
buffer_read			    unsafe fn buffer_read(&mut self, off: uint) -> T 
buffer_write			    unsafe fn buffer_write(&mut self, off: uint, t: T) 
bytes			    fn bytes(&self) -> Bytes 
calculate_allocation			fn calculate_allocation(keys_size: uint, keys_align: uint,
calculate_allocation_generic			fn calculate_allocation_generic<K, V>(capacity: uint, is_leaf: bool) -> (uint, uint) 
calculate_offsets			fn calculate_offsets(keys_size: uint,
calculate_offsets_generic			fn calculate_offsets_generic<K, V>(capacity: uint, is_leaf: bool) -> (uint, uint) 
call_mut			        extern "rust-call" fn call_mut(&mut self, (&x,): (&'c int,)) -> bool 
canonical_sort			fn canonical_sort(comb: &mut [(char, u8)]) 
capacity			    pub fn capacity(&self) -> uint { self.data.capacity() }
capacity			    pub fn capacity(&self) -> uint 
capacity			    pub fn capacity(&self) -> uint 
capacity			    pub fn capacity(&self) -> uint { self.cap - 1 }
capacity			    pub fn capacity(&self) -> uint 
capacity			    pub fn capacity(&self) -> uint 
capacity			    pub fn capacity(&self) -> uint 
capacity_from_b			fn capacity_from_b(b: uint) -> uint 
case			        fn case(a: Vec<uint>, b: Vec<uint>) 
char_at			    fn char_at(&self, i: uint) -> char 
char_at_reverse			    fn char_at_reverse(&self, i: uint) -> char 
char_indices			    fn char_indices(&self) -> CharIndices 
char_indicesator			    fn char_indicesator(b: &mut Bencher) 
char_indicesator_rev			    fn char_indicesator_rev(b: &mut Bencher) 
char_iterator			    fn char_iterator(b: &mut Bencher) 
char_iterator_ascii			    fn char_iterator_ascii(b: &mut Bencher) 
char_iterator_for			    fn char_iterator_for(b: &mut Bencher) 
char_iterator_rev			    fn char_iterator_rev(b: &mut Bencher) 
char_iterator_rev_for			    fn char_iterator_rev_for(b: &mut Bencher) 
char_range_at			    fn char_range_at(&self, start: uint) -> CharRange 
char_range_at_reverse			    fn char_range_at_reverse(&self, start: uint) -> CharRange 
chars			    fn chars(&self) -> Chars 
check			    fn check<F>(a: &[int], b: &[int], expected: &[int], f: F) where
check_difference			        fn check_difference(a: &[int], b: &[int], expected: &[int]) 
check_intersection			        fn check_intersection(a: &[int], b: &[int], expected: &[int]) 
check_links			    pub fn check_links<T>(list: &DList<T>) 
check_symmetric_difference			        fn check_symmetric_difference(a: &[int], b: &[int],
check_to_vec			    fn check_to_vec(mut data: Vec<int>) 
check_union			        fn check_union(a: &[int], b: &[int],
chunks			    fn chunks(&self, size: uint) -> Chunks<Self::Item>;
chunks			    fn chunks<'a>(&'a self, size: uint) -> Chunks<'a, T> 
chunks_mut			    fn chunks_mut(&mut self, chunk_size: uint) -> ChunksMut<Self::Item>;
chunks_mut			    fn chunks_mut<'a>(&'a mut self, chunk_size: uint) -> ChunksMut<'a, T> 
clear			    pub fn clear(&mut self) { self.drain(); }
clear			    pub fn clear(&mut self) 
clear			    pub fn clear(&mut self) 
clear			    pub fn clear(&mut self) 
clear			    pub fn clear(&mut self) 
clear			    pub fn clear(&mut self) 
clear			    pub fn clear(&mut self) 
clear			    pub fn clear(&mut self) 
clear			    pub fn clear(&mut self) 
clear			    pub fn clear(&mut self) { self.v.clear() }
clone			    fn clone(&self) -> Iter<'a, T> 
clone			    fn clone(&self) -> Bitv 
clone			    fn clone(&self) -> Node<K, V> 
clone			    fn clone(&self) -> DList<A> 
clone			    fn clone(&self) -> Iter<'a, T> 
clone			    fn clone(&self) -> Rawlink<T> 
clone			    fn clone(&self) -> Iter<E> 
clone			    fn clone(&self) -> Iter<'a, T> 
clone			    fn clone(&self) -> RingBuf<T> 
clone			    fn clone(&self) -> Vec<T> { ::slice::SliceExt::to_vec(self.as_slice()) }
clone			    fn clone(&self) -> Iter<'a, V> 
clone			    fn clone(&self) -> Keys<'a, V> 
clone			    fn clone(&self) -> Values<'a, V> 
clone			    fn clone(&self) -> VecMap<V> 
clone_from			    fn clone_from(&mut self, source: &Bitv) 
clone_from			    fn clone_from(&mut self, other: &Vec<T>) 
clone_from			    fn clone_from(&mut self, source: &VecMap<V>) 
clone_from_slice			    fn clone_from_slice(&mut self, &[Self::Item]) -> uint where Self::Item: Clone;
clone_from_slice			    fn clone_from_slice(&mut self, src: &[T]) -> uint where T: Clone 
cmp			    fn cmp(&self, other: &Bitv) -> Ordering 
cmp			    fn cmp(&self, other: &BitvSet) -> Ordering 
cmp			    fn cmp(&self, other: &BTreeMap<K, V>) -> Ordering 
cmp			    fn cmp(&self, other: &DList<A>) -> Ordering 
cmp			    fn cmp(&self, other: &RingBuf<A>) -> Ordering 
cmp			    fn cmp(&self, other: &Vec<T>) -> Ordering 
cmp			    fn cmp(&self, other: &VecMap<V>) -> Ordering 
cmp::Eq for Bitv			impl cmp::Eq for Bitv {}
cmp::Eq for BitvSet			impl cmp::Eq for BitvSet {}
cmp::PartialEq for Bitv			impl cmp::PartialEq for Bitv 
cmp::PartialEq for BitvSet			impl cmp::PartialEq for BitvSet 
cmp_opt			fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>,
concat			    fn concat(&self) -> U;
concat			    fn concat(&self) -> Vec<T> 
concat			    fn concat(b: &mut Bencher) 
concat			    fn concat(&self) -> String 
connect			    fn connect(&self, sep: &T) -> U;
connect			    fn connect(&self, sep: &T) -> Vec<T> 
connect			    fn connect(b: &mut Bencher) 
connect			    fn connect(&self, sep: &str) -> String 
contains			    pub fn contains(&self, value: &uint) -> bool 
contains			    pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool where Q: BorrowFrom<T> + Ord 
contains			    pub fn contains(&self, e: &E) -> bool 
contains			    fn contains(&self, x: &Self::Item) -> bool where Self::Item: PartialEq;
contains			    fn contains(&self, x: &T) -> bool where T: PartialEq 
contains			    fn contains(&self, pat: &str) -> bool 
contains_char			    fn contains_char<P: CharEq>(&self, pat: P) -> bool 
contains_key			    pub fn contains_key<Q: ?Sized>(&self, key: &Q) -> bool where Q: BorrowFrom<K> + Ord 
contains_key			    pub fn contains_key(&self, key: &uint) -> bool 
contains_last_element			    fn contains_last_element(b: &mut Bencher) 
copy			    unsafe fn copy(&self, dst: uint, src: uint, len: uint) 
copy_nonoverlapping			    unsafe fn copy_nonoverlapping(&self, dst: uint, src: uint, len: uint) 
count			fn count(tail: uint, head: uint, size: uint) -> uint 
dealloc			unsafe fn dealloc<T>(ptr: *mut T, len: uint) 
dedup			    pub fn dedup(&mut self) 
default			    fn default() -> BinaryHeap<T> { BinaryHeap::new() }
default			    fn default() -> Bitv { Bitv::new() }
default			    fn default() -> BitvSet { BitvSet::new() }
default			    fn default() -> BTreeMap<K, V> 
default			    fn default() -> BTreeSet<T> 
default			    fn default() -> DList<T> { DList::new() }
default			    fn default() -> RingBuf<T> { RingBuf::new() }
default			    fn default() -> String 
default			    fn default() -> Vec<T> 
default			    fn default() -> VecMap<V> { VecMap::new() }
deref			        fn deref(&self) -> &T 
deref			    fn deref<'a>(&'a self) -> &'a str 
deref			    fn deref<'b>(&'b self) -> &'b String 
deref			    fn deref<'a>(&'a self) -> &'a [T] { self.as_slice() }
deref			    fn deref<'b>(&'b self) -> &'b Vec<T> 
deref_mut			        fn deref_mut(&mut self) -> &mut T 
deref_mut			    fn deref_mut<'a>(&'a mut self) -> &'a mut [T] { self.as_mut_slice() }
destroy			    unsafe fn destroy(&mut self) 
diff			        fn diff(w1: u32, w2: u32) -> u32 { w1 & !w2 }
difference			    pub fn difference(&mut self, other: &Bitv) -> bool 
difference			    pub fn difference<'a>(&'a self, other: &'a BitvSet) -> Difference<'a> 
difference			    pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> Difference<'a, T> 
difference_with			    pub fn difference_with(&mut self, other: &BitvSet) 
dlist			pub mod dlist;
do_bench_clone			    fn do_bench_clone(b: &mut Bencher, src_len: uint) 
do_bench_clone_from			    fn do_bench_clone_from(b: &mut Bencher, times: uint, dst_len: uint, src_len: uint) 
do_bench_extend			    fn do_bench_extend(b: &mut Bencher, dst_len: uint, src_len: uint) 
do_bench_from_elem			    fn do_bench_from_elem(b: &mut Bencher, src_len: uint) 
do_bench_from_fn			    fn do_bench_from_fn(b: &mut Bencher, src_len: uint) 
do_bench_from_iter			    fn do_bench_from_iter(b: &mut Bencher, src_len: uint) 
do_bench_from_slice			    fn do_bench_from_slice(b: &mut Bencher, src_len: uint) 
do_bench_push_all			    fn do_bench_push_all(b: &mut Bencher, dst_len: uint, src_len: uint) 
do_bench_push_all_move			    fn do_bench_push_all_move(b: &mut Bencher, dst_len: uint, src_len: uint) 
do_bench_with_capacity			    fn do_bench_with_capacity(b: &mut Bencher, src_len: uint) 
drain			    pub fn drain(&mut self) -> Drain<T> 
drain			    pub fn drain(&mut self) -> Drain<T> 
drain			    pub fn drain<'a>(&'a mut self) -> Drain<'a, T> 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			            fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			            fn drop(&mut self) 
drop			        fn drop(&mut self) 
drop			    fn drop(&mut self) 
edge_mut			    pub fn edge_mut(&mut self) -> &mut Node<K, V> 
edges			    pub fn edges<'a>(&'a self) -> &'a [Node<K, V>] 
edges_mut			    pub fn edges_mut<'a>(&'a mut self) -> &'a mut [Node<K, V>] 
ends_with			    fn ends_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;
ends_with			    fn ends_with(&self, needle: &[T]) -> bool where T: PartialEq 
ends_with			    fn ends_with(&self, pat: &str) -> bool 
ends_with_diff_one_element_at_beginning			    fn ends_with_diff_one_element_at_beginning(b: &mut Bencher) 
ends_with_same_vector			    fn ends_with_same_vector(b: &mut Bencher) 
ends_with_single_element			    fn ends_with_single_element(b: &mut Bencher) 
entry			    pub fn entry<'a>(&'a mut self, mut key: K) -> Entry<'a, K, V> 
enum_set			pub mod enum_set;
eq			    fn eq(&self, other: &Bitv) -> bool 
eq			    fn eq(&self, other: &BitvSet) -> bool 
eq			    fn eq(&self, other: &BTreeMap<K, V>) -> bool 
eq			    fn eq(&self, other: &DList<A>) -> bool 
eq			    fn eq(&self, other: &RingBuf<A>) -> bool 
eq			            fn eq(&self, other: &
eq			            fn eq(&self, other: &
eq			    fn eq(&self, other: &&'b str) -> bool { PartialEq::eq(&**self, &**other) }
eq			    fn eq(&self, other: &CowString<'a>) -> bool { PartialEq::eq(&**self, &**other) }
eq			    fn eq(&self, other: &String) -> bool { PartialEq::eq(&**self, &**other) }
eq			            fn eq(&self, other: &
eq			            fn eq(&self, other: &
eq			            fn eq(&self, other: &CowVec<'a, A>) -> bool { PartialEq::eq(&**self, &**other) }
eq			    fn eq(&self, other: &CowVec<'a, A>) -> bool { PartialEq::eq(&**self, &**other) }
eq			    fn eq(&self, other: &Vec<B>) -> bool { PartialEq::eq(&**self, &**other) }
eq			    fn eq(&self, other: &VecMap<V>) -> bool 
eq_vec			    pub fn eq_vec(&self, v: &[bool]) -> bool 
escape_default			    fn escape_default(&self) -> String 
escape_unicode			    fn escape_unicode(&self) -> String 
extend			    fn extend<Iter: Iterator<Item=T>>(&mut self, mut iter: Iter) 
extend			    fn extend<I: Iterator<Item=bool>>(&mut self, mut iterator: I) 
extend			    fn extend<I: Iterator<Item=uint>>(&mut self, mut iterator: I) 
extend			    fn extend<T: Iterator<Item=(K, V)>>(&mut self, mut iter: T) 
extend			    fn extend<Iter: Iterator<Item=T>>(&mut self, mut iter: Iter) 
extend			    fn extend<T: Iterator<Item=A>>(&mut self, mut iterator: T) 
extend			    fn extend<I: Iterator<Item=E>>(&mut self, mut iterator: I) 
extend			    fn extend<T: Iterator<Item=A>>(&mut self, mut iterator: T) 
extend			    fn extend<I: Iterator<Item=&'a str>>(&mut self, mut iterator: I) 
extend			    fn extend<I:Iterator<Item=char>>(&mut self, mut iterator: I) 
extend			    fn extend<I: Iterator<Item=T>>(&mut self, mut iterator: I) 
extend			    fn extend<Iter: Iterator<Item=(uint, V)>>(&mut self, mut iter: Iter) 
filter			        fn filter<A>((i, v): (uint, Option<A>)) -> Option<(uint, A)> 
find			    fn find<P: CharEq>(&self, pat: P) -> Option<uint> 
find_rand_100			    pub fn find_rand_100(b: &mut Bencher) 
find_rand_100			    pub fn find_rand_100(b: &mut Bencher) 
find_rand_10_000			    pub fn find_rand_10_000(b: &mut Bencher) 
find_rand_10_000			    pub fn find_rand_10_000(b: &mut Bencher) 
find_rand_n			pub fn find_rand_n<M, T, I, F>(n: uint,
find_seq_100			    pub fn find_seq_100(b: &mut Bencher) 
find_seq_100			    pub fn find_seq_100(b: &mut Bencher) 
find_seq_10_000			    pub fn find_seq_10_000(b: &mut Bencher) 
find_seq_10_000			    pub fn find_seq_10_000(b: &mut Bencher) 
find_seq_n			pub fn find_seq_n<M, T, I, F>(n: uint,
find_str			    fn find_str(&self, needle: &str) -> Option<uint> 
first			        fn first<A, B>((a, _): (A, B)) -> A { a }
first			        fn first<A, B>((a, _): (A, B)) -> A { a }
first			    fn first(&self) -> Option<&Self::Item>;
first			    fn first<'a>(&'a self) -> Option<&'a T> 
first			        fn first<A, B>((a, _): (A, B)) -> A { a }
first_mut			    fn first_mut(&mut self) -> Option<&mut Self::Item>;
first_mut			    fn first_mut<'a>(&'a mut self) -> Option<&'a mut T> 
fix_last_block			    fn fix_last_block(&mut self) 
fixme_14344_be_sure_to_link_to_collections			pub fn fixme_14344_be_sure_to_link_to_collections() {}
fmt			    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt::Show for Bitv			impl fmt::Show for Bitv 
fmt::Show for BitvSet			impl fmt::Show for BitvSet 
fmt::Show for DList			impl<A: fmt::Show> fmt::Show for DList<A> 
fmt::Show for EnumSet			impl<E:CLike+fmt::Show> fmt::Show for EnumSet<E> 
fmt::Show for FromUtf16Error			impl fmt::Show for FromUtf16Error 
fmt::Show for FromUtf8Error			impl fmt::Show for FromUtf8Error 
fmt::Show for RingBuf			impl<T: fmt::Show> fmt::Show for RingBuf<T> 
fmt::Show for String			impl fmt::Show for String 
fmt::Show for Vec			impl<T: fmt::Show> fmt::Show for Vec<T> 
fmt::Show for VecMap			impl<V: fmt::Show> fmt::Show for VecMap<V> 
fmt::String for FromUtf16Error			impl fmt::String for FromUtf16Error 
fmt::String for FromUtf8Error			impl fmt::String for FromUtf8Error 
fmt::String for String			impl fmt::String for String 
fmt::Writer for String			impl fmt::Writer for String 
fmt::Writer for Vec			impl<'a> fmt::Writer for Vec<u8> 
force			    pub fn force(self) -> ForceResult<NodeRef, Type> 
from_bitv			    pub fn from_bitv(bitv: Bitv) -> BitvSet 
from_bytes			    pub fn from_bytes(bytes: &[u8]) -> Bitv 
from_elem			    pub fn from_elem(nbits: uint, bit: bool) -> Bitv 
from_fn			    pub fn from_fn<F>(len: uint, mut f: F) -> Bitv where F: FnMut(uint) -> bool 
from_iter			    fn from_iter<Iter: Iterator<Item=T>>(iter: Iter) -> BinaryHeap<T> 
from_iter			    fn from_iter<I:Iterator<Item=bool>>(iterator: I) -> Bitv 
from_iter			    fn from_iter<I:Iterator<Item=uint>>(iterator: I) -> BitvSet 
from_iter			    fn from_iter<T: Iterator<Item=(K, V)>>(iter: T) -> BTreeMap<K, V> 
from_iter			    fn from_iter<Iter: Iterator<Item=T>>(iter: Iter) -> BTreeSet<T> 
from_iter			    fn from_iter<T: Iterator<Item=A>>(iterator: T) -> DList<A> 
from_iter			    fn from_iter<I:Iterator<Item=E>>(iterator: I) -> EnumSet<E> 
from_iter			    fn from_iter<T: Iterator<Item=A>>(iterator: T) -> RingBuf<A> 
from_iter			    fn from_iter<I:Iterator<Item=&'a str>>(iterator: I) -> String 
from_iter			    fn from_iter<I:Iterator<Item=char>>(iterator: I) -> String 
from_iter			    fn from_iter<I: Iterator<Item=T>>(it: I) -> CowVec<'a, T> 
from_iter			    fn from_iter<I:Iterator<Item=T>>(mut iterator: I) -> Vec<T> 
from_iter			    fn from_iter<Iter: Iterator<Item=(uint, V)>>(iter: Iter) -> VecMap<V> 
from_parts			    unsafe fn from_parts(ptr: *const T, len: uint) -> RawItems<T> 
from_raw			    pub unsafe fn from_raw<'a>(&'a self) -> Handle<&'a Node<K, V>, Type, NodeType> 
from_raw_buf			    pub unsafe fn from_raw_buf(ptr: *const T, elts: uint) -> Vec<T> 
from_raw_mut			    pub unsafe fn from_raw_mut<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, Type, NodeType> 
from_raw_parts			    pub unsafe fn from_raw_parts(buf: *mut u8, length: uint, capacity: uint) -> String 
from_raw_parts			    pub unsafe fn from_raw_parts(ptr: *mut T, length: uint,
from_slice			    unsafe fn from_slice(slice: &[T]) -> RawItems<T> 
from_str			    fn from_str(s: &str) -> Option<String> 
from_str			    pub fn from_str(string: &str) -> String 
from_uint			            fn from_uint(v: uint) -> Bar 
from_uint			        fn from_uint(v: uint) -> Foo 
from_uint			    fn from_uint(uint) -> Self;
from_utf16			    pub fn from_utf16(v: &[u16]) -> Result<String, FromUtf16Error> 
from_utf16_lossy			    pub fn from_utf16_lossy(v: &[u16]) -> String 
from_utf8			    pub fn from_utf8(vec: Vec<u8>) -> Result<String, FromUtf8Error> 
from_utf8_lossy			    pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> CowString<'a> 
from_utf8_lossy_100_ascii			    fn from_utf8_lossy_100_ascii(b: &mut Bencher) 
from_utf8_lossy_100_invalid			    fn from_utf8_lossy_100_invalid(b: &mut Bencher) 
from_utf8_lossy_100_multibyte			    fn from_utf8_lossy_100_multibyte(b: &mut Bencher) 
from_utf8_lossy_invalid			    fn from_utf8_lossy_invalid(b: &mut Bencher) 
from_utf8_unchecked			    pub unsafe fn from_utf8_unchecked(bytes: Vec<u8>) -> String 
from_vec			    pub fn from_vec(vec: Vec<T>) -> BinaryHeap<T> 
front			    pub fn front(&self) -> Option<&T> 
front			    pub fn front(&self) -> Option<&T> 
front_mut			    pub fn front_mut(&mut self) -> Option<&mut T> 
front_mut			    pub fn front_mut(&mut self) -> Option<&mut T> 
fuzz_test			    fn fuzz_test(sz: int) 
generate_test			    fn generate_test() -> DList<int> 
get			    pub fn get(&self, i: uint) -> Option<bool> 
get			    pub fn get(&self) -> &V 
get			    pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, K, V>> 
get			    pub fn get<Q: ?Sized>(&self, key: &Q) -> Option<&V> where Q: BorrowFrom<K> + Ord 
get			    pub fn get(&self, i: uint) -> Option<&T> 
get			    fn get(&self, index: uint) -> Option<&Self::Item>;
get			    fn get<'a>(&'a self, index: uint) -> Option<&'a T> 
get			    pub fn get(&self, key: &uint) -> Option<&V> 
get_mut			    pub fn get_mut(&mut self) -> &mut V 
get_mut			    pub fn get_mut<Q: ?Sized>(&mut self, key: &Q) -> Option<&mut V> where Q: BorrowFrom<K> + Ord 
get_mut			    pub fn get_mut(&mut self, i: uint) -> Option<&mut T> 
get_mut			    fn get_mut(&mut self, index: uint) -> Option<&mut Self::Item>;
get_mut			    fn get_mut<'a>(&'a mut self, index: uint) -> Option<&'a mut T> 
get_mut			    pub fn get_mut(&mut self, key: &uint) -> Option<&mut V> 
get_ref			    pub fn get_ref(&self) -> &Bitv 
get_unchecked			    unsafe fn get_unchecked(&self, index: uint) -> &Self::Item;
get_unchecked			    unsafe fn get_unchecked<'a>(&'a self, index: uint) -> &'a T 
get_unchecked_mut			    unsafe fn get_unchecked_mut(&mut self, index: uint) -> &mut Self::Item;
get_unchecked_mut			    unsafe fn get_unchecked_mut<'a>(&'a mut self, index: uint) -> &'a mut T 
grapheme_indices			    fn grapheme_indices(&self, is_extended: bool) -> GraphemeIndices 
graphemes			    fn graphemes(&self, is_extended: bool) -> Graphemes 
grow			    pub fn grow(&mut self, n: uint, value: bool) 
grow_capacity			    fn grow_capacity(&mut self, capacity: uint) 
half_a_million_letter_a			        fn half_a_million_letter_a() -> String 
half_a_million_letter_x			        fn half_a_million_letter_x() -> String 
handle			pub mod handle 
handle_underflow			    pub fn handle_underflow(mut self) 
handle_underflow_to_left			    unsafe fn handle_underflow_to_left(&mut self) 
handle_underflow_to_right			    unsafe fn handle_underflow_to_right(&mut self) 
hash			    fn hash(&self, state: &mut S) 
hash			    fn hash(&self, state: &mut S) 
hash			    fn hash(&self, state: &mut S) 
hash			    fn hash(&self, state: &mut S) 
hash			    fn hash(&self, hasher: &mut H) 
hash			    fn hash(&self, state: &mut S) 
hash			    fn hash(&self, state: &mut S) 
hash::Hash for Bitv			impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for Bitv 
hash::Hash for BitvSet			impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for BitvSet 
hash::Hash for String			impl<H: hash::Writer + hash::Hasher> hash::Hash<H> for String 
hash::Hash for String			impl<H: hash::Writer> hash::Hash<H> for String 
hoist_lone_child			    pub fn hoist_lone_child(&mut self) 
idx			    fn idx(&mut self, index: uint) -> Option<bool> 
idx			    fn idx(&mut self, j: uint) -> Option<&'a T> 
index			    fn index(&self, i: &uint) -> &bool 
index			    fn index(&self, key: &Q) -> &V 
index			    fn index<'a>(&'a self, i: &uint) -> &'a A 
index			    fn index(&self, _index: &ops::FullRange) -> &str 
index			    fn index(&self, index: &ops::Range<uint>) -> &str 
index			    fn index(&self, index: &ops::RangeFrom<uint>) -> &str 
index			    fn index(&self, index: &ops::RangeTo<uint>) -> &str 
index			    fn index(&self, _index: &ops::FullRange) -> &[T] 
index			    fn index(&self, index: &ops::Range<uint>) -> &[T] 
index			    fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] 
index			    fn index(&self, index: &ops::RangeTo<uint>) -> &[T] 
index			    fn index<'a>(&'a self, index: &uint) -> &'a T 
index			    fn index<'a>(&'a self, i: &uint) -> &'a V 
index_mut			    fn index_mut(&mut self, key: &Q) -> &mut V 
index_mut			    fn index_mut<'a>(&'a mut self, i: &uint) -> &'a mut A 
index_mut			    fn index_mut(&mut self, _index: &ops::FullRange) -> &mut [T] 
index_mut			    fn index_mut(&mut self, index: &ops::Range<uint>) -> &mut [T] 
index_mut			    fn index_mut(&mut self, index: &ops::RangeFrom<uint>) -> &mut [T] 
index_mut			    fn index_mut(&mut self, index: &ops::RangeTo<uint>) -> &mut [T] 
index_mut			    fn index_mut<'a>(&'a mut self, index: &uint) -> &'a mut T 
index_mut			    fn index_mut<'a>(&'a mut self, i: &uint) -> &'a mut V 
indexable			    fn indexable(&self) -> uint 
indexable			    fn indexable(&self) -> uint 
init			    fn init(&self) -> &[Self::Item];
init			    fn init<'a>(&'a self) -> &'a [T] 
init_mut			    fn init_mut(&mut self) -> &mut [Self::Item];
init_mut			    fn init_mut<'a>(&'a mut self) -> &'a mut [T] 
insert			    pub fn insert(&mut self, value: uint) -> bool 
insert			        pub fn insert(mut self, key: K, val: V) -> &'a mut V 
insert			    pub fn insert(&mut self, mut key: K, mut value: V) -> Option<V> 
insert			    pub fn insert(&mut self, mut value: V) -> V 
insert			    pub fn insert(self, value: V) -> &'a mut V 
insert			    pub fn insert(&mut self, value: T) -> bool 
insert			    pub fn insert(&mut self, e: E) -> bool 
insert			    pub fn insert(&mut self, i: uint, t: T) 
insert			    fn insert() 
insert			    pub fn insert(&mut self, idx: uint, ch: char) 
insert			    pub fn insert(&mut self, index: uint, element: T) 
insert			    pub fn insert(&mut self, key: uint, value: V) -> Option<V> 
insert_as_internal			    pub fn insert_as_internal(mut self, key: K, value: V, right: Node<K, V>)
insert_as_leaf			    pub fn insert_as_leaf(mut self, key: K, value: V) ->
insert_edge			    unsafe fn insert_edge(&mut self, index: uint, edge: Node<K, V>) 
insert_kv			    unsafe fn insert_kv(&mut self, index: uint, key: K, val: V) -> &mut V 
insert_next			    pub fn insert_next(&mut self, elt: A) 
insert_next_node			    fn insert_next_node(&mut self, mut ins_node: Box<Node<A>>) 
insert_rand_100			    pub fn insert_rand_100(b: &mut Bencher) 
insert_rand_100			    pub fn insert_rand_100(b: &mut Bencher) 
insert_rand_10_000			    pub fn insert_rand_10_000(b: &mut Bencher) 
insert_rand_10_000			    pub fn insert_rand_10_000(b: &mut Bencher) 
insert_rand_n			pub fn insert_rand_n<M, I, R>(n: uint,
insert_seq_100			    pub fn insert_seq_100(b: &mut Bencher) 
insert_seq_100			    pub fn insert_seq_100(b: &mut Bencher) 
insert_seq_10_000			    pub fn insert_seq_10_000(b: &mut Bencher) 
insert_seq_10_000			    pub fn insert_seq_10_000(b: &mut Bencher) 
insert_seq_n			pub fn insert_seq_n<M, I, R>(n: uint,
insertion_sort			fn insertion_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Ordering 
intersect			    pub fn intersect(&mut self, other: &Bitv) -> bool 
intersect_with			    pub fn intersect_with(&mut self, other: &BitvSet) 
intersection			    pub fn intersection<'a>(&'a self, other: &'a BitvSet) -> Intersection<'a> 
intersection			    pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>)
intersection			    pub fn intersection(&self, e: EnumSet<E>) -> EnumSet<E> 
into_bitv			    pub fn into_bitv(self) -> Bitv 
into_boxed_slice			    pub fn into_boxed_slice(mut self) -> Box<[T]> 
into_bytes			    pub fn into_bytes(self) -> Vec<u8> { self.bytes }
into_bytes			    pub fn into_bytes(self) -> Vec<u8> 
into_cow			    fn into_cow(self) -> CowString<'a> 
into_cow			    fn into_cow(self) -> CowString<'static> 
into_cow			    fn into_cow(self) -> CowVec<'a, T> 
into_edge			    pub fn into_edge(self) -> &'a Node<K, V> 
into_edge_mut			    pub fn into_edge_mut(self) -> &'a mut Node<K, V> 
into_inner			    pub fn into_inner(mut self) -> Vec<T> 
into_iter			    pub fn into_iter(self) -> IntoIter<T> 
into_iter			    pub fn into_iter(self) -> IntoIter<K, V> 
into_iter			    pub fn into_iter(self) -> MoveTraversal<K, V> 
into_iter			    pub fn into_iter(self) -> IntoIter<T> 
into_iter			    pub fn into_iter(self) -> IntoIter<T> 
into_iter			    pub fn into_iter(self) -> IntoIter<T> 
into_iter			    pub fn into_iter(self) -> IntoIter<T> 
into_iter			    pub fn into_iter(&mut self) -> IntoIter<V> 
into_kv			    pub fn into_kv(self) -> (&'a K, &'a V) 
into_kv_mut			    pub fn into_kv_mut(self) -> (&'a mut K, &'a mut V) 
into_leaf			        fn into_leaf(mut self) -> SearchStack<'a, K, V, handle::KV, handle::Leaf> 
into_left_edge			    pub fn into_left_edge(self) -> Handle<&'a mut Node<K, V>, handle::Edge, NodeType> 
into_mut			    pub fn into_mut(self) -> &'a mut V 
into_sorted_vec			    pub fn into_sorted_vec(mut self) -> Vec<T> 
into_top			        pub fn into_top(mut self) -> &'a mut V 
into_vec			    pub fn into_vec(self) -> Vec<T> { self.data }
into_vec			    fn into_vec(mut self: Box<Self>) -> Vec<T> 
into_vec			    fn into_vec(self: Box<Self>) -> Vec<Self::Item>;
is_char_boundary			    fn is_char_boundary(&self, index: uint) -> bool 
is_contiguous			    fn is_contiguous(&self) -> bool 
is_disjoint			    pub fn is_disjoint(&self, other: &BitvSet) -> bool 
is_disjoint			    pub fn is_disjoint(&self, other: &BTreeSet<T>) -> bool 
is_disjoint			    pub fn is_disjoint(&self, other: &EnumSet<E>) -> bool 
is_empty			    pub fn is_empty(&self) -> bool { self.len() == 0 }
is_empty			    pub fn is_empty(&self) -> bool { self.len() == 0 }
is_empty			    pub fn is_empty(&self) -> bool 
is_empty			    pub fn is_empty(&self) -> bool { self.len() == 0 }
is_empty			    pub fn is_empty(&self) -> bool { self.len() == 0 }
is_empty			    pub fn is_empty(&self) -> bool 
is_empty			    pub fn is_empty(&self) -> bool 
is_empty			    pub fn is_empty(&self) -> bool { self.len() == 0 }
is_empty			    fn is_empty(&self) -> bool { self.len() == 0 }
is_empty			    fn is_empty(&self) -> bool 
is_empty			    fn is_empty(&self) -> bool 
is_empty			    pub fn is_empty(&self) -> bool { self.len() == 0 }
is_empty			    pub fn is_empty(&self) -> bool { self.len() == 0 }
is_empty			    pub fn is_empty(&self) -> bool 
is_full			    pub fn is_full(&self) -> bool 
is_full			    fn is_full(&self) -> bool { self.cap - self.len() == 1 }
is_leaf			    pub fn is_leaf(&self) -> bool 
is_odd			    fn is_odd(n: &uint) -> bool { *n % 2u == 1u }
is_subset			    pub fn is_subset(&self, other: &BitvSet) -> bool 
is_subset			    pub fn is_subset(&self, other: &BTreeSet<T>) -> bool 
is_subset			    pub fn is_subset(&self, other: &EnumSet<E>) -> bool 
is_superset			    pub fn is_superset(&self, other: &BitvSet) -> bool 
is_superset			    pub fn is_superset(&self, other: &BTreeSet<T>) -> bool 
is_superset			    pub fn is_superset(&self, other: &EnumSet<E>) -> bool 
is_underfull			    pub fn is_underfull(&self) -> bool 
iter			    pub fn iter(&self) -> Iter<T> 
iter			    pub fn iter(&self) -> Iter 
iter			    pub fn iter(&self) -> bitv_set::Iter 
iter			    pub fn iter(&self) -> Iter<K, V> 
iter			    pub fn iter<'a>(&'a self) -> Traversal<'a, K, V> 
iter			    pub fn iter(&self) -> Iter<T> 
iter			    pub fn iter(&self) -> Iter<T> 
iter			    pub fn iter(&self) -> Iter<E> 
iter			    pub fn iter(&self) -> Iter<T> 
iter			    fn iter(&self) -> Iter<Self::Item>;
iter			    fn iter<'a>(&'a self) -> Iter<'a, T> 
iter			    pub fn iter<'r>(&'r self) -> Iter<'r, V> 
iter_1000			    pub fn iter_1000(b: &mut Bencher) 
iter_100000			    pub fn iter_100000(b: &mut Bencher) 
iter_20			    pub fn iter_20(b: &mut Bencher) 
iter_mut			    pub fn iter_mut(&mut self) -> IterMut<K, V> 
iter_mut			    pub fn iter_mut<'a>(&'a mut self) -> MutTraversal<'a, K, V> 
iter_mut			    pub fn iter_mut(&mut self) -> IterMut<T> 
iter_mut			    pub fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> 
iter_mut			    fn iter_mut(&mut self) -> IterMut<Self::Item>;
iter_mut			    fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> 
iter_mut			    pub fn iter_mut<'r>(&'r mut self) -> IterMut<'r, V> 
iterator			    fn iterator(b: &mut Bencher) 
key_mut			    pub fn key_mut(&'a mut self) -> &'a mut K 
keys			    pub fn keys<'a>(&'a self) -> Keys<'a, K, V> 
keys			    pub fn keys<'a>(&'a self) -> &'a [K] 
keys			    pub fn keys<'r>(&'r self) -> Keys<'r, V> 
keys_mut			    pub fn keys_mut<'a>(&'a mut self) -> &'a mut [K] 
kv_handle			    pub fn kv_handle(&mut self, index: uint) -> Handle<&mut Node<K, V>, handle::KV,
last			    fn last(&self) -> Option<&Self::Item>;
last			    fn last<'a>(&'a self) -> Option<&'a T> 
last_mut			    fn last_mut(&mut self) -> Option<&mut Self::Item>;
last_mut			    fn last_mut<'a>(&'a mut self) -> Option<&'a mut T> 
left_edge			    pub fn left_edge<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, handle::Edge, NodeType> 
left_kv			    unsafe fn left_kv<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, handle::KV, NodeType> 
len			    pub fn len(&self) -> uint { self.data.len() }
len			    pub fn len(&self) -> uint  
len			    pub fn len(&self) -> uint { self.nbits }
len			    pub fn len(&self) -> uint { self.length }
len			    pub fn len(&self) -> uint 
len			    pub fn len(&self) -> uint { self.map.len() }
len			    pub fn len(&self) -> uint 
len			    pub fn len(&self) -> uint 
len			    pub fn len(&self) -> uint { count(self.tail, self.head, self.cap) }
len			    fn len(&self) -> uint 
len			    fn len(&self) -> uint;
len			    fn len(&self) -> uint 
len			    pub fn len(&self) -> uint { self.vec.len() }
len			    pub fn len(&self) -> uint { self.len }
len			    pub fn len(&self) -> uint 
lines			    fn lines(&self) -> Lines 
lines_any			    fn lines_any(&self) -> LinesAny 
link_with_prev			fn link_with_prev<T>(mut next: Box<Node<T>>, prev: Rawlink<Node<T>>)
list_from			    fn list_from<T: Clone>(v: &[T]) -> DList<T> 
macros			mod macros;
make_internal_root			    pub fn make_internal_root(left_and_out: &mut Node<K,V>, b: uint, key: K, value: V,
make_leaf_root			    pub fn make_leaf_root(b: uint) -> Node<K, V> 
map			pub mod map;
map_in_place			    pub fn map_in_place<U, F>(self, mut f: F) -> Vec<U> where F: FnMut(T) -> U 
mask_for_bits			fn mask_for_bits(bits: uint) -> u32 
match_indices			    fn match_indices<'a>(&'a self, pat: &'a str) -> MatchIndices<'a> 
match_words			fn match_words <'a,'b>(a: &'a Bitv, b: &'b Bitv) -> (MatchWords<'a>, MatchWords<'b>) 
matches			            fn matches(&mut self, c: char) -> bool 
merge_children			    unsafe fn merge_children(mut self) 
merge_sort			fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Ordering 
min_load_from_capacity			fn min_load_from_capacity(cap: uint) -> uint 
move_from			    fn move_from(&mut self, mut src: Vec<T>, start: uint, end: uint) -> uint 
move_from			    fn move_from(&mut self, src: Vec<Self::Item>, start: uint, end: uint) -> uint;
mut_iterator			    fn mut_iterator(b: &mut Bencher) 
ne			    fn ne(&self, other: &DList<A>) -> bool 
ne			            fn ne(&self, other: &
ne			            fn ne(&self, other: &
ne			    fn ne(&self, other: &&'b str) -> bool { PartialEq::ne(&**self, &**other) }
ne			    fn ne(&self, other: &CowString<'a>) -> bool { PartialEq::ne(&**self, &**other) }
ne			    fn ne(&self, other: &String) -> bool { PartialEq::ne(&**self, &**other) }
ne			            fn ne(&self, other: &
ne			            fn ne(&self, other: &
ne			            fn ne(&self, other: &CowVec<'a, A>) -> bool { PartialEq::ne(&**self, &**other) }
ne			    fn ne(&self, other: &CowVec<'a, A>) -> bool { PartialEq::ne(&**self, &**other) }
ne			    fn ne(&self, other: &Vec<B>) -> bool { PartialEq::ne(&**self, &**other) }
negate			    pub fn negate(&mut self) 
new			    pub fn new() -> BinaryHeap<T> { BinaryHeap { data: vec![] } }
new			    pub fn new() -> Bitv 
new			    pub fn new() -> BitvSet 
new			        pub fn new(map: &'a mut BTreeMap<K, V>) -> PartialSearchStack<'a, K, V> 
new			    pub fn new() -> BTreeMap<K, V> 
new			    pub fn new() -> BTreeSet<T> 
new			    fn new(v: T) -> Node<T> 
new			    pub fn new() -> DList<T> 
new			    fn new(bits: uint) -> Iter<E> 
new			    pub fn new() -> EnumSet<E> 
new			    pub fn new() -> RingBuf<T> 
new			    pub fn new(length: uint) -> ElementSwaps 
new			    pub fn new() -> String 
new			    pub fn new() -> Vec<T> 
new			    pub fn new() -> VecMap<V> { VecMap { v: vec![] } }
new_internal			    unsafe fn new_internal(capacity: uint) -> Node<K, V> 
new_leaf			    fn new_leaf(capacity: uint) -> Node<K, V> 
new_pos			        fn new_pos(i: uint, s: Direction) -> uint 
next			    fn next(&mut self) -> Option<&'a T> { self.iter.next() }
next			    fn next(&mut self) -> Option<T> { self.iter.next() }
next			    fn next(&mut self) -> Option<bool> 
next			    fn next(&mut self) -> Option<uint> 
next			    fn next(&mut self) -> Option<(&'a K)> { self.inner.next() }
next			    fn next(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next() }
next			    fn next(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next() }
next			    fn next(&mut self) -> Option<(&'a V)> { self.inner.next() }
next			    fn next(&mut self) -> Option<(K, V)> { self.inner.next() }
next			    fn next(&mut self) -> Option<(K, V)> 
next			    fn next(&mut self) -> Option<T> 
next			    fn next(&mut self) -> Option<TraversalItem<K, V, E>> 
next			    fn next(&mut self) -> Option<&'a T> { self.iter.next() }
next			    fn next(&mut self) -> Option<&'a T> 
next			    fn next(&mut self) -> Option<T> { self.iter.next() }
next			    fn next(&mut self) -> Option<&'a A> 
next			    fn next(&mut self) -> Option<&'a mut A> 
next			    fn next(&mut self) -> Option<A> { self.list.pop_front() }
next			    fn next(&mut self) -> Option<E> 
next			    fn next(&mut self) -> Option<&'a T> 
next			    fn next(&mut self) -> Option<&'a mut T> 
next			    fn next(&mut self) -> Option<T> 
next			    fn next(&mut self) -> Option<(uint, uint)> 
next			    fn next(&mut self) -> Option<Vec<T>> 
next			    fn next(&mut self) -> Option<char> 
next			    fn next(&mut self) -> Option<u16> { self.encoder.next() }
next			    fn next(&mut self) -> Option<T> 
next			    fn next<'a>(&'a mut self) -> Option<T> 
next			            fn next(&mut self) -> Option<
next			    fn next(&mut self) -> Option<(&'a V)> { self.iter.next() }
next			    fn next(&mut self) -> Option<(uint, V)> { self.iter.next() }
next			    fn next(&mut self) -> Option<uint> { self.iter.next() }
next_back			    fn next_back(&mut self) -> Option<&'a T> { self.iter.next_back() }
next_back			    fn next_back(&mut self) -> Option<T> { self.iter.next_back() }
next_back			    fn next_back(&mut self) -> Option<bool> 
next_back			    fn next_back(&mut self) -> Option<(&'a K)> { self.inner.next_back() }
next_back			    fn next_back(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next_back() }
next_back			    fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next_back() }
next_back			    fn next_back(&mut self) -> Option<(&'a V)> { self.inner.next_back() }
next_back			    fn next_back(&mut self) -> Option<(K, V)> { self.inner.next_back() }
next_back			    fn next_back(&mut self) -> Option<(K, V)> 
next_back			    fn next_back(&mut self) -> Option<T> 
next_back			    fn next_back(&mut self) -> Option<TraversalItem<K, V, E>> 
next_back			    fn next_back(&mut self) -> Option<&'a T> { self.iter.next_back() }
next_back			    fn next_back(&mut self) -> Option<T> { self.iter.next_back() }
next_back			    fn next_back(&mut self) -> Option<&'a A> 
next_back			    fn next_back(&mut self) -> Option<&'a mut A> 
next_back			    fn next_back(&mut self) -> Option<A> { self.list.pop_back() }
next_back			    fn next_back(&mut self) -> Option<&'a T> 
next_back			    fn next_back(&mut self) -> Option<&'a mut T> 
next_back			    fn next_back(&mut self) -> Option<T> 
next_back			    fn next_back(&mut self) -> Option<T> 
next_back			    fn next_back<'a>(&'a mut self) -> Option<T> 
next_back			            fn next_back(&mut self) -> Option<
next_back			    fn next_back(&mut self) -> Option<(&'a V)> { self.iter.next_back() }
next_back			    fn next_back(&mut self) -> Option<(uint, V)> { self.iter.next_back() }
next_back			    fn next_back(&mut self) -> Option<uint> { self.iter.next_back() }
next_edge			    fn next_edge(&mut self) -> Option<E> { self.1.next() }
next_edge			    fn next_edge(&mut self) -> Option<E>;
next_edge			    fn next_edge(&mut self) -> Option<Node<K, V>> 
next_edge_back			    fn next_edge_back(&mut self) -> Option<E> { self.1.next_back() }
next_edge_back			    fn next_edge_back(&mut self) -> Option<E>;
next_edge_back			    fn next_edge_back(&mut self) -> Option<Node<K, V>> 
next_kv			    fn next_kv(&mut self) -> Option<(K, V)> { self.0.next() }
next_kv			    fn next_kv(&mut self) -> Option<(K, V)> 
next_kv			    fn next_kv(&mut self) -> Option<(K, V)>;
next_kv_back			    fn next_kv_back(&mut self) -> Option<(K, V)> { self.0.next_back() }
next_kv_back			    fn next_kv_back(&mut self) -> Option<(K, V)> 
next_kv_back			    fn next_kv_back(&mut self) -> Option<(K, V)>;
next_permutation			    fn next_permutation(&mut self) -> bool where Self::Item: Ord;
next_permutation			    fn next_permutation(&mut self) -> bool where T: Ord 
nfc_chars			    fn nfc_chars<'a>(&'a self) -> Recompositions<'a> 
nfd_chars			    fn nfd_chars<'a>(&'a self) -> Decompositions<'a> 
nfkc_chars			    fn nfkc_chars<'a>(&'a self) -> Recompositions<'a> 
nfkd_chars			    fn nfkd_chars<'a>(&'a self) -> Decompositions<'a> 
node			mod node;
node			    pub fn node(&self) -> &Node<K, V> 
none			    pub fn none(&self) -> bool 
none			    fn none() -> Rawlink<T> 
only_ascii			            fn only_ascii(&self) -> bool { false }
ops			impl ops::Index<ops::Range<uint>> for String 
ops			impl ops::Index<ops::RangeFrom<uint>> for String 
ops			impl ops::Index<ops::RangeTo<uint>> for String 
ops			impl<T> ops::Index<ops::Range<uint>> for Vec<T> 
ops			impl<T> ops::Index<ops::RangeFrom<uint>> for Vec<T> 
ops			impl<T> ops::Index<ops::RangeTo<uint>> for Vec<T> 
ops			impl<T> ops::IndexMut<ops::Range<uint>> for Vec<T> 
ops			impl<T> ops::IndexMut<ops::RangeFrom<uint>> for Vec<T> 
ops			impl<T> ops::IndexMut<ops::RangeTo<uint>> for Vec<T> 
ops::Deref for String			impl ops::Deref for String 
ops::Deref for Vec			impl<T> ops::Deref for Vec<T> 
ops::DerefMut for Vec			impl<T> ops::DerefMut for Vec<T> 
ops::Index for String			impl ops::Index<ops::FullRange> for String 
ops::Index for Vec			impl<T> ops::Index<ops::FullRange> for Vec<T> 
ops::IndexMut for Vec			impl<T> ops::IndexMut<ops::FullRange> for Vec<T> 
or			        fn or(w1: u32, w2: u32) -> u32 { w1 | w2 }
other_op			    fn other_op<F>(&mut self, other: &BitvSet, mut f: F) where F: FnMut(u32, u32) -> u32 
parse			    fn parse<F: FromStr>(&self) -> Option<F> 
partial_cmp			    fn partial_cmp(&self, other: &Bitv) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &BitvSet) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &BTreeMap<K, V>) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &DList<A>) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &RingBuf<A>) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &Vec<T>) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &VecMap<V>) -> Option<Ordering> 
peek			    pub fn peek(&self) -> Option<&T> 
peek			        pub fn peek(&self) -> &V 
peek_mut			        pub fn peek_mut(&mut self) -> &mut V 
peek_next			    pub fn peek_next(&mut self) -> Option<&mut A> 
permutations			    fn permutations(&self) -> Permutations<Self::Item> where Self::Item: Clone;
permutations			    fn permutations(&self) -> Permutations<T> where T: Clone 
pop			    pub fn pop(&mut self) -> Option<T> 
pop			    pub fn pop(&mut self) -> Option<bool> 
pop			    pub fn pop(&mut self) -> Option<char> 
pop			    pub fn pop(&mut self) -> Option<T> 
pop_back			    pub fn pop_back(&mut self) -> Option<T> 
pop_back			    pub fn pop_back(&mut self) -> Option<T> 
pop_back_node			    fn pop_back_node(&mut self) -> Option<Box<Node<T>>> 
pop_edge			    unsafe fn pop_edge(&mut self) -> Node<K, V> 
pop_front			    pub fn pop_front(&mut self) -> Option<T> 
pop_front			    pub fn pop_front(&mut self) -> Option<T> 
pop_front_node			    fn pop_front_node(&mut self) -> Option<Box<Node<T>>> 
pop_kv			    unsafe fn pop_kv(&mut self) -> (K, V) 
position_elem			    fn position_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;
position_elem			    fn position_elem(&self, t: &T) -> Option<uint> where T: PartialEq 
pred			        fn pred(c: char) -> bool { c == ' ' }
prelude			mod prelude 
prev_permutation			    fn prev_permutation(&mut self) -> bool where Self::Item: Ord;
prev_permutation			    fn prev_permutation(&mut self) -> bool where T: Ord 
process			    fn process<F>(&mut self, other: &Bitv, mut op: F) -> bool where F: FnMut(u32, u32) -> u32 
push			    pub fn push(&mut self, item: T) 
push			    pub fn push(&mut self, elem: bool) 
push			        pub fn push(mut self, mut edge: node::Handle<IdRef<'id, Node<K, V>>,
push			    unsafe fn push(&mut self, val: T) 
push			    fn push(b: &mut Bencher) 
push			    pub fn push(&mut self, ch: char) 
push			    pub fn push(&mut self, value: T) 
push_all			    pub fn push_all(&mut self, other: &[T]) 
push_back			    pub fn push_back(&mut self, elt: T) 
push_back			    pub fn push_back(&mut self, t: T) 
push_back_node			    fn push_back_node(&mut self, mut new_tail: Box<Node<T>>) 
push_edge			    unsafe fn push_edge(&mut self, edge: Node<K, V>) 
push_front			    pub fn push_front(&mut self, elt: T) 
push_front			    pub fn push_front(&mut self, t: T) 
push_front_node			    fn push_front_node(&mut self, mut new_head: Box<Node<T>>) 
push_kv			    unsafe fn push_kv(&mut self, key: K, val: V) 
push_pop			    pub fn push_pop(&mut self, mut item: T) -> T 
push_str			    pub fn push_str(&mut self, string: &str) 
random_inserts			    fn random_inserts(b: &mut Bencher) 
random_removes			    fn random_removes(b: &mut Bencher) 
remove			    pub fn remove(&mut self, value: &uint) -> bool 
remove			        pub fn remove(self) -> V 
remove			    pub fn remove(self) -> V 
remove			    pub fn remove<Q: ?Sized>(&mut self, key: &Q) -> Option<V> where Q: BorrowFrom<K> + Ord 
remove			    pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool where Q: BorrowFrom<T> + Ord 
remove			    pub fn remove(&mut self, e: &E) -> bool 
remove			    pub fn remove(&mut self, i: uint) -> Option<T> 
remove			    fn remove() 
remove			    pub fn remove(&mut self, idx: uint) -> char 
remove			    pub fn remove(&mut self, index: uint) -> T 
remove			    pub fn remove(&mut self, key: &uint) -> Option<V> 
remove_as_leaf			    pub fn remove_as_leaf(mut self) -> (K, V) 
remove_bad			    fn remove_bad() 
remove_edge			    unsafe fn remove_edge(&mut self, index: uint) -> Node<K, V> 
remove_kv			    unsafe fn remove_kv(&mut self, index: uint) -> (K, V) 
remove_leaf			        fn remove_leaf(mut self) -> V 
replace			    pub fn replace(&mut self, mut item: T) -> Option<T> 
replace			    fn replace(&self, from: &str, to: &str) -> String 
reserve			    pub fn reserve(&mut self, additional: uint) 
reserve			    pub fn reserve(&mut self, additional: uint) 
reserve			    pub fn reserve(&mut self, additional: uint) 
reserve			    pub fn reserve(&mut self, additional: uint) 
reserve			    pub fn reserve(&mut self, additional: uint) 
reserve_exact			    pub fn reserve_exact(&mut self, additional: uint) 
reserve_exact			    pub fn reserve_exact(&mut self, additional: uint) 
reserve_exact			    pub fn reserve_exact(&mut self, additional: uint) 
reserve_exact			    pub fn reserve_exact(&mut self, additional: uint) 
reserve_exact			    pub fn reserve_exact(&mut self, additional: uint) 
reserve_len			    pub fn reserve_len(&mut self, len: uint) 
reserve_len			    pub fn reserve_len(&mut self, len: uint) 
reserve_len_exact			    pub fn reserve_len_exact(&mut self, len: uint) 
reserve_len_exact			    pub fn reserve_len_exact(&mut self, len: uint) 
resize			    pub fn resize(&mut self, new_len: uint, value: T) 
resize			    pub fn resize(&mut self, new_len: uint, value: T) 
resolve			    fn resolve<'a>(&mut self) -> Option<&'a mut T> 
resolve_immut			    fn resolve_immut<'a>(&self) -> Option<&'a T> 
retain			    pub fn retain<F>(&mut self, mut f: F) where F: FnMut(&T) -> bool 
reverse			    fn reverse(&mut self) 
reverse			    fn reverse(&mut self);
reverse_bits			fn reverse_bits(byte: u8) -> u8 
rfind			    fn rfind<P: CharEq>(&self, pat: P) -> Option<uint> 
right_edge			    pub fn right_edge<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, handle::Edge, NodeType> 
right_kv			    unsafe fn right_kv<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, handle::KV, NodeType> 
ring_buf			pub mod ring_buf;
rng			    fn rng() -> rand::IsaacRng 
round_up_to_next			fn round_up_to_next(unrounded: uint, target_alignment: uint) -> uint 
rposition_elem			    fn rposition_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;
rposition_elem			    fn rposition_elem(&self, t: &T) -> Option<uint> where T: PartialEq 
rsplitn			    fn rsplitn<F>(&self, n: uint, pred: F) -> RSplitN<Self::Item, F>
rsplitn			    fn rsplitn<F>(&self, n: uint, pred: F) -> RSplitN<T, F>
rsplitn			    fn rsplitn<P: CharEq>(&self, count: uint, pat: P) -> RSplitN<P> 
rsplitn_mut			    fn rsplitn_mut<F>(&mut self,  n: uint, pred: F) -> RSplitNMut<Self::Item, F>
rsplitn_mut			    fn rsplitn_mut<F>(&mut self,  n: uint, pred: F) -> RSplitNMut<T, F>
s			    fn s(x: &str) -> String { x.to_string() }
safe_get			        fn safe_get(xs: &[u8], i: uint, total: uint) -> u8 
seal			        pub fn seal<Type, NodeType>
search			    pub fn search<Q: ?Sized, NodeRef: Deref<Target=Node<K, V>>>(node: NodeRef, key: &Q)
search_linear			    fn search_linear<Q: ?Sized>(&self, key: &Q) -> (bool, uint) where Q: BorrowFrom<K> + Ord 
second			        fn second<A, B>((_, b): (A, B)) -> B { b }
second			        fn second<A, B>((_, b): (A, B)) -> B { b }
set			    pub fn set(&mut self, i: uint, x: bool) 
set			pub mod set;
set_all			    pub fn set_all(&mut self) 
set_len			    pub unsafe fn set_len(&mut self, len: uint) 
shrink_to_fit			    pub fn shrink_to_fit(&mut self) 
shrink_to_fit			    pub fn shrink_to_fit(&mut self) 
shrink_to_fit			    pub fn shrink_to_fit(&mut self) 
shrink_to_fit			    pub fn shrink_to_fit(&mut self) 
shrink_to_fit			    pub fn shrink_to_fit(&mut self) 
sift_down			    fn sift_down(&mut self, pos: uint) 
sift_down_range			    fn sift_down_range(&mut self, mut pos: uint, end: uint) 
sift_up			    fn sift_up(&mut self, start: uint, mut pos: uint) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) { self.encoder.size_hint() }
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			            fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }
slice			pub mod slice;
slice			    fn slice(&self, start: uint, end: uint) -> &[Self::Item];
slice			    fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [T] 
slice			    fn slice(&self, begin: uint, end: uint) -> &str 
slice_chars			    fn slice_chars(&self, begin: uint, end: uint) -> &str 
slice_from			    fn slice_from(&self, start: uint) -> &[Self::Item];
slice_from			    fn slice_from<'a>(&'a self, start: uint) -> &'a [T] 
slice_from			    fn slice_from(&self, begin: uint) -> &str 
slice_from_mut			    fn slice_from_mut(&mut self, start: uint) -> &mut [Self::Item];
slice_from_mut			    fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [T] 
slice_mut			    fn slice_mut(&mut self, start: uint, end: uint) -> &mut [Self::Item];
slice_mut			    fn slice_mut<'a>(&'a mut self, start: uint, end: uint) -> &'a mut [T] 
slice_shift_char			    fn slice_shift_char(&self) -> Option<(char, &str)> 
slice_to			    fn slice_to(&self, end: uint) -> &[Self::Item];
slice_to			    fn slice_to<'a>(&'a self, end: uint) -> &'a [T] 
slice_to			    fn slice_to(&self, end: uint) -> &str 
slice_to_mut			    fn slice_to_mut(&mut self, end: uint) -> &mut [Self::Item];
slice_to_mut			    fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [T] 
slice_unchecked			    unsafe fn slice_unchecked(&self, begin: uint, end: uint) -> &str 
some			    fn some(n: &mut T) -> Rawlink<T> 
sort			    fn sort(&mut self) where Self::Item: Ord;
sort			    fn sort(&mut self) where T: Ord 
sort_big_random_large			    fn sort_big_random_large(b: &mut Bencher) 
sort_big_random_medium			    fn sort_big_random_medium(b: &mut Bencher) 
sort_big_random_small			    fn sort_big_random_small(b: &mut Bencher) 
sort_big_sorted			    fn sort_big_sorted(b: &mut Bencher) 
sort_by			    fn sort_by<F>(&mut self, compare: F) where F: FnMut(&Self::Item, &Self::Item) -> Ordering;
sort_by			    fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering 
sort_random_large			    fn sort_random_large(b: &mut Bencher) 
sort_random_medium			    fn sort_random_medium(b: &mut Bencher) 
sort_random_small			    fn sort_random_small(b: &mut Bencher) 
sort_sorted			    fn sort_sorted(b: &mut Bencher) 
split			    fn split(&mut self) -> (K, V, Node<K, V>) 
split			    fn split<F>(&self, pred: F) -> Split<Self::Item, F>
split			    fn split<F>(&self, pred: F) -> Split<T, F>
split			    fn split<P: CharEq>(&self, pat: P) -> Split<P> 
split_ascii			    fn split_ascii(b: &mut Bencher) 
split_at			    fn split_at(&self, mid: uint) -> (&[Self::Item], &[Self::Item]);
split_at			    fn split_at<'a>(&'a self, mid: uint) -> (&'a [T], &'a [T]) 
split_at_mut			    fn split_at_mut(&mut self, mid: uint) -> (&mut [Self::Item], &mut [Self::Item]);
split_at_mut			    fn split_at_mut<'a>(&'a mut self, mid: uint) -> (&'a mut [T], &'a mut [T]) 
split_closure			    fn split_closure(b: &mut Bencher) 
split_extern_fn			    fn split_extern_fn(b: &mut Bencher) 
split_mut			    fn split_mut<F>(&mut self, pred: F) -> SplitMut<Self::Item, F>
split_mut			    fn split_mut<F>(&mut self, pred: F) -> SplitMut<T, F>
split_not_ascii			    fn split_not_ascii(b: &mut Bencher) 
split_off			    pub fn split_off(&mut self, at: uint) -> DList<T> 
split_slice			    fn split_slice(b: &mut Bencher) 
split_str			    fn split_str<'a>(&'a self, pat: &'a str) -> SplitStr<'a> 
split_terminator			    fn split_terminator<P: CharEq>(&self, pat: P) -> SplitTerminator<P> 
split_unicode_ascii			    fn split_unicode_ascii(b: &mut Bencher) 
split_unicode_not_ascii			    fn split_unicode_not_ascii(b: &mut Bencher) 
splitn			    fn splitn<F>(&self, n: uint, pred: F) -> SplitN<Self::Item, F>
splitn			    fn splitn<F>(&self, n: uint, pred: F) -> SplitN<T, F>
splitn			    fn splitn<P: CharEq>(&self, count: uint, pat: P) -> SplitN<P> 
splitn_mut			    fn splitn_mut<F>(&mut self, n: uint, pred: F) -> SplitNMut<Self::Item, F>
splitn_mut			    fn splitn_mut<F>(&mut self, n: uint, pred: F) -> SplitNMut<T, F>
square			    fn square(n: uint) -> uint { n * n }
stack			mod stack 
starts_with			    fn starts_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;
starts_with			    fn starts_with(&self, needle: &[T]) -> bool where T: PartialEq 
starts_with			    fn starts_with(&self, pat: &str) -> bool 
starts_with_diff_one_element_at_end			    fn starts_with_diff_one_element_at_end(b: &mut Bencher) 
starts_with_same_vector			    fn starts_with_same_vector(b: &mut Bencher) 
starts_with_single_element			    fn starts_with_single_element(b: &mut Bencher) 
std			mod std 
steal_leftward			    unsafe fn steal_leftward(&mut self) 
steal_rightward			    unsafe fn steal_rightward(&mut self) 
step			    unsafe fn step<T>(ptr: &mut *mut T) -> *mut T 
str			pub mod str;
string			pub mod string;
sub			    fn sub(self, rhs: &BTreeSet<T>) -> BTreeSet<T> 
sub			    fn sub(self, e: EnumSet<E>) -> EnumSet<E> 
subslice_offset			    fn subslice_offset(&self, inner: &str) -> uint 
sum_len			        fn sum_len(v: &[&str]) -> uint 
swap			    pub fn swap(&mut self, i: uint, j: uint) 
swap			    fn swap(&mut self, a: uint, b: uint) 
swap			    fn swap(&mut self, a: uint, b: uint);
swap_back_remove			    pub fn swap_back_remove(&mut self, index: uint) -> Option<T> 
swap_front_remove			    pub fn swap_front_remove(&mut self, index: uint) -> Option<T> 
swap_remove			    pub fn swap_remove(&mut self, index: uint) -> T 
symmetric_difference			    pub fn symmetric_difference<'a>(&'a self, other: &'a BitvSet) -> SymmetricDifference<'a> 
symmetric_difference			    pub fn symmetric_difference<'a>(&'a self, other: &'a BTreeSet<T>)
symmetric_difference_with			    pub fn symmetric_difference_with(&mut self, other: &BitvSet) 
t			        fn t(a: &str, b: &str, start: uint) 
t			        fn t(s: &str, sep: &str, u: &[&str]) 
t			        fn t<S: Default + Str>() 
tail			    fn tail(&self) -> &[Self::Item];
tail			    fn tail<'a>(&'a self) -> &'a [T] 
tail_mut			    fn tail_mut(&mut self) -> &mut [Self::Item];
tail_mut			    fn tail_mut<'a>(&'a mut self) -> &'a mut [T] 
take			    fn take(&mut self) -> Rawlink<T> 
test			mod test 
test			mod test 
test			mod test 
test			        fn test(back: bool) 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
to_bytes			    pub fn to_bytes(&self) -> Vec<u8> 
to_owned			    fn to_owned(&self) -> Vec<T> { self.to_vec() }
to_owned			    fn to_owned(&self) -> String 
to_string			    fn to_string(&self) -> String 
to_string			    fn to_string(&self) -> String;
to_uint			            fn to_uint(&self) -> uint 
to_uint			        fn to_uint(&self) -> uint 
to_uint			    fn to_uint(&self) -> uint;
to_vec			    fn to_vec(&self) -> Vec<Self::Item> where Self::Item: Clone;
to_vec			    fn to_vec(&self) -> Vec<T> where T: Clone 
traverse			    fn traverse(node: &'a Node<K, V>) -> Traversal<'a, K, V> 
traverse			    fn traverse(node: &'a mut Node<K, V>) -> MutTraversal<'a, K, V> 
traverse			    fn traverse(node: N) -> Self;
traverse			    fn traverse(node: Node<K, V>) -> MoveTraversal<K, V> 
trim			    fn trim(&self) -> &str 
trim_left			    fn trim_left(&self) -> &str 
trim_left_matches			    fn trim_left_matches<P: CharEq>(&self, pat: P) -> &str 
trim_matches			    fn trim_matches<P: CharEq>(&self, pat: P) -> &str 
trim_right			    fn trim_right(&self) -> &str 
trim_right_matches			    fn trim_right_matches<P: CharEq>(&self, pat: P) -> &str 
truncate			    pub fn truncate(&mut self, len: uint) 
truncate			    pub fn truncate(&mut self, len: uint) 
truncate			    pub fn truncate(&mut self, new_len: uint) 
truncate			    pub fn truncate(&mut self, len: uint) 
union			    pub fn union(&mut self, other: &Bitv) -> bool 
union			    pub fn union<'a>(&'a self, other: &'a BitvSet) -> Union<'a> 
union			    pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> Union<'a, T> 
union			    pub fn union(&self, e: EnumSet<E>) -> EnumSet<E> 
union_with			    pub fn union_with(&mut self, other: &BitvSet) 
unsafe_get			        fn unsafe_get(xs: &[u8], i: uint) -> u8 
utf16_units			    fn utf16_units(&self) -> Utf16Units 
utf8_error			    pub fn utf8_error(&self) -> Utf8Error { self.error }
val_mut			    pub fn val_mut(&'a mut self) -> &'a mut V 
vals			    pub fn vals<'a>(&'a self) -> &'a [V] 
vals_mut			    pub fn vals_mut<'a>(&'a mut self) -> &'a mut [V] 
values			    pub fn values<'a>(&'a self) -> Values<'a, K, V> 
values			    pub fn values<'r>(&'r self) -> Values<'r, V> 
vec			pub mod vec;
vec_map			pub mod vec_map;
vec_str_conversions			    fn vec_str_conversions() 
width			    fn width(&self, is_cjk: bool) -> uint 
windows			    fn windows(&self, size: uint) -> Windows<Self::Item>;
windows			    fn windows<'a>(&'a self, size: uint) -> Windows<'a, T> 
with			        pub fn with<T, F: for<'id> FnOnce(Pusher<'id, 'a, K, V>,
with_b			    pub fn with_b(b: uint) -> BTreeMap<K, V> 
with_b			    pub fn with_b(b: uint) -> BTreeSet<T> 
with_capacity			    pub fn with_capacity(capacity: uint) -> BinaryHeap<T> 
with_capacity			    pub fn with_capacity(nbits: uint) -> Bitv 
with_capacity			    pub fn with_capacity(nbits: uint) -> BitvSet 
with_capacity			    pub fn with_capacity(n: uint) -> RingBuf<T> 
with_capacity			    pub fn with_capacity(capacity: uint) -> String 
with_capacity			    pub fn with_capacity(capacity: uint) -> Vec<T> 
with_capacity			    pub fn with_capacity(capacity: uint) -> VecMap<V> 
words			    fn words(&self) -> Words 
wrap_index			    fn wrap_index(&self, idx: uint) -> uint { wrap_index(idx, self.cap) }
wrap_index			fn wrap_index(index: uint, size: uint) -> uint 
write_str			    fn write_str(&mut self, s: &str) -> fmt::Result 
write_str			    fn write_str(&mut self, s: &str) -> fmt::Result 
zero_1kb_from_elem			    fn zero_1kb_from_elem(b: &mut Bencher) 
zero_1kb_loop_set			    fn zero_1kb_loop_set(b: &mut Bencher) 
zero_1kb_mut_iter			    fn zero_1kb_mut_iter(b: &mut Bencher) 
zero_1kb_set_memory			    fn zero_1kb_set_memory(b: &mut Bencher) 
zero_sized_values			    fn zero_sized_values() 
