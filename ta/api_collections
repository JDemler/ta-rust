BTree			pub struct BTree<K, V> 
BigBitv			impl BigBitv 
BigBitv			struct BigBitv 
BitPositions			pub struct BitPositions<'a> 
Bits			pub struct Bits<'a> 
Bitv			impl Bitv 
Bitv			pub struct Bitv 
BitvSet			impl BitvSet 
BitvSet			pub struct BitvSet 
BitvVariant			enum BitvVariant { Big(BigBitv), Small(SmallBitv) }
Branch			struct Branch<K, V> 
BranchElt			struct BranchElt<K, V> 
BucketState			    pub enum BucketState 
CLike			    impl CLike for Foo 
CLike			pub trait CLike 
Child			enum Child<T> 
Container			impl Container for BitvSet 
Container			impl Container for TrieSet 
DList			pub struct DList<T> 
Deque			pub trait Deque<T> : Mutable 
DifferenceItems			pub struct DifferenceItems<'a, T> 
Drop			    impl Drop for Dropable 
Dropable			    impl Dropable 
Dropable			    struct Dropable 
EmptyIndex			    pub struct EmptyIndex 
Entries			    pub struct Entries<'a, K, V> 
Entries			pub struct Entries<'a, T> 
Entries			pub struct Entries<'a, K, V> 
Entries			pub struct Entries<'a, T> 
EnumSet			pub struct EnumSet<E> 
Extendable			impl Extendable<uint> for TrieSet 
Foo			    enum Foo 
FromIterator			impl FromIterator<uint> for TrieSet 
FullIndex			    impl FullIndex 
FullIndex			    pub struct FullIndex 
HashMap			pub struct HashMap<K, V, H = sip::SipHasher> 
HashSet			pub struct HashSet<T, H = sip::SipHasher> 
IntersectionItems			pub struct IntersectionItems<'a, T> 
Items			pub struct Items<'a, T> 
Items			pub struct Items<E> 
Items			pub struct Items <'a, T> 
Items			pub struct Items<'a, T> 
KeyRef			struct KeyRef<K> { k: *K }
Leaf			struct Leaf<K, V> 
LeafElt			struct LeafElt<K, V> 
ListInsertion			pub trait ListInsertion<A> 
LruCache			pub struct LruCache<K, V> 
LruEntry			struct LruEntry<K, V> 
MoveEntries			    pub struct MoveEntries<K, V> 
MoveEntries			pub struct MoveEntries<K, V> 
MoveItems			pub struct MoveItems<T> 
MutEntries			    pub struct MutEntries<'a, K, V> 
MutEntries			pub struct MutEntries<'a, T> 
MutEntries			pub struct MutEntries<'a, K, V> 
MutEntries			pub struct MutEntries<'a, T> 
MutItems			pub struct MutItems<'a, T> 
MutItems			pub struct MutItems<'a, T> 
Mutable			impl Mutable for BitvSet 
Mutable			impl Mutable for TrieSet 
MutableSet			impl MutableSet<uint> for BitvSet 
Node			enum Node<K, V> 
Node			struct Node<T> 
Op			enum Op {Union, Intersect, Assign, Difference}
PriorityQueue			pub struct PriorityQueue<T> 
RawTable			    pub struct RawTable<K, V> 
Rawlink			struct Rawlink<T> { p: *mut T }
RecCy			    struct RecCy 
RevEntries			pub struct RevEntries<'a, K, V> 
RevMutEntries			pub struct RevMutEntries<'a, K, V> 
RevSetItems			pub struct RevSetItems<'a, T> 
RingBuf			pub struct RingBuf<T> 
SafeHash			    impl SafeHash 
SafeHash			    pub struct SafeHash 
Set			impl Set<uint> for BitvSet 
SetItems			pub struct SetItems<'a, T> 
SetItems			pub struct SetItems<'a> 
SmallBitv			impl SmallBitv 
SmallBitv			struct SmallBitv 
SmallIntMap			pub struct SmallIntMap<T> 
SymDifferenceItems			pub struct SymDifferenceItems<'a, T> 
Taggy			    enum Taggy 
Taggypar			    enum Taggypar<T> 
TreeMap			pub struct TreeMap<K, V> 
TreeNode			struct TreeNode<K, V> 
TreeSet			pub struct TreeSet<T> 
TrieMap			pub struct TrieMap<T> 
TrieNode			struct TrieNode<T> 
TrieSet			impl TrieSet 
TrieSet			pub struct TrieSet 
UnionItems			pub struct UnionItems<'a, T> 
add			    pub fn add(&mut self, e: E) 
addMoreToCount			        fn addMoreToCount(_k: uint, v0: uint, v1: uint) -> uint 
addMoreToCount_simple			        fn addMoreToCount_simple(v0: uint, v1: uint) -> uint 
append			    pub fn append(&mut self, mut other: DList<T>) 
assert_opt_eq			    fn assert_opt_eq<V: Eq>(opt: Option<&V>, v: V) 
assign			    pub fn assign(&mut self, v: &Bitv) -> bool { self.do_op(Assign, v) }
attach			    fn attach(&mut self, node: *mut LruEntry<K, V>) 
back			    fn back<'a>(&'a self) -> Option<&'a T>;
back			    fn back<'a>(&'a self) -> Option<&'a T> 
back			    fn back<'a>(&'a self) -> Option<&'a T> 
back_mut			    fn back_mut<'a>(&'a mut self) -> Option<&'a mut T>;
back_mut			    fn back_mut<'a>(&'a mut self) -> Option<&'a mut T> 
back_mut			    fn back_mut<'a>(&'a mut self) -> Option<&'a mut T> 
become			    pub fn become(&mut self, b: &BigBitv, nbits: uint) -> bool 
become			    pub fn become(&mut self, s: &SmallBitv, nbits: uint) -> bool 
bench			pub mod bench 
bench			mod bench 
bench			mod bench 
bench			mod bench 
bench_big_bitv_big			    fn bench_big_bitv_big(b: &mut BenchHarness) 
bench_big_bitv_small			    fn bench_big_bitv_small(b: &mut BenchHarness) 
bench_bitv_big			    fn bench_bitv_big(b: &mut BenchHarness) 
bench_bitv_big_iter			    fn bench_bitv_big_iter(b: &mut BenchHarness) 
bench_bitv_big_union			    fn bench_bitv_big_union(b: &mut BenchHarness) 
bench_bitv_set_big			    fn bench_bitv_set_big(b: &mut BenchHarness) 
bench_bitv_set_small			    fn bench_bitv_set_small(b: &mut BenchHarness) 
bench_bitv_small			    fn bench_bitv_small(b: &mut BenchHarness) 
bench_bitvset_iter			    fn bench_bitvset_iter(b: &mut BenchHarness) 
bench_btv_small_iter			    fn bench_btv_small_iter(b: &mut BenchHarness) 
bench_collect_into			    fn bench_collect_into(b: &mut test::BenchHarness) 
bench_grow			    fn bench_grow(b: &mut test::BenchHarness) 
bench_insert_large			    fn bench_insert_large(bh: &mut BenchHarness) 
bench_insert_large_low_bits			    fn bench_insert_large_low_bits(bh: &mut BenchHarness) 
bench_insert_small			    fn bench_insert_small(bh: &mut BenchHarness) 
bench_insert_small_low_bits			    fn bench_insert_small_low_bits(bh: &mut BenchHarness) 
bench_iter			    fn bench_iter(b: &mut test::BenchHarness) 
bench_iter_large			    fn bench_iter_large(bh: &mut BenchHarness) 
bench_iter_mut			    fn bench_iter_mut(b: &mut test::BenchHarness) 
bench_iter_mut_rev			    fn bench_iter_mut_rev(b: &mut test::BenchHarness) 
bench_iter_rev			    fn bench_iter_rev(b: &mut test::BenchHarness) 
bench_iter_small			    fn bench_iter_small(bh: &mut BenchHarness) 
bench_lower_bound			    fn bench_lower_bound(bh: &mut BenchHarness) 
bench_map			mod bench_map 
bench_new			    fn bench_new(b: &mut test::BenchHarness) 
bench_push_back			    fn bench_push_back(b: &mut test::BenchHarness) 
bench_push_back			    fn bench_push_back(b: &mut test::BenchHarness) 
bench_push_back_pop_back			    fn bench_push_back_pop_back(b: &mut test::BenchHarness) 
bench_push_front			    fn bench_push_front(b: &mut test::BenchHarness) 
bench_push_front			    fn bench_push_front(b: &mut test::BenchHarness) 
bench_push_front_pop_front			    fn bench_push_front_pop_front(b: &mut test::BenchHarness) 
bench_rotate_backward			    fn bench_rotate_backward(b: &mut test::BenchHarness) 
bench_rotate_forward			    fn bench_rotate_forward(b: &mut test::BenchHarness) 
bench_small_bitv_small			    fn bench_small_bitv_small(b: &mut BenchHarness) 
bench_uint_small			    fn bench_uint_small(b: &mut BenchHarness) 
bench_upper_bound			    fn bench_upper_bound(bh: &mut BenchHarness) 
big_mask			fn big_mask(nbits: uint, elem: uint) -> uint 
bit			        fn bit (bitv: &Bitv, byte: uint, bit: uint) -> u8 
bit			fn bit<E:CLike>(e: E) -> uint 
bitand			    fn bitand(&self, e: &EnumSet<E>) -> EnumSet<E> 
bitor			    fn bitor(&self, e: &EnumSet<E>) -> EnumSet<E> 
bits_op			    pub fn bits_op(&mut self,
bitv			pub mod bitv;
bound			    fn bound<'a>(&'a self, key: uint, upper: bool) -> Entries<'a, T> 
bsearch_branch			    fn bsearch_branch(&self, k: K) -> Option<uint> 
bsearch_leaf			    fn bsearch_leaf(&self, k: K) -> Option<uint> 
bsearch_node			    fn bsearch_node(&self, k: K) -> Option<uint> 
bsearch_test_four			    fn bsearch_test_four() 
bsearch_test_one			    fn bsearch_test_one() 
bsearch_test_three			    fn bsearch_test_three() 
bsearch_test_two			    fn bsearch_test_two() 
btree			pub mod btree;
btree_clone_test			    fn btree_clone_test() 
btree_cmp_test_eq			    fn btree_cmp_test_eq() 
btree_cmp_test_greater			    fn btree_cmp_test_greater() 
btree_cmp_test_less			    fn btree_cmp_test_less() 
btree_tostr_test			    fn btree_tostr_test() 
bucket_distance			    fn bucket_distance(&self, index_of_elem: &table::FullIndex) -> uint 
capacity			    pub fn capacity(&self) -> uint { self.bitv.storage.len() * uint::BITS }
capacity			        pub fn capacity(&self) -> uint 
capacity			    pub fn capacity(&self) -> uint 
capacity			    pub fn capacity(&self) -> uint { self.data.capacity() }
change_capacity			    pub fn change_capacity(&mut self, capacity: uint) 
check			    fn check(a: &[int],
check_difference			        fn check_difference(a: &[int], b: &[int], expected: &[int]) 
check_equal			    fn check_equal<K: Eq + TotalOrd, V: Eq>(ctrl: &[(K, V)],
check_integrity			    fn check_integrity<T>(trie: &TrieNode<T>) 
check_intersection			        fn check_intersection(a: &[int], b: &[int], expected: &[int]) 
check_left			    fn check_left<K: TotalOrd, V>(node: &Option<~TreeNode<K, V>>,
check_links			    pub fn check_links<T>(list: &DList<T>) 
check_right			    fn check_right<K: TotalOrd, V>(node: &Option<~TreeNode<K, V>>,
check_structure			    fn check_structure<K: TotalOrd, V>(map: &TreeMap<K, V>) 
check_symmetric_difference			        fn check_symmetric_difference(a: &[int], b: &[int],
check_to_vec			    fn check_to_vec(mut data: ~[int]) 
check_union			        fn check_union(a: &[int], b: &[int],
chunk			fn chunk(n: uint, idx: uint) -> uint 
clear			    fn clear(&mut self) 
clear			    pub fn clear(&mut self) { self.bits = 0; }
clear			    pub fn clear(&mut self) 
clear			    fn clear(&mut self) 
clear			    fn clear(&mut self) { self.map.clear() }
clear			    fn clear(&mut self) 
clear			    fn clear(&mut self) 
clear			    fn clear(&mut self) { self.data.truncate(0) }
clear			    fn clear(&mut self) 
clear			    fn clear(&mut self) { self.v.clear() }
clear			    fn clear(&mut self) { self.map.clear() }
clear			    fn clear(&mut self) 
clear			    fn clear(&mut self) { self.map.clear() }
clear			    fn clear(&mut self) 
clone			    fn clone(&self) -> BTree<K, V> 
clone			    fn clone(&self) -> Branch<K, V> 
clone			    fn clone(&self) -> BranchElt<K, V> 
clone			    fn clone(&self) -> Leaf<K, V> 
clone			    fn clone(&self) -> LeafElt<K, V> 
clone			    fn clone(&self) -> Node<K, V> 
clone			    fn clone(&self) -> DList<A> 
clone			    fn clone(&self) -> Items<'a, T> { *self }
clone			    fn clone(&self) -> Rawlink<T> 
clone			        fn clone(&self) -> RawTable<K, V> 
cmp			impl cmp::Eq for BitvSet 
cmp			    fn cmp(&self, other: &BTree<K, V>) -> Ordering 
cmp			    fn cmp(&self, other: &Branch<K, V>) -> Ordering 
cmp			    fn cmp(&self, other: &BranchElt<K, V>) -> Ordering 
cmp			    fn cmp(&self, other: &Leaf<K, V>) -> Ordering 
cmp			    fn cmp(&self, other: &LeafElt<K, V>) -> Ordering 
cmp			    fn cmp(&self, other: &Node<K, V>) -> Ordering 
cmp_opt			fn cmp_opt<T: TotalOrd>(x: Option<&T>, y: Option<&T>,
commons			    fn commons<'a>(&'a self, other: &'a BitvSet)
contains			    fn contains(&self, value: &uint) -> bool 
contains			    pub fn contains(&self, e: EnumSet<E>) -> bool 
contains			    fn contains(&self, value: &T) -> bool { self.map.search(value).is_some() }
contains			    fn contains(&self, value: &T) -> bool 
contains			    pub fn contains(&self, value: &uint) -> bool 
contains_elem			    pub fn contains_elem(&self, e: E) -> bool 
contains_equiv			    pub fn contains_equiv<Q: Hash<S> + Equiv<T>>(&self, value: &Q) -> bool 
contains_key			    fn contains_key(&self, k: &K) -> bool 
contains_key_equiv			    pub fn contains_key_equiv<Q: Hash<S> + Equiv<K>>(&self, key: &Q) -> bool 
default			    fn default() -> HashMap<K, V, H> 
default			    fn default() -> HashSet<T> { HashSet::new() }
deque			pub mod deque;
deref			fn deref<'a, K, V>(node: &'a Option<~TreeNode<K, V>>) -> *TreeNode<K, V> 
detach			    fn detach(&mut self, node: *mut LruEntry<K, V>) 
die			fn die() -> ! 
difference			    pub fn difference(&mut self, b: &BigBitv, nbits: uint) -> bool 
difference			    pub fn difference(&mut self, s: &SmallBitv, nbits: uint) -> bool 
difference			    pub fn difference(&mut self, v: &Bitv) -> bool 
difference			    pub fn difference(&self, other: &BitvSet, f: |&uint| -> bool) -> bool 
difference			    pub fn difference<'a>(&'a self, other: &'a HashSet<T, H>) -> SetAlgebraItems<'a, T, H> 
difference			    pub fn difference<'a>(&'a self, other: &'a TreeSet<T>) -> DifferenceItems<'a, T> 
difference_with			    pub fn difference_with(&mut self, other: &BitvSet) 
dlist			pub mod dlist;
do_op			    fn do_op(&mut self, op: Op, other: &Bitv) -> bool 
drop			    fn drop(&mut self) 
drop			        fn drop(&mut self) 
drop			    fn drop(&mut self) 
each_reverse			    fn each_reverse<'a>(&'a self, f: |&uint, &'a T| -> bool) -> bool 
each_reverse			    pub fn each_reverse(&self, f: |&uint| -> bool) -> bool 
each_reverse			    pub fn each_reverse<'a>(&'a self, f: |&uint, &'a T| -> bool) -> bool 
each_storage			    pub fn each_storage(&mut self, op: |v: &mut uint| -> bool) -> bool 
empty			    pub fn empty() -> EnumSet<E> 
enum_set			pub mod enum_set;
eq			    fn eq(&self, other: &BitvSet) -> bool 
eq			    fn eq(&self, other: &BTree<K, V>) -> bool 
eq			    fn eq(&self, other: &Branch<K, V>) -> bool 
eq			    fn eq(&self, other: &BranchElt<K, V>) -> bool 
eq			    fn eq(&self, other: &Leaf<K, V>) -> bool 
eq			    fn eq(&self, other: &LeafElt<K, V>) -> bool 
eq			    fn eq(&self, other: &Node<K, V>) -> bool 
eq			    fn eq(&self, other: &DList<A>) -> bool 
eq			    fn eq(&self, other: &HashMap<K, V, H>) -> bool 
eq			    fn eq(&self, other: &HashSet<T, H>) -> bool 
eq			    fn eq(&self, other: &KeyRef<K>) -> bool 
eq			    fn eq(&self, other: &RingBuf<A>) -> bool 
eq			    fn eq(&self, other: &TreeMap<K, V>) -> bool 
eq			    fn eq(&self, other: &TreeSet<T>) -> bool { self.map == other.map }
eq_vec			    pub fn eq_vec(&self, v: &[bool]) -> bool 
equal			    pub fn equal(&self, v1: &Bitv) -> bool 
equals			    pub fn equals(&self, b: &BigBitv, nbits: uint) -> bool 
equals			    pub fn equals(&self, b: &SmallBitv, nbits: uint) -> bool 
extend			    fn extend<T: Iterator<A>>(&mut self, mut iterator: T) 
extend			    fn extend<I: Iterator<T>>(&mut self, mut iter: I) 
extend			    fn extend<T: Iterator<(K, V)>>(&mut self, mut iter: T) 
extend			    fn extend<Iter: Iterator<T>>(&mut self, mut iter: Iter) 
extend			    fn extend<T: Iterator<A>>(&mut self, mut iterator: T) 
extend			    fn extend<Iter: Iterator<T>>(&mut self, mut iter: Iter) 
extend			    fn extend<T: Iterator<(K, V)>>(&mut self, mut iter: T) 
extend			    fn extend<Iter: Iterator<(uint, T)>>(&mut self, mut iter: Iter) 
extend			    fn extend<Iter: Iterator<uint>>(&mut self, mut iter: Iter) 
find			    fn find<'a>(&'a self, k: &K) -> Option<&'a V> 
find			    fn find<'a>(&'a self, key: &uint) -> Option<&'a V> 
find			    fn find<'a>(&'a self, key: &K) -> Option<&'a V> 
find			    fn find<'a>(&'a self, key: &uint) -> Option<&'a T> 
find_copy			    pub fn find_copy(&self, k: &K) -> Option<V> 
find_empty			    fn find_empty() 
find_equiv			    pub fn find_equiv<'a, Q: Hash<S> + Equiv<K>>(&'a self, k: &Q) -> Option<&'a V> 
find_existing			    fn find_existing(b: &mut BenchHarness) 
find_mut			    fn find_mut<'a>(&'a mut self, k: &K) -> Option<&'a mut V> 
find_mut			    fn find_mut<'a>(&'a mut self, key: &uint) -> Option<&'a mut V> 
find_mut			    fn find_mut<'a>(&'a mut self, key: &K) -> Option<&'a mut V> 
find_mut			fn find_mut<'r, K: TotalOrd, V>(node: &'r mut Option<~TreeNode<K, V>>,
find_mut			    fn find_mut<'a>(&'a mut self, key: &uint) -> Option<&'a mut T> 
find_mut			fn find_mut<'r, T>(child: &'r mut Child<T>, key: uint, idx: uint) -> Option<&'r mut T> 
find_nonexisting			    fn find_nonexisting(b: &mut BenchHarness) 
find_not_found			    fn find_not_found() 
find_or_insert			    pub fn find_or_insert<'a>(&'a mut self, k: K, v: V) -> &'a mut V 
find_or_insert_with			    pub fn find_or_insert_with<'a>(&'a mut self, k: K, f: |&K| -> V)
find_pop_insert			    fn find_pop_insert(b: &mut BenchHarness) 
find_rand_100			    pub fn find_rand_100(bh: &mut BenchHarness) 
find_rand_100			    pub fn find_rand_100(bh: &mut BenchHarness) 
find_rand_10_000			    pub fn find_rand_10_000(bh: &mut BenchHarness) 
find_rand_10_000			    pub fn find_rand_10_000(bh: &mut BenchHarness) 
find_rand_n			    pub fn find_rand_n<M:MutableMap<uint,uint>>(n: uint,
find_seq_100			    pub fn find_seq_100(bh: &mut BenchHarness) 
find_seq_100			    pub fn find_seq_100(bh: &mut BenchHarness) 
find_seq_10_000			    pub fn find_seq_10_000(bh: &mut BenchHarness) 
find_seq_10_000			    pub fn find_seq_10_000(bh: &mut BenchHarness) 
find_seq_n			    pub fn find_seq_n<M:MutableMap<uint,uint>>(n: uint,
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fraction_mul			fn fraction_mul(lhs: uint, (num, den): Fraction) -> uint 
from_bitv			    pub fn from_bitv(bitv: Bitv) -> BitvSet 
from_bools			pub fn from_bools(bools: &[bool]) -> Bitv 
from_bytes			pub fn from_bytes(bytes: &[u8]) -> Bitv 
from_fn			pub fn from_fn(len: uint, f: |index: uint| -> bool) -> Bitv 
from_iter			    fn from_iter<T: Iterator<A>>(iterator: T) -> DList<A> 
from_iter			    fn from_iter<I: Iterator<T>>(iter: I) -> HashSet<T, H> 
from_iter			    fn from_iter<T: Iterator<(K, V)>>(iter: T) -> HashMap<K, V, H> 
from_iter			    fn from_iter<Iter: Iterator<T>>(iter: Iter) -> PriorityQueue<T> 
from_iter			    fn from_iter<T: Iterator<A>>(iterator: T) -> RingBuf<A> 
from_iter			    fn from_iter<Iter: Iterator<T>>(iter: Iter) -> TreeSet<T> 
from_iter			    fn from_iter<T: Iterator<(K, V)>>(iter: T) -> TreeMap<K, V> 
from_iter			    fn from_iter<Iter: Iterator<(uint, T)>>(iter: Iter) -> TrieMap<T> 
from_iter			    fn from_iter<Iter: Iterator<uint>>(iter: Iter) -> TrieSet 
from_uint			        fn from_uint(v: uint) -> Foo 
from_uint			    fn from_uint(uint) -> Self;
from_vec			    pub fn from_vec(xs: ~[T]) -> PriorityQueue<T> 
front			    fn front<'a>(&'a self) -> Option<&'a T>;
front			    fn front<'a>(&'a self) -> Option<&'a T> 
front			    fn front<'a>(&'a self) -> Option<&'a T> 
front_mut			    fn front_mut<'a>(&'a mut self) -> Option<&'a mut T>;
front_mut			    fn front_mut<'a>(&'a mut self) -> Option<&'a mut T> 
front_mut			    fn front_mut<'a>(&'a mut self) -> Option<&'a mut T> 
fuzz_test			    fn fuzz_test(sz: int) 
ge			    fn ge(&self, other: &DList<A>) -> bool 
ge			    fn ge(&self, other: &TreeMap<K, V>) -> bool { !lt(self, other) }
ge			    fn ge(&self, other: &TreeSet<T>) -> bool { self.map >= other.map }
generate_test			    fn generate_test() -> DList<int> 
get			    pub fn get(&self, i: uint) -> bool 
get			    fn get(&self, k: K) -> Option<V> 
get			    pub fn get(self, k: K) -> Option<V> 
get			    pub fn get<'a>(&'a self, k: &K) -> &'a V 
get			    pub fn get<'a>(&'a mut self, k: &K) -> Option<&'a V> 
get			    pub fn get<'a>(&'a self, i: uint) -> &'a T 
get			    pub fn get<'a>(&'a self, key: &uint) -> &'a V 
get_copy			    pub fn get_copy(&self, k: &K) -> V 
get_mut			    pub fn get_mut<'a>(&'a mut self, k: &K) -> &'a mut V 
get_mut			    pub fn get_mut<'a>(&'a mut self, i: uint) -> &'a mut T 
get_test			    fn get_test() 
grow			fn grow<T>(nelts: uint, loptr: &mut uint, elts: &mut ~[Option<T>]) 
grow_at			fn grow_at(capacity: uint, load_factor: Fraction) -> uint 
gt			    fn gt(&self, other: &DList<A>) -> bool 
gt			    fn gt(&self, other: &TreeMap<K, V>) -> bool { lt(other, self) }
gt			    fn gt(&self, other: &TreeSet<T>) -> bool { self.map > other.map }
hash			        pub fn hash(&self) -> SafeHash { self.hash }
hash			    fn hash(&self, state: &mut S) 
hashmap			pub mod hashmap;
hashmap_as_queue			    fn hashmap_as_queue(b: &mut BenchHarness) 
heir_swap			    fn heir_swap<K: TotalOrd, V>(node: &mut ~TreeNode<K, V>,
idx			    fn idx(&self, index: uint) -> Option<bool> 
idx			    fn idx(&self, j: uint) -> Option<&'a T> 
index			    fn index(&self, i: &uint) -> bool 
indexable			    fn indexable(&self) -> uint 
indexable			    fn indexable(&self) -> uint { self.rindex - self.index }
init_to_vec			    pub fn init_to_vec(&self, i: uint) -> uint 
insert			    fn insert(&mut self, value: uint) -> bool 
insert			    fn insert(mut self, k: K, v: V, ub: uint) -> (Node<K, V>, bool) 
insert			    fn insert(self, k: K, v: V, ub: uint) -> (Node<K, V>, bool) 
insert			    pub fn insert(mut self, k: K, v: V) -> BTree<K, V> 
insert			    fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }
insert			    fn insert(b: &mut BenchHarness) 
insert			    fn insert(&mut self, key: uint, value: V) -> bool 
insert			    fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }
insert			fn insert<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,
insert			    pub fn insert(&mut self, value: uint) -> bool 
insert			fn insert<T>(count: &mut uint, child: &mut Child<T>, key: uint, value: T,
insert_next			    fn insert_next(&mut self, elt: A) 
insert_next			    fn insert_next(&mut self, elt: A);
insert_next_node			    fn insert_next_node(&mut self, mut ins_node: ~Node<A>) 
insert_or_update_with			    pub fn insert_or_update_with<'a>(
insert_ordered			    pub fn insert_ordered(&mut self, elt: T) 
insert_rand_100			    pub fn insert_rand_100(bh: &mut BenchHarness) 
insert_rand_100			    pub fn insert_rand_100(bh: &mut BenchHarness) 
insert_rand_10_000			    pub fn insert_rand_10_000(bh: &mut BenchHarness) 
insert_rand_10_000			    pub fn insert_rand_10_000(bh: &mut BenchHarness) 
insert_rand_n			    pub fn insert_rand_n<M:MutableMap<uint,uint>>(n: uint,
insert_replace			    fn insert_replace() 
insert_seq_100			    pub fn insert_seq_100(bh: &mut BenchHarness) 
insert_seq_100			    pub fn insert_seq_100(bh: &mut BenchHarness) 
insert_seq_10_000			    pub fn insert_seq_10_000(bh: &mut BenchHarness) 
insert_seq_10_000			    pub fn insert_seq_10_000(bh: &mut BenchHarness) 
insert_seq_n			    pub fn insert_seq_n<M:MutableMap<uint,uint>>(n: uint,
insert_test_four			    fn insert_test_four() 
insert_test_one			    fn insert_test_one() 
insert_test_three			    fn insert_test_three() 
insert_test_two			    fn insert_test_two() 
insert_when			    pub fn insert_when(&mut self, elt: T, f: |&T, &T| -> bool) 
inspect			        pub fn inspect(&self) -> u64 { self.hash }
intersect			    pub fn intersect(&mut self, b: &BigBitv, nbits: uint) -> bool 
intersect			    pub fn intersect(&mut self, s: &SmallBitv, nbits: uint) -> bool 
intersect			    pub fn intersect(&mut self, v1: &Bitv) -> bool 
intersect_with			    pub fn intersect_with(&mut self, other: &BitvSet) 
intersection			    pub fn intersection(&self, other: &BitvSet, f: |&uint| -> bool) -> bool 
intersection			    pub fn intersection(&self, e: EnumSet<E>) -> EnumSet<E> 
intersection			    pub fn intersection<'a>(&'a self, other: &'a HashSet<T, H>)
intersection			    pub fn intersection<'a>(&'a self, other: &'a TreeSet<T>)
intersects			    pub fn intersects(&self, e: EnumSet<E>) -> bool 
is_disjoint			    fn is_disjoint(&self, other: &BitvSet) -> bool 
is_disjoint			    fn is_disjoint(&self, other: &HashSet<T, H>) -> bool 
is_disjoint			    fn is_disjoint(&self, other: &TreeSet<T>) -> bool 
is_empty			    fn is_empty(&self) -> bool 
is_empty			    pub fn is_empty(&self) -> bool 
is_empty			    fn is_empty(&self) -> bool 
is_empty			    fn is_empty(&self) -> bool { self.map.is_empty() }
is_empty			    fn is_empty(&self) -> bool { self.root.is_none() }
is_false			    pub fn is_false(&self) -> bool 
is_false			    pub fn is_false(&self, nbits: uint) -> bool 
is_leaf			    fn is_leaf(&self) -> bool 
is_subset			    fn is_subset(&self, other: &BitvSet) -> bool 
is_subset			    fn is_subset(&self, other: &HashSet<T, H>) -> bool 
is_subset			    fn is_subset(&self, other: &TreeSet<T>) -> bool 
is_superset			    fn is_superset(&self, other: &BitvSet) -> bool 
is_superset			    fn is_superset(&self, other: &HashSet<T, H>) -> bool 
is_superset			    fn is_superset(&self, other: &TreeSet<T>) -> bool 
is_true			    pub fn is_true(&self) -> bool 
is_true			    pub fn is_true(&self, nbits: uint) -> bool 
iter			    pub fn iter<'a>(&'a self) -> BitPositions<'a> 
iter			    pub fn iter<'a>(&'a self) -> Bits<'a> 
iter			    pub fn iter<'a>(&'a self) -> Items<'a, T> 
iter			    pub fn iter(&self) -> Items<E> 
iter			        pub fn iter<'a>(&'a self) -> Entries<'a, K, V> 
iter			    pub fn iter<'a>(&'a self) -> Entries<'a, K, V> 
iter			    pub fn iter<'a>(&'a self) -> SetItems<'a, T> 
iter			    pub fn iter<'a>(&'a self) -> Items<'a, T> 
iter			    pub fn iter<'a>(&'a self) -> Items<'a, T> 
iter			    pub fn iter<'r>(&'r self) -> Entries<'r, V> 
iter			    pub fn iter<'a>(&'a self) -> Entries<'a, K, V> 
iter			    pub fn iter<'a>(&'a self) -> SetItems<'a, T> 
iter			    pub fn iter<'a>(&'a self) -> Entries<'a, T> 
iter			    pub fn iter<'a>(&'a self) -> SetItems<'a> 
iter_for_traversal			    fn iter_for_traversal<'a>(&'a self) -> Entries<'a, K, V> 
iterate_bits			fn iterate_bits(base: uint, bits: uint, f: |uint| -> bool) -> bool 
keys			    pub fn keys<'a>(&'a self) -> Keys<'a, K, V> 
le			    fn le(&self, other: &DList<A>) -> bool 
le			    fn le(&self, other: &TreeMap<K, V>) -> bool { !lt(other, self) }
le			    fn le(&self, other: &TreeSet<T>) -> bool { self.map <= other.map }
len			    fn len(&self) -> uint { self.size }
len			    fn len(&self) -> uint 
len			    fn len(&self) -> uint { self.map.len() }
len			    fn len(&self) -> uint { self.table.size() }
len			    fn len(&self) -> uint 
len			    fn len(&self) -> uint { self.data.len() }
len			    fn len(&self) -> uint { self.nelts }
len			    fn len(&self) -> uint 
len			    fn len(&self) -> uint { self.length }
len			    fn len(&self) -> uint { self.map.len() }
len			    fn len(&self) -> uint { self.length }
len			    fn len(&self) -> uint { self.map.len() }
link_with_prev			fn link_with_prev<T>(mut next: ~Node<T>, prev: Rawlink<Node<T>>) -> Link<T> 
list_from			    fn list_from<T: Clone>(v: &[T]) -> DList<T> 
lower_bound			    pub fn lower_bound<'a>(&'a self, k: &K) -> Entries<'a, K, V> 
lower_bound			    pub fn lower_bound<'a>(&'a self, v: &T) -> SetItems<'a, T> 
lower_bound			    pub fn lower_bound<'a>(&'a self, key: uint) -> Entries<'a, T> 
lower_bound			    pub fn lower_bound<'a>(&'a self, val: uint) -> SetItems<'a> 
lru_cache			pub mod lru_cache;
lt			    fn lt(&self, other: &BTree<K, V>) -> bool 
lt			    fn lt(&self, other: &Branch<K, V>) -> bool 
lt			    fn lt(&self, other: &BranchElt<K, V>) -> bool 
lt			    fn lt(&self, other: &Leaf<K, V>) -> bool 
lt			    fn lt(&self, other: &LeafElt<K, V>) -> bool 
lt			    fn lt(&self, other: &Node<K, V>) -> bool 
lt			    fn lt(&self, other: &DList<A>) -> bool 
lt			    fn lt(&self, other: &TreeMap<K, V>) -> bool { lt(self, other) }
lt			    fn lt(&self, other: &TreeSet<T>) -> bool { self.map < other.map }
lt			fn lt<K: Ord + TotalOrd, V: Ord>(a: &TreeMap<K, V>,
make_hash			    fn make_hash<X: Hash<S>>(&self, x: &X) -> table::SafeHash 
make_hash			    pub fn make_hash<T: Hash<S>, S, H: Hasher<S>>(hasher: &H, t: &T) -> SafeHash 
make_some_room			    fn make_some_room(&mut self, new_size: uint) 
manual_insert			    fn manual_insert<'a>(&'a mut self, k: K, v: V) -> &'a mut V 
manual_insert_hashed			    fn manual_insert_hashed<'a>(&'a mut self, hash: table::SafeHash, k: K, v: V) -> &'a mut V 
manual_insert_hashed_nocheck			    fn manual_insert_hashed_nocheck<'a>(
maybe_pop			    pub fn maybe_pop(&mut self) -> Option<T> 
maybe_top			    pub fn maybe_top<'a>(&'a self) -> Option<&'a T> 
merge			    pub fn merge(&mut self, mut other: DList<T>, f: |&T, &T| -> bool) 
move_iter			    pub fn move_iter(self) -> MoveItems<T> 
move_iter			        pub fn move_iter(self) -> MoveEntries<K, V> 
move_iter			    pub fn move_iter(self) -> MoveEntries<K, V> 
move_iter			    pub fn move_iter(self) -> SetMoveItems<T> 
move_iter			    pub fn move_iter(&mut self)
move_iter			    pub fn move_iter(self) -> MoveEntries<K, V> 
move_rev_iter			    pub fn move_rev_iter(self) -> Rev<MoveItems<T>> 
mut_bound			    fn mut_bound<'a>(&'a mut self, key: uint, upper: bool) -> MutEntries<'a, T> 
mut_deref			fn mut_deref<K, V>(x: &mut Option<~TreeNode<K, V>>) -> *mut TreeNode<K, V> 
mut_iter			    pub fn mut_iter<'a>(&'a mut self) -> MutItems<'a, T> 
mut_iter			        pub fn mut_iter<'a>(&'a mut self) -> MutEntries<'a, K, V> 
mut_iter			    pub fn mut_iter<'a>(&'a mut self) -> MutEntries<'a, K, V> 
mut_iter			    pub fn mut_iter<'a>(&'a mut self) -> MutItems<'a, T> 
mut_iter			    pub fn mut_iter<'r>(&'r mut self) -> MutEntries<'r, V> 
mut_iter			    pub fn mut_iter<'a>(&'a mut self) -> MutEntries<'a, K, V> 
mut_iter			    pub fn mut_iter<'a>(&'a mut self) -> MutEntries<'a, T> 
mut_iter_for_traversal			    fn mut_iter_for_traversal<'a>(&'a mut self) -> MutEntries<'a, K, V> 
mut_lower_bound			    pub fn mut_lower_bound<'a>(&'a mut self, k: &K) -> MutEntries<'a, K, V> 
mut_lower_bound			    pub fn mut_lower_bound<'a>(&'a mut self, key: uint) -> MutEntries<'a, T> 
mut_rev_iter			    pub fn mut_rev_iter<'a>(&'a mut self) -> Rev<MutItems<'a, T>> 
mut_rev_iter			    pub fn mut_rev_iter<'a>(&'a mut self) -> Rev<MutItems<'a, T>> 
mut_rev_iter			    pub fn mut_rev_iter<'r>(&'r mut self) -> RevMutEntries <'r, V> 
mut_rev_iter			    pub fn mut_rev_iter<'a>(&'a mut self) -> RevMutEntries<'a, K, V> 
mut_upper_bound			    pub fn mut_upper_bound<'a>(&'a mut self, k: &K) -> MutEntries<'a, K, V> 
mut_upper_bound			    pub fn mut_upper_bound<'a>(&'a mut self, key: uint) -> MutEntries<'a, T> 
nbits			        fn nbits(mut w: uint) -> uint 
ne			    fn ne(&self, other: &BitvSet) -> bool { !self.eq(other) }
ne			    fn ne(&self, other: &DList<A>) -> bool 
ne			    fn ne(&self, other: &RingBuf<A>) -> bool 
ne			    fn ne(&self, other: &TreeSet<T>) -> bool { self.map != other.map }
negate			    pub fn negate(&mut self) { self.bits = !self.bits; }
negate			    pub fn negate(&mut self) 
new			    pub fn new() -> BitvSet 
new			    pub fn new(bits: uint) -> SmallBitv 
new			    pub fn new(nbits: uint, init: bool) -> Bitv 
new			    pub fn new(storage: ~[uint]) -> BigBitv 
new			    fn new(k: K, v: V) -> LeafElt<K, V> 
new			    fn new(k: K, v: V, n: ~Node<K, V>) -> BranchElt<K, V> 
new			    fn new(vec: ~[BranchElt<K, V>], right: ~Node<K, V>) -> Branch<K, V> 
new			    fn new(vec: ~[LeafElt<K, V>]) -> Leaf<K, V> 
new			    pub fn new(k: K, v: V, lb: uint) -> BTree<K, V> 
new			    fn new(v: T) -> Node<T> 
new			    pub fn new() -> DList<T> 
new			    fn new(bits: uint) -> Items<E> 
new			        fn new(k: int) -> Dropable 
new			        pub fn new(capacity: uint) -> RawTable<K, V> 
new			    pub fn new() -> HashMap<K, V, sip::SipHasher> 
new			    pub fn new() -> HashSet<T, sip::SipHasher> 
new			    fn new() -> LruEntry<K, V> 
new			    pub fn new(capacity: uint) -> LruCache<K, V> 
new			    pub fn new() -> PriorityQueue<T> { PriorityQueue{data: ~[],} }
new			    pub fn new() -> RingBuf<T> 
new			    pub fn new() -> SmallIntMap<V> { SmallIntMap{v: ~[]} }
new			    pub fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }
new			    pub fn new() -> TreeSet<T> { TreeSet{map: TreeMap::new()} }
new			    pub fn new(key: K, value: V) -> TreeNode<K, V> 
new			            unsafe fn new() -> $name<'a, T> 
new			    fn new() -> TrieNode<T> 
new			    pub fn new() -> TrieMap<T> 
new			    pub fn new() -> TrieSet 
new_branch			    fn new_branch(vec: ~[BranchElt<K, V>], right: ~Node<K, V>) -> Node<K, V> 
new_leaf			    fn new_leaf(vec: ~[LeafElt<K, V>]) -> Node<K,V> 
new_uninitialized			        unsafe fn new_uninitialized(capacity: uint) -> RawTable<K, V> 
new_with_node_len			    fn new_with_node_len(n: Node<K, V>,
next			    fn next(&mut self) -> Option<bool> 
next			    fn next(&mut self) -> Option<uint> 
next			    fn next(&mut self) -> Option<&'a A> 
next			    fn next(&mut self) -> Option<&'a mut A> 
next			    fn next(&mut self) -> Option<A> { self.list.pop_front() }
next			    fn next(&mut self) -> Option<E> 
next			        fn next(&mut self) -> Option<(&'a K, &'a V)> 
next			        fn next(&mut self) -> Option<(&'a K, &'a mut V)> 
next			        fn next(&mut self) -> Option<(SafeHash, K, V)> 
next			    fn next(&mut self) -> Option<(&'a T)> { self.iter.next() }
next			    fn next(&mut self) -> Option<&'a T> 
next			    fn next(&mut self) -> Option<&'a mut T> 
next			            fn next(&mut self) -> Option<$elem> 
next			            fn next(&mut self) -> Option<(&'a K, &'a $($addr_mut)* V)> 
next			    fn next(&mut self) -> Option<&'a T> 
next			    fn next(&mut self) -> Option<(K, V)> 
next			                fn next(&mut self) -> Option<(uint, &'a $($mut_)* T)> 
next			    fn next(&mut self) -> Option<uint> 
next_			            fn next_(&mut self, forward: bool) -> Option<(&'a K, &'a $($addr_mut)* V)> 
next_back			    fn next_back(&mut self) -> Option<bool> 
next_back			    fn next_back(&mut self) -> Option<&'a A> 
next_back			    fn next_back(&mut self) -> Option<&'a mut A> 
next_back			    fn next_back(&mut self) -> Option<A> { self.list.pop_back() }
next_back			    fn next_back(&mut self) -> Option<&'a T> 
next_back			    fn next_back(&mut self) -> Option<&'a mut T> 
next_back			            fn next_back(&mut self) -> Option<$elem> 
none			    fn none() -> Rawlink<T> 
ones			    pub fn ones(&self, f: |uint| -> bool) -> bool 
ops			impl ops::Index<uint,bool> for Bitv 
other_op			    fn other_op(&mut self, other: &BitvSet, f: |uint, uint| -> uint) 
outliers			    fn outliers<'a>(&'a self, other: &'a BitvSet)
peek			        pub fn peek(&self, index: uint) -> BucketState 
peek_next			    fn peek_next<'a>(&'a mut self) -> Option<&'a mut A> 
peek_next			    fn peek_next<'a>(&'a mut self) -> Option<&'a mut A>;
pop			    fn pop(&mut self, k: &K) -> Option<V> 
pop			    pub fn pop(&mut self, k: &K) -> Option<V> 
pop			    pub fn pop(&mut self) -> T 
pop			    fn pop(&mut self, key: &uint) -> Option<V> 
pop			    fn pop(&mut self, key: &K) -> Option<V> 
pop			    fn pop(&mut self, key: &uint) -> Option<T> 
pop_back			    fn pop_back(&mut self) -> Option<T>;
pop_back			    fn pop_back(&mut self) -> Option<T> 
pop_back			    fn pop_back(&mut self) -> Option<T> 
pop_back_node			    fn pop_back_node(&mut self) -> Option<~Node<T>> 
pop_front			    fn pop_front(&mut self) -> Option<T>;
pop_front			    fn pop_front(&mut self) -> Option<T> 
pop_front			    fn pop_front(&mut self) -> Option<T> 
pop_front_node			    fn pop_front_node(&mut self) -> Option<~Node<T>> 
prepend			    pub fn prepend(&mut self, mut other: DList<T>) 
priority_queue			pub mod priority_queue;
probe			    fn probe(&self, hash: &table::SafeHash, idx: uint) -> uint 
probe_next			    fn probe_next(&self, probe: uint) -> uint 
process			    pub fn process(&mut self,
push			    pub fn push(&mut self, item: T) 
push_back			    fn push_back(&mut self, elt: T);
push_back			    fn push_back(&mut self, elt: T) 
push_back			    fn push_back(&mut self, t: T) 
push_back_node			    fn push_back_node(&mut self, mut new_tail: ~Node<T>) 
push_front			    fn push_front(&mut self, elt: T);
push_front			    fn push_front(&mut self, elt: T) 
push_front			    fn push_front(&mut self, t: T) 
push_front_node			    fn push_front_node(&mut self, mut new_head: ~Node<T>) 
push_pop			    pub fn push_pop(&mut self, mut item: T) -> T 
put			        pub fn put(&mut self, index: EmptyIndex, hash: SafeHash, k: K, v: V) -> FullIndex 
put			    pub fn put(&mut self, k: K, v: V) 
raw_index			        pub fn raw_index(&self) -> uint { self.idx as uint }
raw_index			    fn raw_index(&self, idx: uint) -> uint 
raw_index			fn raw_index(lo: uint, len: uint, index: uint) -> uint 
read			        pub fn read<'a>(&'a self, index: &FullIndex) -> (&'a K, &'a V) 
read_all_mut			        pub fn read_all_mut<'a>(&'a mut self, index: &FullIndex)
read_mut			        pub fn read_mut<'a>(&'a mut self, index: &FullIndex) -> (&'a K, &'a mut V) 
remove			    fn remove(&mut self, value: &uint) -> bool 
remove			    fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }
remove			    fn remove(&mut self, key: &uint) -> bool 
remove			    fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }
remove			fn remove<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,
remove			    pub fn remove(&mut self, value: &uint) -> bool 
remove			fn remove<T>(count: &mut uint, child: &mut Child<T>, key: uint,
remove_lru			    fn remove_lru(&mut self) 
replace			    pub fn replace(&mut self, mut item: T) -> T 
reserve			    pub fn reserve(&mut self, n: uint) 
reserve			    pub fn reserve(&mut self, new_minimum_capacity: uint) 
reserve			    pub fn reserve(&mut self, n: uint) 
reserve			    pub fn reserve(&mut self, n: uint) 
reserve_exact			    pub fn reserve_exact(&mut self, n: uint) { self.data.reserve_exact(n) }
reserve_exact			    pub fn reserve_exact(&mut self, n: uint) 
resize			    fn resize(&mut self, new_capacity: uint) 
resolve			    fn resolve(&mut self) -> Option<&mut T> 
resolve_immut			    fn resolve_immut(&self) -> Option<&T> 
rev_iter			    pub fn rev_iter<'a>(&'a self) -> Rev<Bits<'a>> 
rev_iter			    pub fn rev_iter<'a>(&'a self) -> Rev<Items<'a, T>> 
rev_iter			    pub fn rev_iter<'a>(&'a self) -> Rev<Items<'a, T>> 
rev_iter			    pub fn rev_iter<'r>(&'r self) -> RevEntries<'r, V> 
rev_iter			    pub fn rev_iter<'a>(&'a self) -> RevEntries<'a, K, V> 
rev_iter			    pub fn rev_iter<'a>(&'a self) -> RevSetItems<'a, T> 
ringbuf			pub mod ringbuf;
rng			    fn rng() -> rand::IsaacRng 
robin_hood			    fn robin_hood(&mut self, mut index: table::FullIndex, mut dib_param: uint,
rotate_backward			    pub fn rotate_backward(&mut self) 
rotate_forward			    pub fn rotate_forward(&mut self) 
search			    fn search(&self, k: &K) -> Option<table::FullIndex> 
search_equiv			    fn search_equiv<Q: Hash<S> + Equiv<K>>(&self, q: &Q) -> Option<table::FullIndex> 
search_hashed			    fn search_hashed(&self, hash: &table::SafeHash, k: &K) -> Option<table::FullIndex> 
search_hashed_generic			    fn search_hashed_generic(&self, hash: &table::SafeHash, is_match: |&K| -> bool)
set			    pub fn set(&mut self, i: uint, x: bool) 
set_all			    pub fn set_all(&mut self) { self.bits = !0; }
set_all			    pub fn set_all(&mut self) 
shrink_at			    fn shrink_at(&self) -> uint 
siftdown			    fn siftdown(&mut self, pos: uint) 
siftdown_range			    fn siftdown_range(&mut self, mut pos: uint, end: uint) 
siftup			    fn siftup(&mut self, start: uint, mut pos: uint) 
size			        pub fn size(&self) -> uint 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			        fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			            fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			            fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			                fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
skew			fn skew<K: TotalOrd, V>(node: &mut ~TreeNode<K, V>) 
small_mask			fn small_mask(nbits: uint) -> uint 
smallintmap			pub mod smallintmap;
some			    fn some(n: &mut T) -> Rawlink<T> 
split			fn split<K: TotalOrd, V>(node: &mut ~TreeNode<K, V>) 
sub			    fn sub(&self, e: &EnumSet<E>) -> EnumSet<E> 
swap			    fn swap(&mut self, k: K, v: V) -> Option<V> 
swap			    pub fn swap(&mut self, i: uint, j: uint) 
swap			    fn swap(&mut self, key: uint, value: V) -> Option<V> 
swap			    fn swap(&mut self, key: K, value: V) -> Option<V> 
swap			    fn swap(&mut self, key: uint, value: T) -> Option<T> 
symmetric_difference			    pub fn symmetric_difference(&self, other: &BitvSet, f: |&uint| -> bool)
symmetric_difference			    pub fn symmetric_difference<'a>(&'a self, other: &'a HashSet<T, H>)
symmetric_difference			    pub fn symmetric_difference<'a>(&'a self, other: &'a TreeSet<T>)
symmetric_difference_with			    pub fn symmetric_difference_with(&mut self, other: &BitvSet) 
table			mod table 
take			    fn take(&mut self) -> Rawlink<T> 
take			        pub fn take(&mut self, index: FullIndex) -> (EmptyIndex, K, V) 
test			mod test 
test_0_elements			    fn test_0_elements() 
test_10_elements			    fn test_10_elements() 
test_1_element			    fn test_1_element() 
test_2_elements			    fn test_2_elements() 
test_31_elements			    fn test_31_elements() 
test_32_elements			    fn test_32_elements() 
test_33_elements			    fn test_33_elements() 
test_append			    fn test_append() 
test_basic			    fn test_basic() 
test_big_clear			    fn test_big_clear() 
test_big_difference			    fn test_big_difference() 
test_bitv_clone			    fn test_bitv_clone() 
test_bitv_iterator			    fn test_bitv_iterator() 
test_bitv_remove			    fn test_bitv_remove() 
test_bitv_set_basic			    fn test_bitv_set_basic() 
test_bitv_set_difference			    fn test_bitv_set_difference() 
test_bitv_set_frombitv_init			    fn test_bitv_set_frombitv_init() 
test_bitv_set_intersection			    fn test_bitv_set_intersection() 
test_bitv_set_iterator			    fn test_bitv_set_iterator() 
test_bitv_set_symmetric_difference			    fn test_bitv_set_symmetric_difference() 
test_bitv_set_union			    fn test_bitv_set_union() 
test_bound			    fn test_bound() 
test_boxes			    fn test_boxes() 
test_btree			mod test_btree 
test_change_capacity			    fn test_change_capacity() 
test_clear			    fn test_clear() 
test_clear			    fn test_clear() 
test_clear			    fn test_clear() 
test_clone			    fn test_clone() 
test_clone_eq			    fn test_clone_eq() 
test_conflict_remove			    fn test_conflict_remove() 
test_contains			    fn test_contains() 
test_contains_elem			    fn test_contains_elem() 
test_create_capacity_zero			    fn test_create_capacity_zero() 
test_difference			    fn test_difference() 
test_difference			    fn test_difference() 
test_disjoint			    fn test_disjoint() 
test_disjoint			    fn test_disjoint() 
test_disjoint_intersects			    fn test_disjoint_intersects() 
test_drops			    fn test_drops() 
test_each_reverse			    fn test_each_reverse() 
test_each_reverse_break			    fn test_each_reverse_break() 
test_empty			    fn test_empty() 
test_empty_does_not_intersect_with_full			    fn test_empty_does_not_intersect_with_full() 
test_empty_maybe_pop			    fn test_empty_maybe_pop() 
test_empty_maybe_top			    fn test_empty_maybe_top() 
test_empty_pop			    fn test_empty_pop() 
test_empty_pop			    fn test_empty_pop() 
test_empty_replace			    fn test_empty_replace() 
test_empty_top			    fn test_empty_top() 
test_eq			    fn test_eq() 
test_eq			    fn test_eq() 
test_eq			    fn test_eq() 
test_eq			    fn test_eq() 
test_equal_differing_sizes			    fn test_equal_differing_sizes() 
test_equal_greatly_differing_sizes			    fn test_equal_greatly_differing_sizes() 
test_equal_sneaky_big			    fn test_equal_sneaky_big() 
test_equal_sneaky_small			    fn test_equal_sneaky_small() 
test_expand			    fn test_expand() 
test_expire_lru			    fn test_expire_lru() 
test_find			    fn test_find() 
test_find_equiv			    fn test_find_equiv() 
test_find_mut			    fn test_find_mut() 
test_find_mut			    fn test_find_mut() 
test_find_mut			    fn test_find_mut() 
test_find_mut			    fn test_find_mut() 
test_find_mut_missing			    fn test_find_mut_missing() 
test_from_bools			    fn test_from_bools() 
test_from_bytes			    fn test_from_bytes() 
test_from_iter			    fn test_from_iter() 
test_from_iter			    fn test_from_iter() 
test_from_iter			    fn test_from_iter() 
test_from_iter			    fn test_from_iter() 
test_from_iter			    fn test_from_iter() 
test_fuzz			    fn test_fuzz() 
test_insert			    fn test_insert() 
test_insert_conflicts			    fn test_insert_conflicts() 
test_insert_ordered			    fn test_insert_ordered() 
test_insert_overwrite			    fn test_insert_overwrite() 
test_insert_prev			    fn test_insert_prev() 
test_insert_with_key			    fn test_insert_with_key() 
test_intersection			    fn test_intersection() 
test_intersection			    fn test_intersection() 
test_interval_iteration			    fn test_interval_iteration() 
test_is_empty			    fn test_is_empty() 
test_iter			    fn test_iter() 
test_iterate			    fn test_iterate() 
test_iteration			    fn test_iteration() 
test_iterator			    fn test_iterator() 
test_iterator			    fn test_iterator() 
test_iterator			    fn test_iterator() 
test_iterator			    fn test_iterator() 
test_iterator			    fn test_iterator() 
test_iterator_clone			    fn test_iterator_clone() 
test_iterator_double_end			    fn test_iterator_double_end() 
test_iterator_mut_double_end			    fn test_iterator_mut_double_end() 
test_iterator_size_hints			    fn test_iterator_size_hints() 
test_keys			    fn test_keys() 
test_lazy_iterator			    fn test_lazy_iterator() 
test_len			    fn test_len() 
test_len			    fn test_len() 
test_lots_of_insertions			    fn test_lots_of_insertions() 
test_lt			    fn test_lt() 
test_map			mod test_map 
test_map			mod test_map 
test_map			mod test_map 
test_merge			    fn test_merge() 
test_move_iter			    fn test_move_iter() 
test_move_iter			    fn test_move_iter() 
test_mut_bound			    fn test_mut_bound() 
test_mut_interval_iter			    fn test_mut_interval_iter() 
test_mut_iter			    fn test_mut_iter() 
test_mut_iter			    fn test_mut_iter() 
test_mut_iter			    fn test_mut_iter() 
test_mut_iter			    fn test_mut_iter() 
test_mut_iterator			    fn test_mut_iterator() 
test_mut_rev_iter			    fn test_mut_rev_iter() 
test_mut_rev_iter			    fn test_mut_rev_iter() 
test_mut_rev_iter			    fn test_mut_rev_iter() 
test_mut_rev_iter_wrap			    fn test_mut_rev_iter_wrap() 
test_mut_rev_iterator			    fn test_mut_rev_iterator() 
test_operators			    fn test_operators() 
test_ord			    fn test_ord() 
test_ord			    fn test_ord() 
test_ord_nan			    fn test_ord_nan() 
test_overlapping_intersects			    fn test_overlapping_intersects() 
test_param_at_int			    fn test_param_at_int() 
test_param_int			    fn test_param_int() 
test_param_reccy			    fn test_param_reccy() 
test_param_taggy			    fn test_param_taggy() 
test_param_taggypar			    fn test_param_taggypar() 
test_parameterized			    fn test_parameterized<T:Clone + Eq + Show>(a: T, b: T, c: T, d: T) 
test_pop			    fn test_pop() 
test_pop			    fn test_pop() 
test_pop			    fn test_pop() 
test_pop			    fn test_pop() 
test_pop			    fn test_pop() 
test_prepend			    fn test_prepend() 
test_push			    fn test_push() 
test_push_front_grow			    fn test_push_front_grow() 
test_push_pop			    fn test_push_pop() 
test_push_unique			    fn test_push_unique() 
test_put_and_get			    fn test_put_and_get() 
test_put_update			    fn test_put_update() 
test_rand_int			    fn test_rand_int() 
test_replace			    fn test_replace() 
test_reserve			    fn test_reserve() 
test_reserve_exact			    fn test_reserve_exact() 
test_rev_iter			    fn test_rev_iter() 
test_rev_iter			    fn test_rev_iter() 
test_rev_iter			    fn test_rev_iter() 
test_rev_iterator			    fn test_rev_iterator() 
test_rotate			    fn test_rotate() 
test_sane_chunk			    fn test_sane_chunk() 
test_send			    fn test_send() 
test_set			mod test_set 
test_set			mod test_set 
test_set			mod test_set 
test_show			    fn test_show() 
test_simple			    fn test_simple() 
test_small_clear			    fn test_small_clear() 
test_small_difference			    fn test_small_difference() 
test_step			    fn test_step() 
test_subset_and_superset			    fn test_subset_and_superset() 
test_subset_and_superset			    fn test_subset_and_superset() 
test_swap			    fn test_swap() 
test_swap			    fn test_swap() 
test_swap			    fn test_swap() 
test_swap			    fn test_swap() 
test_swap			    fn test_swap() 
test_symmetric_difference			    fn test_symmetric_difference() 
test_symmetric_difference			    fn test_symmetric_difference() 
test_to_bools			    fn test_to_bools() 
test_to_bytes			    fn test_to_bytes() 
test_to_str			    fn test_to_str() 
test_to_str			    fn test_to_str() 
test_to_vec			    fn test_to_vec() 
test_top_and_pop			    fn test_top_and_pop() 
test_treemap			mod test_treemap 
test_two_empties_do_not_intersect			    fn test_two_empties_do_not_intersect() 
test_union			    fn test_union() 
test_union			    fn test_union() 
test_values			    fn test_values() 
test_with_capacity			    fn test_with_capacity() 
test_zip			    fn test_zip() 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
to_bools			    pub fn to_bools(&self) -> ~[bool] 
to_bytes			    pub fn to_bytes(&self) -> ~[u8] 
to_sorted_vec			    pub fn to_sorted_vec(self) -> ~[T] 
to_str			     pub fn to_str(&self) -> ~str 
to_uint			        fn to_uint(&self) -> uint 
to_uint			    fn to_uint(&self) -> uint;
to_vec			    pub fn to_vec(&self) -> ~[uint] 
to_vec			    pub fn to_vec(self) -> ~[T] { let PriorityQueue{data: v} = self; v }
top			    pub fn top<'a>(&'a self) -> &'a T { &self.data[0] }
traverse_complete			            fn traverse_complete(&mut self) 
traverse_left			            fn traverse_left(&mut self) 
traverse_right			            fn traverse_right(&mut self) 
treemap			pub mod treemap;
trie			pub mod trie;
u8_map			    fn u8_map() 
union			    pub fn union(&mut self, b: &BigBitv, nbits: uint) -> bool 
union			    pub fn union(&mut self, s: &SmallBitv, nbits: uint) -> bool 
union			    pub fn union(&mut self, v1: &Bitv) -> bool { self.do_op(Union, v1) }
union			    pub fn union(&self, other: &BitvSet, f: |&uint| -> bool) -> bool 
union			    pub fn union(&self, e: EnumSet<E>) -> EnumSet<E> 
union			    pub fn union<'a>(&'a self, other: &'a HashSet<T, H>)
union			    pub fn union<'a>(&'a self, other: &'a TreeSet<T>) -> UnionItems<'a, T> 
union_with			    pub fn union_with(&mut self, other: &BitvSet) 
unwrap			    pub fn unwrap(self) -> Bitv 
update			    pub fn update(&mut self, key: uint, newval: V, ff: |V, V| -> V) -> bool 
update_with_key			    pub fn update_with_key(&mut self,
upper_bound			    pub fn upper_bound<'a>(&'a self, k: &K) -> Entries<'a, K, V> 
upper_bound			    pub fn upper_bound<'a>(&'a self, v: &T) -> SetItems<'a, T> 
upper_bound			    pub fn upper_bound<'a>(&'a self, key: uint) -> Entries<'a, T> 
upper_bound			    pub fn upper_bound<'a>(&'a self, val: uint) -> SetItems<'a> 
values			    pub fn values<'a>(&'a self) -> Values<'a, K, V> 
with_capacity			    pub fn with_capacity(capacity: uint) -> HashMap<K, V, sip::SipHasher> 
with_capacity			    pub fn with_capacity(capacity: uint) -> HashSet<T, sip::SipHasher> 
with_capacity			    pub fn with_capacity(n: uint) -> RingBuf<T> 
with_capacity_and_hasher			    pub fn with_capacity_and_hasher(capacity: uint, hasher: H) -> HashMap<K, V, H> 
with_capacity_and_hasher			    pub fn with_capacity_and_hasher(capacity: uint, hasher: H) -> HashSet<T, H> 
with_hasher			    pub fn with_hasher(hasher: H) -> HashMap<K, V, H> 
with_hasher			    pub fn with_hasher(hasher: H) -> HashSet<T, H> 
with_key_value			    fn with_key_value(k: K, v: V) -> LruEntry<K, V> 
