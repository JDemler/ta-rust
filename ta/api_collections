BTree			pub struct BTree<K, V> 
BadElem			        struct BadElem(int);
BigBitv			impl BigBitv 
BigBitv			struct BigBitv 
BitPositions			pub struct BitPositions<'a> 
Bits			pub struct Bits<'a> 
Bitv			impl Bitv 
Bitv			pub struct Bitv 
BitvSet			impl BitvSet 
BitvSet			pub struct BitvSet 
BitvVariant			enum BitvVariant { Big(BigBitv), Small(SmallBitv) }
Branch			struct Branch<K, V> 
BranchElt			struct BranchElt<K, V> 
Bytes			    struct Bytes<'a>(&'a [u8]);
CLike			    impl CLike for Foo 
CLike			pub trait CLike 
CharEq			        impl CharEq for NotAscii 
Child			enum Child<T> 
Clone			impl Clone for SipState 
Clone			        impl Clone for S 
CloneableVector			pub trait CloneableVector<T> 
Collection			impl Collection for BitvSet 
Collection			impl Collection for String 
Collection			impl Collection for TrieSet 
Custom			    struct Custom 
DList			pub struct DList<T> 
DecompositionType			enum DecompositionType 
Decompositions			pub struct Decompositions<'a> 
Default			impl Default for BitvSet 
Default			impl Default for SipHasher 
Default			impl Default for SipState 
Default			impl Default for String 
Default			impl Default for TrieSet 
Deque			pub trait Deque<T> : Mutable 
DifferenceItems			pub struct DifferenceItems<'a, T> 
Direction			enum Direction { Pos, Neg }
Drop			        impl Drop for BadElem 
Drop			        impl Drop for Elem 
DropCounter			        struct DropCounter<'a> 
Elem			        struct Elem(int);
ElementSwaps			impl ElementSwaps 
ElementSwaps			pub struct ElementSwaps 
Entries			pub struct Entries<'a, T> 
Entries			pub struct Entries<'a, K, V> 
Entries			pub struct Entries<'a, T> 
EnumSet			pub struct EnumSet<E> 
Extendable			impl Extendable<char> for String 
Extendable			impl Extendable<uint> for TrieSet 
Foo			    enum Foo 
Foo			    struct Foo;
FromIterator			impl FromIterator<char> for String 
FromIterator			impl FromIterator<uint> for TrieSet 
Hash			    impl Hash<u64> for Custom 
Hash			pub trait Hash<S = sip::SipState> 
Hasher			    impl Hasher<MyWriter> for MyWriterHasher 
Hasher			pub trait Hasher<S> 
Hasher			impl Hasher<SipState> for SipHasher 
ImmutableCloneableVector			pub trait ImmutableCloneableVector<T> 
IntersectionItems			pub struct IntersectionItems<'a, T> 
IntoMaybeOwned			pub trait IntoMaybeOwned<'a> 
Items			pub struct Items<'a, T> 
Items			pub struct Items<E> 
Items			pub struct Items <'a, T> 
Items			pub struct Items<'a, T> 
Iterator			impl Iterator<(uint, uint)> for ElementSwaps 
Leaf			struct Leaf<K, V> 
LeafElt			struct LeafElt<K, V> 
ListInsertion			pub trait ListInsertion<A> 
Map			pub trait Map<K, V>: Collection 
MaybeOwned			pub enum MaybeOwned<'a> 
MoveEntries			pub struct MoveEntries<K, V> 
MoveItems			pub struct MoveItems<T> 
MoveItems			pub struct MoveItems<T> 
MutEntries			pub struct MutEntries<'a, T> 
MutEntries			pub struct MutEntries<'a, K, V> 
MutEntries			pub struct MutEntries<'a, T> 
MutItems			pub struct MutItems<'a, T> 
MutItems			pub struct MutItems<'a, T> 
Mutable			impl Mutable for BitvSet 
Mutable			pub trait Mutable: Collection 
Mutable			impl Mutable for String 
Mutable			impl Mutable for TrieSet 
MutableMap			pub trait MutableMap<K, V>: Map<K, V> + Mutable 
MutableOrdVector			pub trait MutableOrdVector<T> 
MutableSet			impl MutableSet<uint> for BitvSet 
MutableSet			pub trait MutableSet<T>: Set<T> + Mutable 
MutableSet			impl MutableSet<uint> for TrieSet 
MutableVectorAllocating			pub trait MutableVectorAllocating<'a, T> 
MyWriter			    struct MyWriter 
MyWriterHasher			    struct MyWriterHasher;
Node			enum Node<K, V> 
Node			struct Node<T> 
NotAscii			        struct NotAscii(char);
Op			enum Op {Union, Intersect, Assign, Difference}
OwnedStr			impl OwnedStr for String 
OwnedStr			pub trait OwnedStr 
Permutations			pub struct Permutations<T> 
PriorityQueue			pub struct PriorityQueue<T> 
Rawlink			struct Rawlink<T> { p: *mut T }
RecCy			    struct RecCy 
RevEntries			pub struct RevEntries<'a, K, V> 
RevMutEntries			pub struct RevMutEntries<'a, K, V> 
RevSetItems			pub struct RevSetItems<'a, T> 
RingBuf			pub struct RingBuf<T> 
S			        struct S 
Set			impl Set<uint> for BitvSet 
Set			pub trait Set<T>: Collection 
Set			impl Set<uint> for TrieSet 
SetItems			pub struct SetItems<'a, T> 
SetItems			pub struct SetItems<'a> 
SipHasher			impl SipHasher 
SipHasher			pub struct SipHasher 
SipState			impl SipState 
SipState			pub struct SipState 
SizeDirection			struct SizeDirection 
SmallBitv			impl SmallBitv 
SmallBitv			struct SmallBitv 
SmallIntMap			pub struct SmallIntMap<T> 
Str			impl Str for String 
StrAllocating			pub trait StrAllocating: Str 
StrAllocating			impl StrAllocating for String 
StrVector			pub trait StrVector 
String			impl String 
String			pub struct String 
SymDifferenceItems			pub struct SymDifferenceItems<'a, T> 
Taggy			    enum Taggy 
Taggypar			    enum Taggypar<T> 
TreeMap			pub struct TreeMap<K, V> 
TreeNode			struct TreeNode<K, V> 
TreeSet			pub struct TreeSet<T> 
TrieMap			pub struct TrieMap<T> 
TrieNode			struct TrieNode<T> 
TrieSet			impl TrieSet 
TrieSet			pub struct TrieSet 
TwoVec			        struct TwoVec<T> 
UnionItems			pub struct UnionItems<'a, T> 
Vec			pub struct Vec<T> 
VectorVector			pub trait VectorVector<T> 
Writer			    impl Writer for MyWriter 
Writer			pub trait Writer 
Writer			impl Writer for SipState 
a_million_letter_a			        fn a_million_letter_a() -> String 
a_million_letter_x			        fn a_million_letter_x() -> String 
add			    pub fn add(&mut self, e: E) 
add			    fn add(&self, other: &S) -> String 
add			    fn add(&self, rhs: &V) -> Vec<T> 
add_more_to_count			        fn add_more_to_count(_k: uint, v0: uint, v1: uint) -> uint 
add_more_to_count_simple			        fn add_more_to_count_simple(v0: uint, v1: uint) -> uint 
all			    fn all(&self, nbits: uint) -> bool 
all			    pub fn all(&self) -> bool 
alloc_or_realloc			unsafe fn alloc_or_realloc<T>(ptr: *mut T, size: uint, old_size: uint) -> *mut T 
any			    pub fn any(&self) -> bool 
append			    pub fn append(&mut self, mut other: DList<T>) 
append			    fn append(mut self, rhs: &str) -> String 
append			    fn append(self, rhs: &str) -> String;
append			    pub fn append(mut self, second: &str) -> String 
append			    pub fn append(mut self, second: &[T]) -> Vec<T> 
append_one			    pub fn append_one(mut self, x: T) -> Vec<T> 
as_bytes			    pub fn as_bytes<'a>(&'a self) -> &'a [u8] 
as_mut_bytes			    pub unsafe fn as_mut_bytes<'a>(&'a mut self) -> &'a mut [u8] 
as_mut_ptr			    pub fn as_mut_ptr(&mut self) -> *mut T 
as_mut_slice			    pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] 
as_mut_vec			    pub unsafe fn as_mut_vec<'a>(&'a mut self) -> &'a mut Vec<u8> 
as_ptr			    pub fn as_ptr(&self) -> *const T 
as_slice			    fn as_slice<'b>(&'b self) -> &'b str 
as_slice			    fn as_slice<'a>(&'a self) -> &'a str 
as_slice			    fn as_slice<'a>(&'a self) -> &'a [T] 
assign			    pub fn assign(&mut self, v: &Bitv) -> bool { self.do_op(Assign, v) }
back			    fn back<'a>(&'a self) -> Option<&'a T> 
back			    fn back<'a>(&'a self) -> Option<&'a T>;
back			    fn back<'a>(&'a self) -> Option<&'a T> 
back_mut			    fn back_mut<'a>(&'a mut self) -> Option<&'a mut T> 
back_mut			    fn back_mut<'a>(&'a mut self) -> Option<&'a mut T>;
back_mut			    fn back_mut<'a>(&'a mut self) -> Option<&'a mut T> 
become			    fn become(&mut self, b: &BigBitv, nbits: uint) -> bool 
become			    fn become(&mut self, s: &SmallBitv, nbits: uint) -> bool 
bench			pub mod bench 
bench			mod bench 
bench			mod bench 
bench			mod bench 
bench			mod bench 
bench_big_bitv_big			    fn bench_big_bitv_big(b: &mut Bencher) 
bench_big_bitv_small			    fn bench_big_bitv_small(b: &mut Bencher) 
bench_bitv_big			    fn bench_bitv_big(b: &mut Bencher) 
bench_bitv_big_iter			    fn bench_bitv_big_iter(b: &mut Bencher) 
bench_bitv_big_union			    fn bench_bitv_big_union(b: &mut Bencher) 
bench_bitv_set_big			    fn bench_bitv_set_big(b: &mut Bencher) 
bench_bitv_set_small			    fn bench_bitv_set_small(b: &mut Bencher) 
bench_bitv_small			    fn bench_bitv_small(b: &mut Bencher) 
bench_bitvset_iter			    fn bench_bitvset_iter(b: &mut Bencher) 
bench_btv_small_iter			    fn bench_btv_small_iter(b: &mut Bencher) 
bench_collect_into			    fn bench_collect_into(b: &mut test::Bencher) 
bench_connect			    fn bench_connect(b: &mut Bencher) 
bench_contains_bad_naive			    fn bench_contains_bad_naive(b: &mut Bencher) 
bench_contains_equal			    fn bench_contains_equal(b: &mut Bencher) 
bench_contains_short_long			    fn bench_contains_short_long(b: &mut Bencher) 
bench_contains_short_short			    fn bench_contains_short_short(b: &mut Bencher) 
bench_extend_0			    fn bench_extend_0(b: &mut Bencher) 
bench_extend_5			    fn bench_extend_5(b: &mut Bencher) 
bench_from_fn_0			    fn bench_from_fn_0(b: &mut Bencher) 
bench_from_fn_5			    fn bench_from_fn_5(b: &mut Bencher) 
bench_from_iter_0			    fn bench_from_iter_0(b: &mut Bencher) 
bench_from_iter_5			    fn bench_from_iter_5(b: &mut Bencher) 
bench_from_slice_0			    fn bench_from_slice_0(b: &mut Bencher) 
bench_from_slice_5			    fn bench_from_slice_5(b: &mut Bencher) 
bench_grow			    fn bench_grow(b: &mut test::Bencher) 
bench_insert_large			    fn bench_insert_large(b: &mut Bencher) 
bench_insert_large_low_bits			    fn bench_insert_large_low_bits(b: &mut Bencher) 
bench_insert_small			    fn bench_insert_small(b: &mut Bencher) 
bench_insert_small_low_bits			    fn bench_insert_small_low_bits(b: &mut Bencher) 
bench_iter			    fn bench_iter(b: &mut test::Bencher) 
bench_iter_large			    fn bench_iter_large(b: &mut Bencher) 
bench_iter_mut			    fn bench_iter_mut(b: &mut test::Bencher) 
bench_iter_mut_rev			    fn bench_iter_mut_rev(b: &mut test::Bencher) 
bench_iter_rev			    fn bench_iter_rev(b: &mut test::Bencher) 
bench_iter_small			    fn bench_iter_small(b: &mut Bencher) 
bench_long_str			    fn bench_long_str(b: &mut Bencher) 
bench_lower_bound			    fn bench_lower_bound(b: &mut Bencher) 
bench_map			mod bench_map 
bench_new			    fn bench_new(b: &mut test::Bencher) 
bench_new			    fn bench_new(b: &mut Bencher) 
bench_push_back			    fn bench_push_back(b: &mut test::Bencher) 
bench_push_back			    fn bench_push_back(b: &mut test::Bencher) 
bench_push_back_pop_back			    fn bench_push_back_pop_back(b: &mut test::Bencher) 
bench_push_front			    fn bench_push_front(b: &mut test::Bencher) 
bench_push_front			    fn bench_push_front(b: &mut test::Bencher) 
bench_push_front_pop_front			    fn bench_push_front_pop_front(b: &mut test::Bencher) 
bench_push_str			    fn bench_push_str(b: &mut Bencher) 
bench_rotate_backward			    fn bench_rotate_backward(b: &mut test::Bencher) 
bench_rotate_forward			    fn bench_rotate_forward(b: &mut test::Bencher) 
bench_small_bitv_small			    fn bench_small_bitv_small(b: &mut Bencher) 
bench_str_of_8_bytes			    fn bench_str_of_8_bytes(b: &mut Bencher) 
bench_str_over_8_bytes			    fn bench_str_over_8_bytes(b: &mut Bencher) 
bench_str_under_8_bytes			    fn bench_str_under_8_bytes(b: &mut Bencher) 
bench_u64			    fn bench_u64(b: &mut Bencher) 
bench_uint_small			    fn bench_uint_small(b: &mut Bencher) 
bench_upper_bound			    fn bench_upper_bound(b: &mut Bencher) 
bench_with_capacity			    fn bench_with_capacity(b: &mut Bencher) 
bench_with_capacity_0			    fn bench_with_capacity_0(b: &mut Bencher) 
bench_with_capacity_100			    fn bench_with_capacity_100(b: &mut Bencher) 
bench_with_capacity_5			    fn bench_with_capacity_5(b: &mut Bencher) 
big_mask			fn big_mask(nbits: uint, elem: uint) -> uint 
bit			        fn bit (bitv: &Bitv, byte: uint, bit: uint) -> u8 
bit			fn bit<E:CLike>(e: E) -> uint 
bitand			    fn bitand(&self, e: &EnumSet<E>) -> EnumSet<E> 
bitor			    fn bitor(&self, e: &EnumSet<E>) -> EnumSet<E> 
bits_op			    fn bits_op(&mut self,
bitv			pub mod bitv;
bound			    fn bound<'a>(&'a self, key: uint, upper: bool) -> Entries<'a, T> 
bsearch_branch			    fn bsearch_branch(&self, k: K) -> Option<uint> 
bsearch_leaf			    fn bsearch_leaf(&self, k: K) -> Option<uint> 
bsearch_node			    fn bsearch_node(&self, k: K) -> Option<uint> 
bsearch_range_value_table			    fn bsearch_range_value_table(c: char, r: &'static [(char, char, u8)]) -> u8 
bsearch_test_four			    fn bsearch_test_four() 
bsearch_test_one			    fn bsearch_test_one() 
bsearch_test_three			    fn bsearch_test_three() 
bsearch_test_two			    fn bsearch_test_two() 
btree			pub mod btree;
btree_clone_test			    fn btree_clone_test() 
btree_cmp_test_eq			    fn btree_cmp_test_eq() 
btree_cmp_test_greater			    fn btree_cmp_test_greater() 
btree_cmp_test_less			    fn btree_cmp_test_less() 
btree_tostr_test			    fn btree_tostr_test() 
byte_capacity			    pub fn byte_capacity(&self) -> uint 
canonical_combining_class			    pub fn canonical_combining_class(c: char) -> u8 
canonical_sort			fn canonical_sort(comb: &mut [(char, u8)]) 
capacity			    pub fn capacity(&self) -> uint { self.bitv.storage.len() * uint::BITS }
capacity			    pub fn capacity(&self) -> uint { self.data.capacity() }
capacity			    pub fn capacity(&self) -> uint 
case			        fn case(a: Vec<uint>, b: Vec<uint>) 
char_indicesator			    fn char_indicesator(b: &mut Bencher) 
char_indicesator_rev			    fn char_indicesator_rev(b: &mut Bencher) 
char_iterator			    fn char_iterator(b: &mut Bencher) 
char_iterator_ascii			    fn char_iterator_ascii(b: &mut Bencher) 
char_iterator_rev			    fn char_iterator_rev(b: &mut Bencher) 
check			    fn check(a: &[int],
check_difference			        fn check_difference(a: &[int], b: &[int], expected: &[int]) 
check_equal			    fn check_equal<K: PartialEq + Ord, V: PartialEq>(ctrl: &[(K, V)],
check_integrity			    fn check_integrity<T>(trie: &TrieNode<T>) 
check_intersection			        fn check_intersection(a: &[int], b: &[int], expected: &[int]) 
check_left			    fn check_left<K: Ord, V>(node: &Option<Box<TreeNode<K, V>>>,
check_links			    pub fn check_links<T>(list: &DList<T>) 
check_right			    fn check_right<K: Ord, V>(node: &Option<Box<TreeNode<K, V>>>,
check_structure			    fn check_structure<K: Ord, V>(map: &TreeMap<K, V>) 
check_symmetric_difference			        fn check_symmetric_difference(a: &[int], b: &[int],
check_to_vec			    fn check_to_vec(mut data: Vec<int>) 
check_union			        fn check_union(a: &[int], b: &[int],
chunk			fn chunk(n: uint, idx: uint) -> uint 
clear			    fn clear(&mut self) { self.bits = 0; }
clear			    fn clear(&mut self) 
clear			    pub fn clear(&mut self) 
clear			    fn clear(&mut self) 
clear			    fn clear(&mut self);
clear			    fn clear(&mut self) { self.data.truncate(0) }
clear			    fn clear(&mut self) 
clear			    fn clear(&mut self) { self.v.clear() }
clear			    fn clear(&mut self) 
clear			    fn clear(&mut self) { self.map.clear() }
clear			    fn clear(&mut self) 
clear			    fn clear(&mut self) { self.map.clear() }
clear			    fn clear(&mut self) 
clear			    fn clear(&mut self) 
clone			    fn clone(&self) -> BTree<K, V> 
clone			    fn clone(&self) -> Branch<K, V> 
clone			    fn clone(&self) -> BranchElt<K, V> 
clone			    fn clone(&self) -> Leaf<K, V> 
clone			    fn clone(&self) -> LeafElt<K, V> 
clone			    fn clone(&self) -> Node<K, V> 
clone			    fn clone(&self) -> DList<A> 
clone			    fn clone(&self) -> Items<'a, T> { *self }
clone			    fn clone(&self) -> Rawlink<T> 
clone			    fn clone(&self) -> SipState 
clone			            fn clone(&self) -> S 
clone			    fn clone(&self) -> MaybeOwned<'a> 
clone			    fn clone(&self) -> Vec<T> 
clone_from			    fn clone_from(&mut self, other: &Vec<T>) 
cmp			impl cmp::Eq for Bitv {}
cmp			impl cmp::Eq for BitvSet {}
cmp			impl cmp::PartialEq for Bitv 
cmp			impl cmp::PartialEq for BitvSet 
cmp			    fn cmp(&self, other: &BTree<K, V>) -> Ordering 
cmp			    fn cmp(&self, other: &Branch<K, V>) -> Ordering 
cmp			    fn cmp(&self, other: &BranchElt<K, V>) -> Ordering 
cmp			    fn cmp(&self, other: &Leaf<K, V>) -> Ordering 
cmp			    fn cmp(&self, other: &LeafElt<K, V>) -> Ordering 
cmp			    fn cmp(&self, other: &Node<K, V>) -> Ordering 
cmp			    fn cmp(&self, other: &MaybeOwned) -> Ordering 
cmp			    fn cmp(&self, other: &Vec<T>) -> Ordering 
cmp_opt			fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>,
commons			    fn commons<'a>(&'a self, other: &'a BitvSet)
concat			    fn concat(b: &mut Bencher) 
concat			    fn concat(&self) -> String 
concat			    fn concat(&self) -> String;
concat_vec			    fn concat_vec(&self) -> Vec<T> 
concat_vec			    fn concat_vec(&self) -> Vec<T>;
connect			    fn connect(b: &mut Bencher) 
connect			    fn connect(&self, sep: &str) -> String 
connect			    fn connect(&self, sep: &str) -> String;
connect_vec			    fn connect_vec(&self, sep: &T) -> Vec<T> 
connect_vec			    fn connect_vec(&self, sep: &T) -> Vec<T>;
contains			    fn contains(&self, value: &uint) -> bool 
contains			    pub fn contains(&self, e: EnumSet<E>) -> bool 
contains			    fn contains(&self, value: &T) -> bool;
contains			    fn contains(&self, value: &T) -> bool 
contains			    fn contains(&self, value: &uint) -> bool 
contains			    pub fn contains(&self, x: &T) -> bool 
contains_elem			    pub fn contains_elem(&self, e: E) -> bool 
contains_key			    fn contains_key(&self, key: &K) -> bool 
contains_last_element			    fn contains_last_element(b: &mut Bencher) 
dealloc			unsafe fn dealloc<T>(ptr: *mut T, len: uint) 
dedup			    pub fn dedup(&mut self) 
default			    fn default() -> BitvSet { BitvSet::new() }
default			    fn default() -> DList<T> { DList::new() }
default			    fn default() -> SipHasher 
default			    fn default() -> SipState 
default			    fn default() -> PriorityQueue<T> { PriorityQueue::new() }
default			    fn default() -> RingBuf<T> { RingBuf::new() }
default			    fn default() -> SmallIntMap<V> { SmallIntMap::new() }
default			    fn default() -> MaybeOwned<'a> { Slice("") }
default			    fn default() -> String 
default			    fn default() -> TreeMap<K, V> { TreeMap::new() }
default			    fn default() -> TreeSet<T> { TreeSet::new() }
default			    fn default() -> TrieMap<T> { TrieMap::new() }
default			    fn default() -> TrieSet { TrieSet::new() }
default			    fn default() -> Vec<T> 
deque			mod deque;
deref			fn deref<'a, K, V>(node: &'a Option<Box<TreeNode<K, V>>>) -> *const TreeNode<K, V> 
die			fn die() -> ! 
difference			    fn difference(&mut self, b: &BigBitv, nbits: uint) -> bool 
difference			    fn difference(&mut self, s: &SmallBitv, nbits: uint) -> bool 
difference			    pub fn difference(&mut self, v: &Bitv) -> bool 
difference			    pub fn difference(&self, other: &BitvSet, f: |&uint| -> bool) -> bool 
difference			    pub fn difference<'a>(&'a self, other: &'a TreeSet<T>) -> DifferenceItems<'a, T> 
difference_with			    pub fn difference_with(&mut self, other: &BitvSet) 
dlist			pub mod dlist;
do_op			    fn do_op(&mut self, op: Op, other: &Bitv) -> bool 
drop			    fn drop(&mut self) 
drop			            fn drop(&mut self) 
drop			    fn drop(&mut self) 
each_reverse			    fn each_reverse<'a>(&'a self, f: |&uint, &'a T| -> bool) -> bool 
each_reverse			    pub fn each_reverse(&self, f: |&uint| -> bool) -> bool 
each_reverse			    pub fn each_reverse<'a>(&'a self, f: |&uint, &'a T| -> bool) -> bool 
each_storage			    fn each_storage(&mut self, op: |v: &mut uint| -> bool) -> bool 
empty			    pub fn empty() -> EnumSet<E> 
ends_with_diff_one_element_at_beginning			    fn ends_with_diff_one_element_at_beginning(b: &mut Bencher) 
ends_with_same_vector			    fn ends_with_same_vector(b: &mut Bencher) 
ends_with_single_element			    fn ends_with_single_element(b: &mut Bencher) 
enum_set			pub mod enum_set;
eq			    fn eq(&self, other: &Bitv) -> bool 
eq			    fn eq(&self, other: &BitvSet) -> bool 
eq			    fn eq(&self, other: &BTree<K, V>) -> bool 
eq			    fn eq(&self, other: &Branch<K, V>) -> bool 
eq			    fn eq(&self, other: &BranchElt<K, V>) -> bool 
eq			    fn eq(&self, other: &Leaf<K, V>) -> bool 
eq			    fn eq(&self, other: &LeafElt<K, V>) -> bool 
eq			    fn eq(&self, other: &Node<K, V>) -> bool 
eq			    fn eq(&self, other: &DList<A>) -> bool 
eq			    fn eq(&self, other: &RingBuf<A>) -> bool 
eq			    fn eq(&self, other: &MaybeOwned) -> bool 
eq			    fn eq(&self, other: &TreeMap<K, V>) -> bool 
eq			    fn eq(&self, other: &TreeSet<T>) -> bool { self.map == other.map }
eq			    fn eq(&self, other: &Vec<T>) -> bool 
eq_vec			    pub fn eq_vec(&self, v: &[bool]) -> bool 
equals			    fn equals(&self, b: &BigBitv, nbits: uint) -> bool 
equals			    fn equals(&self, b: &SmallBitv, nbits: uint) -> bool 
equiv			    fn equiv(&self, other: &S) -> bool 
equiv			    fn equiv(&self, other: &S) -> bool 
equiv			    fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }
escape_default			    fn escape_default(&self) -> String 
escape_unicode			    fn escape_unicode(&self) -> String 
extend			    fn extend<T: Iterator<A>>(&mut self, mut iterator: T) 
extend			    fn extend<Iter: Iterator<T>>(&mut self, mut iter: Iter) 
extend			    fn extend<T: Iterator<A>>(&mut self, mut iterator: T) 
extend			    fn extend<I:Iterator<char>>(&mut self, mut iterator: I) 
extend			    fn extend<Iter: Iterator<T>>(&mut self, mut iter: Iter) 
extend			    fn extend<T: Iterator<(K, V)>>(&mut self, mut iter: T) 
extend			    fn extend<Iter: Iterator<(uint, T)>>(&mut self, mut iter: Iter) 
extend			    fn extend<Iter: Iterator<uint>>(&mut self, mut iter: Iter) 
extend			    fn extend<I: Iterator<T>>(&mut self, mut iterator: I) 
find			    fn find<'a>(&'a self, key: &K) -> Option<&'a V>;
find			    fn find<'a>(&'a self, key: &uint) -> Option<&'a V> 
find			    fn find<'a>(&'a self, key: &K) -> Option<&'a V> 
find			    fn find<'a>(&'a self, key: &uint) -> Option<&'a T> 
find_empty			    fn find_empty() 
find_mut			    fn find_mut<'a>(&'a mut self, key: &K) -> Option<&'a mut V>;
find_mut			    fn find_mut<'a>(&'a mut self, key: &uint) -> Option<&'a mut V> 
find_mut			    fn find_mut<'a>(&'a mut self, key: &K) -> Option<&'a mut V> 
find_mut			fn find_mut<'r, K: Ord, V>(node: &'r mut Option<Box<TreeNode<K, V>>>,
find_mut			    fn find_mut<'a>(&'a mut self, key: &uint) -> Option<&'a mut T> 
find_mut			fn find_mut<'r, T>(child: &'r mut Child<T>, key: uint, idx: uint) -> Option<&'r mut T> 
find_not_found			    fn find_not_found() 
find_rand_100			    pub fn find_rand_100(b: &mut Bencher) 
find_rand_100			    pub fn find_rand_100(b: &mut Bencher) 
find_rand_10_000			    pub fn find_rand_10_000(b: &mut Bencher) 
find_rand_10_000			    pub fn find_rand_10_000(b: &mut Bencher) 
find_rand_n			    pub fn find_rand_n<M:MutableMap<uint,uint>>(n: uint,
find_seq_100			    pub fn find_seq_100(b: &mut Bencher) 
find_seq_100			    pub fn find_seq_100(b: &mut Bencher) 
find_seq_10_000			    pub fn find_seq_10_000(b: &mut Bencher) 
find_seq_10_000			    pub fn find_seq_10_000(b: &mut Bencher) 
find_seq_n			    pub fn find_seq_n<M:MutableMap<uint,uint>>(n: uint,
fixme_14344_be_sure_to_link_to_collections			pub fn fixme_14344_be_sure_to_link_to_collections() {}
fmt			    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result 
fmt			impl fmt::Show for Bitv 
fmt			impl fmt::Show for BitvSet 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			impl fmt::Show for String 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
from_bitv			    pub fn from_bitv(bitv: Bitv) -> BitvSet 
from_bools			pub fn from_bools(bools: &[bool]) -> Bitv 
from_buf			    pub unsafe fn from_buf<T>(ptr: *const T, elts: uint) -> Vec<T> 
from_buf_len			    pub unsafe fn from_buf_len(buf: *const u8, len: uint) -> String 
from_byte			    pub unsafe fn from_byte(u: u8) -> String 
from_byte			pub fn from_byte(b: u8) -> String 
from_bytes			pub fn from_bytes(bytes: &[u8]) -> Bitv 
from_c_str			    pub unsafe fn from_c_str(c_string: *const i8) -> String 
from_char			pub fn from_char(ch: char) -> String 
from_char			    pub fn from_char(length: uint, ch: char) -> String 
from_chars			pub fn from_chars(chs: &[char]) -> String 
from_elem			    pub fn from_elem(length: uint, value: T) -> Vec<T> 
from_fn			pub fn from_fn(len: uint, f: |index: uint| -> bool) -> Bitv 
from_fn			    pub fn from_fn(length: uint, op: |uint| -> T) -> Vec<T> 
from_iter			    fn from_iter<T: Iterator<A>>(iterator: T) -> DList<A> 
from_iter			    fn from_iter<Iter: Iterator<T>>(iter: Iter) -> PriorityQueue<T> 
from_iter			    fn from_iter<T: Iterator<A>>(iterator: T) -> RingBuf<A> 
from_iter			    fn from_iter<I:Iterator<char>>(iterator: I) -> String 
from_iter			    fn from_iter<Iter: Iterator<T>>(iter: Iter) -> TreeSet<T> 
from_iter			    fn from_iter<T: Iterator<(K, V)>>(iter: T) -> TreeMap<K, V> 
from_iter			    fn from_iter<Iter: Iterator<(uint, T)>>(iter: Iter) -> TrieMap<T> 
from_iter			    fn from_iter<Iter: Iterator<uint>>(iter: Iter) -> TrieSet 
from_iter			    fn from_iter<I:Iterator<T>>(mut iterator: I) -> Vec<T> 
from_owned_str			    pub fn from_owned_str(string: String) -> String 
from_raw_parts			    pub unsafe fn from_raw_parts(length: uint, capacity: uint, ptr: *mut u8) -> String 
from_raw_parts			    pub unsafe fn from_raw_parts(length: uint, capacity: uint,
from_slice			    pub fn from_slice(values: &[T]) -> Vec<T> 
from_str			    pub fn from_str(string: &str) -> String 
from_uint			        fn from_uint(v: uint) -> Foo 
from_uint			    fn from_uint(uint) -> Self;
from_utf16			pub fn from_utf16(v: &[u16]) -> Option<String> 
from_utf16_lossy			pub fn from_utf16_lossy(v: &[u16]) -> String 
from_utf8			    pub fn from_utf8(vec: Vec<u8>) -> Result<String, Vec<u8>> 
from_utf8_lossy			pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> MaybeOwned<'a> 
from_utf8_lossy_100_ascii			    fn from_utf8_lossy_100_ascii(b: &mut Bencher) 
from_utf8_lossy_100_invalid			    fn from_utf8_lossy_100_invalid(b: &mut Bencher) 
from_utf8_lossy_100_multibyte			    fn from_utf8_lossy_100_multibyte(b: &mut Bencher) 
from_utf8_lossy_invalid			    fn from_utf8_lossy_invalid(b: &mut Bencher) 
from_utf8_owned			    pub unsafe fn from_utf8_owned(v: Vec<u8>) -> String 
from_utf8_owned			pub fn from_utf8_owned(vv: Vec<u8>) -> Result<String, Vec<u8>> 
from_vec			    pub fn from_vec(xs: Vec<T>) -> PriorityQueue<T> 
front			    fn front<'a>(&'a self) -> Option<&'a T> 
front			    fn front<'a>(&'a self) -> Option<&'a T>;
front			    fn front<'a>(&'a self) -> Option<&'a T> 
front_mut			    fn front_mut<'a>(&'a mut self) -> Option<&'a mut T> 
front_mut			    fn front_mut<'a>(&'a mut self) -> Option<&'a mut T>;
front_mut			    fn front_mut<'a>(&'a mut self) -> Option<&'a mut T> 
fuzz_test			    fn fuzz_test(sz: int) 
generate_test			    fn generate_test() -> DList<int> 
get			    fn get(&self, i: uint) -> bool 
get			    pub fn get(&self, i: uint) -> bool 
get			    fn get(&self, k: K) -> Option<V> 
get			    pub fn get(self, k: K) -> Option<V> 
get			    pub fn get<'a>(&'a self, i: uint) -> &'a T 
get			    pub fn get<'a>(&'a self, key: &uint) -> &'a V 
get			    pub fn get<'a>(&'a self, index: uint) -> &'a T 
get_mut			    pub fn get_mut<'a>(&'a mut self, i: uint) -> &'a mut T 
get_mut			    pub fn get_mut<'a>(&'a mut self, index: uint) -> &'a mut T 
get_test			    fn get_test() 
grow			fn grow<T>(nelts: uint, loptr: &mut uint, elts: &mut Vec<Option<T>>) 
grow			    pub fn grow(&mut self, count: uint, ch: char) 
grow			    pub fn grow(&mut self, n: uint, value: &T) 
grow_fn			    pub fn grow_fn(&mut self, n: uint, f: |uint| -> T) 
grow_set			    pub fn grow_set(&mut self, index: uint, initval: &T, value: T) 
half_a_million_letter_a			        fn half_a_million_letter_a() -> String 
half_a_million_letter_x			        fn half_a_million_letter_x() -> String 
hash			    fn hash(&self, state: &mut S) 
hash			            fn hash(&self, state: &mut S) 
hash			        fn hash(&self, state: &mut u64) 
hash			        fn hash<T: Hash<MyWriter>>(&self, value: &T) -> u64 
hash			    fn hash(&self, state: &mut S) 
hash			    fn hash(&self, state: &mut S);
hash			    fn hash<T: Hash<S>>(&self, value: &T) -> u64;
hash			        fn hash(&self, state: &mut S) 
hash			    fn hash<T: Hash<SipState>>(&self, value: &T) -> u64 
hash			pub fn hash<T: Hash<SipState>>(value: &T) -> u64 
hash			pub mod hash;
hash			    fn hash(&self, hasher: &mut H) 
hash			    fn hash(&self, hasher: &mut H) 
hash_with_keys			pub fn hash_with_keys<T: Hash<SipState>>(k0: u64, k1: u64, value: &T) -> u64 
heir_swap			    fn heir_swap<K: Ord, V>(node: &mut Box<TreeNode<K, V>>,
idx			    fn idx(&mut self, index: uint) -> Option<bool> 
idx			    fn idx(&mut self, j: uint) -> Option<&'a T> 
index			    fn index(&self, i: &uint) -> bool 
indexable			    fn indexable(&self) -> uint 
indexable			    fn indexable(&self) -> uint { self.rindex - self.index }
init			    pub fn init<'a>(&'a self) -> &'a [T] 
insert			    fn insert(&mut self, value: uint) -> bool 
insert			    fn insert(mut self, k: K, v: V, ub: uint) -> (Node<K, V>, bool) 
insert			    fn insert(self, k: K, v: V, ub: uint) -> (Node<K, V>, bool) 
insert			    pub fn insert(mut self, k: K, v: V) -> BTree<K, V> 
insert			    fn insert(&mut self, key: K, value: V) -> bool 
insert			    fn insert(&mut self, value: T) -> bool;
insert			    fn insert(&mut self, key: uint, value: V) -> bool 
insert			    fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }
insert			fn insert<K: Ord, V>(node: &mut Option<Box<TreeNode<K, V>>>,
insert			    fn insert(&mut self, value: uint) -> bool 
insert			fn insert<T>(count: &mut uint, child: &mut Child<T>, key: uint, value: T,
insert			    pub fn insert(&mut self, index: uint, element: T) 
insert_next			    fn insert_next(&mut self, elt: A) 
insert_next			    fn insert_next(&mut self, elt: A);
insert_next_node			    fn insert_next_node(&mut self, mut ins_node: Box<Node<A>>) 
insert_ordered			    pub fn insert_ordered(&mut self, elt: T) 
insert_rand_100			    pub fn insert_rand_100(b: &mut Bencher) 
insert_rand_100			    pub fn insert_rand_100(b: &mut Bencher) 
insert_rand_10_000			    pub fn insert_rand_10_000(b: &mut Bencher) 
insert_rand_10_000			    pub fn insert_rand_10_000(b: &mut Bencher) 
insert_rand_n			    pub fn insert_rand_n<M:MutableMap<uint,uint>>(n: uint,
insert_replace			    fn insert_replace() 
insert_seq_100			    pub fn insert_seq_100(b: &mut Bencher) 
insert_seq_100			    pub fn insert_seq_100(b: &mut Bencher) 
insert_seq_10_000			    pub fn insert_seq_10_000(b: &mut Bencher) 
insert_seq_10_000			    pub fn insert_seq_10_000(b: &mut Bencher) 
insert_seq_n			    pub fn insert_seq_n<M:MutableMap<uint,uint>>(n: uint,
insert_test_four			    fn insert_test_four() 
insert_test_one			    fn insert_test_one() 
insert_test_three			    fn insert_test_three() 
insert_test_two			    fn insert_test_two() 
insert_when			    pub fn insert_when(&mut self, elt: T, f: |&T, &T| -> bool) 
insertion_sort			fn insertion_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) 
intersect			    fn intersect(&mut self, b: &BigBitv, nbits: uint) -> bool 
intersect			    fn intersect(&mut self, s: &SmallBitv, nbits: uint) -> bool 
intersect			    pub fn intersect(&mut self, v1: &Bitv) -> bool 
intersect_with			    pub fn intersect_with(&mut self, other: &BitvSet) 
intersection			    pub fn intersection(&self, other: &BitvSet, f: |&uint| -> bool) -> bool 
intersection			    pub fn intersection(&self, e: EnumSet<E>) -> EnumSet<E> 
intersection			    pub fn intersection<'a>(&'a self, other: &'a TreeSet<T>)
intersects			    pub fn intersects(&self, e: EnumSet<E>) -> bool 
into_bytes			    fn into_bytes(self) -> Vec<u8> 
into_bytes			    fn into_bytes(self) -> Vec<u8>;
into_bytes			    pub fn into_bytes(self) -> Vec<u8> 
into_maybe_owned			    fn into_maybe_owned(self) -> MaybeOwned<'a> { Slice(self) }
into_maybe_owned			    fn into_maybe_owned(self) -> MaybeOwned<'a> { self }
into_maybe_owned			    fn into_maybe_owned(self) -> MaybeOwned<'a> 
into_maybe_owned			    fn into_maybe_owned(self) -> MaybeOwned<'a>;
into_owned			    fn into_owned(self) -> Vec<T> { self.to_owned() }
into_owned			    fn into_owned(self) -> Vec<T>;
into_owned			    fn into_owned(self) -> String 
into_owned			    fn into_owned(self) -> Vec<T> { self }
into_sorted_vec			    pub fn into_sorted_vec(self) -> Vec<T> 
into_string			    fn into_string(self) -> String 
into_string			    fn into_string(self) -> String;
into_string			    fn into_string(self) -> String 
into_vec			    pub fn into_vec(self) -> Vec<T> { let PriorityQueue{data: v} = self; v }
is_disjoint			    fn is_disjoint(&self, other: &BitvSet) -> bool 
is_disjoint			    fn is_disjoint(&self, other: &Self) -> bool;
is_disjoint			    fn is_disjoint(&self, other: &TreeSet<T>) -> bool 
is_disjoint			    fn is_disjoint(&self, other: &TrieSet) -> bool 
is_empty			    fn is_empty(&self) -> bool 
is_empty			    pub fn is_empty(&self) -> bool 
is_empty			    fn is_empty(&self) -> bool 
is_leaf			    fn is_leaf(&self) -> bool 
is_odd			    fn is_odd(n: &uint) -> bool { *n % 2u == 1u }
is_owned			    pub fn is_owned(&self) -> bool 
is_slice			    pub fn is_slice(&self) -> bool 
is_subset			    fn is_subset(&self, other: &BitvSet) -> bool 
is_subset			    fn is_subset(&self, other: &Self) -> bool;
is_subset			    fn is_subset(&self, other: &TreeSet<T>) -> bool 
is_subset			    fn is_subset(&self, other: &TrieSet) -> bool 
is_superset			    fn is_superset(&self, other: &BitvSet) -> bool 
is_superset			    fn is_superset(&self, other: &Self) -> bool 
is_superset			    fn is_superset(&self, other: &TrieSet) -> bool 
is_utf8_100_ascii			    fn is_utf8_100_ascii(b: &mut Bencher) 
is_utf8_100_multibyte			    fn is_utf8_100_multibyte(b: &mut Bencher) 
iter			    pub fn iter<'a>(&'a self) -> BitPositions<'a> 
iter			    pub fn iter<'a>(&'a self) -> Bits<'a> 
iter			    pub fn iter<'a>(&'a self) -> Items<'a, T> 
iter			    pub fn iter(&self) -> Items<E> 
iter			    pub fn iter<'a>(&'a self) -> Items<'a, T> 
iter			    pub fn iter<'a>(&'a self) -> Items<'a, T> 
iter			    pub fn iter<'r>(&'r self) -> Entries<'r, V> 
iter			    pub fn iter<'a>(&'a self) -> Entries<'a, K, V> 
iter			    pub fn iter<'a>(&'a self) -> SetItems<'a, T> 
iter			    pub fn iter<'a>(&'a self) -> Entries<'a, T> 
iter			    pub fn iter<'a>(&'a self) -> SetItems<'a> 
iter			    pub fn iter<'a>(&'a self) -> Items<'a,T> 
iter_for_traversal			    fn iter_for_traversal<'a>(&'a self) -> Entries<'a, K, V> 
iterate_bits			fn iterate_bits(base: uint, bits: uint, f: |uint| -> bool) -> bool 
iterator			    fn iterator(b: &mut Bencher) 
last			    pub fn last<'a>(&'a self) -> Option<&'a T> 
len			    fn len(&self) -> uint { self.size }
len			    fn len(&self) -> uint 
len			    fn len(&self) -> uint { self.data.len() }
len			    fn len(&self) -> uint { self.nelts }
len			    fn len(&self) -> uint 
len			    fn len(&self) -> uint { self.as_slice().len() }
len			    fn len(&self) -> uint 
len			    fn len(&self) -> uint { self.length }
len			    fn len(&self) -> uint { self.map.len() }
len			    fn len(&self) -> uint { self.length }
len			    fn len(&self) -> uint { self.map.len() }
len			    fn len(&self) -> uint 
lev_distance			    fn lev_distance(&self, t: &str) -> uint 
link_with_prev			fn link_with_prev<T>(mut next: Box<Node<T>>, prev: Rawlink<Node<T>>)
list_from			    fn list_from<T: Clone>(v: &[T]) -> DList<T> 
lower_bound			    pub fn lower_bound<'a>(&'a self, k: &K) -> Entries<'a, K, V> 
lower_bound			    pub fn lower_bound<'a>(&'a self, v: &T) -> SetItems<'a, T> 
lower_bound			    pub fn lower_bound<'a>(&'a self, key: uint) -> Entries<'a, T> 
lower_bound			    pub fn lower_bound<'a>(&'a self, val: uint) -> SetItems<'a> 
macros			mod macros;
main			fn main() 
matches			            fn matches(&mut self, c: char) -> bool 
maybe_pop			    pub fn maybe_pop(&mut self) -> Option<T> { self.pop() }
maybe_top			    pub fn maybe_top<'a>(&'a self) -> Option<&'a T> { self.top() }
merge			    pub fn merge(&mut self, mut other: DList<T>, f: |&T, &T| -> bool) 
merge_sort			fn merge_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) 
move_from			    fn move_from(self, mut src: Vec<T>, start: uint, end: uint) -> uint 
move_from			    fn move_from(self, src: Vec<T>, start: uint, end: uint) -> uint;
move_iter			    pub fn move_iter(self) -> MoveItems<T> 
move_iter			    pub fn move_iter(&mut self)
move_iter			    pub fn move_iter(self) -> MoveEntries<K, V> 
move_iter			    pub fn move_iter(self) -> MoveSetItems<T> 
move_iter			    pub fn move_iter(self) -> MoveItems<T> 
mut_bound			    fn mut_bound<'a>(&'a mut self, key: uint, upper: bool) -> MutEntries<'a, T> 
mut_deref			fn mut_deref<K, V>(x: &mut Option<Box<TreeNode<K, V>>>)
mut_iter			    pub fn mut_iter<'a>(&'a mut self) -> MutItems<'a, T> 
mut_iter			    pub fn mut_iter<'a>(&'a mut self) -> MutItems<'a, T> 
mut_iter			    pub fn mut_iter<'r>(&'r mut self) -> MutEntries<'r, V> 
mut_iter			    pub fn mut_iter<'a>(&'a mut self) -> MutEntries<'a, K, V> 
mut_iter			    pub fn mut_iter<'a>(&'a mut self) -> MutEntries<'a, T> 
mut_iter			    pub fn mut_iter<'a>(&'a mut self) -> MutItems<'a,T> 
mut_iter_for_traversal			    fn mut_iter_for_traversal<'a>(&'a mut self) -> MutEntries<'a, K, V> 
mut_iterator			    fn mut_iterator(b: &mut Bencher) 
mut_last			    pub fn mut_last<'a>(&'a mut self) -> Option<&'a mut T> 
mut_lower_bound			    pub fn mut_lower_bound<'a>(&'a mut self, k: &K) -> MutEntries<'a, K, V> 
mut_lower_bound			    pub fn mut_lower_bound<'a>(&'a mut self, key: uint) -> MutEntries<'a, T> 
mut_rev_iter			    pub fn mut_rev_iter<'a>(&'a mut self) -> RevMutEntries<'a, K, V> 
mut_slice			    pub fn mut_slice<'a>(&'a mut self, start: uint, end: uint)
mut_slice_from			    pub fn mut_slice_from<'a>(&'a mut self, start: uint) -> &'a mut [T] 
mut_slice_to			    pub fn mut_slice_to<'a>(&'a mut self, end: uint) -> &'a mut [T] 
mut_split_at			    pub fn mut_split_at<'a>(&'a mut self, mid: uint) -> (&'a mut [T], &'a mut [T]) 
mut_upper_bound			    pub fn mut_upper_bound<'a>(&'a mut self, k: &K) -> MutEntries<'a, K, V> 
mut_upper_bound			    pub fn mut_upper_bound<'a>(&'a mut self, key: uint) -> MutEntries<'a, T> 
nbits			        fn nbits(mut w: uint) -> uint 
ne			    fn ne(&self, other: &BitvSet) -> bool { !self.eq(other) }
ne			    fn ne(&self, other: &DList<A>) -> bool 
ne			    fn ne(&self, other: &RingBuf<A>) -> bool 
negate			    fn negate(&mut self) { self.bits = !self.bits; }
negate			    fn negate(&mut self) 
negate			    pub fn negate(&mut self) 
new			    fn new(bits: uint) -> SmallBitv 
new			    fn new(storage: Vec<uint>) -> BigBitv 
new			    pub fn new() -> BitvSet 
new			    pub fn new(nbits: uint, init: bool) -> Bitv 
new			    fn new(k: K, v: V) -> LeafElt<K, V> 
new			    fn new(k: K, v: V, n: Box<Node<K, V>>) -> BranchElt<K, V> 
new			    fn new(vec: Vec<BranchElt<K, V>>, right: Box<Node<K, V>>)
new			    fn new(vec: Vec<LeafElt<K, V>>) -> Leaf<K, V> 
new			    pub fn new(k: K, v: V, lb: uint) -> BTree<K, V> 
new			    fn new(v: T) -> Node<T> 
new			    pub fn new() -> DList<T> 
new			    fn new(bits: uint) -> Items<E> 
new			    pub fn new() -> SipHasher 
new			    pub fn new() -> SipState 
new			    pub fn new() -> PriorityQueue<T> { PriorityQueue{data: vec!(),} }
new			    pub fn new() -> RingBuf<T> 
new			    pub fn new(length: uint) -> ElementSwaps 
new			    pub fn new() -> SmallIntMap<V> { SmallIntMap{v: vec!()} }
new			    pub fn new() -> String 
new			    pub fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }
new			    pub fn new() -> TreeSet<T> { TreeSet{map: TreeMap::new()} }
new			    pub fn new(key: K, value: V) -> TreeNode<K, V> 
new			            unsafe fn new() -> 
new			    fn new() -> TrieNode<T> 
new			    pub fn new() -> TrieMap<T> 
new			    pub fn new() -> TrieSet 
new			    pub fn new() -> Vec<T> 
new_branch			    fn new_branch(vec: Vec<BranchElt<K, V>>, right: Box<Node<K, V>>)
new_leaf			    fn new_leaf(vec: Vec<LeafElt<K, V>>) -> Node<K,V> 
new_pos			        fn new_pos(i: uint, s: Direction) -> uint 
new_with_keys			    pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher 
new_with_keys			    pub fn new_with_keys(key0: u64, key1: u64) -> SipState 
new_with_node_len			    fn new_with_node_len(n: Node<K, V>,
next			    fn next(&mut self) -> Option<bool> 
next			    fn next(&mut self) -> Option<uint> 
next			    fn next(&mut self) -> Option<&'a A> 
next			    fn next(&mut self) -> Option<&'a mut A> 
next			    fn next(&mut self) -> Option<A> { self.list.pop_front() }
next			    fn next(&mut self) -> Option<E> 
next			    fn next(&mut self) -> Option<(&'a T)> { self.iter.next() }
next			    fn next(&mut self) -> Option<&'a T> 
next			    fn next(&mut self) -> Option<&'a mut T> 
next			    fn next(&mut self) -> Option<(uint, uint)> 
next			    fn next(&mut self) -> Option<Vec<T>> 
next			            fn next(&mut self) -> Option<
next			    fn next(&mut self) -> Option<char> 
next			            fn next(&mut self) -> Option<(&'a K, &'a 
next			    fn next(&mut self) -> Option<&'a T> 
next			    fn next(&mut self) -> Option<(K, V)> 
next			                fn next(&mut self) -> Option<(uint, &'a 
next			    fn next(&mut self) -> Option<uint> 
next			    fn next(&mut self) -> Option<T> 
next_			            fn next_(&mut self, forward: bool) -> Option<(&'a K, &'a 
next_back			    fn next_back(&mut self) -> Option<bool> 
next_back			    fn next_back(&mut self) -> Option<&'a A> 
next_back			    fn next_back(&mut self) -> Option<&'a mut A> 
next_back			    fn next_back(&mut self) -> Option<A> { self.list.pop_back() }
next_back			    fn next_back(&mut self) -> Option<&'a T> 
next_back			    fn next_back(&mut self) -> Option<&'a mut T> 
next_back			            fn next_back(&mut self) -> Option<
next_back			    fn next_back(&mut self) -> Option<T> 
next_permutation			    fn next_permutation(self) -> bool 
next_permutation			    fn next_permutation(self) -> bool;
nfd_chars			    fn nfd_chars<'a>(&'a self) -> Decompositions<'a> 
nfkd_chars			    fn nfkd_chars<'a>(&'a self) -> Decompositions<'a> 
none			    fn none(&self, nbits: uint) -> bool 
none			    pub fn none(&self) -> bool 
none			    fn none() -> Rawlink<T> 
normalization			pub mod normalization 
ones			    pub fn ones(&self, f: |uint| -> bool) -> bool 
only_ascii			            fn only_ascii(&self) -> bool { false }
ops			impl ops::Index<uint,bool> for Bitv 
other_op			    fn other_op(&mut self, other: &BitvSet, f: |uint, uint| -> uint) 
outliers			    fn outliers<'a>(&'a self, other: &'a BitvSet)
partial_cmp			    fn partial_cmp(&self, other: &BTree<K, V>) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &Branch<K, V>) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &BranchElt<K, V>) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &Leaf<K, V>) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &LeafElt<K, V>) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &Node<K, V>) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &DList<A>) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &MaybeOwned) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &TreeMap<K, V>) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &TreeSet<T>) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &Vec<T>) -> Option<Ordering> 
partition			    pub fn partition(self, f: |&T| -> bool) -> (Vec<T>, Vec<T>) 
partitioned			    fn partitioned(&self, f: |&T| -> bool) -> (Vec<T>, Vec<T>) 
partitioned			    fn partitioned(&self, f: |&T| -> bool) -> (Vec<T>, Vec<T>);
partitioned			    pub fn partitioned(&self, f: |&T| -> bool) -> (Vec<T>, Vec<T>) 
peek_next			    fn peek_next<'a>(&'a mut self) -> Option<&'a mut A> 
peek_next			    fn peek_next<'a>(&'a mut self) -> Option<&'a mut A>;
permutations			    fn permutations(self) -> Permutations<T> 
permutations			    fn permutations(self) -> Permutations<T>;
pop			    fn pop(&mut self, k: &K) -> Option<V>;
pop			    pub fn pop(&mut self) -> Option<T> 
pop			    fn pop(&mut self, key: &uint) -> Option<V> 
pop			    fn pop(&mut self, key: &K) -> Option<V> 
pop			    fn pop(&mut self, key: &uint) -> Option<T> 
pop			    pub fn pop(&mut self) -> Option<T> 
pop_back			    fn pop_back(&mut self) -> Option<T> 
pop_back			    fn pop_back(&mut self) -> Option<T>;
pop_back			    fn pop_back(&mut self) -> Option<T> 
pop_back_node			    fn pop_back_node(&mut self) -> Option<Box<Node<T>>> 
pop_byte			    pub unsafe fn pop_byte(&mut self) -> Option<u8> 
pop_char			    pub fn pop_char(&mut self) -> Option<char> 
pop_front			    fn pop_front(&mut self) -> Option<T> 
pop_front			    fn pop_front(&mut self) -> Option<T>;
pop_front			    fn pop_front(&mut self) -> Option<T> 
pop_front_node			    fn pop_front_node(&mut self) -> Option<Box<Node<T>>> 
pred			        fn pred(c: char) -> bool { c == ' ' }
prepend			    pub fn prepend(&mut self, mut other: DList<T>) 
prev_permutation			    fn prev_permutation(self) -> bool 
prev_permutation			    fn prev_permutation(self) -> bool;
priority_queue			pub mod priority_queue;
process			    fn process(&mut self,
push			    pub fn push(&mut self, item: T) 
push			    fn push(b: &mut Bencher) 
push			    pub fn push(&mut self, value: T) 
push_all			    pub fn push_all(&mut self, other: &[T]) 
push_all_move			    pub fn push_all_move(&mut self, other: Vec<T>) 
push_back			    fn push_back(&mut self, elt: T) 
push_back			    fn push_back(&mut self, elt: T);
push_back			    fn push_back(&mut self, t: T) 
push_back_node			    fn push_back_node(&mut self, mut new_tail: Box<Node<T>>) 
push_byte			    pub unsafe fn push_byte(&mut self, byte: u8) 
push_bytes			    pub unsafe fn push_bytes(&mut self, bytes: &[u8]) 
push_char			    pub fn push_char(&mut self, ch: char) 
push_front			    fn push_front(&mut self, elt: T) 
push_front			    fn push_front(&mut self, elt: T);
push_front			    fn push_front(&mut self, t: T) 
push_front_node			    fn push_front_node(&mut self, mut new_head: Box<Node<T>>) 
push_pop			    pub fn push_pop(&mut self, mut item: T) -> T 
push_str			    pub fn push_str(&mut self, string: &str) 
random_inserts			    fn random_inserts(b: &mut Bencher) 
random_removes			    fn random_removes(b: &mut Bencher) 
raw			pub mod raw 
raw			pub mod raw 
raw			pub mod raw 
raw_index			    fn raw_index(&self, idx: uint) -> uint 
raw_index			fn raw_index(lo: uint, len: uint, index: uint) -> uint 
remove			    fn remove(&mut self, value: &uint) -> bool 
remove			    fn remove(&mut self, key: &K) -> bool 
remove			    fn remove(&mut self, value: &T) -> bool;
remove			    fn remove(&mut self, key: &uint) -> bool 
remove			    fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }
remove			fn remove<K: Ord, V>(node: &mut Option<Box<TreeNode<K, V>>>,
remove			    fn remove(&mut self, value: &uint) -> bool 
remove			fn remove<T>(count: &mut uint, child: &mut Child<T>, key: uint,
remove			    pub fn remove(&mut self, index: uint) -> Option<T> 
repeat			    fn repeat(&self, nn: uint) -> String 
replace			    pub fn replace(&mut self, mut item: T) -> Option<T> 
replace			    fn replace(&self, from: &str, to: &str) -> String 
replace			pub fn replace(s: &str, from: &str, to: &str) -> String 
reserve			    pub fn reserve(&mut self, n: uint) 
reserve			    pub fn reserve(&mut self, n: uint) 
reserve			    pub fn reserve(&mut self, capacity: uint) 
reserve			    pub fn reserve(&mut self, capacity: uint) 
reserve_additional			    pub fn reserve_additional(&mut self, extra: uint) 
reserve_additional			    pub fn reserve_additional(&mut self, extra: uint) 
reserve_exact			    pub fn reserve_exact(&mut self, n: uint) { self.data.reserve_exact(n) }
reserve_exact			    pub fn reserve_exact(&mut self, n: uint) 
reserve_exact			    pub fn reserve_exact(&mut self, capacity: uint) 
reserve_exact			    pub fn reserve_exact(&mut self, capacity: uint) 
reset			    pub fn reset(&mut self) 
resolve			    fn resolve(&mut self) -> Option<&mut T> 
resolve_immut			    fn resolve_immut(&self) -> Option<&T> 
result			    pub fn result(&self) -> u64 
result_bytes			        fn result_bytes(h: u64) -> Vec<u8> 
result_str			        fn result_str(h: u64) -> String 
retain			    pub fn retain(&mut self, f: |&T| -> bool) 
rev_iter			    pub fn rev_iter<'a>(&'a self) -> RevEntries<'a, K, V> 
rev_iter			    pub fn rev_iter<'a>(&'a self) -> RevSetItems<'a, T> 
reverse			    pub fn reverse(&mut self) 
ringbuf			pub mod ringbuf;
rng			    fn rng() -> rand::IsaacRng 
rotate_backward			    pub fn rotate_backward(&mut self) 
rotate_forward			    pub fn rotate_forward(&mut self) 
safe_get			    fn safe_get(xs: &[u8], i: uint, total: uint) -> u8 
set			    fn set(&mut self, i: uint, x: bool) 
set			    pub fn set(&mut self, i: uint, x: bool) 
set_all			    fn set_all(&mut self) { self.bits = !0; }
set_all			    pub fn set_all(&mut self) 
set_len			    pub unsafe fn set_len(&mut self, len: uint) 
shift			    pub fn shift(&mut self) -> Option<T> 
shift_byte			    pub unsafe fn shift_byte(&mut self) -> Option<u8> 
shift_char			    pub fn shift_char (&mut self) -> Option<char> 
shrink_to_fit			    pub fn shrink_to_fit(&mut self) 
shrink_to_fit			    pub fn shrink_to_fit(&mut self) 
siftdown			    fn siftdown(&mut self, pos: uint) 
siftdown_range			    fn siftdown_range(&mut self, mut pos: uint, end: uint) 
siftup			    fn siftup(&mut self, start: uint, mut pos: uint) 
sip			pub mod sip;
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			            fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			            fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			                fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
skew			fn skew<K: Ord, V>(node: &mut Box<TreeNode<K, V>>) 
slice			pub mod slice;
slice			    pub fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [T] 
slice_from			    pub fn slice_from<'a>(&'a self, start: uint) -> &'a [T] 
slice_to			    pub fn slice_to<'a>(&'a self, end: uint) -> &'a [T] 
small_mask			fn small_mask(nbits: uint) -> uint 
smallintmap			pub mod smallintmap;
some			    fn some(n: &mut T) -> Rawlink<T> 
sort			    fn sort(self) 
sort			    fn sort(self);
sort			    pub fn sort(&mut self) 
sort_big_random_large			    fn sort_big_random_large(b: &mut Bencher) 
sort_big_random_medium			    fn sort_big_random_medium(b: &mut Bencher) 
sort_big_random_small			    fn sort_big_random_small(b: &mut Bencher) 
sort_big_sorted			    fn sort_big_sorted(b: &mut Bencher) 
sort_by			    fn sort_by(self, compare: |&T, &T| -> Ordering) 
sort_by			    fn sort_by(self, compare: |&T, &T| -> Ordering);
sort_by			    pub fn sort_by(&mut self, compare: |&T, &T| -> Ordering) 
sort_random_large			    fn sort_random_large(b: &mut Bencher) 
sort_random_medium			    fn sort_random_medium(b: &mut Bencher) 
sort_random_small			    fn sort_random_small(b: &mut Bencher) 
sort_sorted			    fn sort_sorted(b: &mut Bencher) 
split			fn split<K: Ord, V>(node: &mut Box<TreeNode<K, V>>) 
split_ascii			    fn split_ascii(b: &mut Bencher) 
split_closure			    fn split_closure(b: &mut Bencher) 
split_extern_fn			    fn split_extern_fn(b: &mut Bencher) 
split_not_ascii			    fn split_not_ascii(b: &mut Bencher) 
split_slice			    fn split_slice(b: &mut Bencher) 
split_unicode_ascii			    fn split_unicode_ascii(b: &mut Bencher) 
split_unicode_not_ascii			    fn split_unicode_not_ascii(b: &mut Bencher) 
square			    fn square(n: uint) -> uint { n * n }
starts_with_diff_one_element_at_end			    fn starts_with_diff_one_element_at_end(b: &mut Bencher) 
starts_with_same_vector			    fn starts_with_same_vector(b: &mut Bencher) 
starts_with_single_element			    fn starts_with_single_element(b: &mut Bencher) 
std			mod std 
step			    unsafe fn step<T>(ptr: &mut *mut T) -> *mut T 
str			pub mod str;
string			pub mod string;
sub			    fn sub(&self, e: &EnumSet<E>) -> EnumSet<E> 
sum_len			        fn sum_len<S: Collection>(v: &[S]) -> uint 
swap			    fn swap(&mut self, k: K, v: V) -> Option<V>;
swap			    pub fn swap(&mut self, i: uint, j: uint) 
swap			    fn swap(&mut self, key: uint, value: V) -> Option<V> 
swap			    fn swap(&mut self, key: K, value: V) -> Option<V> 
swap			    fn swap(&mut self, key: uint, value: T) -> Option<T> 
swap_remove			    pub fn swap_remove(&mut self, index: uint) -> Option<T> 
symmetric_difference			    pub fn symmetric_difference(&self, other: &BitvSet, f: |&uint| -> bool)
symmetric_difference			    pub fn symmetric_difference<'a>(&'a self, other: &'a TreeSet<T>)
symmetric_difference_with			    pub fn symmetric_difference_with(&mut self, other: &BitvSet) 
t			        fn t(a: &str, b: &str, start: uint) 
t			        fn t(s: &str, sep: &str, u: &[&str]) 
t			        fn t(v: &[&str], s: &str) 
t			        fn t(v: &[&str], sep: &str, s: &str) 
t			        fn t(v: &[String], s: &str) 
t			        fn t(v: &[String], sep: &str, s: &str) 
t			        fn t<S: Default + Str>() 
tail			    pub fn tail<'a>(&'a self) -> &'a [T] 
tailn			    pub fn tailn<'a>(&'a self, n: uint) -> &'a [T] 
take			    fn take(&mut self) -> Rawlink<T> 
test			mod test 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
to_bools			    pub fn to_bools(&self) -> Vec<bool> 
to_bytes			    pub fn to_bytes(&self) -> Vec<u8> 
to_hex_str			        fn to_hex_str(r: &[u8, ..8]) -> String 
to_owned			    fn to_owned(&self) -> Vec<T> { Vec::from_slice(*self) }
to_owned			    fn to_owned(&self) -> Vec<T>;
to_owned			    fn to_owned(&self) -> String 
to_owned			    fn to_owned(&self) -> Vec<T> { self.clone() }
to_sorted_vec			    fn to_sorted_vec(self) -> Vec<T> { self.into_sorted_vec() }
to_string			    fn to_string(&self) -> String 
to_uint			        fn to_uint(&self) -> uint 
to_uint			    fn to_uint(&self) -> uint;
to_utf16			    fn to_utf16(&self) -> Vec<u16> 
to_vec			    pub fn to_vec(&self) -> Vec<uint> 
to_vec			    fn to_vec(self) -> Vec<T> { self.into_vec() }
top			    pub fn top<'a>(&'a self) -> Option<&'a T> 
traverse_complete			            fn traverse_complete(&mut self) 
traverse_left			            fn traverse_left(&mut self) 
traverse_right			            fn traverse_right(&mut self) 
treemap			pub mod treemap;
trie			pub mod trie;
truncate			    pub fn truncate(&mut self, len: uint) 
truncate			    pub fn truncate(&mut self, len: uint) 
u8_map			    fn u8_map() 
unicode			mod unicode;
union			    fn union(&mut self, b: &BigBitv, nbits: uint) -> bool 
union			    fn union(&mut self, s: &SmallBitv, nbits: uint) -> bool 
union			    pub fn union(&mut self, v1: &Bitv) -> bool { self.do_op(Union, v1) }
union			    pub fn union(&self, other: &BitvSet, f: |&uint| -> bool) -> bool 
union			    pub fn union(&self, e: EnumSet<E>) -> EnumSet<E> 
union			    pub fn union<'a>(&'a self, other: &'a TreeSet<T>) -> UnionItems<'a, T> 
union_with			    pub fn union_with(&mut self, other: &BitvSet) 
unsafe_get			    fn unsafe_get(xs: &[u8], i: uint) -> u8 
unshift			    pub fn unshift(&mut self, element: T) 
unwrap			    pub fn unwrap(self) -> Bitv 
unzip			pub fn unzip<T, U, V: Iterator<(T, U)>>(mut iter: V) -> (Vec<T>, Vec<U>) 
update			    pub fn update(&mut self, key: uint, newval: V, ff: |V, V| -> V) -> bool 
update_with_key			    pub fn update_with_key(&mut self,
upper_bound			    pub fn upper_bound<'a>(&'a self, k: &K) -> Entries<'a, K, V> 
upper_bound			    pub fn upper_bound<'a>(&'a self, v: &T) -> SetItems<'a, T> 
upper_bound			    pub fn upper_bound<'a>(&'a self, key: uint) -> Entries<'a, T> 
upper_bound			    pub fn upper_bound<'a>(&'a self, val: uint) -> SetItems<'a> 
vec			pub mod vec;
vec_str_conversions			    fn vec_str_conversions() 
with_capacity			    pub fn with_capacity(capacity: uint) -> PriorityQueue<T> 
with_capacity			    pub fn with_capacity(n: uint) -> RingBuf<T> 
with_capacity			    pub fn with_capacity(capacity: uint) -> SmallIntMap<V> 
with_capacity			    pub fn with_capacity(capacity: uint) -> String 
with_capacity			    pub fn with_capacity(capacity: uint) -> Vec<T> 
write			        fn write(&mut self, buf: &[u8]) 
write			    fn write(&mut self, bytes: &[u8]);
write			    fn write(&mut self, msg: &[u8]) 
zero_1kb_from_elem			    fn zero_1kb_from_elem(b: &mut Bencher) 
zero_1kb_loop_set			    fn zero_1kb_loop_set(b: &mut Bencher) 
zero_1kb_mut_iter			    fn zero_1kb_mut_iter(b: &mut Bencher) 
zero_1kb_set_memory			    fn zero_1kb_set_memory(b: &mut Bencher) 
zero_byte			        fn zero_byte(val: u32, byte: uint) -> u32 
zero_byte			        fn zero_byte(val: u64, byte: uint) -> u64 
zero_sized_values			    fn zero_sized_values() 
