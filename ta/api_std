ADDRESS64			    struct ADDRESS64 
ADDRESS_MODE			    enum ADDRESS_MODE 
Acceptor			pub trait Acceptor<T> 
Acceptor			impl Acceptor<TcpStream> for TcpAcceptor 
Acceptor			impl Acceptor<UnixStream> for UnixAcceptor 
Add			        impl Add<Foo, Foo> for Foo 
Add			impl Add<f32,f32> for f32 
Add			impl Add<f64,f64> for f64 
Add			impl Add<$T,$T> for $T 
Add			impl Add<$T,$T> for $T 
Add			pub trait Add<RHS,Result> 
AdditiveIterator			pub trait AdditiveIterator<A> 
Alignment			pub enum Alignment 
AllocHeader			impl AllocHeader 
AllocHeader			struct AllocHeader 
AllocHeader			struct AllocHeader;
Alphabetic			    pub fn Alphabetic(c: char) -> bool 
Any			pub trait Any 
AnyMutRefExt			pub trait AnyMutRefExt<'a> 
AnyOwnExt			impl AnyOwnExt for ~Any 
AnyOwnExt			pub trait AnyOwnExt 
AnyRefExt			pub trait AnyRefExt<'a> 
ArcData			struct ArcData<T> 
Argument			pub struct Argument<'a> 
Argument			pub struct Argument<'a> 
Argument			pub struct Argument<'a> 
Arguments			pub struct Arguments<'a> 
Ascii			impl Ascii 
Ascii			pub struct Ascii { chr: u8 }
AsciiCast			impl AsciiCast<Ascii> for char 
AsciiCast			impl AsciiCast<Ascii> for u8 
AsciiCast			pub trait AsciiCast<T> 
AsciiStr			pub trait AsciiStr 
AtomicBool			impl AtomicBool 
AtomicBool			pub struct AtomicBool 
AtomicInt			impl AtomicInt 
AtomicInt			pub struct AtomicInt 
AtomicOption			pub struct AtomicOption<T> 
AtomicPtr			pub struct AtomicPtr<T> 
AtomicUint			impl AtomicUint 
AtomicUint			pub struct AtomicUint 
Bar			    struct Bar(int, int);
Binary			pub trait Binary 
Binary			struct Binary;
BitAnd			impl BitAnd<bool, bool> for bool 
BitAnd			impl BitAnd<$T,$T> for $T 
BitAnd			impl BitAnd<$T,$T> for $T 
BitAnd			pub trait BitAnd<RHS,Result> 
BitOr			impl BitOr<bool, bool> for bool 
BitOr			impl BitOr<$T,$T> for $T 
BitOr			impl BitOr<$T,$T> for $T 
BitOr			pub trait BitOr<RHS,Result> 
BitXor			impl BitXor<bool, bool> for bool 
BitXor			impl BitXor<$T,$T> for $T 
BitXor			impl BitXor<$T,$T> for $T 
BitXor			pub trait BitXor<RHS,Result> 
Bitwise			impl Bitwise for i16 
Bitwise			impl Bitwise for i32 
Bitwise			impl Bitwise for i64 
Bitwise			impl Bitwise for i8 
Bitwise			impl Bitwise for int 
Bitwise			pub trait Bitwise: Bounded
Bitwise			impl Bitwise for $T 
BlockedTask			impl BlockedTask 
BlockedTask			pub enum BlockedTask 
BlockedTasks			pub struct BlockedTasks 
Blocker			enum Blocker 
Bool			impl Bool for bool 
Bool			pub trait Bool 
Borrowed			pub struct Borrowed<T> 
Bounded			impl Bounded for f32 
Bounded			impl Bounded for f64 
Bounded			impl Bounded for $T 
Bounded			pub trait Bounded 
Bounded			impl Bounded for $T 
Box			pub struct Box<T> 
BufReader			pub struct BufReader<'a> 
BufWriter			pub struct BufWriter<'a> 
Buffer			struct Buffer<T> 
Buffer			impl Buffer for MemReader 
Buffer			pub trait Buffer: Reader 
Buffer			struct Buffer<T> 
BufferPool			pub struct BufferPool<T> 
BufferedReader			pub struct BufferedReader<R> 
BufferedStream			pub struct BufferedStream<S> 
BufferedWriter			pub struct BufferedWriter<W> 
ByRef			pub struct ByRef<'a, T> 
Bytes			    struct Bytes<'a>(&'a [u8]);
Bytes			pub struct Bytes<'r, T> 
BytesContainer			impl BytesContainer for CString 
BytesContainer			impl BytesContainer for ~[u8] 
BytesContainer			impl BytesContainer for ~str 
BytesContainer			pub trait BytesContainer 
BytesContainer			impl BytesContainer for Path 
BytesContainer			impl BytesContainer for Path 
CChars			pub struct CChars<'a> 
CONTEXT			        pub struct CONTEXT 
CString			impl CString 
CString			pub struct CString 
CVec			pub struct CVec<T> 
Callback			pub trait Callback 
Cc			    pub fn Cc(c: char) -> bool 
Cell			pub struct Cell<T> 
Chain			pub struct Chain<T, U> 
ChainedReader			pub struct ChainedReader<I, R> 
ChanReader			impl ChanReader 
ChanReader			pub struct ChanReader 
ChanWriter			impl ChanWriter 
ChanWriter			pub struct ChanWriter 
Char			impl Char for char 
Char			pub trait Char 
Char			impl Char for char 
Char			pub trait Char 
CharEq			        impl CharEq for NotAscii 
CharEq			impl CharEq for char 
CharEq			impl CharEq for extern "Rust" fn(char) -> bool 
CharEq			pub trait CharEq 
CharOffsets			pub struct CharOffsets<'a> 
CharRange			pub struct CharRange 
CharSplits			pub struct CharSplits<'a, Sep> 
CharSplitsN			pub struct CharSplitsN<'a, Sep> 
Chars			pub struct Chars<'r, T> 
Chars			pub struct Chars<'a> 
CheckedAdd			impl CheckedAdd for i16 
CheckedAdd			impl CheckedAdd for i32 
CheckedAdd			impl CheckedAdd for i64 
CheckedAdd			impl CheckedAdd for i8 
CheckedAdd			impl CheckedAdd for int 
CheckedAdd			pub trait CheckedAdd: Add<Self, Self> 
CheckedAdd			impl CheckedAdd for u16 
CheckedAdd			impl CheckedAdd for u32 
CheckedAdd			impl CheckedAdd for u64 
CheckedAdd			impl CheckedAdd for u8 
CheckedAdd			impl CheckedAdd for uint 
CheckedDiv			impl CheckedDiv for $T 
CheckedDiv			pub trait CheckedDiv: Div<Self, Self> 
CheckedDiv			impl CheckedDiv for $T 
CheckedMul			impl CheckedMul for i16 
CheckedMul			impl CheckedMul for i32 
CheckedMul			impl CheckedMul for i64 
CheckedMul			impl CheckedMul for i8 
CheckedMul			impl CheckedMul for int 
CheckedMul			pub trait CheckedMul: Mul<Self, Self> 
CheckedMul			impl CheckedMul for u16 
CheckedMul			impl CheckedMul for u32 
CheckedMul			impl CheckedMul for u64 
CheckedMul			impl CheckedMul for u8 
CheckedMul			impl CheckedMul for uint 
CheckedSub			impl CheckedSub for i16 
CheckedSub			impl CheckedSub for i32 
CheckedSub			impl CheckedSub for i64 
CheckedSub			impl CheckedSub for i8 
CheckedSub			impl CheckedSub for int 
CheckedSub			pub trait CheckedSub: Sub<Self, Self> 
CheckedSub			impl CheckedSub for u16 
CheckedSub			impl CheckedSub for u32 
CheckedSub			impl CheckedSub for u64 
CheckedSub			impl CheckedSub for u8 
CheckedSub			impl CheckedSub for uint 
Chunks			pub struct Chunks<'a, T> 
Cleanup			    struct Cleanup 
Clone			impl Clone for CString 
Clone			        impl Clone for $t 
Clone			pub trait Clone 
Clone			impl Clone for SipState 
Clone			impl Clone for ChanWriter 
Clone			impl Clone for TcpStream 
Clone			impl Clone for UdpSocket 
Clone			impl Clone for UnixStream 
Clone			impl Clone for PipeStream 
Clone			        impl Clone for Foo 
Clone			        impl Clone for S 
Clone			impl Clone for ~str 
CloneableIterator			pub trait CloneableIterator 
CloneableVector			pub trait CloneableVector<T> 
CloseBehavior			pub enum CloseBehavior 
CloseHandle			                pub fn CloseHandle(hObject: HANDLE) -> BOOL;
Closure			pub struct Closure 
CommandLineToArgvW			    fn CommandLineToArgvW(lpCmdLine: LPCWSTR, pNumArgs: *mut c_int) -> **u16;
Compound			    struct Compound 
ConnectNamedPipe			                pub fn ConnectNamedPipe(hNamedPipe: HANDLE,
Container			impl Container for CString 
Container			pub trait Container 
Container			impl Container for ~str 
Context			    struct Context<'a> 
ContravariantLifetime			    pub struct ContravariantLifetime<'a>;
ContravariantType			    pub struct ContravariantType<T>;
Copy			pub trait Copy 
CopyFileW			                pub fn CopyFileW(lpExistingFileName: LPCWSTR,
Count			pub enum Count<'a> 
Count			pub enum Count 
Counter			pub struct Counter<A> 
CovariantLifetime			    pub struct CovariantLifetime<'a>;
CovariantType			    pub struct CovariantType<T>;
CreateDirectoryW			                pub fn CreateDirectoryW(lpPathName: LPCWSTR,
CreateEventA			        fn CreateEventA(lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
CreateEventW			                pub fn CreateEventW(lpEventAttributes: LPSECURITY_ATTRIBUTES,
CreateFileMappingW			                pub fn CreateFileMappingW(hFile: HANDLE,
CreateFileW			                pub fn CreateFileW(lpFileName: LPCWSTR,
CreateHardLinkW			                pub fn CreateHardLinkW(lpSymlinkFileName: LPCWSTR,
CreateNamedPipeW			                pub fn CreateNamedPipeW(
CreateProcessA			                pub fn CreateProcessA(lpApplicationName: LPCSTR,
CreateSymbolicLinkW			                pub fn CreateSymbolicLinkW(lpSymlinkFileName: LPCWSTR,
CreateThread			        fn CreateThread(lpThreadAttributes: LPSECURITY_ATTRIBUTES,
Custom			    struct Custom 
Cycle			pub struct Cycle<T> 
Cycle			        struct Cycle 
DIR			            pub enum DIR {}
Death			impl Death 
Death			pub struct Death 
DeathAction			pub enum DeathAction 
Decimal			struct Decimal;
Default			impl Default for bool 
Default			impl Default for char 
Default			pub trait Default 
Default			impl Default for SipHasher 
Default			impl Default for SipState 
Default			impl Default for f32 
Default			impl Default for f64 
Default			impl Default for $T 
Default			impl Default for $T 
Default			impl Default for ~str 
Default			impl Default for () 
DeflateWriter			pub struct DeflateWriter<W> 
DeleteCriticalSection			        fn DeleteCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);
DeleteFileW			                pub fn DeleteFileW(lpPathName: LPCWSTR) -> BOOL;
Deque			struct Deque<T> 
Deref			pub trait Deref<Result> 
DerefMut			pub trait DerefMut<Result>: Deref<Result> 
Direction			enum Direction { Pos, Neg }
Directories			pub struct Directories 
DisconnectNamedPipe			                pub fn DisconnectNamedPipe(hNamedPipe: HANDLE) -> BOOL;
Display			pub struct Display<'a, P> 
Div			impl Div<f32,f32> for f32 
Div			impl Div<f64,f64> for f64 
Div			impl Div<$T,$T> for $T 
Div			impl Div<$T,$T> for $T 
Div			pub trait Div<RHS,Result> 
Dl_info			        struct Dl_info 
DoubleEndedIterator			pub trait DoubleEndedIterator<A>: Iterator<A> 
Drop			impl Drop for CString 
Drop			impl Drop for Select 
Drop			    impl Drop for TempDir 
Drop			impl Drop for Process 
Drop			impl Drop for TempDir 
Drop			    impl Drop for HasDtor 
Drop			pub trait Drop 
Drop			impl Drop for MemoryMap 
Drop			    impl Drop for Cleanup 
Drop			impl Drop for LocalHeap 
Drop			impl Drop for MemoryRegion 
Drop			impl Drop for Death 
Drop			impl Drop for Task 
Drop			impl Drop for DynamicLibrary 
Drop			impl Drop for NativeMutex 
DropCounter			        struct DropCounter<'a> 
DuplicateHandle			                pub fn DuplicateHandle(hSourceProcessHandle: HANDLE,
DynamicLibrary			impl DynamicLibrary 
DynamicLibrary			pub struct DynamicLibrary { handle: *u8}
ElementSwaps			impl ElementSwaps 
ElementSwaps			pub struct ElementSwaps 
Empty			    impl Empty for int {}
Empty			    trait Empty {}
EnterCriticalSection			        fn EnterCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);
Enumerate			pub struct Enumerate<T> 
EofReader			    struct EofReader;
Eq			impl Eq for bool 
Eq			impl Eq for CString 
Eq			impl Eq for char 
Eq			pub trait Eq 
Eq			        impl Eq for Foo 
Eq			impl Eq for f32 
Eq			impl Eq for f64 
Eq			impl Eq for $T 
Eq			impl Eq for $T 
Eq			impl Eq for Path 
Eq			impl Eq for Path 
Eq			    impl Eq for ~str 
Eq			impl Eq for () 
Equiv			pub trait Equiv<T> 
ErroringLaterReader			    struct ErroringLaterReader 
ErroringReader			    struct ErroringReader;
EventLoop			pub trait EventLoop 
ExData			struct ExData<T> 
ExactSize			pub trait ExactSize<A> : DoubleEndedIterator<A> 
Exclusive			pub struct Exclusive<T> 
ExponentFormat			pub enum ExponentFormat 
Extendable			pub trait Extendable<A>: FromIterator<A> 
Extendable			impl Extendable<char> for ~str 
FILE			            pub enum FILE {}
FILETIME			                pub struct FILETIME 
FLOATING_SAVE_AREA			        pub struct FLOATING_SAVE_AREA 
FPCategory			pub enum FPCategory 
Failure			pub enum Failure<T> 
Failure			pub enum Failure 
Failure			pub enum Failure<T> 
Failure			pub enum Failure 
File			impl File 
File			pub struct File 
FileAccess			pub enum FileAccess 
FileMode			pub enum FileMode 
FileOpenConfig			pub struct FileOpenConfig 
FileStat			pub struct FileStat 
FileType			pub enum FileType 
Filter			pub struct Filter<'a, A, T> 
FilterMap			pub struct FilterMap<'a, A, B, T> 
Finally			pub trait Finally<T> 
Finallyalizer			struct Finallyalizer<'a,A> 
FindClose			                pub fn FindClose(findFile: HANDLE) -> BOOL;
FindFirstFileW			                pub fn FindFirstFileW(fileName: *u16, findFileData: HANDLE)
FindNextFileW			                pub fn FindNextFileW(findFile: HANDLE, findFileData: HANDLE)
Flag			pub enum Flag 
Flag			pub enum Flag 
FlatMap			pub struct FlatMap<'a, A, T, U> 
Flavor			enum Flavor<T> 
Float			    impl Float for $ty 
Float			pub trait Float 
Float			impl Float for f32 
Float			impl Float for f64 
Float			pub trait Float: Signed + Round + Primitive 
FlushFileBuffers			                pub fn FlushFileBuffers(hFile: HANDLE) -> BOOL;
Foo			        struct Foo;
Foo			    struct Foo;
Foo			    struct Foo;
FormatMessageW			            fn FormatMessageW(flags: DWORD,
FormatSpec			pub struct FormatSpec<'a> 
FormatSpec			pub struct FormatSpec 
Formatter			pub struct Formatter<'a> 
FreeEnvironmentStringsA			                pub fn FreeEnvironmentStringsA(env_ptr: LPCH) -> BOOL;
FreeLibrary			        fn FreeLibrary(handle: *libc::c_void);
FromIterator			pub trait FromIterator<A> 
FromIterator			impl FromIterator<char> for ~str 
FromPrimitive			        impl FromPrimitive for $T 
FromPrimitive			    impl FromPrimitive for Value 
FromPrimitive			pub trait FromPrimitive 
FromStr			impl FromStr for bool 
FromStr			pub trait FromStr 
FromStr			impl FromStr for IpAddr 
FromStr			impl FromStr for SocketAddr 
FromStr			impl FromStr for f32 
FromStr			impl FromStr for f64 
FromStr			impl FromStr for $T 
FromStr			impl FromStr for $T 
FromStr			impl FromStr for Path 
FromStr			impl FromStr for Path 
FromStr			impl FromStr for ~str 
FromStrRadix			impl FromStrRadix for $T 
FromStrRadix			pub trait FromStrRadix 
FromStrRadix			impl FromStrRadix for $T 
Fuse			pub struct Fuse<T> 
GUID			                pub struct GUID 
GarbageCollector			pub struct GarbageCollector;
Gc			pub struct Gc<T> 
GenericPath			pub trait GenericPath: Clone + GenericPathUnsafe 
GenericPath			impl GenericPath for Path 
GenericPath			impl GenericPath for Path 
GenericPathUnsafe			pub trait GenericPathUnsafe 
GenericPathUnsafe			impl GenericPathUnsafe for Path 
GenericPathUnsafe			impl GenericPathUnsafe for Path 
GenericRadix			        impl GenericRadix for $T 
GenericRadix			impl GenericRadix for Radix 
GenericRadix			trait GenericRadix 
GetCommandLineW			    fn GetCommandLineW() -> LPCWSTR;
GetCurrentDirectoryW			                pub fn GetCurrentDirectoryW(nBufferLength: DWORD,
GetCurrentProcess			                pub fn GetCurrentProcess() -> HANDLE;
GetCurrentProcess			        fn GetCurrentProcess() -> libc::HANDLE;
GetCurrentProcessId			                pub fn GetCurrentProcessId() -> DWORD;
GetCurrentThread			        fn GetCurrentThread() -> libc::HANDLE;
GetEnvironmentStringsA			                pub fn GetEnvironmentStringsA() -> LPCH;
GetEnvironmentVariableW			                pub fn GetEnvironmentVariableW(n: LPCWSTR,
GetExitCodeProcess			                pub fn GetExitCodeProcess(hProcess: HANDLE,
GetFinalPathNameByHandleW			                pub fn GetFinalPathNameByHandleW(hFile: HANDLE,
GetLastError			                pub fn GetLastError() -> DWORD;
GetLastError			        fn GetLastError() -> DWORD;
GetModuleFileNameW			                pub fn GetModuleFileNameW(hModule: HMODULE,
GetModuleHandleExW			        fn GetModuleHandleExW(dwFlags: libc::DWORD, name: *u16,
GetOverlappedResult			                pub fn GetOverlappedResult(hFile: HANDLE,
GetProcAddress			        fn GetProcAddress(handle: *libc::c_void, name: *libc::c_char) -> *libc::c_void;
GetSystemInfo			                pub fn GetSystemInfo(lpSystemInfo: LPSYSTEM_INFO);
GetSystemTimeAsFileTime			                pub fn GetSystemTimeAsFileTime(
Handle			pub struct Handle<'rx, T> 
HasDtor			    struct HasDtor 
Hash			    impl Hash<u64> for Custom 
Hash			pub trait Hash<S = sip::SipState> 
Hasher			    impl Hasher<MyWriter> for MyWriterHasher 
Hasher			pub trait Hasher<S> 
Hasher			impl Hasher<SipState> for SipHasher 
Hint			pub struct Hint 
ImmutableCloneableVector			pub trait ImmutableCloneableVector<T> 
ImmutableEqVector			pub trait ImmutableEqVector<T:Eq> 
ImmutableTotalOrdVector			pub trait ImmutableTotalOrdVector<T: TotalOrd> 
ImmutableVector			pub trait ImmutableVector<'a, T> 
IncomingConnections			pub struct IncomingConnections<'a, A> 
Index			pub trait Index<Index,Result> 
InflateReader			pub struct InflateReader<R> 
Info			pub struct Info 
InitialZeroByteReader			    struct InitialZeroByteReader 
InitializeCriticalSectionAndSpinCount			        fn InitializeCriticalSectionAndSpinCount(
Inspect			pub struct Inspect<'a, A, T> 
Int			impl Int for $T {}
Int			pub trait Int: Primitive
Int			impl Int for $T {}
InternalBufferedWriter			struct InternalBufferedWriter<W>(BufferedWriter<W>);
IntoBytes			impl IntoBytes for ~[Ascii] 
IntoBytes			pub trait IntoBytes 
IntoMaybeOwned			pub trait IntoMaybeOwned<'a> 
IntoStr			impl IntoStr for Vec<Ascii> 
IntoStr			impl IntoStr for ~[Ascii] 
IntoStr			pub trait IntoStr 
InvariantLifetime			    pub struct InvariantLifetime<'a>;
InvariantType			    pub struct InvariantType<T>;
IoError			impl IoError 
IoError			pub struct IoError 
IoErrorKind			pub enum IoErrorKind 
IoFactory			pub trait IoFactory 
IpAddr			pub enum IpAddr 
Item			pub struct Item<A> 
Items			pub struct Items<'a, T> 
Iterator			impl Iterator<*mut Handle<'static, ()>> for Packets 
Iterator			impl Iterator<Path> for Directories 
Iterator			pub trait Iterator<A> 
Iterator			impl Iterator<BlockedTask> for BlockedTasks 
Iterator			impl Iterator<(uint, uint)> for ElementSwaps 
Juju			    struct Juju;
KDHELP64			    struct KDHELP64 
KeyValue			pub enum KeyValue<T> { Key }
LeaveCriticalSection			        fn LeaveCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);
LimitReader			pub struct LimitReader<R> 
LineBufferedWriter			pub struct LineBufferedWriter<W> 
Lines			pub struct Lines<'r, T> 
List			        struct List 
Listener			pub trait Listener<T, A: Acceptor<T>> 
Listener			impl Listener<TcpStream, TcpAcceptor> for TcpListener 
Listener			impl Listener<UnixStream, UnixAcceptor> for UnixListener 
Listener			impl Listener 
Listener			pub struct Listener 
LoadLibraryW			        fn LoadLibraryW(name: *libc::c_void) -> *libc::c_void;
LoanState			enum LoanState 
LoanState			impl LoanState 
Local			impl Local<local_ptr::Borrowed<Task>> for Task 
Local			pub trait Local<Borrowed> 
LocalData			trait LocalData {}
LocalFree			    fn LocalFree(ptr: *c_void);
LocalHeap			impl LocalHeap 
LocalHeap			pub struct LocalHeap 
LocalIo			pub struct LocalIo<'a> 
LocalStorage			pub struct LocalStorage(Option<local_data::Map>);
LockGuard			pub struct LockGuard<'a> 
LowerExp			    impl LowerExp for $ty 
LowerExp			pub trait LowerExp 
LowerHex			pub trait LowerHex 
LowerHex			struct LowerHex;
Lowercase			    pub fn Lowercase(c: char) -> bool 
MEMORY_BASIC_INFORMATION			                pub struct MEMORY_BASIC_INFORMATION 
Managed			    pub struct Managed;
Map			pub trait Map<K, V>: Container 
Map			pub struct Map<'a, A, B, T> 
MapError			pub enum MapError 
MapOption			pub enum MapOption 
MapViewOfFile			                pub fn MapViewOfFile(hFileMappingObject: HANDLE,
MatchIndices			pub struct MatchIndices<'a> 
MaybeOwned			pub enum MaybeOwned<'a> 
MemReader			impl MemReader 
MemReader			pub struct MemReader 
MemWriter			impl MemWriter 
MemWriter			pub struct MemWriter 
MemoryMap			impl MemoryMap 
MemoryMap			pub struct MemoryMap 
MemoryMapKind			pub enum MemoryMapKind 
MemoryRegion			impl MemoryRegion 
MemoryRegion			pub struct MemoryRegion 
Message			enum Message<T> 
Messages			pub struct Messages<'a, T> 
Method			pub enum Method<'a> 
Method			pub enum Method<'a> 
MinMaxResult			pub enum MinMaxResult<T> 
MoveFileExW			                pub fn MoveFileExW(lpExistingFileName: LPCWSTR,
MoveItems			pub struct MoveItems<T> 
MoveItems			pub struct MoveItems<T> 
MovePtr			pub trait MovePtr 
MovePtrAdaptor			pub fn MovePtrAdaptor<V:TyVisitor + MovePtr>(v: V) -> MovePtrAdaptor<V> 
MovePtrAdaptor			pub struct MovePtrAdaptor<V> 
Mul			        impl Mul<Foo, Foo> for Foo 
Mul			impl Mul<f32,f32> for f32 
Mul			impl Mul<f64,f64> for f64 
Mul			impl Mul<$T,$T> for $T 
Mul			impl Mul<$T,$T> for $T 
Mul			pub trait Mul<RHS,Result> 
MultiWriter			impl MultiWriter 
MultiWriter			pub struct MultiWriter 
MultiplicativeIterator			pub trait MultiplicativeIterator<A> 
MutChunks			pub struct MutChunks<'a, T> 
MutItems			pub struct MutItems<'a, T> 
MutSplits			pub struct MutSplits<'a, T> 
Mutable			pub trait Mutable: Container 
Mutable			impl Mutable for ~str 
MutableByteVector			    pub trait MutableByteVector 
MutableCloneableVector			pub trait MutableCloneableVector<T> 
MutableDoubleEndedIterator			pub trait MutableDoubleEndedIterator 
MutableMap			pub trait MutableMap<K, V>: Map<K, V> + Mutable 
MutableSet			pub trait MutableSet<T>: Set<T> + Mutable 
MutableTotalOrdVector			pub trait MutableTotalOrdVector<T> 
MutableVector			pub trait MutableVector<'a, T> 
Mutex			    impl Mutex 
Mutex			    pub struct Mutex 
MyUpgrade			enum MyUpgrade<T> 
MyWriter			    struct MyWriter 
MyWriterHasher			    struct MyWriterHasher;
NativeMutex			impl NativeMutex 
NativeMutex			pub struct NativeMutex 
Nd			    pub fn Nd(c: char) -> bool 
Neg			impl Neg<f32> for f32 
Neg			impl Neg<f64> for f64 
Neg			impl Neg<$T> for $T 
Neg			impl Neg<$T> for $T 
Neg			pub trait Neg<Result> 
Nl			    pub fn Nl(c: char) -> bool 
No			    pub fn No(c: char) -> bool 
NoCopy			    pub struct NoCopy;
NoSend			    pub struct NoSend;
NoShare			    pub struct NoShare;
Node			struct Node 
Node			struct Node<T> 
Node			struct Node<T> 
Node			struct Node<T> 
NormalizationForm			enum NormalizationForm 
Normalizations			pub struct Normalizations<'a> 
Not			impl Not<bool> for bool 
Not			impl Not<$T> for $T 
Not			impl Not<$T> for $T 
Not			pub trait Not<Result> 
NotAscii			        struct NotAscii(char);
NullReader			pub struct NullReader;
NullStream			    pub struct NullStream;
NullWriter			pub struct NullWriter;
Num			impl Num for f32 {}
Num			impl Num for f64 {}
Num			impl Num for $T {}
Num			pub trait Num: Eq + Zero + One
Num			impl Num for $T {}
NumCast			        impl NumCast for $T 
NumCast			pub trait NumCast: ToPrimitive 
NumStrConv			    impl NumStrConv for $t 
NumStrConv			pub trait NumStrConv 
OVERLAPPED			                pub struct OVERLAPPED 
Octal			pub trait Octal 
Octal			struct Octal;
One			impl One for f32 
One			impl One for f64 
One			impl One for $T 
One			pub trait One: Mul<Self, Self> 
One			impl One for $T 
Opaque			pub enum Opaque { }
OpenProcess			                pub fn OpenProcess(dwDesiredAccess: DWORD,
Option			pub enum Option<T> 
Ord			impl Ord for bool 
Ord			impl Ord for char 
Ord			impl Ord for Ordering 
Ord			pub trait Ord: Eq 
Ord			        impl Ord for Foo 
Ord			impl Ord for f32 
Ord			impl Ord for f64 
Ord			impl Ord for $T 
Ord			impl Ord for $T 
Ord			    impl Ord for ~str 
Ord			impl Ord for () 
OrdIterator			pub trait OrdIterator<A> 
Ordering			pub enum Ordering { Less = -1, Equal = 0, Greater = 1 }
Ordering			pub enum Ordering 
OwnedAsciiCast			impl OwnedAsciiCast for ~[u8] 
OwnedAsciiCast			impl OwnedAsciiCast for ~str 
OwnedAsciiCast			pub trait OwnedAsciiCast 
OwnedCloneableVector			pub trait OwnedCloneableVector<T:Clone> 
OwnedEqVector			pub trait OwnedEqVector<T:Eq> 
OwnedStr			impl OwnedStr for ~str 
OwnedStr			pub trait OwnedStr 
OwnedStrAsciiExt			impl OwnedStrAsciiExt for ~str 
OwnedStrAsciiExt			pub trait OwnedStrAsciiExt 
OwnedVector			pub trait OwnedVector<T> 
P			struct P {a: int, b: f64}
PROCESS_INFORMATION			                pub struct PROCESS_INFORMATION 
Packet			pub struct Packet<T> 
Packet			pub trait Packet 
Packet			pub struct Packet<T> 
Packet			pub struct Packet<T> 
Packet			pub struct Packet<T> 
Packets			struct Packets { cur: *mut Handle<'static, ()> }
Pair			            struct Pair 
Parser			pub struct Parser<'a> 
Parser			struct Parser<'a> 
PartialReader			    struct PartialReader 
Path			impl Path 
Path			pub struct Path 
Path			impl Path 
Path			pub struct Path 
PathPrefix			pub enum PathPrefix 
PausableIdleCallback			pub trait PausableIdleCallback 
Peekable			pub struct Peekable<A, T> 
Permutations			pub struct Permutations<T> 
Piece			pub enum Piece<'a> 
Piece			pub enum Piece<'a> 
Pipe			pub struct Pipe 
PipeStream			impl PipeStream 
PipeStream			pub struct PipeStream 
PluralArm			pub struct PluralArm<'a> 
PluralArm			pub struct PluralArm<'a> 
PluralKeyword			pub enum PluralKeyword 
PluralSelector			pub enum PluralSelector 
PluralSelector			pub enum PluralSelector 
Pointer			pub trait Pointer 
Poly			pub trait Poly 
PopResult			pub enum PopResult<T> 
Position			pub enum Position<'a> 
Position			pub enum Position 
Primitive			impl Primitive for f32 {}
Primitive			impl Primitive for f64 {}
Primitive			impl Primitive for $T {}
Primitive			pub trait Primitive: Copy
Primitive			impl Primitive for $T {}
Procedure			pub struct Procedure 
Process			impl Process 
Process			pub struct Process 
ProcessConfig			pub struct ProcessConfig<'a> 
ProcessExit			impl ProcessExit 
ProcessExit			pub enum ProcessExit 
ProcessOutput			pub struct ProcessOutput 
Protocol			pub enum Protocol 
QueryPerformanceCounter			                pub fn QueryPerformanceCounter(
QueryPerformanceFrequency			                pub fn QueryPerformanceFrequency(
Queue			impl Queue 
Queue			struct Queue 
Queue			pub struct Queue<T> 
Queue			pub struct Queue<T> 
Queue			pub struct Queue<T> 
R			        fn R(i: Rc<RefCell<int>>) -> R 
R			        struct R 
RTLD			    pub enum RTLD 
Radix			impl Radix 
Radix			pub struct Radix 
RadixFmt			pub struct RadixFmt<T, R>(T, R);
RandomAccessIterator			pub trait RandomAccessIterator<A>: Iterator<A> 
Range			pub struct Range<A> 
RangeInclusive			pub struct RangeInclusive<A> 
RangeStep			pub struct RangeStep<A> 
RangeStepInclusive			pub struct RangeStepInclusive<A> 
RawPtr			pub trait RawPtr<T> 
Rc			pub struct Rc<T> 
RcBox			struct RcBox<T> 
RcBoxPtr			trait RcBoxPtr<T> 
ReadFile			                pub fn ReadFile(hFile: HANDLE,
Reader			    impl Reader for NullStream 
Reader			    impl Reader for ShortReader 
Reader			impl Reader for ChanReader 
Reader			    impl Reader for EofReader 
Reader			    impl Reader for ErroringLaterReader 
Reader			    impl Reader for ErroringReader 
Reader			    impl Reader for InitialZeroByteReader 
Reader			    impl Reader for PartialReader 
Reader			    impl Reader for ThreeChunkReader 
Reader			impl Reader for File 
Reader			impl Reader for MemReader 
Reader			impl Reader for ~Reader 
Reader			pub trait Reader 
Reader			impl Reader for TcpStream 
Reader			impl Reader for UdpStream 
Reader			impl Reader for UnixStream 
Reader			impl Reader for PipeStream 
Reader			impl Reader for StdReader 
Reader			impl Reader for NullReader 
Reader			impl Reader for ZeroReader 
Receiver			pub struct Receiver<T> 
Ref			pub struct Ref<'b, T> 
RefCell			pub struct RefCell<T> 
RefMut			pub struct RefMut<'b, T> 
RefReader			pub struct RefReader<'a, R> 
RefWriter			pub struct RefWriter<'a, W> 
Rem			impl Rem<f32,f32> for f32 
Rem			impl Rem<f64,f64> for f64 
Rem			impl Rem<$T,$T> for $T 
Rem			impl Rem<$T,$T> for $T 
Rem			pub trait Rem<RHS,Result> 
RemoteCallback			pub trait RemoteCallback 
RemoveDirectoryW			                pub fn RemoveDirectoryW(lpPathName: LPCWSTR) -> BOOL;
Repeat			pub struct Repeat<A> 
Repr			impl Repr<*String> for ~str {}
Repr			pub trait Repr<T> 
Repr			impl Repr for () 
Repr			impl Repr for bool 
Repr			impl Repr for int 
Repr			trait Repr 
ReprVisitor			pub fn ReprVisitor<'a>(ptr: *u8,
ReprVisitor			pub struct ReprVisitor<'a> 
Result			pub enum Result<T, E> 
Rev			pub struct Rev<T> 
RevSplits			pub struct RevSplits<'a, T> 
Round			impl Round for f32 
Round			impl Round for f64 
Round			pub trait Round 
RtioFileStream			pub trait RtioFileStream 
RtioPipe			pub trait RtioPipe 
RtioProcess			pub trait RtioProcess 
RtioSignal			pub trait RtioSignal {}
RtioSocket			pub trait RtioSocket 
RtioTTY			pub trait RtioTTY 
RtioTcpAcceptor			pub trait RtioTcpAcceptor : RtioSocket 
RtioTcpListener			pub trait RtioTcpListener : RtioSocket 
RtioTcpStream			pub trait RtioTcpStream : RtioSocket 
RtioTimer			pub trait RtioTimer 
RtioUdpSocket			pub trait RtioUdpSocket : RtioSocket 
RtioUnixAcceptor			pub trait RtioUnixAcceptor 
RtioUnixListener			pub trait RtioUnixListener 
RtlCaptureContext			        fn RtlCaptureContext(ctx: *mut arch::CONTEXT);
Runtime			pub trait Runtime 
S			        struct S;
S			        struct S 
STACKFRAME64			    struct STACKFRAME64 
STARTUPINFO			                pub struct STARTUPINFO 
SYMBOL_INFO			    struct SYMBOL_INFO 
SYSTEM_INFO			                impl SYSTEM_INFO 
SYSTEM_INFO			                pub struct SYSTEM_INFO 
Saturating			pub trait Saturating 
Scan			pub struct Scan<'a, A, B, T, St> 
Seek			impl Seek for File 
Seek			impl Seek for MemReader 
Seek			impl Seek for MemWriter 
Seek			pub trait Seek 
SeekStyle			pub enum SeekStyle 
Select			impl Select 
Select			pub struct Select 
SelectArm			pub struct SelectArm<'a> 
SelectArm			pub struct SelectArm<'a> 
SelectionResult			pub enum SelectionResult<T> 
SelectionResult			pub enum SelectionResult<T> 
Send			pub trait Send 
Sender			pub struct Sender<T> 
Set			pub trait Set<T>: Container 
SetCurrentDirectoryW			                pub fn SetCurrentDirectoryW(lpPathName: LPCWSTR) -> BOOL;
SetEndOfFile			                pub fn SetEndOfFile(hFile: HANDLE) -> BOOL;
SetEnvironmentVariableW			                pub fn SetEnvironmentVariableW(n: LPCWSTR, v: LPCWSTR)
SetEvent			        fn SetEvent(hEvent: HANDLE) -> BOOL;
SetFilePointerEx			                pub fn SetFilePointerEx(hFile: HANDLE,
SetLastError			        fn SetLastError(error: libc::size_t);
SetNamedPipeHandleState			                pub fn SetNamedPipeHandleState(hNamedPipe: HANDLE,
Share			pub trait Share 
Shl			impl Shl<$T,$T> for $T 
Shl			impl Shl<$T,$T> for $T 
Shl			pub trait Shl<RHS,Result> 
ShortReader			    pub struct ShortReader 
Show			pub trait Show 
Shr			impl Shr<$T,$T> for $T 
Shr			impl Shr<$T,$T> for $T 
Shr			pub trait Shr<RHS,Result> 
SignFormat			pub enum SignFormat 
Signed			pub trait Signed 
Signed			impl Signed for f32 
Signed			impl Signed for f64 
Signed			impl Signed for $T 
Signed			pub trait Signed: Num + Neg<Self> 
SignificantDigits			pub enum SignificantDigits 
Signum			pub enum Signum 
SipHasher			impl SipHasher 
SipHasher			pub struct SipHasher 
SipState			impl SipState 
SipState			pub struct SipState 
SizeDirection			struct SizeDirection 
Sized			pub trait Sized 
Skip			pub struct Skip<T> 
SkipWhile			pub struct SkipWhile<'a, A, T> 
Slice			pub struct Slice<T> 
SocketAddr			pub struct SocketAddr 
SocketType			pub enum SocketType 
Splits			pub struct Splits<'a, T> 
State			struct State<T> 
State			        struct State<'a> 
State			struct State<T> 
StaticNativeMutex			impl StaticNativeMutex 
StaticNativeMutex			pub struct StaticNativeMutex 
StdReader			pub struct StdReader 
StdSource			enum StdSource 
StdWriter			impl StdWriter 
StdWriter			pub struct StdWriter 
Stderr			pub struct Stderr;
StdioContainer			pub enum StdioContainer 
Stdout			            struct Stdout;
Stealer			pub struct Stealer<T> 
Stolen			pub enum Stolen<T> 
Str			pub trait Str 
StrAsciiExt			pub trait StrAsciiExt 
StrSlice			pub trait StrSlice<'a> 
StrSplits			pub struct StrSplits<'a> 
StrVector			pub trait StrVector 
Stream			pub trait Stream: Reader + Writer { }
String			pub trait String 
Struct			    struct Struct 
Sub			impl Sub<f32,f32> for f32 
Sub			impl Sub<f64,f64> for f64 
Sub			impl Sub<$T,$T> for $T 
Sub			impl Sub<$T,$T> for $T 
Sub			pub trait Sub<RHS,Result> 
SwitchToThread			        fn SwitchToThread() -> BOOL;
SyncSender			pub struct SyncSender<T> 
Take			pub struct Take<T> 
TakeWhile			pub struct TakeWhile<'a, A, T> 
Task			impl Task 
Task			pub struct Task 
TaskBuilder			impl TaskBuilder 
TaskBuilder			pub struct TaskBuilder 
TaskOpts			impl TaskOpts 
TaskOpts			pub struct TaskOpts 
TcpAcceptor			pub struct TcpAcceptor 
TcpListener			impl TcpListener 
TcpListener			pub struct TcpListener 
TcpStream			impl TcpStream 
TcpStream			pub struct TcpStream 
TeeReader			pub struct TeeReader<R, W> 
TempDir			    impl TempDir 
TempDir			    struct TempDir(Path);
TempDir			impl TempDir 
TempDir			pub struct TempDir 
TerminateProcess			                pub fn TerminateProcess(hProcess: HANDLE, uExitCode: c_uint)
Test			    struct Test;
TestWriter			        struct TestWriter;
Thread			impl Thread<()> 
Thread			pub struct Thread<T> 
ThreeChunkReader			    struct ThreeChunkReader 
Timer			impl Timer 
Timer			pub struct Timer 
TlsAlloc			    fn TlsAlloc() -> DWORD;
TlsFree			    fn TlsFree(dwTlsIndex: DWORD) -> BOOL;
TlsGetValue			    fn TlsGetValue(dwTlsIndex: DWORD) -> LPVOID;
TlsSetValue			    fn TlsSetValue(dwTlsIndex: DWORD, lpTlsvalue: LPVOID) -> BOOL;
ToCStr			pub trait ToCStr 
ToCStr			impl ToCStr for Path 
ToCStr			impl ToCStr for Path 
ToPrimitive			        impl ToPrimitive for Foo 
ToPrimitive			        impl ToPrimitive for $T 
ToPrimitive			    impl ToPrimitive for Value 
ToPrimitive			pub trait ToPrimitive 
ToStr			pub trait ToStr 
ToStrRadix			impl ToStrRadix for $T 
ToStrRadix			pub trait ToStrRadix 
ToStrRadix			impl ToStrRadix for $T 
TotalEq			        impl TotalEq for $t {}
TotalEq			impl TotalEq for Ordering {}
TotalEq			pub trait TotalEq: Eq 
TotalEq			impl TotalEq for Path {}
TotalEq			impl TotalEq for Path {}
TotalEq			    impl TotalEq for ~str {}
TotalEq			impl TotalEq for () {}
TotalOrd			impl TotalOrd for bool 
TotalOrd			        impl TotalOrd for $t 
TotalOrd			impl TotalOrd for Ordering 
TotalOrd			pub trait TotalOrd: TotalEq + Ord 
TotalOrd			    impl TotalOrd for ~str 
TotalOrd			impl TotalOrd for () 
Trait			    impl Trait for Struct 
Trait			    trait Trait 
TraitObject			pub struct TraitObject 
TryEnterCriticalSection			        fn TryEnterCriticalSection(lpCriticalSection: LPCRITICAL_SECTION) -> BOOL;
TryRecvResult			pub enum TryRecvResult<T> 
TrySendResult			pub enum TrySendResult<T> 
TwoVec			        struct TwoVec<T> 
TyDesc			pub struct TyDesc 
TyVisitor			pub trait TyVisitor 
TypeId			impl TypeId 
TypeId			pub struct TypeId 
UTF16Item			impl UTF16Item 
UTF16Item			pub enum UTF16Item 
UTF16Items			pub struct UTF16Items<'a> 
UdpSocket			impl UdpSocket 
UdpSocket			pub struct UdpSocket 
UdpStream			impl UdpStream 
UdpStream			pub struct UdpStream 
Unfold			pub struct Unfold<'a, A, St> 
UnixAcceptor			pub struct UnixAcceptor 
UnixListener			impl UnixListener 
UnixListener			pub struct UnixListener 
UnixStream			impl UnixStream 
UnixStream			pub struct UnixStream 
UnmapViewOfFile			                pub fn UnmapViewOfFile(lpBaseAddress: LPCVOID) -> BOOL;
Unsafe			pub struct Unsafe<T> 
UnsafeArc			pub struct UnsafeArc<T> 
Unsigned			pub trait Unsigned 
Unsigned			pub trait Unsigned: Num {}
Unsigned			impl Unsigned for $T {}
UnstableFileStat			pub struct UnstableFileStat 
Unwinder			impl Unwinder 
Unwinder			pub struct Unwinder 
UpgradeResult			pub enum UpgradeResult 
UpgradeResult			pub enum UpgradeResult 
UpperExp			    impl UpperExp for $ty 
UpperExp			pub trait UpperExp 
UpperHex			pub trait UpperHex 
UpperHex			pub struct UpperHex;
Uppercase			    pub fn Uppercase(c: char) -> bool 
Value			    struct Value { x: int }
VariantState			enum VariantState 
Vec			pub struct Vec<T> 
Vec			pub struct Vec<T> 
Vector			pub trait Vector<T> 
Vector2D			struct Vector2D 
VectorVector			pub trait VectorVector<T> 
VirtualAlloc			                pub fn VirtualAlloc(lpAddress: LPVOID,
VirtualFree			                pub fn VirtualFree(lpAddress: LPVOID,
VirtualLock			                pub fn VirtualLock(lpAddress: LPVOID, dwSize: SIZE_T) -> BOOL;
VirtualProtect			                pub fn VirtualProtect(lpAddress: LPVOID,
VirtualQuery			                pub fn VirtualQuery(lpAddress: LPCVOID,
VirtualUnlock			                pub fn VirtualUnlock(lpAddress: LPVOID, dwSize: SIZE_T)
Void			pub enum Void { }
WSAPROTOCOLCHAIN			                pub struct WSAPROTOCOLCHAIN 
WSAPROTOCOL_INFO			                pub struct WSAPROTOCOL_INFO 
WaitForSingleObject			                pub fn WaitForSingleObject(hHandle: HANDLE,
WaitForSingleObject			        fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;
WaitForSingleObject			        fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;
WaitNamedPipeW			                pub fn WaitNamedPipeW(lpNamedPipeName: LPCWSTR,
Weak			pub struct Weak<T> 
White_Space			    pub fn White_Space(c: char) -> bool 
Windows			pub struct Windows<'a, T> 
Worker			pub struct Worker<T> 
WriteFile			                pub fn WriteFile(hFile: HANDLE,
Writer			    impl Writer for MyWriter 
Writer			impl Writer for SipState 
Writer			    impl Writer for NullStream 
Writer			impl Writer for ChanWriter 
Writer			impl Writer for File 
Writer			impl Writer for MemWriter 
Writer			impl Writer for ~Writer 
Writer			pub trait Writer 
Writer			impl Writer for TcpStream 
Writer			impl Writer for UdpStream 
Writer			impl Writer for UnixStream 
Writer			impl Writer for PipeStream 
Writer			            impl Writer for Stdout 
Writer			impl Writer for StdWriter 
Writer			        impl Writer for TestWriter 
Writer			impl Writer for MultiWriter 
Writer			impl Writer for NullWriter 
XID_Continue			    pub fn XID_Continue(c: char) -> bool 
XID_Start			    pub fn XID_Start(c: char) -> bool 
Zero			impl Zero for f32 
Zero			impl Zero for f64 
Zero			impl Zero for $T 
Zero			pub trait Zero: Add<Self, Self> 
Zero			impl Zero for $T 
ZeroReader			pub struct ZeroReader;
Zip			pub struct Zip<T, U> 
_NSGetArgc			    pub fn _NSGetArgc() -> *c_int;
_NSGetArgv			    pub fn _NSGetArgv() -> ***c_char;
_NSGetExecutablePath			            pub fn _NSGetExecutablePath(buf: *mut c_char, bufsize: *mut u32)
_Unwind_Action			pub enum _Unwind_Action 
_Unwind_Backtrace			    pub fn _Unwind_Backtrace(trace: _Unwind_Trace_Fn,
_Unwind_Context			pub enum _Unwind_Context {}
_Unwind_DeleteException			    pub fn _Unwind_DeleteException(exception: *_Unwind_Exception);
_Unwind_Exception			pub struct _Unwind_Exception 
_Unwind_FindEnclosingFunction			    pub fn _Unwind_FindEnclosingFunction(pc: *libc::c_void) -> *libc::c_void;
_Unwind_FindEnclosingFunction			pub unsafe fn _Unwind_FindEnclosingFunction(pc: *libc::c_void) -> *libc::c_void 
_Unwind_GetIP			    pub fn _Unwind_GetIP(ctx: *_Unwind_Context) -> libc::uintptr_t;
_Unwind_GetIP			pub unsafe fn _Unwind_GetIP(ctx: *_Unwind_Context) -> libc::uintptr_t 
_Unwind_RaiseException			    pub fn _Unwind_RaiseException(exception: *_Unwind_Exception)
_Unwind_Reason_Code			pub enum _Unwind_Reason_Code 
_Unwind_State			pub enum _Unwind_State 
_Unwind_VRS_DataRepresentation			    enum _Unwind_VRS_DataRepresentation 
_Unwind_VRS_Get			        fn _Unwind_VRS_Get(ctx: *_Unwind_Context,
_Unwind_VRS_RegClass			    enum _Unwind_VRS_RegClass 
_Unwind_VRS_Result			    enum _Unwind_VRS_Result 
__errno_location			            fn __errno_location() -> *c_int;
__error			            fn __error() -> *c_int;
__gcc_personality_v0			        fn __gcc_personality_v0(state: uw::_Unwind_State,
__gcc_personality_v0			        fn __gcc_personality_v0(version: c_int,
__xpg_strerror_r			                fn __xpg_strerror_r(errnum: c_int,
_exit			                pub fn _exit(status: c_int) -> !;
_unsetenv			    fn _unsetenv(n: &str) 
a_million_letter_X			        fn a_million_letter_X() -> ~str 
a_million_letter_a			        fn a_million_letter_a() -> ~str 
abort			    pub fn abort() -> !;
abort			fn abort() -> ! 
abort			    fn abort() -> ! 
abort			pub fn abort(msg: &str) -> ! 
abort_selection			    fn abort_selection(&self) -> bool 
abort_selection			    pub fn abort_selection(&mut self) -> Result<bool, Receiver<T>> 
abort_selection			    fn abort_selection(&self) -> bool;
abort_selection			    pub fn abort_selection(&mut self, _was_upgrade: bool) -> bool 
abort_selection			    pub fn abort_selection(&mut self,
abort_selection			    pub fn abort_selection(&self) -> bool 
abs			                pub fn abs(i: c_int) -> c_int;
abs			    fn abs(&self) -> f32 { abs(*self) }
abs			    fn abs(n: f32) -> f32 = intrinsics::fabsf32,
abs			    fn abs(&self) -> f64 { abs(*self) }
abs			    fn abs(n: f64) -> f64 = intrinsics::fabsf64,
abs			    fn abs(&self) -> $T 
abs			    fn abs(&self) -> Self;
abs			pub fn abs<T: Signed>(value: T) -> T 
abs_sub			    fn abs_sub(&self, other: &f32) -> f32 { abs_sub(*self, *other) }
abs_sub			    fn abs_sub(a: c_float, b: c_float) -> c_float = cmath::fdimf,
abs_sub			    fn abs_sub(&self, other: &f64) -> f64 { abs_sub(*self, *other) }
abs_sub			    fn abs_sub(a: c_double, b: c_double) -> c_double = cmath::fdim,
abs_sub			    fn abs_sub(&self, other: &$T) -> $T 
abs_sub			    fn abs_sub(&self, other: &Self) -> Self;
abs_sub			pub fn abs_sub<T: Signed>(x: T, y: T) -> T 
accept			    fn accept(&mut self) -> IoResult<T>;
accept			    fn accept(&mut self) -> IoResult<TcpStream> 
accept			    fn accept(&mut self) -> IoResult<UnixStream> 
accept			    fn accept(&mut self) -> IoResult<T> 
accept			            pub fn accept(socket: SOCKET, address: *mut sockaddr,
accept			            pub fn accept(socket: c_int, address: *mut sockaddr,
accept			    fn accept(&mut self) -> IoResult<~RtioPipe:Send>;
accept			    fn accept(&mut self) -> IoResult<~RtioTcpStream:Send>;
accept_simultaneously			    fn accept_simultaneously(&mut self) -> IoResult<()>;
access			                pub fn access(path: *c_char, amode: c_int) -> c_int;
acos			    fn acos(&self) -> f32 { acos(*self) }
acos			    fn acos(n: c_float) -> c_float = cmath::acosf,
acos			        pub fn acos(n: c_double) -> c_double;
acos			    fn acos(&self) -> f64 { acos(*self) }
acos			    fn acos(n: c_double) -> c_double = cmath::acos,
acos			    fn acos(&self) -> Self;
acosf			        pub fn acosf(n: c_float) -> c_float;
acosh			    fn acosh(&self) -> f32 
acosh			    fn acosh(&self) -> f64 
acosh			    fn acosh(&self) -> Self;
add			    pub unsafe fn add(&mut self) 
add			            fn add(&self, _: &Foo) -> Foo 
add			        fn add(old: &mut int, new: &uint) -> Option<f64> 
add			    fn add(&self, other: &f32) -> f32 { *self + *other }
add			    fn add(&self, other: &f64) -> f64 { *self + *other }
add			    fn add(&self, other: &$T) -> $T { *self + *other }
add			    fn add(&self, other: &$T) -> $T { *self + *other }
add			    fn add(&self, rhs: &RHS) -> Result;
add			        fn add(&self, rhs: &V) -> ~[T] 
add			    fn add(bh: &mut BenchHarness) 
add			        fn add(&self, rhs: & &'a str) -> ~str 
addrinfo			pub mod addrinfo;
addrinfo			                pub struct addrinfo 
advance			    fn advance(&mut self, f: |A| -> bool) -> bool 
alarm			                pub fn alarm(seconds: c_uint) -> c_uint;
align			    pub fn align(&mut self, a: uint) 
align			pub fn align(size: uint, align: uint) -> uint 
align_of_32			    fn align_of_32() 
align_of_64			    fn align_of_64() 
align_of_basic			    fn align_of_basic() 
align_of_val_basic			    fn align_of_val_basic() 
align_to			    pub fn align_to<T>(&mut self) 
align_to			fn align_to(size: uint, align: uint) -> uint 
all			    fn all(&mut self, f: |A| -> bool) -> bool 
alloc			    pub fn alloc(&mut self, drop_glue: fn(*mut u8), size: uint, align: uint) -> *mut Box 
alloc			    fn alloc(&mut self, bits: int) -> ~Buffer<T> 
alloc			    unsafe fn alloc(&mut self) -> *mut Node<T> 
alloc_managed_big			    fn alloc_managed_big(bh: &mut BenchHarness) 
alloc_managed_small			    fn alloc_managed_small(bh: &mut BenchHarness) 
alloc_obj_with_dtor			    fn alloc_obj_with_dtor(bh: &mut BenchHarness) 
alloc_owned_big			    fn alloc_owned_big(bh: &mut BenchHarness) 
alloc_owned_small			    fn alloc_owned_small(bh: &mut BenchHarness) 
and			    pub fn and<U>(self, optb: Option<U>) -> Option<U> 
and			    pub fn and<U>(self, res: Result<U, E>) -> Result<U, E> 
and_then			    pub fn and_then<U>(self, f: |T| -> Option<U>) -> Option<U> 
and_then			    pub fn and_then<U>(self, op: |T| -> Result<U, E>) -> Result<U, E> 
android			    pub mod android 
annihilate			pub unsafe fn annihilate() 
any			    fn any(&mut self, f: |A| -> bool) -> bool 
any			pub mod any;
any_as_mut			    fn any_as_mut() 
any_as_ref			    fn any_as_ref() 
any_move			    fn any_move() 
any_owning			    fn any_owning() 
any_referenced			    fn any_referenced() 
append			pub fn append<T:Clone>(lhs: ~[T], rhs: &[T]) -> ~[T] 
append			    fn append(self, rhs: &str) -> ~str 
append			    fn append(self, rhs: &str) -> ~str;
append			    pub fn append(mut self, second: &[T]) -> Vec<T> 
append_one			pub fn append_one<T>(lhs: ~[T], x: T) -> ~[T] 
append_one			    pub fn append_one(mut self, x: T) -> Vec<T> 
append_path			        fn append_path(me: &mut Path, path: &str) 
arc			pub mod arc;
arch			        pub mod arch 
arch			    mod arch 
arclike_newN			    fn arclike_newN() 
args			pub fn args() -> ~[~str] 
args			pub mod args;
args_as_bytes			pub fn args_as_bytes() -> ~[~[u8]] 
argument			pub fn argument<'a, T>(f: extern "Rust" fn(&T, &mut Formatter) -> Result,
argument			    fn argument(&mut self) -> Argument<'a> 
argumentstr			pub fn argumentstr<'a>(s: &'a &str) -> Argument<'a> 
argumentuint			pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> 
arm			    pub mod arm 
array_each			pub unsafe fn array_each<T>(arr: **T, cb: |*T|) 
array_each_with_len			pub unsafe fn array_each_with_len<T>(arr: **T, len: uint, cb: |*T|) 
as_box			    fn as_box(&mut self) -> *mut Box 
as_bytes			    pub fn as_bytes<'a>(&'a self) -> &'a [u8] 
as_bytes			    fn as_bytes(&self) -> &'a [u8] 
as_bytes			    fn as_bytes(&self) -> &'a [u8];
as_bytes_no_nul			    pub fn as_bytes_no_nul<'a>(&'a self) -> &'a [u8] 
as_maybe_owned			    pub fn as_maybe_owned(&self) -> MaybeOwned<'a> 
as_mut			    fn as_mut<T: 'static>(self) -> Option<&'a mut T> 
as_mut			    fn as_mut<T: 'static>(self) -> Option<&'a mut T>;
as_mut			    unsafe fn as_mut<'a>(&'a self) -> &'a mut RefCell<T> 
as_mut			    pub fn as_mut<'r>(&'r mut self) -> Option<&'r mut T> 
as_mut			    pub fn as_mut<'r>(&'r mut self) -> Result<&'r mut T, &'r mut E> 
as_mut_ptr			    fn as_mut_ptr(self) -> *mut T 
as_mut_ptr			    fn as_mut_ptr(self) -> *mut T;
as_mut_ptr			    pub fn as_mut_ptr(&mut self) -> *mut T 
as_mut_slice			    pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] 
as_mut_slice			    pub fn as_mut_slice<'r>(&'r mut self) -> &'r mut [T] 
as_mut_slice			    fn as_mut_slice(self) -> &'a mut [T] { self }
as_mut_slice			    fn as_mut_slice(self) -> &'a mut [T];
as_mut_slice			    pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] 
as_owned_vec			    pub unsafe fn as_owned_vec<'a>(s: &'a mut ~str) -> &'a mut ~[u8] 
as_ptr			    fn as_ptr(&self) -> *T 
as_ptr			    fn as_ptr(&self) -> *T;
as_ptr			    fn as_ptr(&self) -> *u8 
as_ptr			    fn as_ptr(&self) -> *u8;
as_ptr			    pub fn as_ptr(&self) -> *T 
as_ref			    fn as_ref<T: 'static>(self) -> Option<&'a T> 
as_ref			    fn as_ref<T: 'static>(self) -> Option<&'a T>;
as_ref			    pub fn as_ref<'r>(&'r self) -> Option<&'r T> 
as_ref			    pub fn as_ref<'r>(&'r self) -> Result<&'r T, &'r E> 
as_slice			    pub fn as_slice<'a>(&'a self) -> &'a [T] 
as_slice			    pub fn as_slice<'r>(&'r self) -> &'r [T] 
as_slice			    fn as_slice<'a>(&'a self) -> &'a [T] { *self }
as_slice			    fn as_slice<'a>(&'a self) -> &'a [T] { let v: &'a [T] = *self; v }
as_slice			    fn as_slice<'a>(&'a self) -> &'a [T];
as_slice			    fn as_slice<'a>(&'a self) -> &'a str { *self }
as_slice			    fn as_slice<'a>(&'a self) -> &'a str 
as_slice			    fn as_slice<'a>(&'a self) -> &'a str;
as_slice			    fn as_slice<'b>(&'b self) -> &'b str 
as_slice			    fn as_slice<'a>(&'a self) -> &'a [T] 
as_socket			    pub fn as_socket<T>(&mut self, f: |&mut UdpSocket| -> T) -> T 
as_str			    pub fn as_str<'a>(&'a self) -> Option<&'a str> 
as_str			    fn as_str<'a>(&'a self) -> Option<&'a str> 
as_str			    fn as_str<'a>(&'a self) -> Option<&'a str> 
as_str_ascii			    fn as_str_ascii<'a>(&'a self) -> &'a str 
as_str_ascii			    fn as_str_ascii<'a>(&'a self) -> &'a str;
as_utf16_p			    pub fn as_utf16_p<T>(s: &str, f: |*u16| -> T) -> T 
as_vec			    fn as_vec<'a>(&'a self) -> &'a [u8];
as_vec			    fn as_vec<'a>(&'a self) -> &'a [u8] 
as_vec			    fn as_vec<'a>(&'a self) -> &'a [u8] 
ascii			pub mod ascii;
asin			    fn asin(&self) -> f32 { asin(*self) }
asin			    fn asin(n: c_float) -> c_float = cmath::asinf,
asin			        pub fn asin(n: c_double) -> c_double;
asin			    fn asin(&self) -> f64 { asin(*self) }
asin			    fn asin(n: c_double) -> c_double = cmath::asin,
asin			    fn asin(&self) -> Self;
asinf			        pub fn asinf(n: c_float) -> c_float;
asinh			    fn asinh(&self) -> f32 
asinh			    fn asinh(&self) -> f64 
asinh			    fn asinh(&self) -> Self;
assert_receiver_is_total_eq			    fn assert_receiver_is_total_eq(&self) {}
assert_sane			    fn assert_sane(&self) 
assert_sane			    fn assert_sane(&self) {}
at_exit			pub fn at_exit(f: proc:Send()) 
at_exit_imp			mod at_exit_imp;
atan			    fn atan(&self) -> f32 { atan(*self) }
atan			    fn atan(n: c_float) -> c_float = cmath::atanf,
atan			        pub fn atan(n: c_double) -> c_double;
atan			    fn atan(&self) -> f64 { atan(*self) }
atan			    fn atan(n: c_double) -> c_double = cmath::atan,
atan			    fn atan(&self) -> Self;
atan2			    fn atan2(&self, other: &f32) -> f32 { atan2(*self, *other) }
atan2			    fn atan2(a: c_float, b: c_float) -> c_float = cmath::atan2f,
atan2			        pub fn atan2(a: c_double, b: c_double) -> c_double;
atan2			    fn atan2(&self, other: &f64) -> f64 { atan2(*self, *other) }
atan2			    fn atan2(a: c_double, b: c_double) -> c_double = cmath::atan2,
atan2			    fn atan2(&self, other: &Self) -> Self;
atan2f			        pub fn atan2f(a: c_float, b: c_float) -> c_float;
atanf			        pub fn atanf(n: c_float) -> c_float;
atanh			    fn atanh(&self) -> f32 
atanh			    fn atanh(&self) -> f64 
atanh			    fn atanh(&self) -> Self;
atof			                pub fn atof(s: *c_char) -> c_double;
atoi			                pub fn atoi(s: *c_char) -> c_int;
atomic_add			unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T 
atomic_and			    pub fn atomic_and<T>(dst: *mut T, src: T) -> T;
atomic_and			unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T 
atomic_and_acq			    pub fn atomic_and_acq<T>(dst: *mut T, src: T) -> T;
atomic_and_acqrel			    pub fn atomic_and_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_and_rel			    pub fn atomic_and_rel<T>(dst: *mut T, src: T) -> T;
atomic_and_relaxed			    pub fn atomic_and_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_compare_and_swap			unsafe fn atomic_compare_and_swap<T>(dst: *mut T, old:T, new:T, order: Ordering) -> T 
atomic_cxchg			    pub fn atomic_cxchg<T>(dst: *mut T, old: T, src: T) -> T;
atomic_cxchg_acq			    pub fn atomic_cxchg_acq<T>(dst: *mut T, old: T, src: T) -> T;
atomic_cxchg_acqrel			    pub fn atomic_cxchg_acqrel<T>(dst: *mut T, old: T, src: T) -> T;
atomic_cxchg_rel			    pub fn atomic_cxchg_rel<T>(dst: *mut T, old: T, src: T) -> T;
atomic_cxchg_relaxed			    pub fn atomic_cxchg_relaxed<T>(dst: *mut T, old: T, src: T) -> T;
atomic_fence			    pub fn atomic_fence();
atomic_fence_acq			    pub fn atomic_fence_acq();
atomic_fence_acqrel			    pub fn atomic_fence_acqrel();
atomic_fence_rel			    pub fn atomic_fence_rel();
atomic_load			    pub fn atomic_load<T>(src: *T) -> T;
atomic_load			unsafe fn atomic_load<T>(dst: *T, order:Ordering) -> T 
atomic_load_acq			    pub fn atomic_load_acq<T>(src: *T) -> T;
atomic_load_relaxed			    pub fn atomic_load_relaxed<T>(src: *T) -> T;
atomic_max			    pub fn atomic_max<T>(dst: *mut T, src: T) -> T;
atomic_max_acq			    pub fn atomic_max_acq<T>(dst: *mut T, src: T) -> T;
atomic_max_acqrel			    pub fn atomic_max_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_max_rel			    pub fn atomic_max_rel<T>(dst: *mut T, src: T) -> T;
atomic_max_relaxed			    pub fn atomic_max_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_min			    pub fn atomic_min<T>(dst: *mut T, src: T) -> T;
atomic_min_acq			    pub fn atomic_min_acq<T>(dst: *mut T, src: T) -> T;
atomic_min_acqrel			    pub fn atomic_min_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_min_rel			    pub fn atomic_min_rel<T>(dst: *mut T, src: T) -> T;
atomic_min_relaxed			    pub fn atomic_min_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_nand			    pub fn atomic_nand<T>(dst: *mut T, src: T) -> T;
atomic_nand			unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T 
atomic_nand_acq			    pub fn atomic_nand_acq<T>(dst: *mut T, src: T) -> T;
atomic_nand_acqrel			    pub fn atomic_nand_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_nand_rel			    pub fn atomic_nand_rel<T>(dst: *mut T, src: T) -> T;
atomic_nand_relaxed			    pub fn atomic_nand_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_or			    pub fn atomic_or<T>(dst: *mut T, src: T) -> T;
atomic_or			unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T 
atomic_or_acq			    pub fn atomic_or_acq<T>(dst: *mut T, src: T) -> T;
atomic_or_acqrel			    pub fn atomic_or_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_or_rel			    pub fn atomic_or_rel<T>(dst: *mut T, src: T) -> T;
atomic_or_relaxed			    pub fn atomic_or_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_store			    pub fn atomic_store<T>(dst: *mut T, val: T);
atomic_store			unsafe fn atomic_store<T>(dst: *mut T, val: T, order:Ordering) 
atomic_store_rel			    pub fn atomic_store_rel<T>(dst: *mut T, val: T);
atomic_store_relaxed			    pub fn atomic_store_relaxed<T>(dst: *mut T, val: T);
atomic_sub			unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T 
atomic_swap			unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T 
atomic_umax			    pub fn atomic_umax<T>(dst: *mut T, src: T) -> T;
atomic_umax_acq			    pub fn atomic_umax_acq<T>(dst: *mut T, src: T) -> T;
atomic_umax_acqrel			    pub fn atomic_umax_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_umax_rel			    pub fn atomic_umax_rel<T>(dst: *mut T, src: T) -> T;
atomic_umax_relaxed			    pub fn atomic_umax_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_umin			    pub fn atomic_umin<T>(dst: *mut T, src: T) -> T;
atomic_umin_acq			    pub fn atomic_umin_acq<T>(dst: *mut T, src: T) -> T;
atomic_umin_acqrel			    pub fn atomic_umin_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_umin_rel			    pub fn atomic_umin_rel<T>(dst: *mut T, src: T) -> T;
atomic_umin_relaxed			    pub fn atomic_umin_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_xadd			    pub fn atomic_xadd<T>(dst: *mut T, src: T) -> T;
atomic_xadd_acq			    pub fn atomic_xadd_acq<T>(dst: *mut T, src: T) -> T;
atomic_xadd_acqrel			    pub fn atomic_xadd_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_xadd_rel			    pub fn atomic_xadd_rel<T>(dst: *mut T, src: T) -> T;
atomic_xadd_relaxed			    pub fn atomic_xadd_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_xchg			    pub fn atomic_xchg<T>(dst: *mut T, src: T) -> T;
atomic_xchg_acq			    pub fn atomic_xchg_acq<T>(dst: *mut T, src: T) -> T;
atomic_xchg_acqrel			    pub fn atomic_xchg_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_xchg_rel			    pub fn atomic_xchg_rel<T>(dst: *mut T, src: T) -> T;
atomic_xchg_relaxed			    pub fn atomic_xchg_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_xor			    pub fn atomic_xor<T>(dst: *mut T, src: T) -> T;
atomic_xor			unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T 
atomic_xor_acq			    pub fn atomic_xor_acq<T>(dst: *mut T, src: T) -> T;
atomic_xor_acqrel			    pub fn atomic_xor_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_xor_rel			    pub fn atomic_xor_rel<T>(dst: *mut T, src: T) -> T;
atomic_xor_relaxed			    pub fn atomic_xor_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_xsub			    pub fn atomic_xsub<T>(dst: *mut T, src: T) -> T;
atomic_xsub_acq			    pub fn atomic_xsub_acq<T>(dst: *mut T, src: T) -> T;
atomic_xsub_acqrel			    pub fn atomic_xsub_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_xsub_rel			    pub fn atomic_xsub_rel<T>(dst: *mut T, src: T) -> T;
atomic_xsub_relaxed			    pub fn atomic_xsub_relaxed<T>(dst: *mut T, src: T) -> T;
atomics			pub mod atomics;
avoid_copying_the_body			fn avoid_copying_the_body(spawnfn: |v: proc:Send()|) 
backtrace			pub mod backtrace;
backtrace_create_state			            fn backtrace_create_state(filename: *libc::c_char,
backtrace_state			        enum backtrace_state {}
backtrace_syminfo			            fn backtrace_syminfo(state: *mut backtrace_state,
base			            fn base(&self) -> u8 { $base }
base			    fn base(&self) -> u8 { self.base }
base			    fn base(&self) -> u8;
base_port			fn base_port() -> u16 
begin_unwind			    pub fn begin_unwind(&mut self, cause: ~Any:Send) -> ! 
begin_unwind			pub fn begin_unwind<M: Any + Send>(msg: M, file: &'static str, line: uint) -> ! 
begin_unwind_fmt			pub fn begin_unwind_fmt(msg: &fmt::Arguments, file: &'static str, line: uint) -> ! 
begin_unwind_inner			fn begin_unwind_inner(msg: ~Any:Send, file: &'static str, line: uint) -> ! 
begin_unwind_raw			pub fn begin_unwind_raw(msg: *u8, file: *u8, line: uint) -> ! 
bench			mod bench 
bench			mod bench 
bench			mod bench 
bench			mod bench 
bench			mod bench 
bench			mod bench 
bench			mod bench 
bench			mod bench 
bench			mod bench 
bench			mod bench 
bench			mod bench 
bench			mod bench 
bench			mod bench 
bench_as_ref			    fn bench_as_ref(bh: &mut BenchHarness) 
bench_buffered_reader			    fn bench_buffered_reader(bh: &mut Harness) 
bench_buffered_stream			    fn bench_buffered_stream(bh: &mut Harness) 
bench_buffered_writer			    fn bench_buffered_writer(bh: &mut Harness) 
bench_compound_1			    fn bench_compound_1(bh: &mut BenchHarness) 
bench_connect			    fn bench_connect(bh: &mut BenchHarness) 
bench_pow_function			    fn bench_pow_function(b: &mut BenchHarness) 
bench_push_str			    fn bench_push_str(bh: &mut BenchHarness) 
bench_str			    fn bench_str(bh: &mut BenchHarness) 
bench_to_c_str_long			    fn bench_to_c_str_long(bh: &mut BenchHarness) 
bench_to_c_str_medium			    fn bench_to_c_str_medium(bh: &mut BenchHarness) 
bench_to_c_str_short			    fn bench_to_c_str_short(bh: &mut BenchHarness) 
bench_to_c_str_unchecked			    fn bench_to_c_str_unchecked(bh: &mut BenchHarness, s: &str) 
bench_to_c_str_unchecked_long			    fn bench_to_c_str_unchecked_long(bh: &mut BenchHarness) 
bench_to_c_str_unchecked_medium			    fn bench_to_c_str_unchecked_medium(bh: &mut BenchHarness) 
bench_to_c_str_unchecked_short			    fn bench_to_c_str_unchecked_short(bh: &mut BenchHarness) 
bench_to_str			    fn bench_to_str(bh: &mut BenchHarness, s: &str) 
bench_with_c_str			    fn bench_with_c_str(bh: &mut BenchHarness, s: &str) 
bench_with_c_str_long			    fn bench_with_c_str_long(bh: &mut BenchHarness) 
bench_with_c_str_medium			    fn bench_with_c_str_medium(bh: &mut BenchHarness) 
bench_with_c_str_short			    fn bench_with_c_str_short(bh: &mut BenchHarness) 
bench_with_c_str_unchecked			    fn bench_with_c_str_unchecked(bh: &mut BenchHarness, s: &str) 
bench_with_c_str_unchecked_long			    fn bench_with_c_str_unchecked_long(bh: &mut BenchHarness) 
bench_with_c_str_unchecked_medium			    fn bench_with_c_str_unchecked_medium(bh: &mut BenchHarness) 
bench_with_c_str_unchecked_short			    fn bench_with_c_str_unchecked_short(bh: &mut BenchHarness) 
bench_with_capacity			    fn bench_with_capacity(bh: &mut BenchHarness) 
bind			    pub fn bind(addr: SocketAddr) -> IoResult<TcpListener> 
bind			    pub fn bind(addr: SocketAddr) -> IoResult<UdpSocket> 
bind			    pub fn bind<P: ToCStr>(path: &P) -> IoResult<UnixListener> 
bind			            pub fn bind(socket: SOCKET, address: *sockaddr,
bind			            pub fn bind(socket: c_int, address: *sockaddr,
bitand			    fn bitand(&self, b: &bool) -> bool { *self & *b }
bitand			    fn bitand(&self, other: &$T) -> $T { *self & *other }
bitand			    fn bitand(&self, other: &$T) -> $T { *self & *other }
bitand			    fn bitand(&self, rhs: &RHS) -> Result;
bitor			    fn bitor(&self, b: &bool) -> bool { *self | *b }
bitor			    fn bitor(&self, other: &$T) -> $T { *self | *other }
bitor			    fn bitor(&self, other: &$T) -> $T { *self | *other }
bitor			    fn bitor(&self, rhs: &RHS) -> Result;
bitxor			    fn bitxor(&self, b: &bool) -> bool { *self ^ *b }
bitxor			    fn bitxor(&self, other: &$T) -> $T { *self ^ *other }
bitxor			    fn bitxor(&self, other: &$T) -> $T { *self ^ *other }
bitxor			    fn bitxor(&self, rhs: &RHS) -> Result;
block			    pub fn block(task: ~Task) -> BlockedTask 
block_and_wake			    fn block_and_wake() 
bookkeeping			pub mod bookkeeping;
bool			pub mod bool;
bool_			    fn bool_() 
bool_and			    fn bool_and() 
borrow			    pub fn borrow<'a>(&'a self) -> Ref<'a, T> 
borrow			    pub fn borrow<'r>(&'r self) -> &'r T 
borrow			    fn borrow(_: Option<Task>) -> local_ptr::Borrowed<Task> 
borrow			    fn borrow(unused_value: Option<Self>) -> Borrowed;
borrow			pub unsafe fn borrow<T>() -> Borrowed<T> 
borrow			    pub fn borrow() -> Option<LocalIo> 
borrow_mut			    pub fn borrow_mut<'a>(&'a self) -> RefMut<'a, T> 
borrow_smoke_test			    fn borrow_smoke_test() 
borrow_with_return			    fn borrow_with_return() 
breakpoint			    pub fn breakpoint();
bsd43			    pub mod bsd43 
bsd44			            pub mod bsd44 
bsd44			            pub mod bsd44 {}
bsd44			        pub mod bsd44 
bsd44			        pub mod bsd44 {}
bsd44			    pub mod bsd44 
bsearch			    fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint> 
bsearch			    fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint>;
bsearch_case_table			    fn bsearch_case_table(c: char, table: &'static [(char, char)]) -> Option<uint> 
bsearch_elem			    fn bsearch_elem(&self, x: &T) -> Option<uint> 
bsearch_elem			    fn bsearch_elem(&self, x: &T) -> Option<uint>;
bsearch_range_table			fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool 
bsearch_range_value_table			    fn bsearch_range_value_table(c: char, r: &'static [(char, char, u8)]) -> u8 
bsearch_table			    fn bsearch_table(c: char, r: &'static [(char, &'static [char])]) -> Option<&'static [char]> 
bswap16			    pub fn bswap16(x: i16) -> i16;
bswap32			    pub fn bswap32(x: i32) -> i32;
bswap64			    pub fn bswap64(x: i64) -> i64;
buf_as_slice			    pub unsafe fn buf_as_slice<T,U>(p: *T, len: uint, f: |v: &[T]| -> U)
buf_len			pub unsafe fn buf_len<T>(buf: **T) -> uint 
buffered			mod buffered;
build			pub fn build<A>(size: Option<uint>, builder: |push: |v: A||) -> ~[A] 
bump			    fn bump(&mut self, amt: int) -> int 
bump			    fn bump(&mut self, amt: int) -> int 
bump			    pub fn bump(&mut self, sz: uint) 
bump_box_refcount			pub unsafe fn bump_box_refcount<T>(t: @T) { forget(t); }
bump_past			    pub fn bump_past<T>(&mut self) 
but_always_run_this_function			    fn but_always_run_this_function() { }
by_ref			    fn by_ref<'a>(&'a mut self) -> RefReader<'a, Self> 
by_ref			    fn by_ref<'a>(&'a mut self) -> RefWriter<'a, Self> 
by_ref			    fn by_ref<'r>(&'r mut self) -> ByRef<'r, Self> 
bytes			    fn bytes<'r>(&'r mut self) -> extensions::Bytes<'r, Self> 
bytes			pub mod bytes 
bytes			    fn bytes(&self) -> Bytes<'a> 
bytes			    fn bytes(&self) -> Bytes<'a>;
bytes_0_bytes			    fn bytes_0_bytes() 
bytes_eof			    fn bytes_eof() 
bytes_error			    fn bytes_error() 
bytes_rev			    fn bytes_rev(&self) -> RevBytes<'a> 
bytes_rev			    fn bytes_rev(&self) -> RevBytes<'a>;
c95			            pub mod c95 
c95			        pub mod c95 
c95			    pub mod c95 
c99			            pub mod c99 
c99			        pub mod c99 
c_str			pub mod c_str;
c_str_to_static_slice			    pub unsafe fn c_str_to_static_slice(s: *libc::c_char) -> &'static str 
c_vec			pub mod c_vec;
c_void			            pub enum c_void 
call			    fn call(&mut self);
callback			    fn callback(&mut self, arg: proc:Send());
calloc			                pub fn calloc(nobj: size_t, size: size_t) -> *c_void;
can_block			    fn can_block(&self) -> bool;
can_block			    pub fn can_block(&self) -> bool 
can_recv			    fn can_recv(&self) -> bool 
can_recv			    pub fn can_recv(&mut self) -> Result<bool, Receiver<T>> 
can_recv			    fn can_recv(&self) -> bool;
can_recv			    pub fn can_recv(&mut self) -> bool 
can_recv			    pub fn can_recv(&mut self) -> Result<bool, Receiver<T>> 
can_recv			    pub fn can_recv(&self) -> bool 
canonical			    pub fn canonical(c: char, i: |char|) { d(c, i, false); }
canonical_combining_class			    pub fn canonical_combining_class(c: char) -> u8 
canonical_sort			fn canonical_sort(comb: &mut [(char, u8)]) 
cap			    fn cap(&self) -> uint { self.buf.len() }
capacity			    fn capacity(&self) -> uint 
capacity			    fn capacity(&self) -> uint;
capacity			    fn capacity(&self) -> uint 
capacity			    fn capacity(&self) -> uint;
capacity			    pub fn capacity(&self) -> uint 
case			        fn case(a: ~[uint], b: ~[uint]) 
cast			pub mod cast;
cast			pub fn cast<T: NumCast,U: NumCast>(n: T) -> Option<U> 
cast_from_uint			    pub unsafe fn cast_from_uint(blocked_task_ptr: uint) -> BlockedTask 
cast_to_uint			    pub unsafe fn cast_to_uint(self) -> uint 
casual_pop			    pub fn casual_pop(&mut self) -> Option<T> 
cbrt			    fn cbrt(&self) -> f32 { cbrt(*self) }
cbrt			    fn cbrt(n: c_float) -> c_float = cmath::cbrtf,
cbrt			        pub fn cbrt(n: c_double) -> c_double;
cbrt			    fn cbrt(&self) -> f64 { cbrt(*self) }
cbrt			    fn cbrt(n: c_double) -> c_double = cmath::cbrt,
cbrt			    fn cbrt(&self) -> Self;
cbrtf			        pub fn cbrtf(n: c_float) -> c_float;
ceil			    fn ceil(&self) -> f32 { ceil(*self) }
ceil			    fn ceil(n: f32) -> f32 = intrinsics::ceilf32,
ceil			    fn ceil(&self) -> f64 { ceil(*self) }
ceil			    fn ceil(n: f64) -> f64 = intrinsics::ceilf64,
ceil			    fn ceil(&self) -> Self;
ceilf32			    pub fn ceilf32(x: f32) -> f32;
ceilf64			    pub fn ceilf64(x: f64) -> f64;
cell			pub mod cell;
cell_has_sensible_show			    fn cell_has_sensible_show() 
chain			    fn chain<U: Iterator<A>>(self, other: U) -> Chain<Self, U> 
change_dir			pub fn change_dir(p: &Path) -> bool 
change_file_times			pub fn change_file_times(path: &Path, atime: u64, mtime: u64) -> IoResult<()> 
channel			pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) 
char			pub mod char;
char_at			    fn char_at(&self, i: uint) -> char 
char_at			    fn char_at(&self, i: uint) -> char;
char_at_reverse			    fn char_at_reverse(&self, i: uint) -> char 
char_at_reverse			    fn char_at_reverse(&self, i: uint) -> char;
char_indices			    fn char_indices(&self) -> CharOffsets<'a> 
char_indices			    fn char_indices(&self) -> CharOffsets<'a>;
char_indices_rev			    fn char_indices_rev(&self) -> RevCharOffsets<'a> 
char_indices_rev			    fn char_indices_rev(&self) -> RevCharOffsets<'a>;
char_indicesator			    fn char_indicesator(bh: &mut BenchHarness) 
char_indicesator_rev			    fn char_indicesator_rev(bh: &mut BenchHarness) 
char_iterator			    fn char_iterator(bh: &mut BenchHarness) 
char_iterator_ascii			    fn char_iterator_ascii(bh: &mut BenchHarness) 
char_iterator_rev			    fn char_iterator_rev(bh: &mut BenchHarness) 
char_len			    fn char_len(&self) -> uint { self.chars().len() }
char_len			    fn char_len(&self) -> uint;
char_range_at			    fn char_range_at(&self, i: uint) -> CharRange 
char_range_at			    fn char_range_at(&self, start: uint) -> CharRange;
char_range_at_reverse			    fn char_range_at_reverse(&self, start: uint) -> CharRange 
char_range_at_reverse			    fn char_range_at_reverse(&self, start: uint) -> CharRange;
chars			    fn chars<'r>(&'r mut self) -> Chars<'r, Self> 
chars			    fn chars(&self) -> Chars<'a> 
chars			    fn chars(&self) -> Chars<'a>;
chars_rev			    fn chars_rev(&self) -> RevChars<'a> 
chars_rev			    fn chars_rev(&self) -> RevChars<'a>;
chdir			                pub fn chdir(dir: *c_char) -> c_int;
chdir			    fn chdir(p: &Path) -> bool 
check			    fn check(s: &str, c_str: *libc::c_char) 
check_for_errors_in			    pub fn check_for_errors_in<T>(f: || -> T) -> Result<T, ~str> 
check_for_null			fn check_for_null(v: &[u8], buf: *mut libc::c_char) 
check_randacc_iter			    fn check_randacc_iter<A: Eq, T: Clone + RandomAccessIterator<A>>(a: T, len: uint)
check_word_size			        fn check_word_size() 
checked_add			    fn checked_add(&self, v: &i16) -> Option<i16> 
checked_add			    fn checked_add(&self, v: &i32) -> Option<i32> 
checked_add			    fn checked_add(&self, v: &i64) -> Option<i64> 
checked_add			    fn checked_add(&self, v: &i8) -> Option<i8> 
checked_add			    fn checked_add(&self, v: &int) -> Option<int> 
checked_add			    fn checked_add(&self, v: &Self) -> Option<Self>;
checked_add			    fn checked_add(&self, v: &u16) -> Option<u16> 
checked_add			    fn checked_add(&self, v: &u32) -> Option<u32> 
checked_add			    fn checked_add(&self, v: &u64) -> Option<u64> 
checked_add			    fn checked_add(&self, v: &u8) -> Option<u8> 
checked_add			    fn checked_add(&self, v: &uint) -> Option<uint> 
checked_div			    fn checked_div(&self, v: &$T) -> Option<$T> 
checked_div			    fn checked_div(&self, v: &Self) -> Option<Self>;
checked_div			    fn checked_div(&self, v: &$T) -> Option<$T> 
checked_mul			    fn checked_mul(&self, v: &i16) -> Option<i16> 
checked_mul			    fn checked_mul(&self, v: &i32) -> Option<i32> 
checked_mul			    fn checked_mul(&self, v: &i64) -> Option<i64> 
checked_mul			    fn checked_mul(&self, v: &i8) -> Option<i8> 
checked_mul			    fn checked_mul(&self, v: &int) -> Option<int> 
checked_mul			    fn checked_mul(&self, v: &Self) -> Option<Self>;
checked_mul			    fn checked_mul(&self, v: &u16) -> Option<u16> 
checked_mul			    fn checked_mul(&self, v: &u32) -> Option<u32> 
checked_mul			    fn checked_mul(&self, v: &u64) -> Option<u64> 
checked_mul			    fn checked_mul(&self, v: &u8) -> Option<u8> 
checked_mul			    fn checked_mul(&self, v: &uint) -> Option<uint> 
checked_next_power_of_two			pub fn checked_next_power_of_two<T: Unsigned + Int>(n: T) -> Option<T> 
checked_sub			    fn checked_sub(&self, v: &i16) -> Option<i16> 
checked_sub			    fn checked_sub(&self, v: &i32) -> Option<i32> 
checked_sub			    fn checked_sub(&self, v: &i64) -> Option<i64> 
checked_sub			    fn checked_sub(&self, v: &i8) -> Option<i8> 
checked_sub			    fn checked_sub(&self, v: &int) -> Option<int> 
checked_sub			    fn checked_sub(&self, v: &Self) -> Option<Self>;
checked_sub			    fn checked_sub(&self, v: &u16) -> Option<u16> 
checked_sub			    fn checked_sub(&self, v: &u32) -> Option<u32> 
checked_sub			    fn checked_sub(&self, v: &u64) -> Option<u64> 
checked_sub			    fn checked_sub(&self, v: &u8) -> Option<u8> 
checked_sub			    fn checked_sub(&self, v: &uint) -> Option<uint> 
child_no			    fn child_no(x: uint) -> proc:Send() 
chmod			pub fn chmod(path: &Path, mode: io::FilePermission) -> IoResult<()> 
chmod			                pub fn chmod(path: *c_char, mode: c_int) -> c_int;
chmod			                pub fn chmod(path: *c_char, mode: mode_t) -> c_int;
chown			pub fn chown(path: &Path, uid: int, gid: int) -> IoResult<()> 
chown			                pub fn chown(path: *c_char, uid: uid_t, gid: gid_t) -> c_int;
chunks			    fn chunks(self, size: uint) -> Chunks<'a, T> 
chunks			    fn chunks(self, size: uint) -> Chunks<'a, T>;
claim			    fn claim(&mut self, _alloc: &mut AllocHeader) {}
claim			    fn claim(&mut self, alloc: &mut AllocHeader) 
classify			    fn classify(&self) -> FPCategory 
classify			    fn classify(&self) -> FPCategory 
classify			    fn classify(&self) -> FPCategory;
cleanup			pub mod cleanup;
cleanup			    pub fn cleanup() 
cleanup			    pub unsafe fn cleanup() 
cleanup			    pub unsafe fn cleanup() 
cleanup			    pub unsafe fn cleanup() {}
cleanup			pub unsafe fn cleanup() 
cleanup_task			    fn cleanup_task(mut t: ~Task) 
clear			    fn clear(&mut self);
clear			    fn clear(&mut self) { self.truncate(0) }
clear			    fn clear(&mut self) 
clear			    fn clear(&mut self) 
clone			    fn clone(&self) -> CString 
clone			    fn clone(&self) -> Cell<T> 
clone			    fn clone(&self) -> RefCell<T> 
clone			            fn clone(&self) -> $t { *self }
clone			            fn clone(&self) -> extern "Rust" fn($($A),*) -> ReturnType { *self }
clone			    fn clone(&self) -> &'a T { *self }
clone			    fn clone(&self) -> &'a [T] { *self }
clone			    fn clone(&self) -> &'a str { *self }
clone			    fn clone(&self) -> @T { *self }
clone			    fn clone(&self) -> Self;
clone			    fn clone(&self) -> ~T { ~(**self).clone() }
clone			    fn clone(&self) -> Sender<T> 
clone			    fn clone(&self) -> SyncSender<T> 
clone			    fn clone(&self) -> Gc<T> 
clone			    fn clone(&self) -> SipState 
clone			    fn clone(&self) -> ChanWriter 
clone			    fn clone(&self) -> TcpStream 
clone			    fn clone(&self) -> UdpSocket 
clone			    fn clone(&self) -> UnixStream 
clone			    fn clone(&self) -> PipeStream 
clone			            fn clone(&self) -> Foo 
clone			pub mod clone;
clone			    fn clone(&self) -> *T 
clone			    fn clone(&self) -> *mut T 
clone			    fn clone(&self) -> Rc<T> 
clone			    fn clone(&self) -> Weak<T> 
clone			    pub fn clone() -> Option<~[~[u8]]> 
clone			    fn clone(&self) -> ~RtioPipe:Send;
clone			    fn clone(&self) -> ~RtioTcpStream:Send;
clone			    fn clone(&self) -> ~RtioUdpSocket:Send;
clone			            fn clone(&self) -> S 
clone			    fn clone(&self) -> Items<'a, T> { *self }
clone			    fn clone(&self) -> ~[A] 
clone			    fn clone(&self) -> MaybeOwned<'a> 
clone			    fn clone(&self) -> ~str 
clone			    fn clone(&self) -> UnsafeArc<T> 
clone			    fn clone(&self) -> BufferPool<T> { BufferPool { pool: self.pool.clone() } }
clone			    fn clone(&self) -> Stealer<T> { Stealer { deque: self.deque.clone() } }
clone			    fn clone(&self) -> Queue<T> 
clone			                fn clone(&self) -> ($($T,)+) 
clone			    fn clone(&self) -> Exclusive<T> 
clone			    fn clone(&self) -> Vec<T> 
clone_chan			    pub fn clone_chan(&mut self) 
clone_chan			    pub fn clone_chan(&self) 
clone_from			    fn clone_from(&mut self, source: &Self) 
clone_from			    fn clone_from(&mut self, source: &~T) 
clone_from			    fn clone_from(&mut self, source: &~[A]) 
close			                pub fn close(fd: c_int) -> c_int;
close			pub fn close(fd: int) -> int 
close			    pub unsafe fn close(handle: *u8) 
close_outputs			                fn close_outputs() 
close_write			    fn close_write(&mut self) -> IoResult<()>;
closedir			                pub fn closedir(dirp: *DIR) -> c_int;
closesocket			            pub fn closesocket(socket: SOCKET) -> c_int;
closure_exchange_malloc			pub unsafe fn closure_exchange_malloc(drop_glue: fn(*mut u8), size: uint, align: uint) -> *u8 
closure_exchange_malloc_			pub unsafe fn closure_exchange_malloc_(drop_glue: fn(*mut u8), size: uint, align: uint) -> *u8 
cmath			mod cmath 
cmath			mod cmath 
cmp			    fn cmp(&self, other: &bool) -> Ordering 
cmp			            fn cmp(&self, other: &$t) -> Ordering 
cmp			    fn cmp(&self, other: &Ordering) -> Ordering 
cmp			    fn cmp(&self, other: &Self) -> Ordering;
cmp			    pub fn cmp<A: TotalOrd, T: Iterator<A>>(mut a: T, mut b: T) -> cmp::Ordering 
cmp			    fn cmp(&self, other: &@T) -> Ordering { (**self).cmp(*other) }
cmp			    fn cmp(&self, other: &~T) -> Ordering { (**self).cmp(*other) }
cmp			    fn cmp(&self, other: &Rc<T>) -> Ordering { (**self).cmp(&**other) }
cmp			    fn cmp(&self, other: & &'a T) -> Ordering { (**self).cmp(*other) }
cmp			        fn cmp(&self, other: & &'a [T]) -> Ordering 
cmp			        fn cmp(&self, other: &~[T]) -> Ordering { self.as_slice().cmp(&other.as_slice()) }
cmp			        fn cmp(&self, other: & &'a str) -> Ordering 
cmp			        fn cmp(&self, other: &~str) -> Ordering { self.as_slice().cmp(&other.as_slice()) }
cmp			    fn cmp(&self, other: &MaybeOwned) -> Ordering 
cmp			                fn cmp(&self, other: &($($T,)+)) -> Ordering 
cmp			    fn cmp(&self, _other: &()) -> Ordering { Equal }
cmp			    fn cmp(&self, other: &Vec<T>) -> Ordering 
collect			    fn collect<B: FromIterator<A>>(&mut self) -> B 
collect			pub fn collect<T, Iter: Iterator<Option<T>>, V: FromIterator<T>>(iter: Iter) -> Option<V> 
collect			pub fn collect<T, E, Iter: Iterator<Result<T, E>>, V: FromIterator<T>>(iter: Iter) -> Result<V, E> 
collect_failure			    pub fn collect_failure(&mut self, result: TaskResult) 
combine			fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i64) -> IoResult<u64> 
comm			pub mod comm;
comm_adapters			mod comm_adapters;
comm_shared_chan			    fn comm_shared_chan() 
comm_stream			    fn comm_stream() 
commit			                pub fn commit(fd: c_int) -> c_int;
common			        pub mod common 
common			    pub mod common 
comp_requires_verbatim			        fn comp_requires_verbatim(s: &str) -> bool 
compare_and_swap			    pub fn compare_and_swap(&self, old: *mut T, new: *mut T, order: Ordering) -> *mut T 
compare_and_swap			    pub fn compare_and_swap(&self, old: bool, new: bool, order: Ordering) -> bool 
compare_and_swap			    pub fn compare_and_swap(&self, old: int, new: int, order: Ordering) -> int 
compare_and_swap			    pub fn compare_and_swap(&self, old: uint, new: uint, order: Ordering) -> uint 
compatibility			    pub fn compatibility(c: char, i: |char|) { d(c, i, true); }
compiled			pub mod compiled 
components			    pub fn components<'a>(&'a self) -> Components<'a> 
components			    pub fn components<'a>(&'a self) -> Components<'a> 
concat			    fn concat(bh: &mut BenchHarness) 
concat			    fn concat(&self) -> ~str 
concat			    fn concat(&self) -> ~str;
concat_vec			    fn concat_vec(&self) -> ~[T] 
concat_vec			    fn concat_vec(&self) -> ~[T];
configure			    pub fn configure(config: ProcessConfig) -> IoResult<Process> 
connect			        fn connect(i: int, addr: SocketAddr) 
connect			    pub fn connect(addr: SocketAddr) -> IoResult<TcpStream> 
connect			    pub fn connect(self, other: SocketAddr) -> UdpStream 
connect			    pub fn connect<P: ToCStr>(path: &P) -> IoResult<UnixStream> 
connect			            pub fn connect(socket: SOCKET, address: *sockaddr,
connect			            pub fn connect(socket: c_int, address: *sockaddr,
connect			    fn connect(bh: &mut BenchHarness) 
connect			    fn connect(&self, sep: &str) -> ~str 
connect			    fn connect(&self, sep: &str) -> ~str;
connect_vec			    fn connect_vec(&self, sep: &T) -> ~[T] 
connect_vec			    fn connect_vec(&self, sep: &T) -> ~[T];
consts			pub mod consts 
consts			pub mod consts 
consts			pub mod consts 
consts			pub mod consts 
consume			    fn consume(&mut self, c: char) -> bool 
consume			    fn consume(&mut self, amt: uint) { self.inner.consume(amt) }
consume			    fn consume(&mut self, amt: uint) 
consume			    fn consume(&mut self, amt: uint) { self.pos += amt; }
consume			    fn consume(&mut self, amt: uint);
container			pub mod container;
container_as_bytes			    fn container_as_bytes<'a>(&'a self) -> &'a [u8] 
container_as_bytes			    fn container_as_bytes<'a>(&'a self) -> &'a [u8];
container_as_bytes			    fn container_as_bytes<'b>(&'b self) -> &'b [u8] 
container_as_bytes			    fn container_as_bytes<'a>(&'a self) -> &'a [u8] 
container_as_bytes			    fn container_as_bytes<'a>(&'a self) -> &'a [u8] 
container_as_str			    fn container_as_str<'a>(&'a self) -> Option<&'a str> 
container_as_str			    fn container_as_str<'b>(&'b self) -> Option<&'b str> 
container_as_str			    fn container_as_str<'a>(&'a self) -> Option<&'a str> 
container_into_owned_bytes			    fn container_into_owned_bytes(self) -> ~[u8] 
container_into_owned_bytes			    fn container_into_owned_bytes(self) -> ~[u8] 
container_into_owned_bytes			    fn container_into_owned_bytes(self) -> ~[u8] 
contains			    fn contains(&self, value: &T) -> bool;
contains			    fn contains(&self, x: &T) -> bool 
contains			    fn contains(&self, x: &T) -> bool;
contains			    fn contains<'a>(&self, needle: &'a str) -> bool 
contains			    fn contains<'a>(&self, needle: &'a str) -> bool;
contains			    pub fn contains(&self, x: &T) -> bool 
contains_char			    fn contains_char(&self, needle: char) -> bool 
contains_char			    fn contains_char(&self, needle: char) -> bool;
contains_key			    fn contains_key(&self, key: &K) -> bool 
contains_last_element			    fn contains_last_element(bh: &mut BenchHarness) 
contains_nul			fn contains_nul(v: &[u8]) -> bool 
control_congestion			    fn control_congestion(&mut self) -> IoResult<()>;
conversions			pub mod conversions 
convert			        fn convert<'a>(x: Option<&'a str>) -> &'a [u8] 
copy			pub fn copy(from: &Path, to: &Path) -> IoResult<()> 
copy			pub fn copy<R: Reader, W: Writer>(r: &mut R, w: &mut W) -> io::IoResult<()> 
copy_from			    fn copy_from(self, &[T]) -> uint;
copy_from			    fn copy_from(self, src: &[T]) -> uint 
copy_lifetime			pub unsafe fn copy_lifetime<'a,S,T>(_ptr: &'a S, ptr: &T) -> &'a T 
copy_lifetime_vec			pub unsafe fn copy_lifetime_vec<'a,S,T>(_ptr: &'a [S], ptr: &T) -> &'a T 
copy_memory			    pub fn copy_memory<T>(dst: *mut T, src: *T, count: uint);
copy_memory			pub unsafe fn copy_memory<T>(dst: *mut T, src: *T, count: uint) 
copy_memory			    pub fn copy_memory(dst: &mut [u8], src: &[u8]) 
copy_memory			    unsafe fn copy_memory(self, src: &[T]) 
copy_memory			    unsafe fn copy_memory(self, src: &[T]);
copy_mut_lifetime			pub unsafe fn copy_mut_lifetime<'a,S,T>(_ptr: &'a mut S, ptr: &mut T) -> &'a mut T 
copy_nonoverlapping_memory			    pub fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *T, count: uint);
copy_nonoverlapping_memory			pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T,
copysign			    fn copysign(x: f32, y: f32) -> f32 = intrinsics::copysignf32,
copysign			    fn copysign(x: f64, y: f64) -> f64 = intrinsics::copysignf64,
copysignf32			    pub fn copysignf32(x: f32, y: f32) -> f32;
copysignf64			    pub fn copysignf64(x: f64, y: f64) -> f64;
cos			    fn cos(&self) -> f32 { cos(*self) }
cos			    fn cos(n: f32) -> f32 = intrinsics::cosf32,
cos			    fn cos(&self) -> f64 { cos(*self) }
cos			    fn cos(n: f64) -> f64 = intrinsics::cosf64,
cos			    fn cos(&self) -> Self;
cosf32			    pub fn cosf32(x: f32) -> f32;
cosf64			    pub fn cosf64(x: f64) -> f64;
cosh			    fn cosh(&self) -> f32 { cosh(*self) }
cosh			    fn cosh(n: c_float) -> c_float = cmath::coshf,
cosh			        pub fn cosh(n: c_double) -> c_double;
cosh			    fn cosh(&self) -> f64 { cosh(*self) }
cosh			    fn cosh(n: c_double) -> c_double = cmath::cosh,
cosh			    fn cosh(&self) -> Self;
coshf			        pub fn coshf(n: c_float) -> c_float;
count			    fn count(&mut self) -> Count<'a> 
count			        fn count(st: &mut uint) -> Option<uint> 
count			    fn count(&mut self, predicate: |A| -> bool) -> uint 
count			pub fn count<A>(start: A, step: A) -> Counter<A> 
count_ones			    fn count_ones(&self) -> i16 { unsafe { intrinsics::ctpop16(*self) } }
count_ones			    fn count_ones(&self) -> i32 { unsafe { intrinsics::ctpop32(*self) } }
count_ones			    fn count_ones(&self) -> i64 { unsafe { intrinsics::ctpop64(*self) } }
count_ones			    fn count_ones(&self) -> i8 { unsafe { intrinsics::ctpop8(*self) } }
count_ones			    fn count_ones(&self) -> int { (*self as i32).count_ones() as int }
count_ones			    fn count_ones(&self) -> int { (*self as i64).count_ones() as int }
count_ones			    fn count_ones(&self) -> Self;
count_ones			    fn count_ones(&self) -> $T 
count_zeros			    fn count_zeros(&self) -> Self 
creat			                pub fn creat(path: *c_char, mode: c_int) -> c_int;
creat			                pub fn creat(path: *c_char, mode: mode_t) -> c_int;
create			    pub fn create(path: &Path) -> IoResult<File> 
create			    pub unsafe fn create(stack: uint, p: ~proc:Send()) -> rust_thread 
create			pub unsafe fn create(key: &mut Key) 
ctlz16			    pub fn ctlz16(x: i16) -> i16;
ctlz32			    pub fn ctlz32(x: i32) -> i32;
ctlz64			    pub fn ctlz64(x: i64) -> i64;
ctlz8			    pub fn ctlz8(x: i8) -> i8;
ctpop16			    pub fn ctpop16(x: i16) -> i16;
ctpop32			    pub fn ctpop32(x: i32) -> i32;
ctpop64			    pub fn ctpop64(x: i64) -> i64;
ctpop8			    pub fn ctpop8(x: i8) -> i8;
cttz16			    pub fn cttz16(x: i16) -> i16;
cttz32			    pub fn cttz32(x: i32) -> i32;
cttz64			    pub fn cttz64(x: i64) -> i64;
cttz8			    pub fn cttz8(x: i8) -> i8;
ctype			        pub mod ctype 
cycle			    fn cycle(self) -> Cycle<Self>;
cycle			    fn cycle(self) -> Cycle<T> 
d			    fn d(c: char, i: |char|, k: bool) 
darwin_fd_limit			mod darwin_fd_limit 
data			    fn data() { assert_eq!(Thread::start(proc () { 1 }).join(), 1); }
datasync			    pub fn datasync(&mut self) -> IoResult<()> 
datasync			    fn datasync(&mut self) -> IoResult<()>;
debug_borrow			pub fn debug_borrow() -> bool 
debug_mem			fn debug_mem() -> bool 
dec_strong			    fn dec_strong(&self) { self.inner().strong.set(self.strong() - 1); }
dec_weak			    fn dec_weak(&self) { self.inner().weak.set(self.weak() - 1); }
decompose			pub mod decompose 
decompose_canonical			pub fn decompose_canonical(c: char, f: |char|) 
decompose_compatible			pub fn decompose_compatible(c: char, f: |char|) 
decompose_hangul			fn decompose_hangul(s: char, f: |char|) 
decrement			    fn decrement(&mut self, task: BlockedTask) -> Result<(), BlockedTask> 
decrement			    fn decrement(&mut self, task: BlockedTask) -> Result<(), BlockedTask> 
decrement			pub fn decrement() 
dedup			    fn dedup(&mut self) 
dedup			    fn dedup(&mut self);
dedup			    pub fn dedup(&mut self) 
default			    fn default() -> bool { false }
default			    fn default() -> char { '\\x00' }
default			    fn default() -> @T { @Default::default() }
default			    fn default() -> Self;
default			    fn default() -> ~T { ~Default::default() }
default			    fn default() -> SipHasher 
default			    fn default() -> SipState 
default			pub mod default;
default			    fn default() -> f32 { 0.0 }
default			    fn default() -> f64 { 0.0 }
default			    fn default() -> $T { 0 }
default			    fn default() -> $T { 0 }
default			    fn default() -> Option<T> { None }
default			    fn default() -> &'a [A] { &'a [] }
default			    fn default() -> ~[A] { ~[] }
default			    fn default() -> &'a str { "" }
default			    fn default() -> MaybeOwned<'a> { Slice("") }
default			    fn default() -> ~str { ~"" }
default			                fn default() -> ($($T,)+) 
default			    fn default() -> () { () }
default			    fn default() -> Vec<T> 
default_sched_threads			pub fn default_sched_threads() -> uint 
defined			trait defined in this module. For loops can be viewed as a syntactical expansion
demangle			    fn demangle() 
demangle			fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> 
demangle_dollars			    fn demangle_dollars() 
deque			    pub fn deque(&mut self) -> (Worker<T>, Stealer<T>) 
deque			pub mod deque;
dequeue			    fn dequeue(&mut self) -> Option<BlockedTask> 
dequeue			    fn dequeue(&mut self) -> T 
deref			    fn deref<'a>(&'a self) -> &'a T 
deref			    fn deref<'a>(&'a self) -> &'a Result;
deref			    fn deref<'a>(&'a self) -> &'a T 
deref_mut			    fn deref_mut<'a>(&'a mut self) -> &'a mut T 
deref_mut			    fn deref_mut<'a>(&'a mut self) -> &'a mut Result;
derived_property			pub mod derived_property 
deschedule			    fn deschedule(~self, times: uint, cur_task: ~Task,
deschedule			    pub fn deschedule(mut ~self, amt: uint,
deschedule			pub fn deschedule() 
describe			    fn describe(&self) -> &'static str 
destroy			pub unsafe fn destroy(key: Key) 
destroy			        pub unsafe fn destroy(&self) 
destroy			    pub unsafe fn destroy(&self) { self.inner.destroy() }
destroy_immediately			    fn destroy_immediately() 
detach			    pub unsafe fn detach(native: rust_thread) 
detached			    fn detached() { Thread::spawn(proc () {}) }
different_sizes			    fn different_sizes() 
digit			            fn digit(&self, x: u8) -> u8 
digit			    fn digit(&self, x: u8) -> u8 
digit			    fn digit(&self, x: u8) -> u8;
digits			    fn digits(_: Option<f32>) -> uint { 6 }
digits			    fn digits(_: Option<f64>) -> uint { 15 }
digits			    fn digits(unused_self: Option<Self>) -> uint;
dir_path			    fn dir_path(&self) -> Self 
dir_path			    fn dir_path(&self) -> Path 
dirent			        pub mod dirent 
dirent_t			            pub enum dirent_t {}
dirname			    fn dirname<'a>(&'a self) -> &'a [u8];
dirname			    fn dirname<'a>(&'a self) -> &'a [u8] 
dirname			    fn dirname<'a>(&'a self) -> &'a [u8] 
dirname_str			    fn dirname_str<'a>(&'a self) -> Option<&'a str> 
dirname_str			    fn dirname_str<'a>(&'a self) -> Option<&'a str> 
discard_doesnt_unborrow			    fn discard_doesnt_unborrow() 
disconnect			    pub fn disconnect(self) -> UdpSocket 
display			    fn display<'a>(&'a self) -> Display<'a, Self> 
div			    fn div(&self, other: &f32) -> f32 { *self \/ *other }
div			    fn div(&self, other: &f64) -> f64 { *self \/ *other }
div			    fn div(&self, other: &$T) -> $T { *self \/ *other }
div			    fn div(&self, other: &$T) -> $T { *self \/ *other }
div			    fn div(&self, rhs: &RHS) -> Result;
div_rem			pub fn div_rem<T: Div<T, T> + Rem<T, T>>(x: T, y: T) -> (T, T) 
dl			pub mod dl 
dladdr			            fn dladdr(addr: *libc::c_void,
dlclose			        fn dlclose(handle: *libc::c_void) -> libc::c_int;
dlerror			        fn dlerror() -> *libc::c_char;
dll_filename			pub fn dll_filename(base: &str) -> ~str 
dlopen			        fn dlopen(filename: *libc::c_char, flag: libc::c_int) -> *libc::c_void;
dlsym			        fn dlsym(handle: *libc::c_void, symbol: *libc::c_char) -> *libc::c_void;
do_inspect			    fn do_inspect(&self, elt: Option<A>) -> Option<A> 
do_map			    fn do_map(&self, elt: Option<A>) -> Option<B> 
do_send			    fn do_send(&mut self, t: Message<T>) -> UpgradeResult 
do_some_fallible_work			    fn do_some_fallible_work() {}
dont_accept_simultaneously			    fn dont_accept_simultaneously(&mut self) -> IoResult<()>;
dont_loop_multicast_locally			    fn dont_loop_multicast_locally(&mut self) -> IoResult<()>;
double_borrow_single_release_no_borrow_mut			    fn double_borrow_single_release_no_borrow_mut() 
double_imm_borrow			    fn double_imm_borrow() 
downgrade			    pub fn downgrade(&self) -> Weak<T> 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			        fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			pub fn drop<T>(_x: T) { }
drop			        fn drop(&mut self) 
drop			    fn drop(&mut self);
drop			           fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			        fn drop(&mut self) { (self.SymCleanup)(self.handle); }
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			            fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop_chan			    pub fn drop_chan(&mut self) 
drop_chan			    pub fn drop_chan(&mut self) 
drop_chan			    pub fn drop_chan(&mut self) 
drop_chan			    pub fn drop_chan(&self) 
drop_full			    fn drop_full() 
drop_port			    pub fn drop_port(&mut self) 
drop_port			    pub fn drop_port(&mut self) 
drop_port			    pub fn drop_port(&mut self) 
drop_port			    pub fn drop_port(&self) 
dumb_println			pub fn dumb_println(args: &fmt::Arguments) 
dup			                pub fn dup(fd: c_int) -> c_int;
dup2			                pub fn dup2(src: c_int, dst: c_int) -> c_int;
dynamic_lib			pub mod dynamic_lib;
e			    fn e() -> f32 { 2.71828182845904523536028747135266250 }
e			    fn e() -> f64 { 2.71828182845904523536028747135266250 }
e			    fn e() -> Self;
eabi			pub mod eabi 
each_live_alloc			unsafe fn each_live_alloc(read_next_before: bool,
empty			    pub fn empty() -> AtomicOption<T> { AtomicOption { p: Unsafe::new(0) } }
encode_utf8			    fn encode_utf8(&self, dst: &mut [u8]) -> uint;
encode_utf8			    fn encode_utf8<'a>(&self, dst: &'a mut [u8]) -> uint 
ends_with			    fn ends_with(&self, needle: &[T]) -> bool 
ends_with			    fn ends_with(&self, needle: &[T]) -> bool;
ends_with			    fn ends_with(&self, needle: &str) -> bool 
ends_with			    fn ends_with(&self, needle: &str) -> bool;
ends_with_diff_one_element_at_beginning			    fn ends_with_diff_one_element_at_beginning(bh: &mut BenchHarness) 
ends_with_path			    fn ends_with_path(&self, child: &Self) -> bool;
ends_with_path			    fn ends_with_path(&self, child: &Path) -> bool 
ends_with_path			    fn ends_with_path(&self, child: &Path) -> bool 
ends_with_path_home_dir			    fn ends_with_path_home_dir(bh: &mut BenchHarness) 
ends_with_path_missmatch_jome_home			    fn ends_with_path_missmatch_jome_home(bh: &mut BenchHarness) 
ends_with_same_vector			    fn ends_with_same_vector(bh: &mut BenchHarness) 
ends_with_single_element			    fn ends_with_single_element(bh: &mut BenchHarness) 
enqueue			    fn enqueue(&mut self, lock: &NativeMutex) 
enqueue			    fn enqueue(&mut self, t: T) 
enumerate			    fn enumerate(self) -> Enumerate<Self> 
env			pub fn env() -> ~[(~str,~str)] 
env			pub mod env;
env_as_bytes			pub fn env_as_bytes() -> ~[(~[u8],~[u8])] 
env_convert			        fn env_convert(input: ~[~[u8]]) -> ~[(~[u8], ~[u8])] 
eof			    pub fn eof(&self) -> bool 
eof			    pub fn eof(&self) -> bool { self.pos >= self.buf.len() }
epsilon			    fn epsilon() -> f32 { 1.19209290e-07 }
epsilon			    fn epsilon() -> f64 { 2.2204460492503131e-16 }
epsilon			    fn epsilon() -> Self;
eq			    fn eq(&self, other: &bool) -> bool { (*self) == (*other) }
eq			    fn eq(&self, other: &CString) -> bool 
eq			    fn eq(&self, other: &Cell<T>) -> bool 
eq			    fn eq(&self, other: &RefCell<T>) -> bool 
eq			    fn eq(&self, other: &char) -> bool { (*self) == (*other) }
eq			    fn eq(&self, other: &Self) -> bool;
eq			            fn eq(&self, _: &Foo) -> bool 
eq			    pub fn eq<A: Eq, T: Iterator<A>>(mut a: T, mut b: T) -> bool 
eq			    fn eq(&self, other: &@T) -> bool { *(*self) == *(*other) }
eq			    fn eq(&self, other: &f32) -> bool { (*self) == (*other) }
eq			    fn eq(&self, other: &f64) -> bool { (*self) == (*other) }
eq			    fn eq(&self, other: &$T) -> bool { return (*self) == (*other); }
eq			    fn eq(&self, other: &$T) -> bool { return (*self) == (*other); }
eq			    fn eq(&self, other: &~T) -> bool { *(*self) == *(*other) }
eq			    fn eq(&self, other: &Path) -> bool 
eq			    fn eq(&self, other: &Path) -> bool 
eq			                fn eq(&self, other: &extern "C" fn($($p),*) -> _R) -> bool 
eq			        fn eq(&self, other: &extern "C" fn() -> _R) -> bool 
eq			    fn eq(&self, other: &*T) -> bool 
eq			    fn eq(&self, other: &*mut T) -> bool 
eq			    fn eq(&self, other: &Rc<T>) -> bool { **self == **other }
eq			    fn eq(&self, other: & &'a T) -> bool 
eq			        fn eq(&self, other: & &'a [T]) -> bool 
eq			        fn eq(&self, other: &~[T]) -> bool { self.as_slice() == *other }
eq			        fn eq(&self, other: & &'a str) -> bool 
eq			        fn eq(&self, other: &~str) -> bool 
eq			    fn eq(&self, other: &MaybeOwned) -> bool 
eq			pub fn eq(a: &~str, b: &~str) -> bool 
eq			                fn eq(&self, other: &($($T,)+)) -> bool 
eq			    fn eq(&self, _other: &()) -> bool { true }
eq			    fn eq(&self, other: &Vec<T>) -> bool 
eq_ignore_ascii_case			    fn eq_ignore_ascii_case(&self, other: &str) -> bool 
eq_ignore_ascii_case			    fn eq_ignore_ascii_case(&self, other: &str) -> bool;
eq_ignore_case			    fn eq_ignore_case(self, other: &[Ascii]) -> bool 
eq_ignore_case			    fn eq_ignore_case(self, other: &[Ascii]) -> bool;
eq_ignore_case			    pub fn eq_ignore_case(self, other: Ascii) -> bool 
eq_slice			pub fn eq_slice(a: &str, b: &str) -> bool 
eq_slice_			fn eq_slice_(a: &str, b: &str) -> bool 
equals			    pub fn equals<A: TotalEq, T: Iterator<A>>(mut a: T, mut b: T) -> bool 
equiv			    fn equiv(&self, other: &T) -> bool;
equiv			    fn equiv(&self, other: &*T) -> bool 
equiv			    fn equiv(&self, other: &*mut T) -> bool 
equiv			        fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }
equiv			        fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }
equiv			    fn equiv(&self, other: &S) -> bool 
equiv_prefix			    fn equiv_prefix(&self, other: &Path) -> bool 
erf			        pub fn erf(n: c_double) -> c_double;
erfc			        pub fn erfc(n: c_double) -> c_double;
erfcf			        pub fn erfcf(n: c_float) -> c_float;
erff			        pub fn erff(n: c_float) -> c_float;
err			    fn err(&mut self, msg: &str) 
err			    pub fn err(self) -> Option<E> 
errno			pub fn errno() -> int 
errno			pub fn errno() -> uint 
errno_location			    fn errno_location() -> *c_int 
error_cb			        extern fn error_cb(_data: *mut libc::c_void, _msg: *libc::c_char,
error_string			pub fn error_string(errnum: uint) -> ~str 
escape			    fn escape(&mut self) -> char 
escape_default			    fn escape_default(&self, f: |char|) { escape_default(*self, f) }
escape_default			    fn escape_default(&self, f: |char|);
escape_default			pub fn escape_default(c: char, f: |char|) 
escape_default			    fn escape_default(&self) -> ~str 
escape_default			    fn escape_default(&self) -> ~str;
escape_unicode			    fn escape_unicode(&self, f: |char|) { escape_unicode(*self, f) }
escape_unicode			    fn escape_unicode(&self, f: |char|);
escape_unicode			pub fn escape_unicode(c: char, f: |char|) 
escape_unicode			    fn escape_unicode(&self) -> ~str 
escape_unicode			    fn escape_unicode(&self) -> ~str;
exact_test			    fn exact_test<T>(t: &T, e:&str) 
exception_cleanup			            extern "C" fn exception_cleanup(_unwind_code: uw::_Unwind_Reason_Code,
exchange_free			pub unsafe fn exchange_free(ptr: *u8) 
exchange_free_			pub unsafe fn exchange_free_(ptr: *u8) 
exchange_malloc			pub unsafe fn exchange_malloc(size: uint) -> *u8 
exclusive_new_arc			    fn exclusive_new_arc() 
exclusive_new_poison			    fn exclusive_new_poison() 
execute			    fn execute(&mut self, method: &rt::Method, arg: Argument) -> Result 
execv			                pub fn execv(prog: *c_char, argv: **c_char) -> c_int;
execv			                pub fn execv(prog: *c_char, argv: **c_char) -> intptr_t;
execve			                pub fn execve(prog: *c_char, argv: **c_char, envp: **c_char)
execvp			                pub fn execvp(c: *c_char, argv: **c_char) -> c_int;
execvpe			                pub fn execvpe(c: *c_char, argv: **c_char, envp: **c_char)
exists			    pub fn exists(&self) -> bool 
exists			    fn exists(_: Option<Task>) -> bool { local_ptr::exists() }
exists			    fn exists(unused_value: Option<Self>) -> bool;
exists			    pub fn exists() -> bool 
exit			                pub fn exit(status: c_int) -> !;
exp			    fn exp(&self) -> f32 { exp(*self) }
exp			    fn exp(n: f32) -> f32 = intrinsics::expf32,
exp			    fn exp(&self) -> f64 { exp(*self) }
exp			    fn exp(n: f64) -> f64 = intrinsics::expf64,
exp			    fn exp(&self) -> Self;
exp2			    fn exp2(&self) -> f32 { exp2(*self) }
exp2			    fn exp2(n: f32) -> f32 = intrinsics::exp2f32,
exp2			    fn exp2(&self) -> f64 { exp2(*self) }
exp2			    fn exp2(n: f64) -> f64 = intrinsics::exp2f64,
exp2			    fn exp2(&self) -> Self;
exp2f32			    pub fn exp2f32(x: f32) -> f32;
exp2f64			    pub fn exp2f64(x: f64) -> f64;
exp_m1			    fn exp_m1(&self) -> f32 { exp_m1(*self) }
exp_m1			    fn exp_m1(n: c_float) -> c_float = cmath::expm1f,
exp_m1			    fn exp_m1(&self) -> f64 { exp_m1(*self) }
exp_m1			    fn exp_m1(n: c_double) -> c_double = cmath::expm1,
exp_m1			    fn exp_m1(&self) -> Self;
expect			    pub fn expect<M: Any + Send>(self, msg: M) -> T 
expf32			    pub fn expf32(x: f32) -> f32;
expf64			    pub fn expf64(x: f64) -> f64;
expm1			        pub fn expm1(n: c_double) -> c_double;
expm1f			        pub fn expm1f(n: c_float) -> c_float;
extend			    fn extend<T: Iterator<A>>(&mut self, iterator: T);
extend			    fn extend<T: Iterator<A>>(&mut self, mut iterator: T) 
extend			    fn extend<T: Iterator<char>>(&mut self, mut iterator: T) 
extend			    fn extend<I: Iterator<T>>(&mut self, mut iterator: I) 
extend_sign			fn extend_sign(val: u64, nbytes: uint) -> i64 
extension			    fn extension<'a>(&'a self) -> Option<&'a [u8]> 
extension_str			    fn extension_str<'a>(&'a self) -> Option<&'a str> 
extension_str			    fn extension_str<'a>(&'a self) -> Option<&'a str> 
extensions			pub mod extensions;
externfnpointers			mod externfnpointers 
extra			            pub mod extra 
extra			            pub mod extra {}
extra			        pub mod extra 
extra			    pub mod extra 
f			            fn f() $b
f			            fn f() $b
f			        fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }
f			    fn f(i: int, tx: Sender<()>) 
f32x4			pub struct f32x4(f32, f32, f32, f32);
f64			    mod f64 
f64x2			pub struct f64x2(f64, f64);
fabsf32			    pub fn fabsf32(x: f32) -> f32;
fabsf64			    pub fn fabsf64(x: f64) -> f64;
fail_			pub fn fail_(expr: *u8, file: *u8, line: uint) -> ! 
fail_bounds_check			pub fn fail_bounds_check(file: *u8, line: uint, index: uint, len: uint) -> ! 
failing			pub fn failing() -> bool 
fchmod			                pub fn fchmod(fd: c_int, mode: mode_t) -> c_int;
fclose			                pub fn fclose(file: *FILE) -> c_int;
fcntl			                pub fn fcntl(fd: c_int, cmd: c_int, ...) -> c_int;
fcntl			        pub mod fcntl 
fdatasync			                pub fn fdatasync(fd: c_int) -> c_int;
fdim			        pub fn fdim(a: c_double, b: c_double) -> c_double;
fdimf			        pub fn fdimf(a: c_float, b: c_float) -> c_float;
fdopen			                pub fn fdopen(fd: c_int, mode: *c_char) -> *FILE;
fence			pub fn fence(order: Ordering) 
feof			                pub fn feof(stream: *FILE) -> c_int;
ferror			                pub fn ferror(stream: *FILE) -> c_int;
fetch_add			    pub fn fetch_add(&self, val: int, order: Ordering) -> int 
fetch_add			    pub fn fetch_add(&self, val: uint, order: Ordering) -> uint 
fetch_and			    pub fn fetch_and(&self, val: bool, order: Ordering) -> bool 
fetch_nand			    pub fn fetch_nand(&self, val: bool, order: Ordering) -> bool 
fetch_or			    pub fn fetch_or(&self, val: bool, order: Ordering) -> bool 
fetch_sub			    pub fn fetch_sub(&self, val: int, order: Ordering) -> int 
fetch_sub			    pub fn fetch_sub(&self, val: uint, order: Ordering) -> uint 
fetch_xor			    pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool 
fflush			                pub fn fflush(file: *FILE) -> c_int;
fgetc			                pub fn fgetc(stream: *FILE) -> c_int;
fgetpos			                pub fn fgetpos(stream: *FILE, ptr: *fpos_t) -> c_int;
fgets			                pub fn fgets(buf: *mut c_char, n: c_int, stream: *FILE)
file_product			fn file_product(p: &Path) -> IoResult<u32> 
filename			    fn filename<'a>(&'a self) -> Option<&'a [u8]>;
filename			    fn filename<'a>(&'a self) -> Option<&'a [u8]> 
filename			    fn filename<'a>(&'a self) -> Option<&'a [u8]> 
filename_display			    fn filename_display<'a>(&'a self) -> Display<'a, Self> 
filename_str			    fn filename_str<'a>(&'a self) -> Option<&'a str> 
filename_str			    fn filename_str<'a>(&'a self) -> Option<&'a str> 
fileno			                pub fn fileno(stream: *FILE) -> c_int;
filestem			    fn filestem<'a>(&'a self) -> Option<&'a [u8]> 
filestem_str			    fn filestem_str<'a>(&'a self) -> Option<&'a str> 
filestem_str			    fn filestem_str<'a>(&'a self) -> Option<&'a str> 
fill			    fn fill(&mut self, buf: &mut [u8]) -> IoResult<()> 
fill			    pub fn fill(&self, val: ~T, order: Ordering) -> Option<~T> 
fill_buf			    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> { self.inner.fill_buf() }
fill_buf			    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> 
fill_buf			    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> 
fill_buf			    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]>;
fill_utf16_buf_and_decode			    pub fn fill_utf16_buf_and_decode(f: |*mut u16, DWORD| -> DWORD)
filter			    fn filter<'r>(self, predicate: 'r |&A| -> bool) -> Filter<'r, A, Self> 
filter_map			    fn filter_map<'r, B>(self, f: 'r |A| -> Option<B>) -> FilterMap<'r, A, B, Self> 
filtered			    pub fn filtered(self, f: |t: &T| -> bool) -> Option<T> 
finally			    fn finally(&self, dtor: ||) -> T 
finally			    fn finally(&self, dtor: ||) -> T;
finally			pub mod finally;
find			    fn find<'a>(&'a self, key: &K) -> Option<&'a V>;
find			    fn find(&mut self, predicate: |&A| -> bool) -> Option<A> 
find			    fn find<C: CharEq>(&self, search: C) -> Option<uint> 
find			    fn find<C: CharEq>(&self, search: C) -> Option<uint>;
find_mut			    fn find_mut<'a>(&'a mut self, key: &K) -> Option<&'a mut V>;
find_str			    fn find_str(&self, &str) -> Option<uint>;
find_str			    fn find_str(&self, needle: &str) -> Option<uint> 
fire			    fn fire(&mut self);
first_non_utf8_index			fn first_non_utf8_index(v: &[u8]) -> Option<uint> 
flat_map			    fn flat_map<'r, B, U: Iterator<B>>(self, f: 'r |A| -> U)
float_to_str			        fn float_to_str(bh: &mut BenchHarness) 
float_to_str_bytes_common			pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+Round+
float_to_str_common			pub fn float_to_str_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Float+Round+
floor			    fn floor(&self) -> f32 { floor(*self) }
floor			    fn floor(x: f32) -> f32 = intrinsics::floorf32,
floor			    fn floor(&self) -> f64 { floor(*self) }
floor			    fn floor(x: f64) -> f64 = intrinsics::floorf64,
floor			    fn floor(&self) -> Self;
floorf32			    pub fn floorf32(x: f32) -> f32;
floorf64			    pub fn floorf64(x: f64) -> f64;
flush			    fn flush(&mut self) -> IoResult<()> { self.inner.flush() }
flush			    fn flush(&mut self) -> IoResult<()> 
flush			    fn flush(&mut self) { fail!() }
flush			    fn flush(&mut self) -> IoResult<()> { Ok(()) }
flush			    fn flush(&mut self) -> IoResult<()> { self.flush() }
flush			    fn flush(&mut self) -> IoResult<()> { self.inner.flush() }
flush			    fn flush(&mut self) -> IoResult<()> 
flush			pub fn flush() 
flush			            fn flush(&mut self) -> io::IoResult<()> 
flush			    fn flush(&mut self) -> io::IoResult<()> 
flush_buf			    fn flush_buf(&mut self) -> IoResult<()> 
fmaf32			    pub fn fmaf32(a: f32, b: f32, c: f32) -> f32;
fmaf64			    pub fn fmaf64(a: f64, b: f64, c: f64) -> f64;
fmax			        pub fn fmax(a: c_double, b: c_double) -> c_double;
fmaxf			        pub fn fmaxf(a: c_float, b: c_float) -> c_float;
fmin			        pub fn fmin(a: c_double, b: c_double) -> c_double;
fminf			        pub fn fminf(a: c_float, b: c_float) -> c_float;
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			impl fmt::Show for ~Any 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			        fn fmt(&self, f: &mut Formatter) -> Result 
fmt			        fn fmt(&self, fmt: &mut Formatter) -> Result 
fmt			    fn fmt(&self, &mut Formatter) -> Result;
fmt			    fn fmt(&self, f: &mut Formatter) -> Result { secret_pointer(self, f) }
fmt			    fn fmt(&self, f: &mut Formatter) -> Result { secret_show(&**self, f) }
fmt			    fn fmt(&self, f: &mut Formatter) -> Result { secret_show(*self, f) }
fmt			    fn fmt(&self, f: &mut Formatter) -> Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			fn fmt(&self, f: &mut std::fmt::Formatter) -> fmt::Result;
fmt			impl fmt::Binary for Vector2D 
fmt			impl fmt::Show for Vector2D 
fmt			            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			        impl fmt::$Trait for $T 
fmt			        impl fmt::Show for RadixFmt<$T, Radix> 
fmt			    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result 
fmt			impl fmt::Show for IoError 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result 
fmt			impl fmt::Show for IpAddr 
fmt			impl fmt::Show for SocketAddr 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			impl fmt::Show for ProcessExit 
fmt			pub mod fmt;
fmt			    fn fmt(&self, out: &mut fmt::Formatter) -> fmt::Result 
fmt			impl fmt::Show for MapError 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			impl fmt::Show for () 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt_int			    fn fmt_int<T: Int>(&self, mut x: T, f: &mut fmt::Formatter) -> fmt::Result 
fmtdflt			    fn fmtdflt() -> FormatSpec<'static> 
fold			    fn fold<B>(&mut self, init: B, f: |B, A| -> B) -> B 
fold			pub fn fold<T,
fold_			pub fn fold_<T,E,Iter:Iterator<Result<T,E>>>(iterator: Iter) -> Result<(),E> 
foo			        fn foo(f: |c: &CString|) 
fopen			                pub fn fopen(filename: *c_char, mode: *c_char) -> *FILE;
forget			pub unsafe fn forget<T>(thing: T) { intrinsics::forget(thing); }
forget			    pub fn forget<T>(_: T) -> ();
fork			                pub fn fork() -> pid_t;
format			pub fn format(args: &Arguments) -> ~str 
format			    fn format(&mut self) -> FormatSpec<'a> 
format_align_fill			    fn format_align_fill() 
format_base_36			        fn format_base_36(bh: &mut BenchHarness) 
format_bin			        fn format_bin(bh: &mut BenchHarness) 
format_counts			    fn format_counts() 
format_dec			        fn format_dec(bh: &mut BenchHarness) 
format_flags			    fn format_flags() 
format_hex			        fn format_hex(bh: &mut BenchHarness) 
format_mixture			    fn format_mixture() 
format_nothing			    fn format_nothing() 
format_oct			        fn format_oct(bh: &mut BenchHarness) 
format_position			    fn format_position() 
format_position_nothing_else			    fn format_position_nothing_else() 
format_type			    fn format_type() 
format_unsafe			pub unsafe fn format_unsafe(fmt: &[rt::Piece], args: &[Argument]) -> ~str 
fpathconf			                pub fn fpathconf(filedes: c_int, name: c_int) -> c_long;
fpos_t			            pub enum fpos_t {}
fputc			                pub fn fputc(c: c_int, stream: *FILE) -> c_int;
fputs			                pub fn fputs(s: *c_char, stream: *FILE) -> *c_char;
frac_1_pi			    fn frac_1_pi() -> f32 { 0.318309886183790671537767526745028724 }
frac_1_pi			    fn frac_1_pi() -> f64 { 0.318309886183790671537767526745028724 }
frac_1_pi			    fn frac_1_pi() -> Self;
frac_1_sqrt2			    fn frac_1_sqrt2() -> f32 { 0.707106781186547524400844362104849039 }
frac_1_sqrt2			    fn frac_1_sqrt2() -> f64 { 0.707106781186547524400844362104849039 }
frac_1_sqrt2			    fn frac_1_sqrt2() -> Self;
frac_2_pi			    fn frac_2_pi() -> f32 { 0.636619772367581343075535053490057448 }
frac_2_pi			    fn frac_2_pi() -> f64 { 0.636619772367581343075535053490057448 }
frac_2_pi			    fn frac_2_pi() -> Self;
frac_2_sqrtpi			    fn frac_2_sqrtpi() -> f32 { 1.12837916709551257389615890312154517 }
frac_2_sqrtpi			    fn frac_2_sqrtpi() -> f64 { 1.12837916709551257389615890312154517 }
frac_2_sqrtpi			    fn frac_2_sqrtpi() -> Self;
frac_pi_2			    fn frac_pi_2() -> f32 { 1.57079632679489661923132169163975144 }
frac_pi_2			    fn frac_pi_2() -> f64 { 1.57079632679489661923132169163975144 }
frac_pi_2			    fn frac_pi_2() -> Self;
frac_pi_3			    fn frac_pi_3() -> f32 { 1.04719755119659774615421446109316763 }
frac_pi_3			    fn frac_pi_3() -> f64 { 1.04719755119659774615421446109316763 }
frac_pi_3			    fn frac_pi_3() -> Self;
frac_pi_4			    fn frac_pi_4() -> f32 { 0.785398163397448309615660845819875721 }
frac_pi_4			    fn frac_pi_4() -> f64 { 0.785398163397448309615660845819875721 }
frac_pi_4			    fn frac_pi_4() -> Self;
frac_pi_6			    fn frac_pi_6() -> f32 { 0.52359877559829887307710723054658381 }
frac_pi_6			    fn frac_pi_6() -> f64 { 0.52359877559829887307710723054658381 }
frac_pi_6			    fn frac_pi_6() -> Self;
frac_pi_8			    fn frac_pi_8() -> f32 { 0.39269908169872415480783042290993786 }
frac_pi_8			    fn frac_pi_8() -> f64 { 0.39269908169872415480783042290993786 }
frac_pi_8			    fn frac_pi_8() -> Self;
fract			    fn fract(&self) -> f32 { *self - self.trunc() }
fract			    fn fract(&self) -> f64 { *self - self.trunc() }
fract			    fn fract(&self) -> Self;
fractional_part			        fn fractional_part(&self) -> $t { self.fract() }
fractional_part			    fn fractional_part(&self) -> Self;
fread			                pub fn fread(ptr: *mut c_void,
free			                pub fn free(p: *mut c_void);
free			    fn free(&mut self, alloc: *mut Box) 
free			    pub fn free(&mut self, alloc: *mut Box) 
free			    fn free(&mut self, buf: ~Buffer<T>) 
free_cond			    pub unsafe fn free_cond(h: uint) 
free_lock			    pub unsafe fn free_lock(h: uint) 
freebsd			    pub mod freebsd 
freopen			                pub fn freopen(filename: *c_char, mode: *c_char, file: *FILE)
frexp			    fn frexp(&self) -> (f32, int) 
frexp			    fn frexp(n: c_float, value: &mut c_int) -> c_float = cmath::frexpf,
frexp			        pub fn frexp(n: c_double, value: &mut c_int) -> c_double;
frexp			    fn frexp(&self) -> (f64, int) 
frexp			    fn frexp(n: c_double, value: &mut c_int) -> c_double = cmath::frexp,
frexp			    fn frexp(&self) -> (Self, int);
frexpf			        pub fn frexpf(n: c_float, value: &mut c_int) -> c_float;
from			            fn from<N: ToPrimitive>(n: N) -> Option<$T> 
from			    fn from<T: ToPrimitive>(n: T) -> Option<Self>;
from			    fn from(a_box: *mut Box) -> *mut AllocHeader 
from_buf			pub unsafe fn from_buf<T>(ptr: *T, elts: uint) -> ~[T] 
from_buf_len			    pub unsafe fn from_buf_len(buf: *u8, len: uint) -> ~str 
from_buf_raw			    pub unsafe fn from_buf_raw<T>(ptr: *T, elts: uint) -> ~[T] 
from_byte			    pub unsafe fn from_byte(u: u8) -> ~str { from_utf8_owned(~[u]) }
from_byte			pub fn from_byte(b: u8) -> ~str 
from_c_multistring			pub unsafe fn from_c_multistring(buf: *libc::c_char,
from_c_str			    pub unsafe fn from_c_str(buf: *libc::c_char) -> ~str 
from_char			pub fn from_char(ch: char) -> ~str 
from_chars			pub fn from_chars(chs: &[char]) -> ~str 
from_digit			    fn from_digit(num: uint, radix: uint) -> Option<char> { from_digit(num, radix) }
from_digit			    fn from_digit(num: uint, radix: uint) -> Option<char>;
from_digit			pub fn from_digit(num: uint, radix: uint) -> Option<char> 
from_elem			pub fn from_elem<T:Clone>(n_elts: uint, t: T) -> ~[T] 
from_elem			    pub fn from_elem(length: uint, value: T) -> Vec<T> 
from_errno			    pub fn from_errno(errno: uint, detail: bool) -> IoError 
from_f32			    fn from_f32(n: f32) -> Option<Self> 
from_f32			pub fn from_f32<A: FromPrimitive>(n: f32) -> Option<A> 
from_f64			    fn from_f64(n: f64) -> Option<Self> 
from_f64			pub fn from_f64<A: FromPrimitive>(n: f64) -> Option<A> 
from_fn			pub fn from_fn<T>(n_elts: uint, op: |uint| -> T) -> ~[T] 
from_fn			    pub fn from_fn(length: uint, op: |uint| -> T) -> Vec<T> 
from_i16			    fn from_i16(n: i16) -> Option<Self> 
from_i16			pub fn from_i16<A: FromPrimitive>(n: i16) -> Option<A> 
from_i32			    fn from_i32(n: i32) -> Option<Self> 
from_i32			pub fn from_i32<A: FromPrimitive>(n: i32) -> Option<A> 
from_i64			        fn from_i64(n: i64) -> Option<Value> { Some(Value { x: n as int }) }
from_i64			    fn from_i64(n: i64) -> Option<Self>;
from_i64			pub fn from_i64<A: FromPrimitive>(n: i64) -> Option<A> 
from_i8			    fn from_i8(n: i8) -> Option<Self> 
from_i8			pub fn from_i8<A: FromPrimitive>(n: i8) -> Option<A> 
from_int			    fn from_int(n: int) -> Option<Self> 
from_int			pub fn from_int<A: FromPrimitive>(n: int) -> Option<A> 
from_iter			    fn from_iter<T: Iterator<A>>(iterator: T) -> Self;
from_iter			    fn from_iter<T: Iterator<A>>(mut iterator: T) -> ~[A] 
from_iter			    fn from_iter<T: Iterator<char>>(iterator: T) -> ~str 
from_iter			    fn from_iter<I:Iterator<T>>(mut iterator: I) -> Vec<T> 
from_raw_parts			    pub unsafe fn from_raw_parts(length: uint, capacity: uint, ptr: *mut T) -> Vec<T> 
from_slice			    pub fn from_slice(values: &[T]) -> Vec<T> 
from_str			    fn from_str(s: &str) -> Option<bool> 
from_str			    fn from_str(s: &str) -> Option<Self>;
from_str			pub fn from_str<A: FromStr>(s: &str) -> Option<A> 
from_str			    fn from_str(s: &str) -> Option<IpAddr> 
from_str			    fn from_str(s: &str) -> Option<SocketAddr> 
from_str			pub mod from_str;
from_str			    fn from_str(val: &str) -> Option<f32> 
from_str			    fn from_str(val: &str) -> Option<f64> 
from_str			    fn from_str(s: &str) -> Option<$T> 
from_str			    fn from_str(s: &str) -> Option<$T> 
from_str			    fn from_str(s: &str) -> Option<Path> 
from_str			    fn from_str(s: &str) -> Option<Path> 
from_str			    fn from_str(s: &str) -> Option<~str> { Some(s.to_owned()) }
from_str_bytes_common			pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Div<T,T>+
from_str_common			pub fn from_str_common<T:NumCast+Zero+One+Eq+Ord+Div<T,T>+Mul<T,T>+
from_str_hex			pub fn from_str_hex(num: &str) -> Option<f32> 
from_str_hex			pub fn from_str_hex(num: &str) -> Option<f64> 
from_str_ignore_underscores			    fn from_str_ignore_underscores() 
from_str_issue5770			    fn from_str_issue5770() 
from_str_issue7588			    fn from_str_issue7588() 
from_str_radix			    fn from_str_radix(val: &str, rdx: uint) -> Option<f32> 
from_str_radix			    fn from_str_radix(val: &str, rdx: uint) -> Option<f64> 
from_str_radix			    fn from_str_radix(s: &str, radix: uint) -> Option<$T> 
from_str_radix			    fn from_str_radix(str: &str, radix: uint) -> Option<Self>;
from_str_radix			pub fn from_str_radix<T: FromStrRadix>(str: &str, radix: uint) -> Option<T> 
from_str_radix			    fn from_str_radix(s: &str, radix: uint) -> Option<$T> 
from_u16			    fn from_u16(n: u16) -> Option<Self> 
from_u16			pub fn from_u16<A: FromPrimitive>(n: u16) -> Option<A> 
from_u32			pub fn from_u32(i: u32) -> Option<char> 
from_u32			    fn from_u32(n: u32) -> Option<Self> 
from_u32			pub fn from_u32<A: FromPrimitive>(n: u32) -> Option<A> 
from_u64			        fn from_u64(n: u64) -> Option<Value> { Some(Value { x: n as int }) }
from_u64			    fn from_u64(n: u64) -> Option<Self>;
from_u64			pub fn from_u64<A: FromPrimitive>(n: u64) -> Option<A> 
from_u8			    fn from_u8(n: u8) -> Option<Self> 
from_u8			pub fn from_u8<A: FromPrimitive>(n: u8) -> Option<A> 
from_uint			    fn from_uint(n: uint) -> Option<Self> 
from_uint			pub fn from_uint<A: FromPrimitive>(n: uint) -> Option<A> 
from_utf16			pub fn from_utf16(v: &[u16]) -> Option<~str> 
from_utf16_lossy			pub fn from_utf16_lossy(v: &[u16]) -> ~str 
from_utf8			    pub unsafe fn from_utf8<'a>(v: &'a [u8]) -> &'a str 
from_utf8			pub fn from_utf8<'a>(v: &'a [u8]) -> Option<&'a str> 
from_utf8_lossy			pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> MaybeOwned<'a> 
from_utf8_lossy_100_ascii			    fn from_utf8_lossy_100_ascii(bh: &mut BenchHarness) 
from_utf8_lossy_100_invalid			    fn from_utf8_lossy_100_invalid(bh: &mut BenchHarness) 
from_utf8_lossy_100_multibyte			    fn from_utf8_lossy_100_multibyte(bh: &mut BenchHarness) 
from_utf8_lossy_invalid			    fn from_utf8_lossy_invalid(bh: &mut BenchHarness) 
from_utf8_owned			    pub unsafe fn from_utf8_owned(v: ~[u8]) -> ~str 
from_utf8_owned			pub fn from_utf8_owned(vv: ~[u8]) -> Option<~str> 
fs			pub mod fs;
fs_chmod			    fn fs_chmod(&mut self, path: &CString,
fs_chown			    fn fs_chown(&mut self, path: &CString, uid: int, gid: int) ->
fs_from_raw_fd			    fn fs_from_raw_fd(&mut self, fd: c_int, close: CloseBehavior)
fs_link			    fn fs_link(&mut self, src: &CString, dst: &CString) -> IoResult<()>;
fs_lstat			    fn fs_lstat(&mut self, path: &CString) -> IoResult<FileStat>;
fs_mkdir			    fn fs_mkdir(&mut self, path: &CString,
fs_open			    fn fs_open(&mut self, path: &CString, fm: FileMode, fa: FileAccess)
fs_readdir			    fn fs_readdir(&mut self, path: &CString, flags: c_int) ->
fs_readlink			    fn fs_readlink(&mut self, path: &CString) -> IoResult<Path>;
fs_rename			    fn fs_rename(&mut self, path: &CString, to: &CString) -> IoResult<()>;
fs_rmdir			    fn fs_rmdir(&mut self, path: &CString) -> IoResult<()>;
fs_stat			    fn fs_stat(&mut self, path: &CString) -> IoResult<FileStat>;
fs_symlink			    fn fs_symlink(&mut self, src: &CString, dst: &CString) -> IoResult<()>;
fs_unlink			    fn fs_unlink(&mut self, path: &CString) -> IoResult<()>;
fs_utime			    fn fs_utime(&mut self, src: &CString, atime: u64, mtime: u64) ->
fseek			                pub fn fseek(stream: *FILE, offset: c_long, whence: c_int)
fsetpos			                pub fn fsetpos(stream: *FILE, ptr: *fpos_t) -> c_int;
fstat			                pub fn fstat(fildes: c_int, buf: *mut stat) -> c_int;
fsync			    pub fn fsync(&mut self) -> IoResult<()> 
fsync			                pub fn fsync(fd: c_int) -> c_int;
fsync			    fn fsync(&mut self) -> IoResult<()>;
ftell			                pub fn ftell(stream: *FILE) -> c_long;
ftruncate			                pub fn ftruncate(fd: c_int, length: off_t) -> c_int;
funcs			pub mod funcs 
fuse			    fn fuse(self) -> Fuse<Self> 
future_result			    pub fn future_result(&mut self) -> Receiver<TaskResult> 
fwrite			                pub fn fwrite(ptr: *c_void,
g			        fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }
gc			pub mod gc;
gc_inside			    fn gc_inside() 
ge			    fn ge(&self, other: &Self) -> bool { !self.lt(other) }
ge			    pub fn ge<A: Ord, T: Iterator<A>>(mut a: T, mut b: T) -> bool 
ge			    fn ge(&self, other: &@T) -> bool { *(*self) >= *(*other) }
ge			    fn ge(&self, other: &f32) -> bool { (*self) >= (*other) }
ge			    fn ge(&self, other: &f64) -> bool { (*self) >= (*other) }
ge			    fn ge(&self, other: &~T) -> bool { *(*self) >= *(*other) }
ge			    fn ge(&self, other: &*T) -> bool 
ge			    fn ge(&self, other: &*mut T) -> bool 
ge			    fn ge(&self, other: &Rc<T>) -> bool { **self >= **other }
ge			    fn ge(&self, other: & &'a T) -> bool 
ge			        fn ge(&self, other: & &'a [T]) -> bool 
ge			        fn ge(&self, other: &~[T]) -> bool { self.as_slice() >= other.as_slice() }
ge			                fn ge(&self, other: &($($T,)+)) -> bool 
general_category			pub mod general_category 
get			    pub fn get<'a>(&'a self, ofs: uint) -> Option<&'a T> 
get			    pub fn get(&self) -> T 
get			pub fn get<T: 'static, U>(key: Key<T>, f: |Option<&T>| -> U) -> U 
get			    pub fn get<T>(&mut self, f: |&mut ReprVisitor, &T| -> bool) -> bool 
get			    pub fn get<'a>(&'a mut self) -> &'a mut T 
get			    pub fn get<'a>(&'a mut self) -> &'a mut IoFactory 
get			pub unsafe fn get(key: Key) -> *mut u8 
get			    fn get(&self, index: uint) -> Option<&'a T> 
get			    fn get(&self, index: uint) -> Option<&'a T>;
get			    pub fn get(&self) -> *mut T 
get			    unsafe fn get(&self, i: int) -> T 
get			    pub unsafe fn get(&self) -> *mut T { cast::transmute(&self.value) }
get			    pub fn get<'a>(&'a self, index: uint) -> &'a T 
get_box_size			pub fn get_box_size(body_size: uint, body_align: uint) -> uint 
get_end			    fn get_end(&mut self) -> Option<&'a str> 
get_env_pairs			        unsafe fn get_env_pairs() -> ~[~[u8]] 
get_err			        fn get_err(errno: i32) -> (IoErrorKind, &'static str) 
get_exit_status			pub fn get_exit_status() -> int 
get_global_ptr			    fn get_global_ptr() -> *mut Option<~~[~[u8]]> 
get_host_addresses			pub fn get_host_addresses(host: &str) -> IoResult<~[IpAddr]> 
get_host_addresses			    fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,
get_immut			    pub fn get_immut(&self) -> *T 
get_local_map			unsafe fn get_local_map() -> &mut Map 
get_mut			    pub fn get_mut<'a>(&'a mut self, ofs: uint) -> Option<&'a mut T> 
get_mut			pub fn get_mut<T: 'static, U>(key: Key<T>, f: |Option<&mut T>| -> U) -> U 
get_mut			    pub fn get_mut<'a>(&'a mut self, index: uint) -> &'a mut T 
get_mut_ref			    fn get_mut_ref<'a>(&'a mut self) -> &'a mut BufferedWriter<W> 
get_mut_ref			    pub fn get_mut_ref<'a>(&'a mut self) -> &'a mut T 
get_osfhandle			                pub fn get_osfhandle(fd: c_int) -> c_long;
get_ref			    pub fn get_ref<'a>(&'a self) -> &'a R { &self.inner }
get_ref			    pub fn get_ref<'a>(&'a self) -> &'a S 
get_ref			    pub fn get_ref<'a>(&'a self) -> &'a W { self.inner.get_ref() }
get_ref			    pub fn get_ref<'a>(&'a self) -> &'a [u8] { self.buf.as_slice() }
get_ref			    pub fn get_ref<'a>(&'a self) -> &'a T 
get_sp_limit			            fn get_sp_limit() -> *c_void;
get_sp_limit			pub unsafe fn get_sp_limit() -> uint 
get_tydesc			    pub fn get_tydesc<T>() -> *TyDesc;
get_type_id			    fn get_type_id(&self) -> TypeId 
get_type_id			    fn get_type_id(&self) -> TypeId;
get_winsize			    fn get_winsize(&mut self) -> IoResult<(int, int)>;
get_with			fn get_with<T:'static,
getcond			        unsafe fn getcond(&self) -> *mut c_void 
getcount			    fn getcount(&mut self, cnt: &rt::Count) -> Option<uint> 
getcwd			                pub fn getcwd(buf: *mut c_char, size: size_t) -> *c_char;
getcwd			pub fn getcwd() -> Path 
getdtablesize			            pub fn getdtablesize() -> c_int;
getegid			                pub fn getegid() -> gid_t;
getenv			                pub fn getenv(s: *c_char) -> *c_char;
getenv			pub fn getenv(n: &str) -> Option<~str> 
getenv_as_bytes			pub fn getenv_as_bytes(n: &str) -> Option<~[u8]> 
getenv_nonempty			    fn getenv_nonempty(v: &str) -> Option<Path> 
geteuid			                pub fn geteuid() -> uid_t;
getgid			                pub fn getgid() -> gid_t ;
getgroups			                pub fn getgroups(ngroups_max: c_int, groups: *mut gid_t)
getlock			        unsafe fn getlock(&self) -> *mut c_void 
getlogin			                pub fn getlogin() -> *c_char;
getopt			                pub fn getopt(argc: c_int, argv: **c_char, optstr: *c_char)
getpeername			            pub fn getpeername(socket: SOCKET, address: *mut sockaddr,
getpeername			            pub fn getpeername(socket: c_int, address: *mut sockaddr,
getpgrp			                pub fn getpgrp() -> pid_t;
getpid			                pub fn getpid() -> c_int;
getpid			                pub fn getpid() -> pid_t;
getppid			                pub fn getppid() -> pid_t;
getrlimit			        fn getrlimit(resource: libc::c_int, rlp: *mut rlimit) -> libc::c_int;
getsockname			            pub fn getsockname(socket: SOCKET, address: *mut sockaddr,
getsockname			            pub fn getsockname(socket: c_int, address: *mut sockaddr,
getuid			                pub fn getuid() -> uid_t;
glob			                pub fn glob(pattern: *c_char,
glob			        pub mod glob 
glob_t			                pub struct glob_t 
global_heap			pub mod global_heap;
globfree			                pub fn globfree(pglob: *mut glob_t);
granularity			    pub fn granularity() -> uint 
grow			    fn grow(&mut self, n: uint, initval: &T) 
grow			    fn grow(&mut self, n: uint, initval: &T);
grow			    pub fn grow(&mut self, n: uint, value: &T) 
grow_fn			    fn grow_fn(&mut self, n: uint, op: |uint| -> T) 
grow_fn			    fn grow_fn(&mut self, n: uint, op: |uint| -> T);
grow_set			    fn grow_set(&mut self, index: uint, initval: &T, val: T) 
grow_set			    fn grow_set(&mut self, index: uint, initval: &T, val: T);
grow_set			    pub fn grow_set(&mut self, index: uint, initval: &T, value: T) 
gt			    fn gt(&self, other: &Self) -> bool {  other.lt(self) }
gt			    pub fn gt<A: Ord, T: Iterator<A>>(mut a: T, mut b: T) -> bool 
gt			    fn gt(&self, other: &@T) -> bool { *(*self) > *(*other) }
gt			    fn gt(&self, other: &f32) -> bool { (*self) > (*other) }
gt			    fn gt(&self, other: &f64) -> bool { (*self) > (*other) }
gt			    fn gt(&self, other: &~T) -> bool { *(*self) > *(*other) }
gt			    fn gt(&self, other: &*T) -> bool 
gt			    fn gt(&self, other: &*mut T) -> bool 
gt			    fn gt(&self, other: &Rc<T>) -> bool { **self > **other }
gt			    fn gt(&self, other: & &'a T) -> bool 
gt			        fn gt(&self, other: & &'a [T]) -> bool 
gt			        fn gt(&self, other: &~[T]) -> bool { self.as_slice() > other.as_slice() }
gt			                fn gt(&self, other: &($($T,)+)) -> bool 
half_a_million_letter_X			        fn half_a_million_letter_X() -> ~str 
half_a_million_letter_a			        fn half_a_million_letter_a() -> ~str 
handle			    pub fn handle<'a, T: Send>(&'a self, rx: &'a Receiver<T>) -> Handle<'a, T> 
has_active_io			    fn has_active_io(&self) -> bool;
has_nonsemantic_trailing_slash			    fn has_nonsemantic_trailing_slash(&self) -> bool 
hash			                fn hash(&self, state: &mut S) 
hash			            fn hash(&self, state: &mut S) 
hash			        fn hash(&self, state: &mut u64) 
hash			        fn hash<T: Hash<MyWriter>>(&self, value: &T) -> u64 
hash			    fn hash(&self, state: &mut S) 
hash			    fn hash(&self, state: &mut S);
hash			    fn hash<T: Hash<S>>(&self, value: &T) -> u64;
hash			        fn hash(&self, state: &mut S) 
hash			    fn hash<T: Hash<SipState>>(&self, value: &T) -> u64 
hash			pub fn hash<T: Hash<SipState>>(value: &T) -> u64 
hash			pub mod hash;
hash			    fn hash(&self, state: &mut S) 
hash			    fn hash(&self, state: &mut S) 
hash			    fn hash(&self, hasher: &mut H) 
hash_with_keys			pub fn hash_with_keys<T: Hash<SipState>>(k0: u64, k1: u64, value: &T) -> u64 
head			    fn head(&self) -> Option<&'a T> 
head			    fn head(&self) -> Option<&'a T>;
heap_cycles			    fn heap_cycles() 
hear_broadcasts			    fn hear_broadcasts(&mut self) -> IoResult<()>;
hold_and_signal			    pub unsafe fn hold_and_signal(&self, f: |x: &mut T|) 
hold_and_wait			    pub unsafe fn hold_and_wait(&self, f: |x: &T| -> bool) 
homedir			    fn homedir() 
homedir			pub fn homedir() -> Option<Path> 
hypot			    fn hypot(&self, other: &f32) -> f32 { hypot(*self, *other) }
hypot			    fn hypot(x: c_float, y: c_float) -> c_float = cmath::hypotf,
hypot			        pub fn hypot(x: c_double, y: c_double) -> c_double;
hypot			    fn hypot(&self, other: &f64) -> f64 { hypot(*self, *other) }
hypot			    fn hypot(x: c_double, y: c_double) -> c_double = cmath::hypot,
hypot			    fn hypot(&self, other: &Self) -> Self;
hypotf			        pub fn hypotf(x: c_float, y: c_float) -> c_float;
i16_add_with_overflow			    pub fn i16_add_with_overflow(x: i16, y: i16) -> (i16, bool);
i16_mul_with_overflow			    pub fn i16_mul_with_overflow(x: i16, y: i16) -> (i16, bool);
i16_sub_with_overflow			    pub fn i16_sub_with_overflow(x: i16, y: i16) -> (i16, bool);
i16x8			pub struct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);
i32_add_with_overflow			    pub fn i32_add_with_overflow(x: i32, y: i32) -> (i32, bool);
i32_mul_with_overflow			    pub fn i32_mul_with_overflow(x: i32, y: i32) -> (i32, bool);
i32_sub_with_overflow			    pub fn i32_sub_with_overflow(x: i32, y: i32) -> (i32, bool);
i32x4			pub struct i32x4(i32, i32, i32, i32);
i64_add_with_overflow			    pub fn i64_add_with_overflow(x: i64, y: i64) -> (i64, bool);
i64_mul_with_overflow			    pub fn i64_mul_with_overflow(x: i64, y: i64) -> (i64, bool);
i64_sub_with_overflow			    pub fn i64_sub_with_overflow(x: i64, y: i64) -> (i64, bool);
i64x2			pub struct i64x2(i64, i64);
i8_add_with_overflow			    pub fn i8_add_with_overflow(x: i8, y: i8) -> (i8, bool);
i8_mul_with_overflow			    pub fn i8_mul_with_overflow(x: i8, y: i8) -> (i8, bool);
i8_sub_with_overflow			    pub fn i8_sub_with_overflow(x: i8, y: i8) -> (i8, bool);
i8x16			pub struct i8x16(i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8);
id			    pub fn id(&self) -> uint { self.id }
id			    pub fn id(&self) -> libc::pid_t { self.handle.id() }
id			    fn id(&self) -> libc::pid_t;
idx			    fn idx(&self, _: uint) -> Option<A> { Some(self.element.clone()) }
idx			    fn idx(&self, index: uint) -> Option<(A, B)> 
idx			    fn idx(&self, index: uint) -> Option<(uint, A)> 
idx			    fn idx(&self, index: uint) -> Option<A> 
idx			    fn idx(&self, index: uint) -> Option<A>;
idx			    fn idx(&self, index: uint) -> Option<B> 
idx			    fn idx(&self, index: uint) -> Option<&'a T> 
idx			    fn idx(&self, index: uint) -> Option<&'a [T]> 
ignore_broadcasts			    fn ignore_broadcasts(&mut self) -> IoResult<()>;
ilogb			        pub fn ilogb(n: c_double) -> c_int;
ilogbf			        pub fn ilogbf(n: c_float) -> c_int;
imm_release_borrow_mut			    fn imm_release_borrow_mut() 
imp			mod imp 
imp			mod imp 
imp			mod imp 
imp			mod imp 
in6_addr			                pub struct in6_addr 
in_addr			                pub struct in_addr 
inc_strong			    fn inc_strong(&self) { self.inner().strong.set(self.strong() + 1); }
inc_weak			    fn inc_weak(&self) { self.inner().weak.set(self.weak() + 1); }
incoming			    fn incoming<'r>(&'r mut self) -> IncomingConnections<'r, Self> 
increment			pub fn increment() 
index			    fn index(&self, index: &Index) -> Result;
indexable			    fn indexable(&self) -> uint { self.iter.indexable() }
indexable			    fn indexable(&self) -> uint { uint::MAX }
indexable			    fn indexable(&self) -> uint 
indexable			    fn indexable(&self) -> uint;
indexable			    fn indexable(&self) -> uint 
inf			        fn inf()      -> Option<$t> { Some( 1.0 \/ 0.0) }
inf			    fn inf()      -> Option<Self>;
infinity			    fn infinity() -> f32 { 1.0 \/ 0.0 }
infinity			    fn infinity() -> f64 { 1.0 \/ 0.0 }
infinity			    fn infinity() -> Self;
inherit_blocker			    pub fn inherit_blocker(&mut self, task: Option<BlockedTask>) 
init			    pub fn init<T>() -> T;
init			pub unsafe fn init<T>() -> T 
init			    pub unsafe fn init(_argc: int, _argv: **u8) 
init			    pub unsafe fn init(argc: int, argv: **u8) 
init			pub unsafe fn init(argc: int, argv: **u8) { imp::init(argc, argv) }
init			pub unsafe fn init(argc: int, argv: **u8) { realargs::init(argc, argv) }
init			pub fn init() 
init			pub fn init() 
init			    fn init(&mut self, _size: u32) {}
init			    fn init(&mut self, size: u32) 
init			    pub fn init() 
init			    pub fn init() {}
init			pub fn init(argc: int, argv: **u8) 
init			    fn init(&self) -> &'a [T] 
init			    fn init(&self) -> &'a [T];
init			    pub fn init<'a>(&'a self) -> &'a [T] 
init_cond			    pub unsafe fn init_cond() -> uint 
init_elem			    unsafe fn init_elem(self, i: uint, val: T) 
init_elem			    unsafe fn init_elem(self, i: uint, val: T);
init_frame			        pub fn init_frame(frame: &mut super::STACKFRAME64,
init_lock			    pub unsafe fn init_lock() -> uint 
init_state			        unsafe fn init_state() -> *mut backtrace_state 
initn			    fn initn(&self, n: uint) -> &'a [T] 
initn			    fn initn(&self, n: uint) -> &'a [T];
inner			    fn inner<'a>(&'a self) -> &'a RcBox<T> { unsafe { &(*self.ptr) } }
inner			    fn inner<'a>(&'a self) -> &'a RcBox<T>;
insert			    fn insert(&mut self, key: K, value: V) -> bool 
insert			    fn insert(&mut self, value: T) -> bool;
insert			    fn insert(&mut self, i: uint, x: T) 
insert			    fn insert(&mut self, i: uint, x:T);
insert			    fn insert(&mut self, position: uint, substring: &str) 
insert			    fn insert(&mut self, position: uint, substring: &str);
insert			    pub fn insert(&mut self, index: uint, element: T) 
insert_char			    fn insert_char(&mut self, position: uint, ch: char) 
insert_char			    fn insert_char(&mut self, position: uint, ch: char);
insertion_position			    fn insertion_position(map: &mut Map,
insertion_sort			fn insertion_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) 
inspect			    fn inspect<'r>(self, f: 'r |&A|) -> Inspect<'r, A, Self> 
int			    mod int 
int			    mod int 
int_to_str_bytes_common			pub fn int_to_str_bytes_common<T: Int>(num: T, radix: uint, sign: SignFormat, f: |u8|) 
integer			    fn integer(&mut self) -> Option<uint> 
integer_decode			    fn integer_decode(&self) -> (u64, i16, i8) 
integer_decode			    fn integer_decode(&self) -> (u64, i16, i8) 
integer_decode			    fn integer_decode(&self) -> (u64, i16, i8);
into_ascii			    fn into_ascii(self) -> ~[Ascii] 
into_ascii_lower			    fn into_ascii_lower(self) -> ~str 
into_ascii_lower			    fn into_ascii_lower(self) -> ~str;
into_ascii_nocheck			    unsafe fn into_ascii_nocheck(self) -> ~[Ascii] 
into_ascii_nocheck			    unsafe fn into_ascii_nocheck(self) -> ~[Ascii];
into_ascii_opt			    fn into_ascii_opt(self) -> Option<~[Ascii]> 
into_ascii_upper			    fn into_ascii_upper(self) -> ~str 
into_ascii_upper			    fn into_ascii_upper(self) -> ~str;
into_bytes			    fn into_bytes(self) -> ~[u8] 
into_bytes			    fn into_bytes(self) -> ~[u8];
into_bytes			    fn into_bytes(self) -> ~[u8] 
into_bytes			    fn into_bytes(self) -> ~[u8];
into_maybe_owned			    fn into_maybe_owned(self) -> MaybeOwned<'a> { Owned(self) }
into_maybe_owned			    fn into_maybe_owned(self) -> MaybeOwned<'a> { Slice(self) }
into_maybe_owned			    fn into_maybe_owned(self) -> MaybeOwned<'a> { self }
into_maybe_owned			    fn into_maybe_owned(self) -> MaybeOwned<'a>;
into_option			    pub fn into_option(self) -> Option<(T,T)> 
into_owned			    fn into_owned(self) -> ~[T] { self }
into_owned			    fn into_owned(self) -> ~[T] { self.to_owned() }
into_owned			    fn into_owned(self) -> ~[T];
into_owned			    fn into_owned(self) -> ~str { self }
into_owned			    fn into_owned(self) -> ~str { self.to_owned() }
into_owned			    fn into_owned(self) -> ~str 
into_owned			    fn into_owned(self) -> ~str;
into_str			    fn into_str(self) -> ~str 
into_str			    fn into_str(self) -> ~str;
into_vec			    fn into_vec(self) -> ~[u8];
into_vec			    fn into_vec(self) -> ~[u8] 
into_vec			    fn into_vec(self) -> ~[u8] 
intrinsics			pub mod intrinsics;
io			        impl io::Reader for S 
io			        impl io::Writer for S 
io			pub mod io;
io			    fn io<'a>(&'a mut self) -> Option<&'a mut IoFactory>;
io			impl io::Writer for Stderr 
io_fill			    fn io_fill() 
ip			pub mod ip;
ip6_mreq			                pub struct ip6_mreq 
ip_mreq			                pub struct ip_mreq 
ipv6_addr_from_head_tail			        fn ipv6_addr_from_head_tail(head: &[u16], tail: &[u16]) -> IpAddr 
ipv6_addr_to_str			    fn ipv6_addr_to_str() 
is			    fn is<T: 'static>(self) -> bool 
is			    fn is<T: 'static>(self) -> bool;
is_XID_continue			    fn is_XID_continue(&self) -> bool { is_XID_continue(*self) }
is_XID_continue			    fn is_XID_continue(&self) -> bool;
is_XID_continue			pub fn is_XID_continue(c: char) -> bool { derived_property::XID_Continue(c) }
is_XID_start			    fn is_XID_start(&self) -> bool { is_XID_start(*self) }
is_XID_start			    fn is_XID_start(&self) -> bool;
is_XID_start			pub fn is_XID_start(c: char) -> bool    { derived_property::XID_Start(c) }
is_absolute			    fn is_absolute(&self) -> bool;
is_absolute			    fn is_absolute(&self) -> bool 
is_absolute			    fn is_absolute(&self) -> bool 
is_alnum			    pub fn is_alnum(&self) -> bool 
is_alpha			    pub fn is_alpha(&self) -> bool 
is_alphabetic			    fn is_alphabetic(&self) -> bool { is_alphabetic(*self) }
is_alphabetic			    fn is_alphabetic(&self) -> bool;
is_alphabetic			pub fn is_alphabetic(c: char) -> bool   { derived_property::Alphabetic(c) }
is_alphanumeric			    fn is_alphanumeric(&self) -> bool { is_alphanumeric(*self) }
is_alphanumeric			    fn is_alphanumeric(&self) -> bool;
is_alphanumeric			pub fn is_alphanumeric(c: char) -> bool 
is_alphanumeric			    fn is_alphanumeric(&self) -> bool { self.chars().all(char::is_alphanumeric) }
is_alphanumeric			    fn is_alphanumeric(&self) -> bool;
is_ancestor_of			    fn is_ancestor_of(&self, other: &Self) -> bool;
is_ancestor_of			    fn is_ancestor_of(&self, other: &Path) -> bool 
is_ancestor_of			    fn is_ancestor_of(&self, other: &Path) -> bool 
is_ancestor_of_path_with_10_dirs			    fn is_ancestor_of_path_with_10_dirs(bh: &mut BenchHarness) 
is_ascii			    fn is_ascii(&self) -> bool 
is_ascii			    fn is_ascii(&self) -> bool;
is_blank			    pub fn is_blank(&self) -> bool 
is_char_boundary			    fn is_char_boundary(&self, index: uint) -> bool 
is_char_boundary			    fn is_char_boundary(&self, index: uint) -> bool;
is_control			    pub fn is_control(&self) -> bool 
is_control			    fn is_control(&self) -> bool { is_control(*self) }
is_control			    fn is_control(&self) -> bool;
is_control			pub fn is_control(c: char) -> bool { general_category::Cc(c) }
is_cwd_relative			pub fn is_cwd_relative(path: &Path) -> bool 
is_digit			    pub fn is_digit(&self) -> bool 
is_digit			    fn is_digit(&self) -> bool { is_digit(*self) }
is_digit			    fn is_digit(&self) -> bool;
is_digit			pub fn is_digit(c: char) -> bool 
is_digit_radix			    fn is_digit_radix(&self, radix: uint) -> bool { is_digit_radix(*self, radix) }
is_digit_radix			    fn is_digit_radix(&self, radix: uint) -> bool;
is_digit_radix			pub fn is_digit_radix(c: char, radix: uint) -> bool 
is_dir			    pub fn is_dir(&self) -> bool 
is_disjoint			    fn is_disjoint(&self, other: &Self) -> bool;
is_empty			    fn is_empty(&self) -> bool 
is_empty			    pub fn is_empty(&mut self) -> bool 
is_empty			    pub fn is_empty(&self, order: Ordering) -> bool 
is_eof			    fn is_eof(&self) -> bool 
is_err			    pub fn is_err(&self) -> bool 
is_file			    pub fn is_file(&self) -> bool 
is_finite			    fn is_finite(&self) -> bool 
is_finite			    fn is_finite(&self) -> bool 
is_finite			    fn is_finite(&self) -> bool;
is_graph			    pub fn is_graph(&self) -> bool 
is_hex			    pub fn is_hex(&self) -> bool 
is_infinite			    fn is_infinite(&self) -> bool 
is_infinite			    fn is_infinite(&self) -> bool 
is_infinite			    fn is_infinite(&self) -> bool;
is_lower			    pub fn is_lower(&self) -> bool 
is_lowercase			    fn is_lowercase(&self) -> bool { is_lowercase(*self) }
is_lowercase			    fn is_lowercase(&self) -> bool;
is_lowercase			pub fn is_lowercase(c: char) -> bool { derived_property::Lowercase(c) }
is_nan			    fn is_nan(&self) -> bool { *self != *self }
is_nan			    fn is_nan(&self) -> bool { *self != *self }
is_nan			    fn is_nan(&self) -> bool;
is_negative			    fn is_negative(&self) -> bool { *self < 0.0 || (1.0 \/ *self) == NEG_INFINITY }
is_negative			    fn is_negative(&self) -> bool { *self < 0.0 || (1.0 \/ *self) == NEG_INFINITY }
is_negative			    fn is_negative(&self) -> bool { *self < 0 }
is_negative			    fn is_negative(&self) -> bool;
is_none			    pub fn is_none(&self) -> bool 
is_normal			    fn is_normal(&self) -> bool 
is_normal			    fn is_normal(&self) -> bool 
is_normal			    fn is_normal(&self) -> bool;
is_not_null			    pub fn is_not_null(&self) -> bool 
is_not_null			    fn is_not_null(&self) -> bool { !self.is_null() }
is_null			    pub fn is_null(&self) -> bool 
is_null			    fn is_null(&self) -> bool { *self == RawPtr::null() }
is_null			    fn is_null(&self) -> bool;
is_odd			    fn is_odd(n: &uint) -> bool { *n % 2u == 1u }
is_ok			    pub fn is_ok(&self) -> bool 
is_owned			    pub fn is_owned(&self) -> bool 
is_owned			    pub fn is_owned(&self) -> bool 
is_positive			    fn is_positive(&self) -> bool { *self > 0.0 || (1.0 \/ *self) == INFINITY }
is_positive			    fn is_positive(&self) -> bool { *self > 0.0 || (1.0 \/ *self) == INFINITY }
is_positive			    fn is_positive(&self) -> bool { *self > 0 }
is_positive			    fn is_positive(&self) -> bool;
is_print			    pub fn is_print(&self) -> bool 
is_punctuation			    pub fn is_punctuation(&self) -> bool 
is_relative			    fn is_relative(&self) -> bool 
is_relative			    fn is_relative(&self) -> bool 
is_sep			pub fn is_sep(c: char) -> bool 
is_sep			pub fn is_sep(c: char) -> bool 
is_sep_			        fn is_sep_(prefix: Option<PathPrefix>, u: u8) -> bool 
is_sep_byte			pub fn is_sep_byte(u: &u8) -> bool 
is_sep_byte			pub fn is_sep_byte(u: &u8) -> bool 
is_sep_byte_verbatim			pub fn is_sep_byte_verbatim(u: &u8) -> bool 
is_sep_verbatim			pub fn is_sep_verbatim(c: char) -> bool 
is_slice			    pub fn is_slice(&self) -> bool 
is_some			    pub fn is_some(&self) -> bool 
is_str			    fn is_str(_: Option<&'a str>) -> bool { true }
is_str			    fn is_str(_: Option<Self>) -> bool { false }
is_str			    fn is_str(_: Option<str::MaybeOwned>) -> bool { true }
is_str			    fn is_str(_: Option<~str>) -> bool { true }
is_str			    fn is_str(_: Option<&'a Path>) -> bool { true }
is_str			    fn is_str(_: Option<Path>) -> bool { true }
is_subset			    fn is_subset(&self, other: &Self) -> bool;
is_superset			    fn is_superset(&self, other: &Self) -> bool;
is_upper			    pub fn is_upper(&self) -> bool 
is_uppercase			    fn is_uppercase(&self) -> bool { is_uppercase(*self) }
is_uppercase			    fn is_uppercase(&self) -> bool;
is_uppercase			pub fn is_uppercase(c: char) -> bool { derived_property::Uppercase(c) }
is_utf16			pub fn is_utf16(v: &[u16]) -> bool 
is_utf8			pub fn is_utf8(v: &[u8]) -> bool 
is_utf8_100_ascii			    fn is_utf8_100_ascii(bh: &mut BenchHarness) 
is_utf8_100_multibyte			    fn is_utf8_100_multibyte(bh: &mut BenchHarness) 
is_verbatim			pub fn is_verbatim(path: &Path) -> bool 
is_vol_abs			        fn is_vol_abs(path: &str, prefix: Option<PathPrefix>) -> bool 
is_vol_relative			pub fn is_vol_relative(path: &Path) -> bool 
is_whitespace			    fn is_whitespace(&self) -> bool { is_whitespace(*self) }
is_whitespace			    fn is_whitespace(&self) -> bool;
is_whitespace			pub fn is_whitespace(c: char) -> bool 
is_whitespace			    fn is_whitespace(&self) -> bool { self.chars().all(char::is_whitespace) }
is_whitespace			    fn is_whitespace(&self) -> bool;
is_zero			    fn is_zero(&self) -> bool { *self == 0.0 || *self == -0.0 }
is_zero			    fn is_zero(&self) -> bool { *self == 0.0 || *self == -0.0 }
is_zero			    fn is_zero(&self) -> bool { *self == 0 }
is_zero			    fn is_zero(&self) -> bool;
is_zero			    fn is_zero(&self) -> bool { *self == 0 }
isalnum			                pub fn isalnum(c: c_int) -> c_int;
isalpha			                pub fn isalpha(c: c_int) -> c_int;
isatty			    pub fn isatty(&self) -> bool 
isatty			                pub fn isatty(fd: c_int) -> c_int;
isatty			    fn isatty(&self) -> bool;
iscntrl			                pub fn iscntrl(c: c_int) -> c_int;
isdigit			                pub fn isdigit(c: c_int) -> c_int;
isgraph			                pub fn isgraph(c: c_int) -> c_int;
islower			                pub fn islower(c: c_int) -> c_int;
isprint			                pub fn isprint(c: c_int) -> c_int;
ispunct			                pub fn ispunct(c: c_int) -> c_int;
isspace			                pub fn isspace(c: c_int) -> c_int;
isupper			                pub fn isupper(c: c_int) -> c_int;
isxdigit			                pub fn isxdigit(c: c_int) -> c_int;
iter			    pub fn iter<'a>(&'a self) -> CChars<'a> 
iter			    pub fn iter<'a>(&'a self) -> Messages<'a, T> 
iter			    fn iter(&self) -> Packets { Packets { cur: self.head } }
iter			pub mod iter;
iter			    pub fn iter<'r>(&'r self) -> Item<&'r T> 
iter			    fn iter(self) -> Items<'a, T> 
iter			    fn iter(self) -> Items<'a, T>;
iter			    pub fn iter<'a>(&'a self) -> Items<'a,T> 
iterator			    fn iterator(bh: &mut BenchHarness) 
j0			        pub fn j0(n: c_double) -> c_double;
j1			        pub fn j1(n: c_double) -> c_double;
jn			        pub fn jn(i: c_int, n: c_double) -> c_double;
join			        fn join(&self, path: &str) -> Path 
join			    fn join<T: BytesContainer>(&self, path: T) -> Self 
join			    pub fn join(mut self) -> T 
join			    pub unsafe fn join(native: rust_thread) 
join_abs_path_home_dir			    fn join_abs_path_home_dir(bh: &mut BenchHarness) 
join_home_dir			    fn join_home_dir(bh: &mut BenchHarness) 
join_many			    fn join_many<T: BytesContainer>(&self, paths: &[T]) -> Self 
join_many_abs_path_home_dir			    fn join_many_abs_path_home_dir(bh: &mut BenchHarness) 
join_many_home_dir			    fn join_many_home_dir(bh: &mut BenchHarness) 
join_multicast			    fn join_multicast(&mut self, multi: IpAddr) -> IoResult<()>;
keepalive			    fn keepalive(&mut self, delay_in_seconds: uint) -> IoResult<()>;
kernel32			        pub mod kernel32 
key_to_key_value			fn key_to_key_value<T: 'static>(key: Key<T>) -> *u8 
kill			    pub fn kill(id: libc::pid_t, signal: int) -> IoResult<()> 
kill			                pub fn kill(pid: pid_t, sig: c_int) -> c_int;
kill			    fn kill(&mut self, pid: libc::pid_t, signal: int) -> IoResult<()>;
kill			    fn kill(&mut self, signal: int) -> IoResult<()>;
labs			                pub fn labs(i: c_long) -> c_long;
last			    fn last(&mut self) -> Option<A> 
last			    fn last(&self) -> Option<&'a T> 
last			    fn last(&self) -> Option<&'a T>;
last			    pub fn last<'a>(&'a self) -> Option<&'a T> 
last_error			    pub fn last_error() -> IoError 
last_os_error			    pub fn last_os_error() 
last_os_error			pub fn last_os_error() -> ~str 
ldexp			    fn ldexp(x: c_float, n: c_int) -> c_float = cmath::ldexpf,
ldexp			    fn ldexp(x: f32, exp: int) -> f32 
ldexp			        pub fn ldexp(x: c_double, n: c_int) -> c_double;
ldexp			    fn ldexp(x: c_double, n: c_int) -> c_double = cmath::ldexp,
ldexp			    fn ldexp(x: f64, exp: int) -> f64 
ldexp			    fn ldexp(x: Self, exp: int) -> Self;
ldexpf			        pub fn ldexpf(x: c_float, n: c_int) -> c_float;
le			    fn le(&self, other: &Self) -> bool { !other.lt(self) }
le			    pub fn le<A: Ord, T: Iterator<A>>(mut a: T, mut b: T) -> bool 
le			    fn le(&self, other: &@T) -> bool { *(*self) <= *(*other) }
le			    fn le(&self, other: &f32) -> bool { (*self) <= (*other) }
le			    fn le(&self, other: &f64) -> bool { (*self) <= (*other) }
le			    fn le(&self, other: &~T) -> bool { *(*self) <= *(*other) }
le			    fn le(&self, other: &*T) -> bool 
le			    fn le(&self, other: &*mut T) -> bool 
le			    fn le(&self, other: &Rc<T>) -> bool { **self <= **other }
le			    fn le(&self, other: & &'a T) -> bool 
le			        fn le(&self, other: & &'a [T]) -> bool 
le			        fn le(&self, other: &~[T]) -> bool { self.as_slice() <= other.as_slice() }
le			                fn le(&self, other: &($($T,)+)) -> bool 
leading_zeros			    fn leading_zeros(&self) -> i16 { unsafe { intrinsics::ctlz16(*self) } }
leading_zeros			    fn leading_zeros(&self) -> i32 { unsafe { intrinsics::ctlz32(*self) } }
leading_zeros			    fn leading_zeros(&self) -> i64 { unsafe { intrinsics::ctlz64(*self) } }
leading_zeros			    fn leading_zeros(&self) -> i8 { unsafe { intrinsics::ctlz8(*self) } }
leading_zeros			    fn leading_zeros(&self) -> int { (*self as i32).leading_zeros() as int }
leading_zeros			    fn leading_zeros(&self) -> int { (*self as i64).leading_zeros() as int }
leading_zeros			    fn leading_zeros(&self) -> Self;
leading_zeros			    fn leading_zeros(&self) -> $T 
leave_multicast			    fn leave_multicast(&mut self, multi: IpAddr) -> IoResult<()>;
len			    fn len(&self) -> uint 
len			    fn len(&self) -> uint { self.len }
len			    fn len(&self) -> uint;
len			    fn len(&mut self) -> uint 
len			    fn len(&self) -> uint 
len			    fn len(&self) -> uint { self.as_slice().len() }
len			    fn len(&self) -> uint 
len			    fn len(&self) -> uint 
len_utf8_bytes			    fn len_utf8_bytes(&self) -> uint { len_utf8_bytes(*self) }
len_utf8_bytes			    fn len_utf8_bytes(&self) -> uint;
len_utf8_bytes			pub fn len_utf8_bytes(c: char) -> uint 
letdie			    fn letdie(&mut self) -> IoResult<()>;
lev_distance			    fn lev_distance(&self, t: &str) -> uint 
lev_distance			    fn lev_distance(&self, t: &str) -> uint;
lexical_ordering			pub fn lexical_ordering(o1: Ordering, o2: Ordering) -> Ordering 
lgamma_r			        pub fn lgamma_r(n: c_double, sign: &mut c_int) -> c_double;
lgammaf_r			        pub fn lgammaf_r(n: c_float, sign: &mut c_int) -> c_float;
libc			pub mod libc;
libunwind			mod libunwind;
limit			    pub fn limit(&self) -> uint { self.limit }
limit_thread_creation_due_to_osx_and_valgrind			pub fn limit_thread_creation_due_to_osx_and_valgrind() -> bool 
lines			    fn lines<'r>(&'r mut self) -> Lines<'r, Self> 
lines			    fn lines(&self) -> CharSplits<'a, char> 
lines			    fn lines(&self) -> CharSplits<'a, char>;
lines_any			    fn lines_any(&self) -> AnyLines<'a> 
lines_any			    fn lines_any(&self) -> AnyLines<'a>;
link			pub fn link(src: &Path, dst: &Path) -> IoResult<()> 
link			                pub fn link(src: *c_char, dst: *c_char) -> c_int;
linux			    pub mod linux 
listen			    fn listen(self) -> IoResult<A>;
listen			    fn listen(self) -> IoResult<TcpAcceptor> 
listen			    fn listen(self) -> IoResult<UnixAcceptor> 
listen			    fn listen(self) -> IoResult<A> 
listen			            pub fn listen(socket: SOCKET, backlog: c_int) -> c_int;
listen			            pub fn listen(socket: c_int, backlog: c_int) -> c_int;
listen			    fn listen(~self) -> IoResult<~RtioTcpAcceptor:Send>;
listen			    fn listen(~self) -> IoResult<~RtioUnixAcceptor:Send>;
live_allocs			pub fn live_allocs() -> *mut Box 
ln			    fn ln(&self) -> f32 { ln(*self) }
ln			    fn ln(n: f32) -> f32 = intrinsics::logf32,
ln			    fn ln(&self) -> f64 { ln(*self) }
ln			    fn ln(n: f64) -> f64 = intrinsics::logf64,
ln			    fn ln(&self) -> Self;
ln_10			    fn ln_10() -> f32 { 2.30258509299404568401799145468436421 }
ln_10			    fn ln_10() -> f64 { 2.30258509299404568401799145468436421 }
ln_10			    fn ln_10() -> Self;
ln_1p			    fn ln_1p(&self) -> f32 { ln_1p(*self) }
ln_1p			    fn ln_1p(n: c_float) -> c_float = cmath::log1pf,
ln_1p			    fn ln_1p(&self) -> f64 { ln_1p(*self) }
ln_1p			    fn ln_1p(n: c_double) -> c_double = cmath::log1p,
ln_1p			    fn ln_1p(&self) -> Self;
ln_2			    fn ln_2() -> f32 { 0.693147180559945309417232121458176568 }
ln_2			    fn ln_2() -> f64 { 0.693147180559945309417232121458176568 }
ln_2			    fn ln_2() -> Self;
load			    pub fn load(&self, order: Ordering) -> *mut T 
load			    pub fn load(&self, order: Ordering) -> bool 
load			    pub fn load(&self, order: Ordering) -> int 
load			    pub fn load(&self, order: Ordering) -> uint 
load_argc_and_argv			unsafe fn load_argc_and_argv(argc: int, argv: **c_char) -> ~[~[u8]] 
load_argc_and_argv			    unsafe fn load_argc_and_argv(argc: int, argv: **u8) -> ~[~[u8]] 
load_self			    fn load_self() -> Option<~[u8]> 
local			pub mod local;
local_data			pub mod local_data;
local_free			pub unsafe fn local_free(ptr: *u8) 
local_free_			pub unsafe fn local_free_(ptr: *u8) 
local_heap			pub mod local_heap;
local_heap			    fn local_heap() 
local_io			    fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>>;
local_io			    pub fn local_io<'a>(&'a mut self) -> Option<LocalIo<'a>> 
local_malloc			pub unsafe fn local_malloc(drop_glue: fn(*mut u8), size: uint, align: uint) -> *u8 
local_malloc_			pub unsafe fn local_malloc_(drop_glue: fn(*mut u8), size: uint, align: uint) -> *u8 
local_ptr			mod local_ptr;
lock			    fn lock<'a>(&'a self) -> (LockGuard<'a>, &'a mut State<T>) 
lock			        pub unsafe fn lock(&self) { pthread_mutex_lock(self.lock.get()); }
lock			        pub unsafe fn lock(&self) 
lock			    pub unsafe fn lock<'a>(&'a self) -> LockGuard<'a> 
lock_noguard			    pub unsafe fn lock_noguard(&self) { self.inner.lock() }
lock_noguard			    pub unsafe fn lock_noguard(&self) { self.inner.lock_noguard() }
log			    fn log(&self, base: &f32) -> f32 { self.ln() \/ base.ln() }
log			    fn log(&self, base: &f64) -> f64 { self.ln() \/ base.ln() }
log			    fn log(&self, base: &Self) -> Self;
log10			    fn log10(&self) -> f32 { log10(*self) }
log10			    fn log10(n: f32) -> f32 = intrinsics::log10f32,
log10			    fn log10(&self) -> f64 { log10(*self) }
log10			    fn log10(n: f64) -> f64 = intrinsics::log10f64,
log10			    fn log10(&self) -> Self;
log10_e			    fn log10_e() -> f32 { 0.434294481903251827651128918916605082 }
log10_e			    fn log10_e() -> f64 { 0.434294481903251827651128918916605082 }
log10_e			    fn log10_e() -> Self;
log10f32			    pub fn log10f32(x: f32) -> f32;
log10f64			    pub fn log10f64(x: f64) -> f64;
log1p			        pub fn log1p(n: c_double) -> c_double;
log1pf			        pub fn log1pf(n: c_float) -> c_float;
log2			    fn log2(&self) -> f32 { log2(*self) }
log2			    fn log2(n: f32) -> f32 = intrinsics::log2f32,
log2			    fn log2(&self) -> f64 { log2(*self) }
log2			    fn log2(n: f64) -> f64 = intrinsics::log2f64,
log2			    fn log2(&self) -> Self;
log2_e			    fn log2_e() -> f32 { 1.44269504088896340735992468100189214 }
log2_e			    fn log2_e() -> f64 { 1.44269504088896340735992468100189214 }
log2_e			    fn log2_e() -> Self;
log2f32			    pub fn log2f32(x: f32) -> f32;
log2f64			    pub fn log2f64(x: f64) -> f64;
log_enabled			pub fn log_enabled() -> bool 
logb			        pub fn logb(n: c_double) -> c_double;
logbf			        pub fn logbf(n: c_float) -> c_float;
logf32			    pub fn logf32(x: f32) -> f32;
logf64			    pub fn logf64(x: f64) -> f64;
logging			    fn logging() 
lookup			fn lookup(hostname: Option<&str>, servname: Option<&str>, hint: Option<Hint>)
lookup			    fn lookup() -> Path 
loop_multicast_locally			    fn loop_multicast_locally(&mut self) -> IoResult<()>;
lseek			                pub fn lseek(fd: c_int, offset: c_long, origin: c_int)
lseek			                pub fn lseek(fd: c_int, offset: off_t, whence: c_int)
lseek_			        fn lseek_(fd: c_int, size: uint) 
lstat			pub fn lstat(path: &Path) -> IoResult<FileStat> 
lstat			                pub fn lstat(path: *c_char, buf: *mut stat) -> c_int;
lt			    fn lt(&self, other: &bool) -> bool 
lt			    fn lt(&self, other: &char) -> bool { *self < *other }
lt			    fn lt(&self, other: &Ordering) -> bool { (*self as int) < (*other as int) }
lt			    fn lt(&self, other: &Self) -> bool;
lt			            fn lt(&self, _: &Foo) -> bool 
lt			    pub fn lt<A: Ord, T: Iterator<A>>(mut a: T, mut b: T) -> bool 
lt			    fn lt(&self, other: &@T) -> bool { *(*self) < *(*other) }
lt			    fn lt(&self, other: &f32) -> bool { (*self) < (*other) }
lt			    fn lt(&self, other: &f64) -> bool { (*self) < (*other) }
lt			    fn lt(&self, other: &$T) -> bool { return (*self) < (*other); }
lt			    fn lt(&self, other: &$T) -> bool { (*self) < (*other) }
lt			    fn lt(&self, other: &~T) -> bool { *(*self) < *(*other) }
lt			    fn lt(&self, other: &*T) -> bool 
lt			    fn lt(&self, other: &*mut T) -> bool 
lt			    fn lt(&self, other: &Rc<T>) -> bool { **self < **other }
lt			    fn lt(&self, other: & &'a T) -> bool 
lt			        fn lt(&self, other: & &'a [T]) -> bool 
lt			        fn lt(&self, other: &~[T]) -> bool { self.as_slice() < other.as_slice() }
lt			        fn lt(&self, other: & &'a str) -> bool { self.cmp(other) == Less }
lt			        fn lt(&self, other: &~str) -> bool { self.cmp(other) == Less }
lt			    fn lt(&self, other: &MaybeOwned) -> bool 
lt			                fn lt(&self, other: &($($T,)+)) -> bool 
lt			    fn lt(&self, _other: &()) -> bool { false }
lt			    fn lt(&self, other: &Vec<T>) -> bool 
mach_timebase_info			                pub struct mach_timebase_info 
macos			    pub mod macos 
macros			pub mod macros;
macros			mod macros;
madvise			            pub fn madvise(addr: *c_void, len: size_t, advice: c_int)
main			fn main() 
main			fn main() 
make_absolute			pub fn make_absolute(p: &Path) -> Path 
make_non_verbatim			pub fn make_non_verbatim(path: &Path) -> Option<Path> 
make_rand_name			    fn make_rand_name() -> ~str 
make_selectable			    pub fn make_selectable(self, num_handles: uint) -> Take<BlockedTasks>
malloc			    fn malloc(n: uint) -> CVec<u8> 
malloc			                pub fn malloc(size: size_t) -> *mut c_void;
malloc			    fn malloc(&mut self, size: uint) -> *mut Box 
malloc_raw			pub unsafe fn malloc_raw(size: uint) -> *mut u8 
managed			mod managed;
mantissa_digits			    fn mantissa_digits(_: Option<f32>) -> uint { 24 }
mantissa_digits			    fn mantissa_digits(_: Option<f64>) -> uint { 53 }
mantissa_digits			    fn mantissa_digits(unused_self: Option<Self>) -> uint;
many_stampede			    fn many_stampede() 
map			    fn map<'r, B>(self, f: 'r |A| -> B) -> Map<'r, A, B, Self> 
map			    pub fn map<U>(self, f: |T| -> U) -> Option<U> 
map			    pub fn map<U>(self, op: |T| -> U) -> Result<U,E> 
map_err			    pub fn map_err<F>(self, op: |E| -> F) -> Result<T,F> 
map_or			    pub fn map_or<U>(self, def: U, f: |T| -> U) -> U 
marker			pub mod marker 
mask			    fn mask(&self) -> int { (1 << self.log_size) - 1 }
match_indices			    fn match_indices(&self, sep: &'a str) -> MatchIndices<'a> 
match_indices			    fn match_indices(&self, sep: &'a str) -> MatchIndices<'a>;
match_option_some			    fn match_option_some(bh: &mut BenchHarness) 
match_vec_pattern			    fn match_vec_pattern(bh: &mut BenchHarness) 
matches			            fn matches(&self, c: char) -> bool 
matches			    fn matches(&self, c: char) -> bool { (*self)(c) }
matches			    fn matches(&self, c: char) -> bool { *self == c }
matches			    fn matches(&self, c: char) -> bool 
matches			    fn matches(&self, char) -> bool;
matches_exit_status			    pub fn matches_exit_status(&self, wanted: int) -> bool 
max			pub fn max<T: TotalOrd>(v1: T, v2: T) -> T 
max			    fn max(&mut self) -> Option<A> 
max			    fn max(&mut self) -> Option<A>;
max			    fn max(self, other: f32) -> f32 
max			    fn max(self, other: f64) -> f64 
max			    fn max(self, other: Self) -> Self;
max_10_exp			    fn max_10_exp(_: Option<f32>) -> int { 38 }
max_10_exp			    fn max_10_exp(_: Option<f64>) -> int { 308 }
max_10_exp			    fn max_10_exp(unused_self: Option<Self>) -> int;
max_by			    fn max_by<B: TotalOrd>(&mut self, f: |&A| -> B) -> Option<A> 
max_cached_stacks			pub fn max_cached_stacks() -> uint 
max_exp			    fn max_exp(_: Option<f32>) -> int { 128 }
max_exp			    fn max_exp(_: Option<f64>) -> int { 1024 }
max_exp			    fn max_exp(unused_self: Option<Self>) -> int;
max_value			    fn max_value() -> f32 { 3.40282347e+38 }
max_value			    fn max_value() -> f64 { 1.7976931348623157e+308 }
max_value			    fn max_value() -> $T { MAX }
max_value			    fn max_value() -> Self;
max_value			    fn max_value() -> $T { MAX }
maybe_raise			    pub fn maybe_raise<T>(f: |io: &mut IoFactory| -> IoResult<T>)
maybe_shrink			    unsafe fn maybe_shrink(&mut self, b: int, t: int) 
maybe_take_runtime			    pub fn maybe_take_runtime<T: 'static>(&mut self) -> Option<~T> 
maybe_tls_key			    pub fn maybe_tls_key() -> Option<tls::Key> 
maybe_yield			    fn maybe_yield(~self, cur_task: ~Task);
maybe_yield			    pub fn maybe_yield(mut ~self) 
mem			mod mem;
mem			pub mod mem;
memchr			                pub fn memchr(cx: *c_void, c: c_int, n: size_t) -> *c_void;
memcmp			                pub fn memcmp(cx: *c_void, ct: *c_void, n: size_t) -> c_int;
memory_map_file			    fn memory_map_file() 
memory_map_rw			    fn memory_map_rw() 
merge_sort			fn merge_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) 
method			    fn method(&mut self) -> Option<~Method<'a>> 
method			        fn method(&self) -> int 
method			        fn method(&self) -> int;
min			pub fn min<T: TotalOrd>(v1: T, v2: T) -> T 
min			    fn min(&mut self) -> Option<A> 
min			    fn min(&mut self) -> Option<A>;
min			    fn min(self, other: f32) -> f32 
min			    fn min(self, other: f64) -> f64 
min			    fn min(self, other: Self) -> Self;
min_10_exp			    fn min_10_exp(_: Option<f32>) -> int { -37 }
min_10_exp			    fn min_10_exp(_: Option<f64>) -> int { -307 }
min_10_exp			    fn min_10_exp(unused_self: Option<Self>) -> int;
min_align_of			    pub fn min_align_of<T>() -> uint;
min_align_of			pub fn min_align_of<T>() -> uint 
min_align_of_val			pub fn min_align_of_val<T>(_val: &T) -> uint 
min_by			    fn min_by<B: TotalOrd>(&mut self, f: |&A| -> B) -> Option<A> 
min_exp			    fn min_exp(_: Option<f32>) -> int { -125 }
min_exp			    fn min_exp(_: Option<f64>) -> int { -1021 }
min_exp			    fn min_exp(unused_self: Option<Self>) -> int;
min_max			    fn min_max(&mut self) -> MinMaxResult<A> 
min_max			    fn min_max(&mut self) -> MinMaxResult<A>;
min_stack			pub fn min_stack() -> uint 
min_stack_size			    fn min_stack_size(_: *libc::pthread_attr_t) -> libc::size_t 
min_stack_size			    fn min_stack_size(attr: *libc::pthread_attr_t) -> libc::size_t 
min_value			    fn min_value() -> f32 { 1.17549435e-38 }
min_value			    fn min_value() -> f64 { 2.2250738585072014e-308 }
min_value			    fn min_value() -> $T { MIN }
min_value			    fn min_value() -> Self;
min_value			    fn min_value() -> $T { MIN }
mincore			            pub fn mincore(addr: *c_void, len: size_t, vec: *c_uchar)
mips			    pub mod mips 
mkdir			pub fn mkdir(path: &Path, mode: FilePermission) -> IoResult<()> 
mkdir			                pub fn mkdir(path: *c_char) -> c_int;
mkdir			                pub fn mkdir(path: *c_char, mode: mode_t) -> c_int;
mkdir_recursive			pub fn mkdir_recursive(path: &Path, mode: FilePermission) -> IoResult<()> 
mkfifo			                pub fn mkfifo(path: *c_char, mode: mode_t) -> c_int;
mlock			                pub fn mlock(addr: *c_void, len: size_t) -> c_int;
mlockall			                pub fn mlockall(flags: c_int) -> c_int;
mman			        pub mod mman 
mmap			                pub fn mmap(addr: *c_void,
modf			        pub fn modf(n: c_double, iptr: &mut c_double) -> c_double;
modff			        pub fn modff(n: c_float, iptr: &mut c_float) -> c_float;
modify			pub fn modify<T: 'static>(key: Key<T>, f: |Option<T>| -> Option<T>) 
move			    fn move<T: 'static>(self) -> Result<~T, Self>;
move			    fn move<T: 'static>(self) -> Result<~T, ~Any> 
move_from			    fn move_from(self, mut src: ~[T], start: uint, end: uint) -> uint 
move_from			    fn move_from(self, src: ~[T], start: uint, end: uint) -> uint;
move_iter			    pub fn move_iter(self) -> Item<T> 
move_iter			    fn move_iter(self) -> MoveItems<T> 
move_iter			    fn move_iter(self) -> MoveItems<T>;
move_iter			    pub fn move_iter(self) -> MoveItems<T> 
move_ptr			    fn move_ptr(&mut self, adjustment: |*u8| -> *u8);
move_ptr			    fn move_ptr(&mut self, adjustment: |*u8| -> *u8) 
move_rev_iter			    fn move_rev_iter(self) -> RevMoveItems<T> 
move_rev_iter			    fn move_rev_iter(self) -> RevMoveItems<T>;
move_val_init			    pub fn move_val_init<T>(dst: &mut T, src: T);
move_val_init			pub unsafe fn move_val_init<T>(dst: &mut T, src: T) 
mpmc_bounded_queue			pub mod mpmc_bounded_queue;
mprotect			                pub fn mprotect(addr: *c_void, len: size_t, prot: c_int)
mpsc_queue			pub mod mpsc_queue;
msvcrt			        pub mod msvcrt 
msync			                pub fn msync(addr: *c_void, len: size_t, flags: c_int)
mul			            fn mul(&self, _: &Foo) -> Foo 
mul			    fn mul(&self, other: &f32) -> f32 { *self * *other }
mul			    fn mul(&self, other: &f64) -> f64 { *self * *other }
mul			    fn mul(&self, other: &$T) -> $T { *self * *other }
mul			    fn mul(&self, other: &$T) -> $T { *self * *other }
mul			    fn mul(&self, rhs: &RHS) -> Result;
mul_add			    fn mul_add(&self, a: f32, b: f32) -> f32 
mul_add			    fn mul_add(a: f32, b: f32, c: f32) -> f32 = intrinsics::fmaf32,
mul_add			    fn mul_add(&self, a: f64, b: f64) -> f64 
mul_add			    fn mul_add(a: f64, b: f64, c: f64) -> f64 = intrinsics::fmaf64,
mul_add			    fn mul_add(&self, a: Self, b: Self) -> Self;
multibyte_char_range_at			        fn multibyte_char_range_at(s: &str, i: uint) -> CharRange 
multibyte_char_range_at_reverse			        fn multibyte_char_range_at_reverse(s: &str, mut i: uint) -> CharRange 
multicast_time_to_live			    fn multicast_time_to_live(&mut self, ttl: int) -> IoResult<()>;
munlock			                pub fn munlock(addr: *c_void, len: size_t) -> c_int;
munlockall			                pub fn munlockall() -> c_int;
munmap			                pub fn munmap(addr: *c_void, len: size_t) -> c_int;
must_consume			    fn must_consume(&mut self, c: char) 
musterr			    fn musterr(s: &str) 
mut_buf_as_slice			    pub unsafe fn mut_buf_as_slice<T,
mut_chunks			    fn mut_chunks(self, chunk_size: uint) -> MutChunks<'a, T> 
mut_chunks			    fn mut_chunks(self, chunk_size: uint) -> MutChunks<'a, T>;
mut_iter			    pub fn mut_iter<'r>(&'r mut self) -> Item<&'r mut T> 
mut_iter			    fn mut_iter(self) -> MutItems<'a, T> 
mut_iter			    fn mut_iter(self) -> MutItems<'a, T>;
mut_iter			    pub fn mut_iter<'a>(&'a mut self) -> MutItems<'a,T> 
mut_iterator			    fn mut_iterator(bh: &mut BenchHarness) 
mut_last			    fn mut_last(self) -> Option<&'a mut T> 
mut_last			    fn mut_last(self) -> Option<&'a mut T>;
mut_last			    pub fn mut_last<'a>(&'a mut self) -> Option<&'a mut T> 
mut_null			pub fn mut_null<T>() -> *mut T { 0 as *mut T }
mut_pop_ref			    fn mut_pop_ref(&mut self) -> Option<&'a mut T> 
mut_pop_ref			    fn mut_pop_ref(&mut self) -> Option<&'a mut T>;
mut_ref_slice			pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] 
mut_release_borrow_mut			    fn mut_release_borrow_mut() 
mut_rev_iter			    fn mut_rev_iter(self) -> RevMutItems<'a, T> 
mut_rev_iter			    fn mut_rev_iter(self) -> RevMutItems<'a, T>;
mut_shift_ref			    fn mut_shift_ref(&mut self) -> Option<&'a mut T> 
mut_shift_ref			    fn mut_shift_ref(&mut self) -> Option<&'a mut T>;
mut_slice			    fn mut_slice(self, start: uint, end: uint) -> &'a mut [T] 
mut_slice			    fn mut_slice(self, start: uint, end: uint) -> &'a mut [T];
mut_slice			    pub fn mut_slice<'a>(&'a mut self, start: uint, end: uint)
mut_slice_from			    fn mut_slice_from(self, start: uint) -> &'a mut [T] 
mut_slice_from			    fn mut_slice_from(self, start: uint) -> &'a mut [T];
mut_slice_from			    pub fn mut_slice_from<'a>(&'a mut self, start: uint) -> &'a mut [T] 
mut_slice_to			    fn mut_slice_to(self, end: uint) -> &'a mut [T] 
mut_slice_to			    fn mut_slice_to(self, end: uint) -> &'a mut [T];
mut_slice_to			    pub fn mut_slice_to<'a>(&'a mut self, end: uint) -> &'a mut [T] 
mut_split			    fn mut_split(self, pred: 'a |&T| -> bool) -> MutSplits<'a, T> 
mut_split			    fn mut_split(self, pred: 'a |&T| -> bool) -> MutSplits<'a, T>;
mut_split_at			    fn mut_split_at(self, mid: uint) -> (&'a mut [T], &'a mut [T]) 
mut_split_at			    fn mut_split_at(self, mid: uint) -> (&'a mut [T], &'a mut [T]);
mut_split_at			    pub fn mut_split_at<'a>(&'a mut self, mid: uint) -> (&'a mut [T], &'a mut [T]) 
mutate			    pub fn mutate(&mut self, f: |T| -> T) -> bool 
mutate_or_set			    pub fn mutate_or_set(&mut self, def: T, f: |T| -> T) -> bool 
mutex			pub mod mutex;
my_new			    fn my_new(inner: Flavor<T>) -> Receiver<T> 
my_new			    fn my_new(inner: Flavor<T>) -> Sender<T> 
naive_pow			        fn naive_pow<T: One + Mul<T, T>>(base: T, exp: uint) -> T 
named			    pub fn named<S: IntoMaybeOwned<'static>>(mut self, name: S) -> TaskBuilder 
nan			    fn nan() -> f32 { 0.0 \/ 0.0 }
nan			    fn nan() -> f64 { 0.0 \/ 0.0 }
nan			    fn nan() -> Self;
nan			        fn nan()      -> Option<$t> { Some( 0.0 \/ 0.0) }
nan			    fn nan()      -> Option<Self>;
nanosleep			                pub fn nanosleep(rqtp: *timespec, rmtp: *mut timespec) -> c_int;
native			pub mod native 
ne			    fn ne(&self, other: &Self) -> bool { !self.eq(other) }
ne			    pub fn ne<A: Eq, T: Iterator<A>>(mut a: T, mut b: T) -> bool 
ne			    fn ne(&self, other: &@T) -> bool { *(*self) != *(*other) }
ne			    fn ne(&self, other: &~T) -> bool { *(*self) != *(*other) }
ne			                fn ne(&self, other: &extern "C" fn($($p),*) -> _R) -> bool 
ne			        fn ne(&self, other: &extern "C" fn() -> _R) -> bool 
ne			    fn ne(&self, other: &*T) -> bool { !self.eq(other) }
ne			    fn ne(&self, other: &*mut T) -> bool { !self.eq(other) }
ne			    fn ne(&self, other: &Rc<T>) -> bool { **self != **other }
ne			    fn ne(&self, other: & &'a T) -> bool 
ne			        fn ne(&self, other: & &'a [T]) -> bool 
ne			        fn ne(&self, other: &~[T]) -> bool { !self.eq(other) }
ne			        fn ne(&self, other: & &'a str) -> bool { !(*self).eq(other) }
ne			                fn ne(&self, other: &($($T,)+)) -> bool 
ne			    fn ne(&self, _other: &()) -> bool { false }
nearbyint			    fn nearbyint(n: f32) -> f32 = intrinsics::nearbyintf32,
nearbyint			    fn nearbyint(n: f64) -> f64 = intrinsics::nearbyintf64,
nearbyintf32			    pub fn nearbyintf32(x: f32) -> f32;
nearbyintf64			    pub fn nearbyintf64(x: f64) -> f64;
needs_drop			    pub fn needs_drop<T>() -> bool;
neg			    fn neg(&self) -> f32 { -*self }
neg			    fn neg(&self) -> f64 { -*self }
neg			    fn neg(&self) -> $T { -*self }
neg			    fn neg(&self) -> $T { -*self }
neg			    fn neg(&self) -> Result;
neg_inf			        fn neg_inf()  -> Option<$t> { Some(-1.0 \/ 0.0) }
neg_inf			    fn neg_inf()  -> Option<Self>;
neg_infinity			    fn neg_infinity() -> f32 { -1.0 \/ 0.0 }
neg_infinity			    fn neg_infinity() -> f64 { -1.0 \/ 0.0 }
neg_infinity			    fn neg_infinity() -> Self;
neg_zero			    fn neg_zero() -> f32 { -0.0 }
neg_zero			    fn neg_zero() -> f64 { -0.0 }
neg_zero			    fn neg_zero() -> Self;
neg_zero			        fn neg_zero() -> Option<$t> { Some(-0.0      ) }
neg_zero			    fn neg_zero() -> Option<Self>;
net			pub mod net;
new			    pub unsafe fn new(buf: *libc::c_char, owns_buffer: bool) -> CString 
new			    pub unsafe fn new(base: *mut T, len: uint) -> CVec<T> 
new			    pub fn new(value: T) -> Cell<T> 
new			    pub fn new(value: T) -> RefCell<T> 
new			    fn new(inner: UnsafeArc<sync::Packet<T>>) -> SyncSender<T> 
new			    pub fn new() -> Packet<T> 
new			    pub fn new() -> Select 
new			    pub fn new() -> Packet<T> 
new			    pub fn new() -> Packet<T> 
new			    pub fn new(cap: uint) -> Packet<T> 
new			    pub unsafe fn new<'a>(fmt: &'static [rt::Piece<'static>],
new			    fn new(base: u8) -> Radix 
new			    pub fn new<'a>(s: &'a str) -> Parser<'a> 
new			    pub fn new(value: T) -> Gc<T> 
new			    pub fn new() -> SipHasher 
new			    pub fn new() -> SipState 
new			    pub fn new(inner: R) -> BufferedReader<R> 
new			    pub fn new(inner: S) -> BufferedStream<S> 
new			    pub fn new(inner: W) -> BufferedWriter<W> 
new			    pub fn new(inner: W) -> LineBufferedWriter<W> 
new			    pub fn new(rx: Receiver<~[u8]>) -> ChanReader 
new			    pub fn new(tx: Sender<~[u8]>) -> ChanWriter 
new			    pub fn new(r: &'r mut R) -> Bytes<'r, R> 
new			    pub fn new(inner_reader: R) -> InflateReader<R> 
new			    pub fn new(inner_writer: W) -> DeflateWriter<W> 
new			    pub fn new() -> MemWriter 
new			    pub fn new(buf: ~[u8]) -> MemReader 
new			    pub fn new<'a>(buf: &'a [u8]) -> BufReader<'a> 
new			    pub fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a> 
new			    fn new(s: &'a str) -> Parser<'a> 
new			    fn new(s: ~RtioTcpStream:Send) -> TcpStream 
new			    fn new(obj: ~RtioPipe:Send) -> UnixStream 
new			    pub fn new(inner: ~RtioPipe:Send) -> PipeStream 
new			    pub fn new(prog: &str, args: &[~str]) -> IoResult<Process> 
new			    pub fn new<'a>() -> ProcessConfig<'a> 
new			    pub fn new() -> Listener 
new			    pub fn new(suffix: &str) -> Option<TempDir> 
new			    pub fn new() -> IoResult<Timer> 
new			    pub fn new(mut readers: I) -> ChainedReader<I, R> 
new			    pub fn new(r: R, limit: uint) -> LimitReader<R> 
new			    pub fn new(r: R, w: W) -> TeeReader<R, W> 
new			    pub fn new(writers: ~[~Writer]) -> MultiWriter 
new			    pub fn new(elt: A) -> Repeat<A> 
new			    pub fn new<'a>(initial_state: St, f: 'a |&mut St| -> Option<A>)
new			                    pub fn new() -> SYSTEM_INFO 
new			    pub fn new(min_len: uint, options: &[MapOption]) -> Result<MemoryMap, MapError> 
new			    fn new<T: BytesContainer>(path: T) -> Self 
new			    pub fn new<T: BytesContainer>(path: T) -> Path 
new			    pub fn new<T: BytesContainer>(path: T) -> Path 
new			    pub fn new(value: T) -> Rc<T> 
new			    pub fn new() -> LocalHeap 
new			    pub fn new<'a>(io: &'a mut IoFactory) -> LocalIo<'a> 
new			    pub fn new() -> Death 
new			    pub fn new() -> Task 
new			    pub fn new() -> Unwinder 
new			    pub fn new(length: uint) -> ElementSwaps 
new			    pub fn new(data: T) -> UnsafeArc<T> 
new			    pub fn new(p: *mut T) -> AtomicPtr<T> 
new			    pub fn new(p: ~T) -> AtomicOption<T> 
new			    pub fn new(v: bool) -> AtomicBool 
new			    pub fn new(v: int) -> AtomicInt 
new			    pub fn new(v: uint) -> AtomicUint 
new			    fn new(mut pool: BufferPool<T>) -> Deque<T> 
new			    pub fn new() -> BufferPool<T> 
new			    unsafe fn new(log_size: int) -> Buffer<T> 
new			    pub fn new() -> Queue<T> 
new			    unsafe fn new(v: Option<T>) -> *mut Node<T> 
new			    fn new() -> *mut Node<T> 
new			    pub fn new(bound: uint) -> Queue<T> 
new			    pub fn new() -> TaskOpts 
new			    pub fn new(value: T) -> Unsafe<T> 
new			        pub unsafe fn new() -> Mutex 
new			    pub unsafe fn new() -> NativeMutex 
new			    pub unsafe fn new() -> StaticNativeMutex 
new			    pub fn new(user_data: T) -> Exclusive<T> 
new			    pub fn new() -> Vec<T> 
new2			    pub fn new2(data: T) -> (UnsafeArc<T>, UnsafeArc<T>) 
newN			    pub fn newN(data: T, num_handles: uint) -> ~[UnsafeArc<T>] 
new_in			    pub fn new_in(tmpdir: &Path, suffix: &str) -> Option<TempDir> 
new_inner			unsafe fn new_inner<T: Send>(data: T, refcount: uint) -> *mut ArcData<T> 
new_opt			    fn new_opt<T: BytesContainer>(path: T) -> Option<Self> 
new_opt			    pub fn new_opt<T: BytesContainer>(path: T) -> Option<Path> 
new_opt			    fn new_opt<T: BytesContainer>(path: T) -> Option<Path> 
new_opt			    pub fn new_opt<T: BytesContainer>(path: T) -> Option<Path> 
new_pos			        fn new_pos(i: uint, s: Direction) -> uint 
new_unchecked			    unsafe fn new_unchecked<T: BytesContainer>(path: T) -> Self;
new_unchecked			    unsafe fn new_unchecked<T: BytesContainer>(path: T) -> Path 
new_unchecked			    unsafe fn new_unchecked<T: BytesContainer>(path: T) -> Path 
new_with_dtor			    pub unsafe fn new_with_dtor(base: *mut T, len: uint,
new_with_keys			    pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher 
new_with_keys			    pub fn new_with_keys(key0: u64, key1: u64) -> SipState 
next			    fn next(&mut self) -> Option<libc::c_char> 
next			    fn next(&mut self) -> Option<T> { self.rx.recv_opt() }
next			    fn next(&mut self) -> Option<*mut Handle<'static, ()>> 
next			    fn next(&mut self) -> Option<Piece<'a>> 
next			    fn next(&mut self) -> Option<IoResult<u8>> 
next			    fn next(&mut self) -> Option<Path> 
next			    fn next(&mut self) -> Option<IoResult<T>> 
next			    fn next(&mut self) -> Option<IoResult<char>> 
next			    fn next(&mut self) -> Option<IoResult<~str>> 
next			    fn next(&mut self) -> Option<(A, B)> 
next			    fn next(&mut self) -> Option<(uint, A)> 
next			    fn next(&mut self) -> Option<A> { self.idx(0) }
next			    fn next(&mut self) -> Option<A> { self.iter.next() }
next			    fn next(&mut self) -> Option<A> { self.iter.next_back() }
next			    fn next(&mut self) -> Option<A> 
next			    fn next(&mut self) -> Option<A>;
next			    fn next(&mut self) -> Option<B> 
next			    fn next(&mut self) -> Option<A> 
next			    fn next(&mut self) -> Option<BlockedTask> 
next			            fn next(&mut self) -> Option<$elem> 
next			    fn next(&mut self) -> Option<&'a [T]> 
next			    fn next(&mut self) -> Option<&'a mut [T]> 
next			    fn next(&mut self) -> Option<(uint, uint)> 
next			    fn next(&mut self) -> Option<T> 
next			    fn next(&mut self) -> Option<~[T]> 
next			    fn next(&mut self) -> Option<&'a str> 
next			    fn next(&mut self) -> Option<(uint, char)> 
next			    fn next(&mut self) -> Option<(uint, uint)> 
next			    fn next(&mut self) -> Option<UTF16Item> 
next			    fn next(&mut self) -> Option<char> 
next			    fn next(&mut self) -> Option<T> 
next_after			    fn next_after(&self, other: f32) -> f32 
next_after			    fn next_after(x: c_float, y: c_float) -> c_float = cmath::nextafterf,
next_after			    fn next_after(&self, other: f64) -> f64 
next_after			    fn next_after(x: c_double, y: c_double) -> c_double = cmath::nextafter,
next_after			    fn next_after(&self, other: Self) -> Self;
next_back			    fn next_back(&mut self) -> Option<(A, B)> 
next_back			    fn next_back(&mut self) -> Option<(uint, A)> 
next_back			    fn next_back(&mut self) -> Option<A> { self.idx(0) }
next_back			    fn next_back(&mut self) -> Option<A> { self.iter.next() }
next_back			    fn next_back(&mut self) -> Option<A> { self.iter.next_back() }
next_back			    fn next_back(&mut self) -> Option<A> 
next_back			    fn next_back(&mut self) -> Option<A>;
next_back			    fn next_back(&mut self) -> Option<B> 
next_back			    fn next_back(&mut self) -> Option<A> 
next_back			            fn next_back(&mut self) -> Option<$elem> 
next_back			    fn next_back(&mut self) -> Option<&'a [T]> 
next_back			    fn next_back(&mut self) -> Option<&'a mut [T]> 
next_back			    fn next_back(&mut self) -> Option<T> 
next_back			    fn next_back(&mut self) -> Option<&'a str> 
next_back			    fn next_back(&mut self) -> Option<(uint, char)> 
next_back			    fn next_back(&mut self) -> Option<char> 
next_back			    fn next_back(&mut self) -> Option<T> 
next_power_of_two			pub fn next_power_of_two<T: Unsigned + Int>(n: T) -> T 
next_test_ip4			pub fn next_test_ip4() -> SocketAddr 
next_test_ip6			pub fn next_test_ip6() -> SocketAddr 
next_test_port			pub fn next_test_port() -> u16 
next_test_unix			pub fn next_test_unix() -> Path 
nextafter			        pub fn nextafter(x: c_double, y: c_double) -> c_double;
nextafterf			        pub fn nextafterf(x: c_float, y: c_float) -> c_float;
nfd_chars			    fn nfd_chars(&self) -> Normalizations<'a> 
nfd_chars			    fn nfd_chars(&self) -> Normalizations<'a>;
nfkd_chars			    fn nfkd_chars(&self) -> Normalizations<'a> 
nfkd_chars			    fn nfkd_chars(&self) -> Normalizations<'a>;
no_double_borrow_mut			    fn no_double_borrow_mut() 
no_imm_then_borrow_mut			    fn no_imm_then_borrow_mut() 
no_mut_then_imm_borrow			    fn no_mut_then_imm_borrow() 
no_runtime			    fn no_runtime() 
no_starvation			    fn no_starvation() 
nodelay			    fn nodelay(&mut self) -> IoResult<()>;
nonzero_size_of			pub fn nonzero_size_of<T>() -> uint 
nonzero_size_of_basic			    fn nonzero_size_of_basic() 
nonzero_size_of_val			pub fn nonzero_size_of_val<T>(_val: &T) -> uint 
nonzero_size_of_val_basic			    fn nonzero_size_of_val_basic() 
normalize			    fn normalize<V: Vector<u8>+CloneableVector<u8>>(v: V) -> ~[u8] 
normalize_			    fn normalize_<S: Str>(s: S) -> (Option<PathPrefix>, ~str) 
normalize__			    fn normalize__(s: &str, prefix: Option<PathPrefix>) -> Option<~str> 
normalize_helper			fn normalize_helper<'a>(v: &'a [u8], is_abs: bool) -> Option<~[&'a [u8]]> 
normalize_helper			fn normalize_helper<'a>(s: &'a str, prefix: Option<PathPrefix>) -> (bool,Option<~[&'a str]>) 
not			    fn not(&self) -> bool { !*self }
not			    fn not(&self) -> $T { !*self }
not			    fn not(&self) -> $T { !*self }
not			    fn not(&self) -> Result;
nth			    fn nth(&mut self, mut n: uint) -> Option<A> 
null			    fn null() -> *T { null() }
null			    fn null() -> *mut T { mut_null() }
null			    fn null() -> Self;
null			pub fn null<T>() -> *T { 0 as *T }
num			mod num;
num			        impl num::One for Foo 
num			pub mod num;
num			impl num::FromStrRadix for f32 
num			impl num::ToStrRadix for f32 
num			impl num::FromStrRadix for f64 
num			impl num::ToStrRadix for f64 
num_cpus			pub fn num_cpus() -> uint 
of			    pub fn of<T: 'static>() -> TypeId 
offset			    pub fn offset<T>(dst: *T, offset: int) -> *T;
offset			    unsafe fn offset(self, count: int) -> *T { intrinsics::offset(self, count) }
offset			    unsafe fn offset(self, count: int) -> *mut T { intrinsics::offset(self as *T, count) as *mut T }
offset			    unsafe fn offset(self, count: int) -> Self;
ok			    pub fn ok(self) -> Option<T> 
one			            fn one() -> Foo 
one			    fn one() -> f32 { 1.0 }
one			    fn one() -> f64 { 1.0 }
one			    fn one() -> $T { 1 }
one			    fn one() -> Self;
one			    fn one() -> $T { 1 }
oneshot			mod oneshot;
oneshot			    pub fn oneshot(&mut self, msecs: u64) -> Receiver<()> 
oneshot			    fn oneshot(&mut self, msecs: u64) -> Receiver<()>;
only_ascii			            fn only_ascii(&self) -> bool { false }
only_ascii			    fn only_ascii(&self) -> bool { (*self as uint) < 128 }
only_ascii			    fn only_ascii(&self) -> bool { false }
only_ascii			    fn only_ascii(&self) -> bool 
only_ascii			    fn only_ascii(&self) -> bool;
op1			    pub fn op1() -> Result<int, ~str> { Ok(666) }
op2			    pub fn op2() -> Result<int, ~str> { Err(~"sadface") }
open			    pub fn open(path: &Path) -> IoResult<File> 
open			    pub fn open(fd: libc::c_int) -> IoResult<PipeStream> 
open			                pub fn open(path: *c_char, oflag: c_int, mode: c_int)
open			    pub fn open(filename: Option<&path::Path>) -> Result<DynamicLibrary, ~str> 
open_external			    pub unsafe fn open_external(filename: &path::Path) -> *u8 
open_internal			    pub unsafe fn open_internal() -> *u8 
open_mode			    pub fn open_mode(path: &Path,
open_osfhandle			                pub fn open_osfhandle(osfhandle: intptr_t,
opendir			            pub unsafe fn opendir(dirname: *c_char) -> *DIR 
option			pub mod option;
option_empty			    fn option_empty() 
option_fill			    fn option_fill() 
option_swap			    fn option_swap() 
option_take			    fn option_take() 
or			    pub fn or(self, optb: Option<T>) -> Option<T> 
or			    pub fn or(self, res: Result<T, E>) -> Result<T, E> 
or_else			    pub fn or_else(self, f: || -> Option<T>) -> Option<T> 
or_else			    pub fn or_else<F>(self, op: |E| -> Result<T, F>) -> Result<T, F> 
order			pub mod order 
os			pub mod os;
os			    pub mod os 
os			    mod os 
output			    pub fn output(prog: &str, args: &[~str]) -> IoResult<ProcessOutput> 
output			    fn output(w: &mut Writer, idx: int, addr: *libc::c_void,
owned			pub mod owned;
owns_buffer			    pub fn owns_buffer(&self) -> bool 
owns_managed			    pub fn owns_managed<T>() -> bool;
pad			    pub fn pad(&mut self, s: &str) -> Result 
pad_integral			    pub fn pad_integral(&mut self, is_positive: bool, prefix: &str, buf: &[u8]) -> Result 
page_size			pub fn page_size() -> uint 
parse			pub mod parse;
parse_bytes			pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<$T> 
parse_bytes			pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<$T> 
parse_digit			        fn parse_digit(c: char, radix: u8) -> Option<u8> 
parse_prefix			fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> 
parse_two_comps			    fn parse_two_comps<'a>(mut path: &'a str, f: |char| -> bool)
partition			    fn partition(self, f: |&T| -> bool) -> (~[T], ~[T]) 
partition			    fn partition(self, f: |&T| -> bool) -> (~[T], ~[T]);
partition			    pub fn partition(self, f: |&T| -> bool) -> (Vec<T>, Vec<T>) 
partitioned			    fn partitioned(&self, f: |&T| -> bool) -> (~[T], ~[T]) 
partitioned			    fn partitioned(&self, f: |&T| -> bool) -> (~[T], ~[T]);
partitioned			    pub fn partitioned(&self, f: |&T| -> bool) -> (Vec<T>, Vec<T>) 
path			        fn path<'a>(&'a self) -> &'a Path 
path			    pub fn path<'a>(&'a self) -> &'a Path 
path			impl path::Path 
path			    pub fn path<'a>(&'a self) -> &'a Path 
path			pub mod path;
path_relative_from			    fn path_relative_from(&self, base: &Self) -> Option<Self>;
path_relative_from			    fn path_relative_from(&self, base: &Path) -> Option<Path> 
path_relative_from			    fn path_relative_from(&self, base: &Path) -> Option<Path> 
path_relative_from_backward			    fn path_relative_from_backward(bh: &mut BenchHarness) 
path_relative_from_forward			    fn path_relative_from_forward(bh: &mut BenchHarness) 
path_relative_from_same_level			    fn path_relative_from_same_level(bh: &mut BenchHarness) 
pathconf			                pub fn pathconf(path: *c_char, name: c_int) -> c_long;
pausable_idle_callback			    fn pausable_idle_callback(&mut self,
pause			                pub fn pause() -> c_int;
pause			    fn pause(&mut self);
pclose			                pub fn pclose(stream: *FILE) -> c_int;
peek			    pub fn peek(&'a mut self) -> Option<&'a A> 
peek			    pub fn peek<'a>(&'a mut self) -> Option<&'a mut T> 
peekable			    fn peekable(self) -> Peekable<A, Self> 
peer_name			    pub fn peer_name(&mut self) -> IoResult<SocketAddr> 
peer_name			    pub fn peer_name(addr: SocketAddr) 
peer_name			    fn peer_name(&mut self) -> IoResult<SocketAddr>;
period			    fn period(&mut self, msecs: u64) -> Receiver<()>;
periodic			    pub fn periodic(&mut self, msecs: u64) -> Receiver<()> 
permutations			    fn permutations(self) -> Permutations<T> 
permutations			    fn permutations(self) -> Permutations<T>;
perror			                pub fn perror(s: *c_char);
pi			    fn pi() -> f32 { 3.14159265358979323846264338327950288 }
pi			    fn pi() -> f64 { 3.14159265358979323846264338327950288 }
pi			    fn pi() -> Self;
pipe			pub mod pipe;
pipe			                pub fn pipe(fds: *mut c_int) -> c_int;
pipe			                pub fn pipe(fds: *mut c_int, psize: c_uint, textmode: c_int)
pipe			pub fn pipe() -> Pipe 
pipe_open			    fn pipe_open(&mut self, fd: c_int) -> IoResult<~RtioPipe:Send>;
plural			    fn plural(&mut self) -> ~Method<'a> 
plural_simple			    fn plural_simple() 
pool			    pub fn pool<'a>(&'a mut self) -> &'a mut BufferPool<T> 
pop			    fn pop(&mut self, k: &K) -> Option<V>;
pop			pub fn pop<T: 'static>(key: Key<T>) -> Option<T> 
pop			    fn pop(&mut self) -> bool;
pop			    fn pop(&mut self) -> bool 
pop			    fn pop(&mut self) -> bool 
pop			    fn pop(&mut self) -> Option<T> 
pop			    fn pop(&mut self) -> Option<T>;
pop			    pub fn pop(&mut self) -> Option<T> 
pop			    unsafe fn pop(&mut self) -> Option<T> 
pop			    fn pop(&mut self) -> Option<T> 
pop			    pub fn pop(&mut self) -> Option<T> 
pop			    pub fn pop(&mut self) -> PopResult<T> 
pop			    pub fn pop(&mut self) -> Option<T> 
pop			    pub fn pop(&mut self) -> Option<T> 
pop_byte			    pub unsafe fn pop_byte(s: &mut ~str) -> Option<u8> 
pop_char			    fn pop_char(&mut self) -> Option<char> 
pop_char			    fn pop_char(&mut self) -> Option<char>;
pop_ptr			    fn pop_ptr(&mut self);
pop_ptr			    fn pop_ptr(&mut self) 
pop_ptr			    pub unsafe fn pop_ptr<T>(slice: &mut Slice<T>) -> *T 
pop_ref			    fn pop_ref(&mut self) -> Option<&'a T> 
pop_ref			    fn pop_ref(&mut self) -> Option<&'a T>;
popen			                pub fn popen(command: *c_char, mode: *c_char) -> *FILE;
position			    fn position(&mut self) -> Position<'a> 
position			    fn position(&mut self, predicate: |A| -> bool) -> Option<uint> 
position			pub unsafe fn position<T>(buf: *T, f: |&T| -> bool) -> uint 
position_elem			    fn position_elem(&self, t: &T) -> Option<uint>;
position_elem			    fn position_elem(&self, x: &T) -> Option<uint> 
posix			pub mod posix;
posix01			            pub mod posix01 
posix01			        pub mod posix01 
posix01			        pub mod posix01 {}
posix01			    pub mod posix01 
posix08			            pub mod posix08 
posix08			            pub mod posix08 {}
posix08			        pub mod posix08 
posix08			        pub mod posix08 {}
posix08			    pub mod posix08 
posix88			            pub mod posix88 
posix88			        pub mod posix88 
posix88			    pub mod posix88 
posix_madvise			                pub fn posix_madvise(addr: *c_void,
pow			    fn pow(n: f32, e: f32) -> f32 = intrinsics::powf32,
pow			    fn pow(n: f64, e: f64) -> f64 = intrinsics::powf64,
pow			pub fn pow<T: One + Mul<T, T>>(mut base: T, mut exp: uint) -> T 
powf			    fn powf(&self, n: &f32) -> f32 { pow(*self, *n) }
powf			    fn powf(&self, n: &f64) -> f64 { pow(*self, *n) }
powf			    fn powf(&self, n: &Self) -> Self;
powf32			    pub fn powf32(a: f32, x: f32) -> f32;
powf64			    pub fn powf64(a: f64, x: f64) -> f64;
powi			    fn powi(n: f32, e: i32) -> f32 = intrinsics::powif32,
powi			    fn powi(n: f64, e: i32) -> f64 = intrinsics::powif64,
powif32			    pub fn powif32(a: f32, x: i32) -> f32;
powif64			    pub fn powif64(a: f64, x: i32) -> f64;
pread			                pub fn pread(fd: c_int, buf: *c_void, count: size_t,
pread			    fn pread(&mut self, buf: &mut [u8], offset: u64) -> IoResult<int>;
pred			        fn pred(c: char) -> bool { c == ' ' }
pref_align_of			    pub fn pref_align_of<T>() -> uint;
pref_align_of			pub fn pref_align_of<T>() -> uint 
pref_align_of_val			pub fn pref_align_of_val<T>(_val: &T) -> uint 
prefix			            fn prefix(&self) -> &'static str { $prefix }
prefix			    fn prefix(&self) -> &'static str { "" }
prefix			pub fn prefix(path: &Path) -> Option<PathPrefix> 
prefix_is_verbatim			fn prefix_is_verbatim(p: Option<PathPrefix>) -> bool 
prefix_len			    fn prefix_len(&self) -> uint 
prefix_len			fn prefix_len(p: Option<PathPrefix>) -> uint 
prelude			pub mod prelude;
print			pub fn print(s: &str) 
print			    fn print(w: &mut Writer, idx: int, addr: *libc::c_void) -> IoResult<()> 
print_args			pub fn print_args(fmt: &fmt::Arguments) 
println			pub fn println(s: &str) 
println_args			pub fn println_args(fmt: &fmt::Arguments) 
process			pub mod process;
product			    fn product(&mut self) -> A 
product			    fn product(&mut self) -> A;
property			pub mod property 
pthread_attr_init			        fn pthread_attr_init(attr: *mut libc::pthread_attr_t) -> libc::c_int;
pthread_attr_setdetachstate			        fn pthread_attr_setdetachstate(attr: *mut libc::pthread_attr_t,
pthread_attr_setstacksize			        fn pthread_attr_setstacksize(attr: *mut libc::pthread_attr_t,
pthread_attr_t			                pub struct pthread_attr_t 
pthread_cond_destroy			        fn pthread_cond_destroy(cond: *mut pthread_cond_t) -> libc::c_int;
pthread_cond_init			        fn pthread_cond_init(cond: *mut pthread_cond_t,
pthread_cond_signal			        fn pthread_cond_signal(cond: *mut pthread_cond_t) -> libc::c_int;
pthread_cond_t			        pub struct pthread_cond_t { value: libc::c_int }
pthread_cond_t			        pub struct pthread_cond_t 
pthread_cond_wait			        fn pthread_cond_wait(cond: *mut pthread_cond_t,
pthread_create			        fn pthread_create(native: *mut libc::pthread_t,
pthread_detach			        fn pthread_detach(thread: libc::pthread_t) -> libc::c_int;
pthread_getspecific			    fn pthread_getspecific(key: pthread_key_t) -> *mut u8;
pthread_join			        fn pthread_join(native: libc::pthread_t,
pthread_key_create			    fn pthread_key_create(key: *mut pthread_key_t, dtor: *u8) -> c_int;
pthread_key_delete			    fn pthread_key_delete(key: pthread_key_t) -> c_int;
pthread_mutex_destroy			        fn pthread_mutex_destroy(lock: *mut pthread_mutex_t) -> libc::c_int;
pthread_mutex_init			        fn pthread_mutex_init(lock: *mut pthread_mutex_t,
pthread_mutex_lock			        fn pthread_mutex_lock(lock: *mut pthread_mutex_t) -> libc::c_int;
pthread_mutex_t			        pub struct pthread_mutex_t { value: libc::c_int }
pthread_mutex_t			        pub struct pthread_mutex_t 
pthread_mutex_trylock			        fn pthread_mutex_trylock(lock: *mut pthread_mutex_t) -> libc::c_int;
pthread_mutex_unlock			        fn pthread_mutex_unlock(lock: *mut pthread_mutex_t) -> libc::c_int;
pthread_setspecific			    fn pthread_setspecific(key: pthread_key_t, value: *mut u8) -> c_int;
pthread_yield			        fn pthread_yield() -> libc::c_int;
ptr			pub mod ptr;
ptr_eq			    pub fn ptr_eq(&self, other: &Gc<T>) -> bool 
ptr_eq			pub fn ptr_eq<T>(a: @T, b: @T) -> bool 
ptr_tests			pub mod ptr_tests 
push			    fn push<T: BytesContainer>(&mut self, path: T) 
push			pub fn push(f: proc:Send()) 
push			    fn push(&mut self, t: T) 
push			    fn push(&mut self, t: T);
push			    fn push(bh: &mut BenchHarness) 
push			    pub fn push(&mut self, t: T) 
push			    unsafe fn push(&mut self, data: T) 
push			    fn push(&mut self, value: T) -> bool 
push			    pub fn push(&mut self, value: T) -> bool 
push			    pub fn push(&mut self, t: T) 
push			    pub fn push(&mut self, t: T) 
push			    pub fn push(&mut self, value: T) 
push_abs_path_home_dir			    fn push_abs_path_home_dir(bh: &mut BenchHarness) 
push_all			    fn push_all(&mut self, rhs: &[T]) 
push_all			    fn push_all(&mut self, rhs: &[T]);
push_all			    pub fn push_all(&mut self, other: &[T]) 
push_all_move			    fn push_all_move(&mut self, mut rhs: ~[T]) 
push_all_move			    fn push_all_move(&mut self, rhs: ~[T]);
push_all_move			    pub fn push_all_move(&mut self, other: Vec<T>) 
push_byte			    pub unsafe fn push_byte(s: &mut ~str, b: u8) 
push_bytes			    pub fn push_bytes(dst: &mut ~[u8], src: &[u8]) 
push_bytes			    pub unsafe fn push_bytes(s: &mut ~str, bytes: &[u8]) 
push_char			    fn push_char(&mut self, c: char) 
push_char			    fn push_char(&mut self, c: char);
push_exact			    fn push_exact() 
push_exact			    fn push_exact(&mut self, buf: &mut ~[u8], len: uint) -> IoResult<()> 
push_exact_eof			    fn push_exact_eof() 
push_exact_error			    fn push_exact_error() 
push_exact_partial			    fn push_exact_partial() 
push_fast			        unsafe fn push_fast<T>(this: &mut ~[T], t: T) 
push_home_dir			    fn push_home_dir(bh: &mut BenchHarness) 
push_many			    fn push_many<T: BytesContainer>(&mut self, paths: &[T]) 
push_many_abs_path_home_dir			    fn push_many_abs_path_home_dir(bh: &mut BenchHarness) 
push_many_home_dir			    fn push_many_home_dir(bh: &mut BenchHarness) 
push_ptr			    fn push_ptr(&mut self);
push_ptr			    fn push_ptr(&mut self) 
push_str			    fn push_str(&mut self, rhs: &str) 
push_str			    fn push_str(&mut self, rhs: &str);
push_str			pub fn push_str(lhs: &mut ~str, rhs: &str) 
push_str_no_overallocate			    fn push_str_no_overallocate(&mut self, rhs: &str) 
push_str_no_overallocate			    fn push_str_no_overallocate(&mut self, rhs: &str);
push_unchecked			    unsafe fn push_unchecked<T: BytesContainer>(&mut self, path: T);
push_unchecked			    unsafe fn push_unchecked<T: BytesContainer>(&mut self, path: T) 
push_unchecked			    unsafe fn push_unchecked<T: BytesContainer>(&mut self, path: T) 
put			    pub fn put(_args: ~[~[u8]]) 
put			    pub fn put(args: ~[~[u8]]) 
put			    fn put(value: ~Self);
put			    fn put(value: ~Task) { unsafe { local_ptr::put(value) } }
put			    pub unsafe fn put<T>(sched: ~T) 
put			    unsafe fn put(&mut self, i: int, t: T) 
put_runtime			    pub fn put_runtime(&mut self, ops: ~Runtime:Send) 
putenv			                pub fn putenv(string: *c_char) -> c_int;
puts			    fn puts(s: *libc::c_char);
puts			                pub fn puts(s: *c_char) -> c_int;
pwrite			                pub fn pwrite(fd: c_int, buf: *c_void, count: size_t,
pwrite			    fn pwrite(&mut self, buf: &[u8], offset: u64) -> IoResult<()>;
radix			pub fn radix<T>(x: T, base: u8) -> RadixFmt<T, Radix> 
raise_fd_limit			    pub unsafe fn raise_fd_limit() 
raise_fd_limit			    pub unsafe fn raise_fd_limit() {}
raise_fd_limit			pub fn raise_fd_limit() 
rand			                pub fn rand() -> c_int;
random_inserts			    fn random_inserts(bh: &mut BenchHarness) 
random_removes			    fn random_removes(bh: &mut BenchHarness) 
range			pub fn range<A: Add<A, A> + Ord + Clone + One>(start: A, stop: A) -> Range<A> 
range_inclusive			pub fn range_inclusive<A: Add<A, A> + Ord + Clone + One + ToPrimitive>(start: A, stop: A)
range_step			pub fn range_step<A: CheckedAdd + Ord + Clone + Zero>(start: A, stop: A, step: A) -> RangeStep<A> 
range_step_inclusive			pub fn range_step_inclusive<A: CheckedAdd + Ord + Clone + Zero>(start: A, stop: A,
raw			pub mod raw;
raw			pub mod raw 
raw			pub mod raw 
rc			pub mod rc;
read			            fn read(&mut self, _: &mut [u8]) -> io::IoResult<uint> 
read			        fn read(&mut self, _: &mut [u8]) -> io::IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			        fn read(&mut self, _: &mut [u8]) -> io::IoResult<uint> 
read			        fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> 
read			    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { self.inner.read(buf) }
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { self.read(buf) }
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint>;
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { self.obj.read(buf) }
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { self.obj.read(buf) }
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { self.obj.read(buf) }
read			        fn read(stream: Option<io::PipeStream>) -> Receiver<IoResult<~[u8]>> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    fn read(&mut self, _buf: &mut [u8]) -> io::IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> 
read			                pub fn read(fd: c_int, buf: *mut c_void, count: c_uint)
read			                pub fn read(fd: c_int, buf: *mut c_void, count: size_t)
read			pub unsafe fn read<T>(src: *T) -> T 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<int>;
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint>;
read_all			    pub fn read_all(input: &mut Reader) -> ~str 
read_and_zero			pub unsafe fn read_and_zero<T>(dest: *mut T) -> T 
read_atomically			    fn read_atomically<T>(&mut self, cb: |&mut Parser| -> Option<T>)
read_be_f32			    fn read_be_f32(&mut self) -> IoResult<f32> 
read_be_f64			    fn read_be_f64(&mut self) -> IoResult<f64> 
read_be_i16			    fn read_be_i16(&mut self) -> IoResult<i16> 
read_be_i32			    fn read_be_i32(&mut self) -> IoResult<i32> 
read_be_i64			    fn read_be_i64(&mut self) -> IoResult<i64> 
read_be_int			    fn read_be_int(&mut self) -> IoResult<int> 
read_be_int_n			    fn read_be_int_n(&mut self, nbytes: uint) -> IoResult<i64> 
read_be_u16			    fn read_be_u16(&mut self) -> IoResult<u16> 
read_be_u32			    fn read_be_u32(&mut self) -> IoResult<u32> 
read_be_u64			    fn read_be_u64(&mut self) -> IoResult<u64> 
read_be_uint			    fn read_be_uint(&mut self) -> IoResult<uint> 
read_be_uint_n			    fn read_be_uint_n(&mut self, nbytes: uint) -> IoResult<u64> 
read_byte			    fn read_byte() 
read_byte			    fn read_byte(&mut self) -> IoResult<u8> 
read_byte_0_bytes			    fn read_byte_0_bytes() 
read_byte_eof			    fn read_byte_eof() 
read_byte_error			    fn read_byte_error() 
read_bytes			    fn read_bytes() 
read_bytes_eof			    fn read_bytes_eof() 
read_bytes_partial			    fn read_bytes_partial() 
read_char			    fn read_char(&mut self) -> IoResult<char> 
read_char			    fn read_char(&mut self) -> Option<char> 
read_char_buffered			    fn read_char_buffered() 
read_digit			    fn read_digit(&mut self, radix: u8) -> Option<u8> 
read_exact			    fn read_exact(&mut self, len: uint) -> IoResult<~[u8]> 
read_given_char			    fn read_given_char(&mut self, c: char) -> Option<char> 
read_groups			        fn read_groups(p: &mut Parser, groups: &mut [u16, ..8], limit: uint) -> (uint, bool) 
read_i8			    fn read_i8(&mut self) -> IoResult<i8> 
read_ip_addr			    fn read_ip_addr(&mut self) -> Option<IpAddr> 
read_ipv4_addr			    fn read_ipv4_addr(&mut self) -> Option<IpAddr> 
read_ipv4_addr_impl			    fn read_ipv4_addr_impl(&mut self) -> Option<IpAddr> 
read_ipv6_addr			    fn read_ipv6_addr(&mut self) -> Option<IpAddr> 
read_ipv6_addr_impl			    fn read_ipv6_addr_impl(&mut self) -> Option<IpAddr> 
read_le_f32			    fn read_le_f32(&mut self) -> IoResult<f32> 
read_le_f64			    fn read_le_f64(&mut self) -> IoResult<f64> 
read_le_i16			    fn read_le_i16(&mut self) -> IoResult<i16> 
read_le_i32			    fn read_le_i32(&mut self) -> IoResult<i32> 
read_le_i64			    fn read_le_i64(&mut self) -> IoResult<i64> 
read_le_int			    fn read_le_int(&mut self) -> IoResult<int> 
read_le_int_n			    fn read_le_int_n(&mut self, nbytes: uint) -> IoResult<i64> 
read_le_u16			    fn read_le_u16(&mut self) -> IoResult<u16> 
read_le_u32			    fn read_le_u32(&mut self) -> IoResult<u32> 
read_le_u64			    fn read_le_u64(&mut self) -> IoResult<u64> 
read_le_uint			    fn read_le_uint(&mut self) -> IoResult<uint> 
read_le_uint_n			    fn read_le_uint_n(&mut self, nbytes: uint) -> IoResult<u64> 
read_line			    fn read_line(&mut self) -> IoResult<~str> 
read_number			    fn read_number(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> 
read_number_impl			    fn read_number_impl(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> 
read_or			    fn read_or<T>(&mut self, parsers: &[|&mut Parser| -> Option<T>])
read_seq_3			    fn read_seq_3<A,
read_socket_addr			    fn read_socket_addr(&mut self) -> Option<SocketAddr> 
read_till_eof			    fn read_till_eof<T>(&mut self, cb: |&mut Parser| -> Option<T>)
read_to_end			    fn read_to_end() 
read_to_end			    fn read_to_end(&mut self) -> IoResult<~[u8]> 
read_to_end_error			    fn read_to_end_error() 
read_to_str			    fn read_to_str(&mut self) -> IoResult<~str> 
read_u8			    fn read_u8(&mut self) -> IoResult<u8> 
read_until			    fn read_until(&mut self, byte: u8) -> IoResult<~[u8]> 
readdir			pub fn readdir(path: &Path) -> IoResult<~[Path]> 
readdir_r			            pub unsafe fn readdir_r(dirp: *DIR,
readlink			pub fn readlink(path: &Path) -> IoResult<Path> 
readlink			                pub fn readlink(path: *c_char,
real_args			fn real_args() -> ~[~str] 
real_args_as_bytes			fn real_args_as_bytes() -> ~[~[u8]] 
realloc			                pub fn realloc(p: *mut c_void, size: size_t) -> *mut c_void;
realloc			    fn realloc(&mut self, alloc: *mut Box, size: uint) -> *mut Box 
realloc			    pub fn realloc(&mut self, ptr: *mut Box, size: uint) -> *mut Box 
realloc_raw			pub unsafe fn realloc_raw(ptr: *mut u8, size: uint) -> *mut u8 
reawaken			    fn reawaken(~self, to_wake: ~Task);
reawaken			    pub fn reawaken(mut ~self) 
recip			    fn recip(&self) -> f32 { 1.0 \/ *self }
recip			    fn recip(&self) -> f64 { 1.0 \/ *self }
recip			    fn recip(&self) -> Self;
record_sp_limit			            fn record_sp_limit(limit: *c_void);
record_sp_limit			pub unsafe fn record_sp_limit(limit: uint) 
record_stack_bounds			pub unsafe fn record_stack_bounds(stack_lo: uint, stack_hi: uint) 
recv			            fn recv(rx: Receiver<~int>, i: int) 
recv			    pub fn recv(&self) -> T 
recv			    pub fn recv(&mut self) -> Result<T, Failure<T>> 
recv			    pub fn recv(&mut self) -> T { self.rx.recv() }
recv			    pub fn recv(&mut self) -> Result<T, Failure> 
recv			    pub fn recv(&mut self) -> Result<T, Failure<T>> 
recv			    pub fn recv(&self) -> Option<T> 
recv			            pub fn recv(socket: SOCKET, buf: *mut c_void, len: c_int,
recv			            pub fn recv(socket: c_int, buf: *mut c_void, len: size_t,
recv_from_outside_runtime			    fn recv_from_outside_runtime() 
recv_opt			    pub fn recv_opt(&self) -> Option<T> 
recv_opt			    pub fn recv_opt(&mut self) -> Option<T> { self.rx.recv_opt() }
recvfrom			    pub fn recvfrom(&mut self, buf: &mut [u8])
recvfrom			            pub fn recvfrom(socket: SOCKET, buf: *mut c_void, len: c_int,
recvfrom			            pub fn recvfrom(socket: c_int, buf: *mut c_void, len: size_t,
recvfrom			    fn recvfrom(&mut self, buf: &mut [u8]) -> IoResult<(uint, SocketAddr)>;
ref_slice			pub fn ref_slice<'a, A>(s: &'a A) -> &'a [A] 
reference			mod reference;
reflect			pub mod reflect;
register			    pub fn register(&mut self, signum: Signum) -> io::IoResult<()> 
release			    fn release(&mut self, _alloc: &AllocHeader) {}
release			    fn release(&mut self, alloc: &AllocHeader) 
rem			    fn rem(&self, other: &f32) -> f32 { *self % *other }
rem			    fn rem(&self, other: &f64) -> f64 { *self % *other }
rem			    fn rem(&self, other: &$T) -> $T { *self % *other }
rem			    fn rem(&self, other: &$T) -> $T { *self % *other }
rem			    fn rem(&self, rhs: &RHS) -> Result;
remote_callback			    fn remote_callback(&mut self, ~Callback:Send) -> ~RemoteCallback:Send;
remove			    pub unsafe fn remove(&mut self) 
remove			    fn remove(&mut self, key: &K) -> bool 
remove			    fn remove(&mut self, value: &T) -> bool;
remove			                pub fn remove(filename: *c_char) -> c_int;
remove			    fn remove(&mut self, i: uint) -> Option<T> 
remove			    fn remove(&mut self, i: uint) -> Option<T>;
remove			    pub fn remove(&mut self, index: uint) -> Option<T> 
rename			pub fn rename(from: &Path, to: &Path) -> IoResult<()> 
rename			                pub fn rename(oldname: *c_char, newname: *c_char) -> c_int;
repeat			    fn repeat(&self, nn: uint) -> ~str 
repeat			    fn repeat(&self, nn: uint) -> ~str;
replace			pub fn replace<T>(dest: &mut T, mut src: T) -> T 
replace			pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T 
replace			    fn replace(&self, from: &str, to: &str) -> ~str 
replace			    fn replace(&self, from: &str, to: &str) -> ~str;
replace			pub fn replace(s: &str, from: &str, to: &str) -> ~str 
replace_path			        fn replace_path(me: &mut Path, path: &str, prefix: Option<PathPrefix>) 
repr			pub mod repr;
repr			    fn repr(&self) -> T { unsafe { cast::transmute_copy(self) } }
repr_to_str			pub fn repr_to_str<T>(t: &T) -> ~str 
reserve			    fn reserve(&mut self, n: uint) 
reserve			    fn reserve(&mut self, n: uint);
reserve			    fn reserve(&mut self, n: uint) 
reserve			    fn reserve(&mut self, n: uint);
reserve			    pub fn reserve(&mut self, capacity: uint) 
reserve_additional			    fn reserve_additional(&mut self, n: uint) 
reserve_additional			    fn reserve_additional(&mut self, n: uint);
reserve_additional			    pub fn reserve_additional(&mut self, extra: uint) 
reserve_exact			    fn reserve_exact(&mut self, n: uint) 
reserve_exact			    fn reserve_exact(&mut self, n: uint);
reserve_exact			    fn reserve_exact(&mut self, n: uint) 
reserve_exact			    fn reserve_exact(&mut self, n: uint);
reserve_exact			    pub fn reserve_exact(&mut self, capacity: uint) 
reset			    pub fn reset(&mut self) 
reset_fuse			    pub fn reset_fuse(&mut self) 
reset_helper			fn reset_helper(w: ~Writer:Send,
resize			    unsafe fn resize(&self, b: int, t: int, delta: int) -> Buffer<T> 
result			    pub fn result(&self) -> u64 
result			mod result;
result			pub mod result;
result			    pub fn result(&mut self) -> TaskResult 
result_bytes			        fn result_bytes(h: u64) -> ~[u8] 
result_str			        fn result_str(h: u64) -> ~str 
resume			    fn resume(&mut self);
retain			    fn retain(&mut self, f: |t: &T| -> bool) 
retain			    fn retain(&mut self, f: |t: &T| -> bool);
rev			    fn rev(self) -> Rev<Self> 
rev_components			    pub fn rev_components<'a>(&'a self) -> RevComponents<'a> 
rev_components			    pub fn rev_components<'a>(&'a self) -> RevComponents<'a> 
rev_iter			    fn rev_iter(self) -> RevItems<'a, T> 
rev_iter			    fn rev_iter(self) -> RevItems<'a, T>;
rev_str_components			    pub fn rev_str_components<'a>(&'a self) -> RevStrComponents<'a> 
rev_str_components			    pub fn rev_str_components<'a>(&'a self) -> RevStrComponents<'a> 
reverse			    fn reverse(self) 
reverse			    fn reverse(self);
reverse			    pub fn reverse(&mut self) 
reverse_			    fn reverse_(&mut self) 
reverse_			    fn reverse_(&mut self);
rewind			                pub fn rewind(stream: *FILE);
rewinddir			                pub fn rewinddir(dirp: *DIR);
rfind			    fn rfind<C: CharEq>(&self, search: C) -> Option<uint> 
rfind			    fn rfind<C: CharEq>(&self, search: C) -> Option<uint>;
rint			    fn rint(n: f32) -> f32 = intrinsics::rintf32,
rint			    fn rint(n: f64) -> f64 = intrinsics::rintf64,
rintf32			    pub fn rintf32(x: f32) -> f32;
rintf64			    pub fn rintf64(x: f64) -> f64;
rlimit			    struct rlimit 
rmdir			pub fn rmdir(path: &Path) -> IoResult<()> 
rmdir			                pub fn rmdir(path: *c_char) -> c_int;
rmdir_recursive			pub fn rmdir_recursive(path: &Path) -> IoResult<()> 
rng			    fn rng() 
root_path			    fn root_path(&self) -> Option<Self>;
root_path			    fn root_path(&self) -> Option<Path> 
root_path			    fn root_path(&self) -> Option<Path> 
round			    fn round(&self) -> f32 { round(*self) }
round			    fn round(n: f32) -> f32 = intrinsics::roundf32,
round			    fn round(&self) -> f64 { round(*self) }
round			    fn round(n: f64) -> f64 = intrinsics::roundf64,
round			    fn round(&self) -> Self;
round_to_zero			        fn round_to_zero(&self) -> $t { self.trunc() }
round_to_zero			    fn round_to_zero(&self)   -> Self;
round_up			fn round_up(from: uint, to: uint) -> uint 
roundf32			    pub fn roundf32(x: f32) -> f32;
roundf64			    pub fn roundf64(x: f64) -> f64;
rposition			    fn rposition(&mut self, predicate: |A| -> bool) -> Option<uint> 
rposition_elem			    fn rposition_elem(&self, t: &T) -> Option<uint> 
rposition_elem			    fn rposition_elem(&self, t: &T) -> Option<uint>;
rsplit			    fn rsplit(self, pred: 'a |&T| -> bool) -> RevSplits<'a, T> 
rsplit			    fn rsplit(self, pred: 'a |&T| -> bool) -> RevSplits<'a, T>;
rsplit			    fn rsplit<Sep: CharEq>(&self, sep: Sep) -> RevCharSplits<'a, Sep> 
rsplit			    fn rsplit<Sep: CharEq>(&self, sep: Sep) -> RevCharSplits<'a, Sep>;
rsplitn			    fn rsplitn(self,  n: uint, pred: 'a |&T| -> bool) -> RevSplits<'a, T>;
rsplitn			    fn rsplitn(self, n: uint, pred: 'a |&T| -> bool) -> RevSplits<'a, T> 
rsplitn			    fn rsplitn<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitsN<'a, Sep>;
rsplitn			    fn rsplitn<Sep: CharEq>(&self, sep: Sep, count: uint)
rsqrt			    fn rsqrt(&self) -> f32 { self.sqrt().recip() }
rsqrt			    fn rsqrt(&self) -> f64 { self.sqrt().recip() }
rsqrt			    fn rsqrt(&self) -> Self;
rt			pub mod rt;
rt			pub mod rt;
rtdeps			mod rtdeps;
rtio			pub mod rtio;
run			    fn run(&mut self, piece: &rt::Piece, cur: Option<&str>) -> Result 
run			pub fn run() 
run			    fn run(&mut self);
run			    pub fn run(~self, f: ||) -> ~Task 
run_env			    pub fn run_env(env: Option<~[(~str, ~str)]>) -> Process 
run_fmt			        fn run_fmt(fmt: &::std::fmt::Arguments) -> ! 
run_in_bare_thread			pub fn run_in_bare_thread(f: proc:Send()) 
run_output			    pub fn run_output(args: ProcessConfig) -> ~str 
run_pwd			    pub fn run_pwd(dir: Option<&Path>) -> Process 
run_stampede			    fn run_stampede() 
run_utf8_validation_iterator			fn run_utf8_validation_iterator(iter: &mut slice::Items<u8>) -> bool 
running_on_valgrind			pub fn running_on_valgrind() -> bool 
runplural			    fn runplural(&mut self, value: uint, pieces: &[rt::Piece]) -> Result 
rust_eh_personality			    pub extern "C" fn rust_eh_personality(
rust_eh_personality_catch			    pub extern "C" fn rust_eh_personality_catch(
rust_env_pairs			                fn rust_env_pairs() -> **c_char;
rust_exception_class			fn rust_exception_class() -> uw::_Unwind_Exception_Class 
rust_fail			        fn rust_fail() -> ! 
rust_get_num_cpus			        fn rust_get_num_cpus() -> libc::uintptr_t;
rust_opendir			                fn rust_opendir(dirname: *c_char) -> *DIR;
rust_readdir_r			                fn rust_readdir_r(dirp: *DIR, entry: *mut dirent_t,
rust_running_on_valgrind			    fn rust_running_on_valgrind() -> uintptr_t;
rust_stack_exhausted			pub extern "C" fn rust_stack_exhausted() 
rust_try			            fn rust_try(f: extern "C" fn(*c_void, *c_void),
safe_get			    fn safe_get(xs: &[u8], i: uint, total: uint) -> u8 
same			    fn same(fmt: &'static str, p: ~[Piece<'static>]) 
saturating_add			    fn saturating_add(self, v: Self) -> Self;
saturating_add			    fn saturating_add(self, v: T) -> T 
saturating_sub			    fn saturating_sub(self, v: Self) -> Self;
saturating_sub			    fn saturating_sub(self, v: T) -> T 
scan			    fn scan<'r, St, B>(self, initial_state: St, f: 'r |&mut St, A| -> Option<B>)
sched_yield			        fn sched_yield() -> libc::c_int;
secondary			    fn secondary() -> Option<Path> 
seek			    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> 
seek			    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> 
seek			    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()>;
seek			    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> 
seek			    fn seek(&mut self, pos: i64, whence: SeekStyle) -> IoResult<u64>;
seek_before_0			    fn seek_before_0() 
seek_past_end			    fn seek_past_end() 
seekdir			                pub fn seekdir(dirp: *DIR, loc: c_long);
select			mod select;
select			    fn select(&mut self) -> ~Method<'a> 
select_cases			    fn select_cases() 
select_simple			    fn select_simple() 
self_exe_name			pub fn self_exe_name() -> Option<Path> 
self_exe_path			pub fn self_exe_path() -> Option<Path> 
send			            fn send(tx: Sender<~int>, i: int) 
send			            fn send(tx: SyncSender<~int>, i: int) 
send			    pub fn send(&self, t: T) 
send			    pub fn send(&mut self, t: T) -> bool 
send			    pub fn send(&mut self, t: T) -> bool 
send			    pub fn send(&mut self, t: T) -> bool 
send			    pub fn send(&self, t: T) -> Result<(), T> 
send			            pub fn send(socket: SOCKET, buf: *mut c_void, len: c_int,
send			            pub fn send(socket: c_int, buf: *mut c_void, len: size_t,
send_from_outside_runtime			    fn send_from_outside_runtime() 
send_opt			    pub fn send_opt(&self, t: T) -> Option<T> 
sendto			    pub fn sendto(&mut self, buf: &[u8], dst: SocketAddr) -> IoResult<()> 
sendto			            pub fn sendto(socket: SOCKET, buf: *c_void, len: c_int,
sendto			            pub fn sendto(socket: c_int, buf: *c_void, len: size_t,
sendto			    fn sendto(&mut self, buf: &[u8], dst: SocketAddr) -> IoResult<()>;
sent			    pub fn sent(&self) -> bool 
sepidx_or_prefix_len			    fn sepidx_or_prefix_len(&self) -> Option<(uint,uint,uint)> 
set			    pub fn set(&self, value: T) 
set			pub fn set<T: 'static>(key: Key<T>, data: T) 
set			pub unsafe fn set(key: Key, value: *mut u8) 
set_exit_status			pub fn set_exit_status(code: int) 
set_extension			    fn set_extension<T: BytesContainer>(&mut self, extension: T) 
set_filename			    fn set_filename<T: BytesContainer>(&mut self, filename: T) 
set_filename_unchecked			    unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T);
set_filename_unchecked			    unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T) 
set_filename_unchecked			    unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T) 
set_len			    unsafe fn set_len(&mut self, new_len: uint) 
set_len			    unsafe fn set_len(&mut self, new_len: uint);
set_len			    unsafe fn set_len(&mut self, new_len: uint) 
set_len			    unsafe fn set_len(&mut self, new_len: uint);
set_len			    pub unsafe fn set_len(&mut self, len: uint) 
set_memory			    pub fn set_memory<T>(dst: *mut T, val: u8, count: uint);
set_memory			pub unsafe fn set_memory<T>(dst: *mut T, c: u8, count: uint) 
set_memory			        fn set_memory(self, value: u8) 
set_memory			        fn set_memory(self, value: u8);
set_raw			    pub fn set_raw(&mut self, raw: bool) -> IoResult<()> 
set_raw			    fn set_raw(&mut self, raw: bool) -> IoResult<()>;
set_stderr			pub fn set_stderr(stderr: ~Writer:Send) -> Option<~Writer:Send> 
set_stdout			pub fn set_stdout(stdout: ~Writer:Send) -> Option<~Writer:Send> 
setbuf			                pub fn setbuf(stream: *FILE, buf: *c_char);
setenv			                pub fn setenv(name: *c_char, val: *c_char, overwrite: c_int)
setenv			pub fn setenv(n: &str, v: &str) 
setgid			                pub fn setgid(gid: gid_t) -> c_int;
setpgid			                pub fn setpgid(pid: pid_t, pgid: pid_t) -> c_int;
setrlimit			        fn setrlimit(resource: libc::c_int, rlp: *rlimit) -> libc::c_int;
setsid			                pub fn setsid() -> pid_t;
setsockopt			            pub fn setsockopt(socket: SOCKET, level: c_int, name: c_int,
setsockopt			            pub fn setsockopt(socket: c_int, level: c_int, name: c_int,
setuid			                pub fn setuid(uid: uid_t) -> c_int;
setvbuf			                pub fn setvbuf(stream: *FILE,
shared			mod shared;
shares_volume			        fn shares_volume(me: &Path, path: &str) -> bool 
shift			    fn shift(&mut self) -> Option<T> 
shift			    fn shift(&mut self) -> Option<T>;
shift			    pub fn shift(&mut self) -> Option<T> 
shift_byte			    pub unsafe fn shift_byte(s: &mut ~str) -> Option<u8> 
shift_char			    fn shift_char(&mut self) -> Option<char> 
shift_char			    fn shift_char(&mut self) -> Option<char>;
shift_ptr			    pub unsafe fn shift_ptr<T>(slice: &mut Slice<T>) -> *T 
shift_ref			    fn shift_ref(&mut self) -> Option<&'a T> 
shift_ref			    fn shift_ref(&mut self) -> Option<&'a T>;
shl			    fn shl(&self, other: &$T) -> $T { *self << *other }
shl			    fn shl(&self, other: &$T) -> $T { *self << *other }
shl			    fn shl(&self, rhs: &RHS) -> Result;
shm_open			                pub fn shm_open(name: *c_char, oflag: c_int, mode: mode_t)
shm_unlink			                pub fn shm_unlink(name: *c_char) -> c_int;
shouldnt_be_public			pub mod shouldnt_be_public 
shr			    fn shr(&self, other: &$T) -> $T { *self >> *other }
shr			    fn shr(&self, other: &$T) -> $T { *self >> *other }
shr			    fn shr(&self, rhs: &RHS) -> Result;
shrink_to_fit			    fn shrink_to_fit(&mut self) 
shrink_to_fit			    fn shrink_to_fit(&mut self);
shrink_to_fit			    pub fn shrink_to_fit(&mut self) 
shutdown			            pub fn shutdown(socket: SOCKET, how: c_int) -> c_int;
shutdown			            pub fn shutdown(socket: c_int, how: c_int) -> c_int;
sigint			    fn sigint() 
signal			pub mod signal;
signal			    pub fn signal(&mut self, signal: int) -> IoResult<()> 
signal			                pub fn signal(signum: c_int,
signal			        pub mod signal 
signal			    fn signal(&mut self, signal: Signum, channel: Sender<Signum>)
signal			        pub unsafe fn signal(&self) { pthread_cond_signal(self.cond.get()); }
signal			        pub unsafe fn signal(&self) 
signal			    pub unsafe fn signal(&self) 
signal_exit			    pub fn signal_exit(&mut self) -> IoResult<()> 
signal_kill			    pub fn signal_kill(&mut self) -> IoResult<()> 
signal_noguard			    pub unsafe fn signal_noguard(&self) { self.inner.signal() }
signal_noguard			    pub unsafe fn signal_noguard(&self) { self.inner.signal_noguard() }
signum			    fn signum(&self) -> f32 
signum			    fn signum(&self) -> f64 
signum			    fn signum(&self) -> $T 
signum			    fn signum(&self) -> Self;
simd			pub mod simd;
simple			    fn simple() 
sin			    fn sin(&self) -> f32 { sin(*self) }
sin			    fn sin(n: f32) -> f32 = intrinsics::sinf32,
sin			    fn sin(&self) -> f64 { sin(*self) }
sin			    fn sin(n: f64) -> f64 = intrinsics::sinf64,
sin			    fn sin(&self) -> Self;
sin_cos			    fn sin_cos(&self) -> (f32, f32) 
sin_cos			    fn sin_cos(&self) -> (f64, f64) 
sin_cos			    fn sin_cos(&self) -> (Self, Self);
sinf32			    pub fn sinf32(x: f32) -> f32;
sinf64			    pub fn sinf64(x: f64) -> f64;
sinh			    fn sinh(&self) -> f32 { sinh(*self) }
sinh			    fn sinh(n: c_float) -> c_float = cmath::sinhf,
sinh			        pub fn sinh(n: c_double) -> c_double;
sinh			    fn sinh(&self) -> f64 { sinh(*self) }
sinh			    fn sinh(n: c_double) -> c_double = cmath::sinh,
sinh			    fn sinh(&self) -> Self;
sinhf			        pub fn sinhf(n: c_float) -> c_float;
sip			pub mod sip;
size			    fn size(&self) -> uint { self.size }
size			    fn size() -> uint 
size			    fn size(&self) -> int { 1 << self.log_size }
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) { (0, None) }
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) { (uint::MAX, None) }
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			            fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_of			    pub fn size_of<T>() -> uint;
size_of			pub fn size_of<T>() -> uint 
size_of_32			    fn size_of_32() 
size_of_64			    fn size_of_64() 
size_of_basic			    fn size_of_basic() 
size_of_val			pub fn size_of_val<T>(_val: &T) -> uint 
size_of_val_basic			    fn size_of_val_basic() 
skip			    fn skip(self, n: uint) -> Skip<Self> 
skip_while			    fn skip_while<'r>(self, predicate: 'r |&A| -> bool) -> SkipWhile<'r, A, Self> 
sleep			    pub fn sleep(&mut self, msecs: u64) 
sleep			pub fn sleep(msecs: u64) 
sleep			                pub fn sleep(secs: c_uint) -> c_uint;
sleep			    fn sleep(&mut self, msecs: u64);
sleeper			    pub fn sleeper() -> Process 
slice			pub mod slice;
slice			    fn slice(&self, start: uint, end: uint) -> &'a [T] 
slice			    fn slice(&self, start: uint, end: uint) -> &'a [T];
slice			    fn slice(&self, begin: uint, end: uint) -> &'a str 
slice			    fn slice(&self, begin: uint, end: uint) -> &'a str;
slice			    pub fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [T] 
slice_bytes			    pub unsafe fn slice_bytes<'a>(s: &'a str, begin: uint, end: uint) -> &'a str 
slice_chars			    fn slice_chars(&self, begin: uint, end: uint) -> &'a str 
slice_chars			    fn slice_chars(&self, begin: uint, end: uint) -> &'a str;
slice_from			    fn slice_from(&self, start: uint) -> &'a [T] 
slice_from			    fn slice_from(&self, start: uint) -> &'a [T];
slice_from			    fn slice_from(&self, begin: uint) -> &'a str 
slice_from			    fn slice_from(&self, begin: uint) -> &'a str;
slice_from			    pub fn slice_from<'a>(&'a self, start: uint) -> &'a [T] 
slice_shift_char			    fn slice_shift_char(&self) -> (Option<char>, &'a str) 
slice_shift_char			    fn slice_shift_char(&self) -> (Option<char>, &'a str);
slice_to			    fn slice_to(&self, end: uint) -> &'a [T] 
slice_to			    fn slice_to(&self, end: uint) -> &'a [T];
slice_to			    fn slice_to(&self, end: uint) -> &'a str 
slice_to			    fn slice_to(&self, end: uint) -> &'a str;
slice_to			    pub fn slice_to<'a>(&'a self, end: uint) -> &'a [T] 
slice_unchecked			    pub unsafe fn slice_unchecked<'a>(s: &'a str, begin: uint, end: uint) -> &'a str 
small_stacks			    fn small_stacks() 
smalltest			    pub fn smalltest(server: proc:Send(UnixStream), client: proc:Send(UnixStream)) 
smoke			    fn smoke() { Thread::start(proc (){}).join(); }
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke_bound			    fn smoke_bound() 
smoke_cond			    fn smoke_cond() 
smoke_cond_noguard			    fn smoke_cond_noguard() 
smoke_lock			    fn smoke_lock() 
smoke_lock_noguard			    fn smoke_lock_noguard() 
smoke_test			        fn smoke_test() 
smoketest_cell			    fn smoketest_cell() 
sockaddr			                pub struct sockaddr 
sockaddr_in			                pub struct sockaddr_in 
sockaddr_in6			                pub struct sockaddr_in6 
sockaddr_storage			                pub struct sockaddr_storage 
sockaddr_un			                pub struct sockaddr_un 
socket			            pub fn socket(domain: c_int, ty: c_int, protocol: c_int) -> SOCKET;
socket			            pub fn socket(domain: c_int, ty: c_int, protocol: c_int) -> c_int;
socket_name			    pub fn socket_name(&mut self) -> IoResult<SocketAddr> 
socket_name			    pub fn socket_name(addr: SocketAddr) 
socket_name			    pub fn socket_name(&mut self) -> IoResult<SocketAddr> 
socket_name			    pub fn socket_name(addr: SocketAddr) 
socket_name			    fn socket_name(&mut self) -> IoResult<SocketAddr>;
sort			    fn sort(self) 
sort			    fn sort(self);
sort			    pub fn sort(&mut self) 
sort_big_random_large			    fn sort_big_random_large(bh: &mut BenchHarness) 
sort_big_random_medium			    fn sort_big_random_medium(bh: &mut BenchHarness) 
sort_big_random_small			    fn sort_big_random_small(bh: &mut BenchHarness) 
sort_big_sorted			    fn sort_big_sorted(bh: &mut BenchHarness) 
sort_by			    fn sort_by(self, compare: |&T, &T| -> Ordering) 
sort_by			    fn sort_by(self, compare: |&T, &T| -> Ordering);
sort_by			    pub fn sort_by(&mut self, compare: |&T, &T| -> Ordering) 
sort_random_large			    fn sort_random_large(bh: &mut BenchHarness) 
sort_random_medium			    fn sort_random_medium(bh: &mut BenchHarness) 
sort_random_small			    fn sort_random_small(bh: &mut BenchHarness) 
sort_sorted			    fn sort_sorted(bh: &mut BenchHarness) 
spawn			    fn spawn(&mut self, config: ProcessConfig)
spawn			    pub fn spawn(main: proc:Send()) 
spawn			    pub fn spawn(mut self, f: proc:Send()) 
spawn			pub fn spawn(f: proc:Send()) 
spawn_sibling			    fn spawn_sibling(~self, cur_task: ~Task, opts: TaskOpts, f: proc:Send());
spawn_sibling			    pub fn spawn_sibling(mut ~self, opts: TaskOpts, f: proc:Send()) 
spawn_stack			    pub fn spawn_stack(stack: uint, main: proc:Send()) 
split			    fn split(self, pred: 'a |&T| -> bool) -> Splits<'a, T> 
split			    fn split(self, pred: 'a |&T| -> bool) -> Splits<'a, T>;
split			    fn split<Sep: CharEq>(&self, sep: Sep) -> CharSplits<'a, Sep> 
split			    fn split<Sep: CharEq>(&self, sep: Sep) -> CharSplits<'a, Sep>;
split_ascii			    fn split_ascii(bh: &mut BenchHarness) 
split_closure			    fn split_closure(bh: &mut BenchHarness) 
split_extern_fn			    fn split_extern_fn(bh: &mut BenchHarness) 
split_not_ascii			    fn split_not_ascii(bh: &mut BenchHarness) 
split_slice			    fn split_slice(bh: &mut BenchHarness) 
split_str			    fn split_str(&self, &'a str) -> StrSplits<'a>;
split_str			    fn split_str(&self, sep: &'a str) -> StrSplits<'a> 
split_terminator			    fn split_terminator<Sep: CharEq>(&self, sep: Sep) -> CharSplits<'a, Sep>;
split_terminator			    fn split_terminator<Sep: CharEq>(&self, sep: Sep)
split_unicode_ascii			    fn split_unicode_ascii(bh: &mut BenchHarness) 
split_unicode_not_ascii			    fn split_unicode_not_ascii(bh: &mut BenchHarness) 
splitn			    fn splitn(self, n: uint, pred: 'a |&T| -> bool) -> Splits<'a, T> 
splitn			    fn splitn(self, n: uint, pred: 'a |&T| -> bool) -> Splits<'a, T>;
splitn			    fn splitn<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitsN<'a, Sep>;
splitn			    fn splitn<Sep: CharEq>(&self, sep: Sep, count: uint)
spsc_queue			pub mod spsc_queue;
sqrt			    fn sqrt(&self) -> f32 { sqrt(*self) }
sqrt			    fn sqrt(n: f32) -> f32 = intrinsics::sqrtf32,
sqrt			    fn sqrt(&self) -> f64 { sqrt(*self) }
sqrt			    fn sqrt(n: f64) -> f64 = intrinsics::sqrtf64,
sqrt			    fn sqrt(&self) -> Self;
sqrt2			    fn sqrt2() -> f32 { 1.41421356237309504880168872420969808 }
sqrt2			    fn sqrt2() -> f64 { 1.41421356237309504880168872420969808 }
sqrt2			    fn sqrt2() -> Self;
sqrtf32			    pub fn sqrtf32(x: f32) -> f32;
sqrtf64			    pub fn sqrtf64(x: f64) -> f64;
square			    fn square(n: uint) -> uint { n * n }
square_ref			    fn square_ref(n: &uint) -> uint { square(*n) }
srand			                pub fn srand(seed: c_uint);
src			fn src<T>(fd: libc::c_int, readable: bool, f: |StdSource| -> T) -> T 
stack			pub mod stack;
stack_bounds			    fn stack_bounds(&self) -> (uint, uint); \/\/ (lo, hi)
stack_bounds			    pub fn stack_bounds(&self) -> (uint, uint) 
stampede			    fn stampede(mut w: Worker<~int>, s: Stealer<~int>,
standard_error			pub fn standard_error(kind: IoErrorKind) -> IoError 
start			fn start(argc: int, argv: **u8) -> int 
start			    pub fn start<T: Send>(main: proc:Send() -> T) -> Thread<T> 
start_selection			    fn start_selection(&self, mut task: BlockedTask) -> Result<(), BlockedTask>
start_selection			    pub fn start_selection(&mut self, task: BlockedTask) -> SelectionResult<T> 
start_selection			    fn start_selection(&self, task: BlockedTask) -> Result<(), BlockedTask>;
start_selection			    pub fn start_selection(&mut self,
start_selection			    pub fn start_selection(&mut self, task: BlockedTask) -> SelectionResult<T> 
start_selection			    pub fn start_selection(&self, task: BlockedTask) -> Result<(), BlockedTask>
start_stack			    pub fn start_stack<T: Send>(stack: uint, main: proc:Send() -> T) -> Thread<T> 
starts_with			    fn starts_with(&self, needle: &[T]) -> bool 
starts_with			    fn starts_with(&self, needle: &[T]) -> bool;
starts_with			    fn starts_with(&self, needle: &str) -> bool;
starts_with			    fn starts_with<'a>(&self, needle: &'a str) -> bool 
starts_with_diff_one_element_at_end			    fn starts_with_diff_one_element_at_end(bh: &mut BenchHarness) 
starts_with_same_vector			    fn starts_with_same_vector(bh: &mut BenchHarness) 
starts_with_single_element			    fn starts_with_single_element(bh: &mut BenchHarness) 
stat			    pub fn stat(&self) -> IoResult<FileStat> { stat(self) }
stat			pub fn stat(path: &Path) -> IoResult<FileStat> 
stat			                pub fn stat(path: *c_char, buf: *mut stat) -> c_int;
stat			                pub struct stat 
stat_			        pub mod stat_ 
static_char_ptr			    fn static_char_ptr(p: *u8) -> &'static str 
static_init			    fn static_init() 
status			    pub fn status(prog: &str, args: &[~str]) -> IoResult<ProcessExit> 
std			mod std 
stderr			pub fn stderr() -> LineBufferedWriter<StdWriter> 
stderr_raw			pub fn stderr_raw() -> StdWriter 
stdin			pub fn stdin() -> BufferedReader<StdReader> 
stdin_raw			pub fn stdin_raw() -> StdReader 
stdio			pub mod stdio;
stdio			        pub mod stdio 
stdlib			        pub mod stdlib 
stdout			pub fn stdout() -> LineBufferedWriter<StdWriter> 
stdout_raw			pub fn stdout_raw() -> StdWriter 
steal			    pub fn steal(&mut self) -> Stolen<T> 
steal			    unsafe fn steal(&mut self) -> Stolen<T> 
stealpush			    fn stealpush() 
stealpush_large			    fn stealpush_large() 
step			    unsafe fn step<T>(ptr: &mut *mut T) -> *mut T 
store			    pub fn store(&self, ptr: *mut T, order: Ordering) 
store			    pub fn store(&self, val: bool, order: Ordering) 
store			    pub fn store(&self, val: int, order: Ordering) 
store			    pub fn store(&self, val: uint, order: Ordering) 
str			pub mod str;
str_components			    pub fn str_components<'a>(&'a self) -> StrComponents<'a> 
str_components			    pub fn str_components<'a>(&'a self) -> StrComponents<'a> 
str_copy_map_bytes			unsafe fn str_copy_map_bytes(string: &str, map: &'static [u8]) -> ~str 
str_map_bytes			unsafe fn str_map_bytes(string: ~str, map: &'static [u8]) -> ~str 
strcat			                pub fn strcat(s: *c_char, ct: *c_char) -> *c_char;
strchr			                pub fn strchr(cs: *c_char, c: c_int) -> *c_char;
strcmp			                pub fn strcmp(cs: *c_char, ct: *c_char) -> c_int;
strcoll			                pub fn strcoll(cs: *c_char, ct: *c_char) -> c_int;
strconv			pub mod strconv;
strcpy			                pub fn strcpy(dst: *c_char, src: *c_char) -> *c_char;
strcspn			                pub fn strcspn(cs: *c_char, ct: *c_char) -> size_t;
strdup_uniq			    unsafe fn strdup_uniq(ptr: *u8, len: uint) -> ~str 
stream			mod stream;
strerror			                pub fn strerror(n: c_int) -> *c_char;
strerror			    fn strerror(errnum: uint) -> ~str 
strerror_r			                fn strerror_r(errnum: c_int, buf: *mut c_char,
strerror_r			        fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: libc::size_t)
strerror_r			        fn strerror_r(errnum: c_int, buf: *mut c_char,
stress			    fn stress() 
stress			    fn stress() 
stress_bound			        fn stress_bound(bound: uint) 
stress_factor			    pub fn stress_factor() -> uint 
string			    fn string(c: char) -> ~str 
string			    fn string(&mut self, start: uint) -> &'a str 
string			        pub mod string 
strlen			                pub fn strlen(cs: *c_char) -> size_t;
strncat			                pub fn strncat(s: *c_char, ct: *c_char, n: size_t) -> *c_char;
strncmp			                pub fn strncmp(cs: *c_char, ct: *c_char, n: size_t) -> c_int;
strncpy			                pub fn strncpy(dst: *c_char, src: *c_char, n: size_t)
strong			    fn strong(&self) -> uint { self.inner().strong.get() }
strpbrk			                pub fn strpbrk(cs: *c_char, ct: *c_char) -> *c_char;
strrchr			                pub fn strrchr(cs: *c_char, c: c_int) -> *c_char;
strspn			                pub fn strspn(cs: *c_char, ct: *c_char) -> size_t;
strstr			                pub fn strstr(cs: *c_char, ct: *c_char) -> *c_char;
strtod			                pub fn strtod(s: *c_char, endp: **c_char) -> c_double;
strtok			                pub fn strtok(s: *c_char, t: *c_char) -> *c_char;
strtol			                pub fn strtol(s: *c_char, endp: **c_char, base: c_int)
strtoul			                pub fn strtoul(s: *c_char, endp: **c_char, base: c_int)
strxfrm			                pub fn strxfrm(s: *c_char, ct: *c_char, n: size_t) -> size_t;
sub			    fn sub(&self, other: &f32) -> f32 { *self - *other }
sub			    fn sub(&self, other: &f64) -> f64 { *self - *other }
sub			    fn sub(&self, other: &$T) -> $T { *self - *other }
sub			    fn sub(&self, other: &$T) -> $T { *self - *other }
sub			    fn sub(&self, rhs: &RHS) -> Result;
subslice_offset			    fn subslice_offset(&self, inner: &str) -> uint 
subslice_offset			    fn subslice_offset(&self, inner: &str) -> uint;
success			    pub fn success(&self) -> bool 
sum			    fn sum(&mut self) -> A 
sum			    fn sum(&mut self) -> A;
sum_len			        fn sum_len<S: Container>(v: &[S]) -> uint 
swap			    fn swap(&mut self, k: K, v: V) -> Option<V>;
swap			pub fn swap<T>(x: &mut T, y: &mut T) 
swap			pub unsafe fn swap<T>(x: *mut T, y: *mut T) 
swap			    fn swap(self, a: uint, b: uint) 
swap			    fn swap(self, a: uint, b: uint);
swap			    pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T 
swap			    pub fn swap(&self, val: bool, order: Ordering) -> bool 
swap			    pub fn swap(&self, val: int, order: Ordering) -> int 
swap			    pub fn swap(&self, val: uint, order: Ordering) -> uint 
swap			    pub fn swap(&self, val: ~T, order: Ordering) -> Option<~T> 
swap_buffer			    unsafe fn swap_buffer(&mut self, b: int, old: *mut Buffer<T>,
swap_remove			    fn swap_remove(&mut self, index: uint) -> Option<T> 
swap_remove			    fn swap_remove(&mut self, index: uint) -> Option<T>;
swap_remove			    pub fn swap_remove(&mut self, index: uint) -> Option<T> 
symbol			    pub unsafe fn symbol(handle: *u8, symbol: *libc::c_char) -> *u8 
symbol			    pub unsafe fn symbol<T>(&self, symbol: &str) -> Result<T, ~str> 
syminfo_cb			        extern fn syminfo_cb(data: *mut libc::c_void,
symlink			pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> 
symlink			                pub fn symlink(path1: *c_char, path2: *c_char) -> c_int;
sync			mod sync;
sync			pub mod sync;
sync			pub mod sync;
sync_channel			pub fn sync_channel<T: Send>(bound: uint) -> (SyncSender<T>, Receiver<T>) 
sync_tests			mod sync_tests 
synthesize_closure			    fn synthesize_closure() 
sysconf			                pub fn sysconf(name: c_int) -> c_long;
sysconf			        pub mod sysconf 
sysctl			        fn sysctl(name: *mut libc::c_int, namelen: libc::c_uint,
sysctl			            pub fn sysctl(name: *c_int,
sysctlbyname			            pub fn sysctlbyname(name: *c_char,
sysctlnametomib			            pub fn sysctlnametomib(name: *c_char,
system			                pub fn system(s: *c_char) -> c_int;
t			        fn t(o1: Ordering, o2: Ordering, e: Ordering) 
t			        fn t(a: &str, b: &str, start: uint) 
t			        fn t(v: &[&str], s: &str) 
t			        fn t(v: &[&str], sep: &str, s: &str) 
t			        fn t(v: &[~str], s: &str) 
t			        fn t(v: &[~str], sep: &str, s: &str) 
t			        fn t<'a>(s: &str, sep: &'a str, u: ~[&str]) 
t			        fn t<S: Default + Str>() 
tail			    fn tail(&self) -> &'a [T] { self.slice(1, self.len()) }
tail			    fn tail(&self) -> &'a [T];
tail			    pub fn tail<'a>(&'a self) -> &'a [T] 
tailn			    fn tailn(&self, n: uint) -> &'a [T] { self.slice(n, self.len()) }
tailn			    fn tailn(&self, n: uint) -> &'a [T];
tailn			    pub fn tailn<'a>(&'a self, n: uint) -> &'a [T] 
take			    fn take(self, n: uint) -> Take<Self> 
take			    pub fn take(&mut self) -> Option<T> 
take			    pub fn take() -> Option<~[~[u8]]> 
take			    fn take() -> ~Self;
take			    fn take() -> ~Task { unsafe { local_ptr::take() } }
take			    pub unsafe fn take<T>() -> ~T 
take			    pub fn take(&self, order: Ordering) -> Option<~T> 
take_to_wake			    fn take_to_wake(&mut self) -> BlockedTask 
take_to_wake			    fn take_to_wake(&mut self) -> BlockedTask 
take_unwrap			    pub fn take_unwrap(&mut self) -> T 
take_while			    fn take_while<'r>(self, predicate: 'r |&A| -> bool) -> TakeWhile<'r, A, Self> 
tan			    fn tan(&self) -> f32 { tan(*self) }
tan			    fn tan(n: c_float) -> c_float = cmath::tanf,
tan			        pub fn tan(n: c_double) -> c_double;
tan			    fn tan(&self) -> f64 { tan(*self) }
tan			    fn tan(n: c_double) -> c_double = cmath::tan,
tan			    fn tan(&self) -> Self;
tanf			        pub fn tanf(n: c_float) -> c_float;
tanh			    fn tanh(&self) -> f32 { tanh(*self) }
tanh			    fn tanh(n: c_float) -> c_float = cmath::tanhf
tanh			        pub fn tanh(n: c_double) -> c_double;
tanh			    fn tanh(&self) -> f64 { tanh(*self) }
tanh			    fn tanh(n: c_double) -> c_double = cmath::tanh
tanh			    fn tanh(&self) -> Self;
tanhf			        pub fn tanhf(n: c_float) -> c_float;
target_get_sp_limit			    unsafe fn target_get_sp_limit() -> uint 
target_record_sp_limit			    unsafe fn target_record_sp_limit(limit: uint) 
target_record_stack_bounds			    unsafe fn target_record_stack_bounds(_stack_lo: uint, _stack_hi: uint) {}
target_record_stack_bounds			    unsafe fn target_record_stack_bounds(stack_lo: uint, stack_hi: uint) 
task			pub mod task;
task			pub mod task;
task			pub fn task() -> TaskBuilder 
tcgetpgrp			                pub fn tcgetpgrp(fd: c_int) -> pid_t;
tcp			pub mod tcp;
tcp_bind			    fn tcp_bind(&mut self, addr: SocketAddr) -> IoResult<~RtioTcpListener:Send>;
tcp_connect			    fn tcp_connect(&mut self, addr: SocketAddr) -> IoResult<~RtioTcpStream:Send>;
tell			    fn tell(&self) -> IoResult<u64> 
tell			    fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }
tell			    fn tell(&self) -> IoResult<u64>;
tell			    fn tell(&self) -> IoResult<u64> 
tell			    fn tell(&self) -> IoResult<u64>;
telldir			                pub fn telldir(dirp: *DIR) -> c_long;
tempfile			mod tempfile;
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			pub mod test;
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			fn test() 
test			mod test 
test			    fn test() 
test			    fn test() 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			    fn test() 
test			    fn test() 
test			mod test 
test			mod test 
test			mod test 
test_MinMaxResult			    fn test_MinMaxResult() 
test_abs			    pub fn test_abs() 
test_abs			    pub fn test_abs() 
test_abs			    pub fn test_abs() 
test_abs_sub			    fn test_abs_sub() 
test_abs_sub			    fn test_abs_sub() 
test_abs_sub			    fn test_abs_sub() 
test_abs_sub_nowin			    fn test_abs_sub_nowin() 
test_abs_sub_nowin			    fn test_abs_sub_nowin() 
test_acosh			    fn test_acosh() 
test_acosh			    fn test_acosh() 
test_add			    fn test_add() 
test_all			    fn test_all() 
test_and			    fn test_and() 
test_and			    pub fn test_and() 
test_and_then			    fn test_and_then() 
test_and_then			    pub fn test_and_then() 
test_any			    fn test_any() 
test_append			    fn test_append() 
test_args			    pub fn test_args() 
test_as_bytes			    fn test_as_bytes() 
test_as_bytes			    fn test_as_bytes() 
test_as_bytes_fail			    fn test_as_bytes_fail() 
test_as_bytes_fail			    fn test_as_bytes_fail() 
test_as_bytes_no_nul			    fn test_as_bytes_no_nul() 
test_as_bytes_no_nul_fail			    fn test_as_bytes_no_nul_fail() 
test_as_ptr			    fn test_as_ptr() 
test_as_str			    fn test_as_str() 
test_as_str_fail			    fn test_as_str_fail() 
test_ascii			    fn test_ascii() 
test_ascii_as_str			    fn test_ascii_as_str() 
test_ascii_fail_char_slice			    fn test_ascii_fail_char_slice() { 'λ'.to_ascii(); }
test_ascii_fail_u8_slice			    fn test_ascii_fail_u8_slice() { 255u8.to_ascii(); }
test_ascii_into_str			    fn test_ascii_into_str() 
test_ascii_to_bytes			    fn test_ascii_to_bytes() 
test_ascii_vec			    fn test_ascii_vec() 
test_ascii_vec_fail_str_slice			    fn test_ascii_vec_fail_str_slice() { "zoä华".to_ascii(); }
test_ascii_vec_fail_u8_slice			    fn test_ascii_vec_fail_u8_slice()  { (&[127u8, 128u8, 255u8]).to_ascii(); }
test_ascii_vec_ng			    fn test_ascii_vec_ng() 
test_asinh			    fn test_asinh() 
test_asinh			    fn test_asinh() 
test_atanh			    fn test_atanh() 
test_atanh			    fn test_atanh() 
test_avoid_copying_the_body_spawn			fn test_avoid_copying_the_body_spawn() 
test_avoid_copying_the_body_task_spawn			fn test_avoid_copying_the_body_task_spawn() 
test_avoid_copying_the_body_try			fn test_avoid_copying_the_body_try() 
test_back_to_the_future_result			fn test_back_to_the_future_result() 
test_basic			    fn test_basic() 
test_begin_unwind			    fn test_begin_unwind() 
test_bitand			    fn test_bitand() 
test_bitor			    fn test_bitor() 
test_bitwise			    fn test_bitwise() 
test_bitwise			    fn test_bitwise() 
test_bitxor			    fn test_bitxor() 
test_borrowed_clone			fn test_borrowed_clone() 
test_bsearch_elem			    fn test_bsearch_elem() 
test_buf_len			    fn test_buf_len() 
test_buf_reader			    fn test_buf_reader() 
test_buf_writer			    fn test_buf_writer() 
test_buf_writer_error			    fn test_buf_writer_error() 
test_buf_writer_seek			    fn test_buf_writer_seek() 
test_buffered_reader			    fn test_buffered_reader() 
test_buffered_stream			    fn test_buffered_stream() 
test_buffered_writer			    fn test_buffered_writer() 
test_buffered_writer_inner_flushes			    fn test_buffered_writer_inner_flushes() 
test_build_fail			    fn test_build_fail() 
test_bump_managed_refcount			    fn test_bump_managed_refcount() 
test_by_ref			    fn test_by_ref() 
test_bytes_revator			    fn test_bytes_revator() 
test_bytes_set_memory			    fn test_bytes_set_memory() 
test_bytesator			    fn test_bytesator() 
test_capacity			    fn test_capacity() 
test_cast_range_i16_max			    fn test_cast_range_i16_max() 
test_cast_range_i16_min			    fn test_cast_range_i16_min() 
test_cast_range_i32_max			    fn test_cast_range_i32_max() 
test_cast_range_i32_min			    fn test_cast_range_i32_min() 
test_cast_range_i64_max			    fn test_cast_range_i64_max() 
test_cast_range_i64_min			    fn test_cast_range_i64_min() 
test_cast_range_i8_max			    fn test_cast_range_i8_max() 
test_cast_range_i8_min			    fn test_cast_range_i8_min() 
test_cast_range_int_max			    fn test_cast_range_int_max() 
test_cast_range_int_min			    fn test_cast_range_int_min() 
test_cast_range_u16_max			    fn test_cast_range_u16_max() 
test_cast_range_u16_min			    fn test_cast_range_u16_min() 
test_cast_range_u32_max			    fn test_cast_range_u32_max() 
test_cast_range_u32_min			    fn test_cast_range_u32_min() 
test_cast_range_u64_max			    fn test_cast_range_u64_max() 
test_cast_range_u64_min			    fn test_cast_range_u64_min() 
test_cast_range_u8_max			    fn test_cast_range_u8_max() 
test_cast_range_u8_min			    fn test_cast_range_u8_min() 
test_cast_range_uint_max			    fn test_cast_range_uint_max() 
test_cast_range_uint_min			    fn test_cast_range_uint_min() 
test_ceil			    fn test_ceil() 
test_ceil			    fn test_ceil() 
test_chained_reader			    fn test_chained_reader() 
test_chan_writer			    fn test_chan_writer() 
test_char_at			    fn test_char_at() 
test_char_at_reverse			    fn test_char_at_reverse() 
test_char_indices_revator			    fn test_char_indices_revator() 
test_char_indicesator			    fn test_char_indicesator() 
test_char_range_at			    fn test_char_range_at() 
test_char_range_at_reverse_underflow			    fn test_char_range_at_reverse_underflow() 
test_chars			    fn test_chars() 
test_checked_add			    fn test_checked_add() 
test_checked_mul			    fn test_checked_mul() 
test_checked_sub			    fn test_checked_sub() 
test_child_doesnt_ref_parent			fn test_child_doesnt_ref_parent() 
test_chunksator			    fn test_chunksator() 
test_chunksator_0			    fn test_chunksator_0() 
test_classify			    fn test_classify() 
test_classify			    fn test_classify() 
test_clear			    fn test_clear() 
test_clear			    fn test_clear() 
test_clone			    fn test_clone() 
test_clone			    fn test_clone() 
test_clone			    fn test_clone() 
test_clone			    fn test_clone() 
test_clone_eq_null			    fn test_clone_eq_null() 
test_clone_from			fn test_clone_from() 
test_clone_noleak			    fn test_clone_noleak() 
test_collect			    fn test_collect() 
test_collect			    fn test_collect() 
test_collect			    fn test_collect() 
test_collect			    fn test_collect() 
test_compact			fn test_compact() 
test_components			    fn test_components() 
test_components			    fn test_components() 
test_components_iter			    fn test_components_iter() 
test_components_iter			    fn test_components_iter() 
test_concat			    fn test_concat() 
test_concat			    fn test_concat() 
test_concat_slices			    fn test_concat_slices() 
test_connect			    fn test_connect() 
test_connect			    fn test_connect() 
test_connect_slices			    fn test_connect_slices() 
test_contains			    fn test_contains() 
test_contains_char			    fn test_contains_char() 
test_copy			    fn test_copy() 
test_copy_from			    fn test_copy_from() 
test_copy_memory_oob			    fn test_copy_memory_oob() 
test_count			    fn test_count() 
test_count_ones			    fn test_count_ones() 
test_count_ones			    fn test_count_ones() 
test_count_zeros			    fn test_count_zeros() 
test_count_zeros			    fn test_count_zeros() 
test_counter_from_iter			    fn test_counter_from_iter() 
test_cstring			    fn test_cstring() 
test_custom_state			    fn test_custom_state() 
test_cycle			    fn test_cycle() 
test_dead			    fn test_dead() 
test_dedup			    fn test_dedup() 
test_dedup_shared			    fn test_dedup_shared() 
test_dedup_unique			    fn test_dedup_unique() 
test_destructor			    fn test_destructor() 
test_destructor			    fn test_destructor() 
test_dir_path			    fn test_dir_path() 
test_dir_path			    fn test_dir_path() 
test_display			    fn test_display() 
test_display			    fn test_display() 
test_display_str			    fn test_display_str() 
test_display_str			    fn test_display_str() 
test_double_drop			    fn test_double_drop() 
test_double_ended_chain			    fn test_double_ended_chain() 
test_double_ended_enumerate			    fn test_double_ended_enumerate() 
test_double_ended_filter			    fn test_double_ended_filter() 
test_double_ended_filter_map			    fn test_double_ended_filter_map() 
test_double_ended_flat_map			    fn test_double_ended_flat_map() 
test_double_ended_map			    fn test_double_ended_map() 
test_double_ended_range			    fn test_double_ended_range() 
test_double_ended_zip			    fn test_double_ended_zip() 
test_element_swaps			    fn test_element_swaps() 
test_ends_with			    fn test_ends_with() 
test_ends_with			    fn test_ends_with() 
test_ends_with_path			    fn test_ends_with_path() 
test_ends_with_path			    fn test_ends_with_path() 
test_env_getenv			    fn test_env_getenv() 
test_env_set_get_huge			    fn test_env_set_get_huge() 
test_env_setenv			    fn test_env_setenv() 
test_eq			    fn test_eq() 
test_eq			    fn test_eq() 
test_eq_ignore_ascii_case			    fn test_eq_ignore_ascii_case() 
test_eq_slice			    fn test_eq_slice() 
test_errors_do_not_crash			    fn test_errors_do_not_crash() 
test_escape_default			fn test_escape_default() 
test_escape_default			    fn test_escape_default() 
test_escape_unicode			fn test_escape_unicode() 
test_escape_unicode			    fn test_escape_unicode() 
test_extend			    fn test_extend() 
test_extend			    fn test_extend() 
test_extern_fn_clone			fn test_extern_fn_clone() 
test_fail			fn test_fail() 
test_fail_at_null			    fn test_fail_at_null() 
test_filter_map			    fn test_filter_map() 
test_filtered			    fn test_filtered() 
test_find			    fn test_find() 
test_find			    fn test_find() 
test_find_str			    fn test_find_str() 
test_floor			    fn test_floor() 
test_floor			    fn test_floor() 
test_fmt_default			    pub fn test_fmt_default() 
test_fn_a			    fn test_fn_a() -> f64 { 1.0 }
test_fn_b			    fn test_fn_b<T: Empty>(x: T) -> T { x }
test_fn_c			    fn test_fn_c(_: int, _: f64, _: ~[int], _: int, _: int, _: int) {}
test_fold			    fn test_fold() 
test_format_int			    fn test_format_int() 
test_format_int_flags			    fn test_format_int_flags() 
test_format_int_sign_padding			    fn test_format_int_sign_padding() 
test_format_int_twos_complement			    fn test_format_int_twos_complement() 
test_format_int_zero			    fn test_format_int_zero() 
test_format_radix			    fn test_format_radix() 
test_fract			    fn test_fract() 
test_fract			    fn test_fract() 
test_frexp			    fn test_frexp() 
test_frexp			    fn test_frexp() 
test_frexp_nowin			    fn test_frexp_nowin() 
test_frexp_nowin			    fn test_frexp_nowin() 
test_from_buf_len			    fn test_from_buf_len() 
test_from_elem			    fn test_from_elem() 
test_from_elem_fail			    fn test_from_elem_fail() 
test_from_fn			    fn test_from_fn() 
test_from_fn_fail			    fn test_from_fn_fail() 
test_from_primitive			    fn test_from_primitive() 
test_from_str			    fn test_from_str() 
test_from_str			    fn test_from_str() 
test_from_str			    pub fn test_from_str() 
test_from_str			    fn test_from_str() 
test_from_str_ipv4			    fn test_from_str_ipv4() 
test_from_str_ipv4_in_ipv6			    fn test_from_str_ipv4_in_ipv6() 
test_from_str_ipv6			    fn test_from_str_ipv6() 
test_from_str_socket_addr			    fn test_from_str_socket_addr() 
test_full			    fn test_full() 
test_future_result			fn test_future_result() 
test_get			    fn test_get() 
test_get_mut			    fn test_get_mut() 
test_get_ptr			    fn test_get_ptr() 
test_get_resource			    fn test_get_resource() 
test_get_str			    fn test_get_str() 
test_getenv_big			    fn test_getenv_big() 
test_getters			    fn test_getters() 
test_getters			    fn test_getters() 
test_getters			    fn test_getters() 
test_grow			    fn test_grow() 
test_grow_fn			    fn test_grow_fn() 
test_grow_fn_fail			    fn test_grow_fn_fail() 
test_grow_set			    fn test_grow_set() 
test_hash_idempotent			    fn test_hash_idempotent() 
test_hash_no_bytes_dropped_32			    fn test_hash_no_bytes_dropped_32() 
test_hash_no_bytes_dropped_64			    fn test_hash_no_bytes_dropped_64() 
test_hash_no_concat_alias			    fn test_hash_no_concat_alias() 
test_hash_uint			    fn test_hash_uint() 
test_head			    fn test_head() 
test_hex_radix_digit_overflow			    fn test_hex_radix_digit_overflow() 
test_impl_map			    pub fn test_impl_map() 
test_impl_map_err			    pub fn test_impl_map_err() 
test_init			    fn test_init() 
test_init_empty			    fn test_init_empty() 
test_initn			    fn test_initn() 
test_initn_empty			    fn test_initn_empty() 
test_insert			    fn test_insert() 
test_insert			    fn test_insert() 
test_insert_char			    fn test_insert_char() 
test_insert_oob			    fn test_insert_oob() 
test_inspect			    fn test_inspect() 
test_int_from_str_overflow			    fn test_int_from_str_overflow() 
test_int_to_str_overflow			    fn test_int_to_str_overflow() 
test_int_totalord			    fn test_int_totalord() 
test_integer_decode			    fn test_integer_decode() 
test_integer_decode			    fn test_integer_decode() 
test_into_ascii_lower			    fn test_into_ascii_lower() 
test_into_ascii_upper			    fn test_into_ascii_upper() 
test_into_bytes			    fn test_into_bytes() 
test_into_maybe_owned			    fn test_into_maybe_owned() 
test_io_signal_invalid_signum			    fn test_io_signal_invalid_signum() 
test_io_signal_smoketest			    fn test_io_signal_smoketest() 
test_io_signal_two_signal_one_signum			    fn test_io_signal_two_signal_one_signum() 
test_io_signal_unregister			    fn test_io_signal_unregister() 
test_is_absolute			    fn test_is_absolute() 
test_is_absolute			    fn test_is_absolute() 
test_is_ancestor_of			    fn test_is_ancestor_of() 
test_is_ancestor_of			    fn test_is_ancestor_of() 
test_is_control			fn test_is_control() 
test_is_digit			fn test_is_digit() 
test_is_empty			    fn test_is_empty() 
test_is_empty			    fn test_is_empty() 
test_is_lowercase			fn test_is_lowercase() 
test_is_negative			    fn test_is_negative() 
test_is_negative			    fn test_is_negative() 
test_is_negative			    fn test_is_negative() 
test_is_normal			    fn test_is_normal() 
test_is_normal			    fn test_is_normal() 
test_is_null			    fn test_is_null() 
test_is_null			    fn test_is_null() 
test_is_positive			    fn test_is_positive() 
test_is_positive			    fn test_is_positive() 
test_is_positive			    fn test_is_positive() 
test_is_uppercase			fn test_is_uppercase() 
test_is_utf16			    fn test_is_utf16() 
test_is_utf8			    fn test_is_utf8() 
test_is_whitespace			fn test_is_whitespace() 
test_is_whitespace			    fn test_is_whitespace() 
test_iter			    fn test_iter() 
test_iter_clone			    fn test_iter_clone() 
test_iter_fail			    fn test_iter_fail() 
test_iter_size_hints			    fn test_iter_size_hints() 
test_iter_zero_sized			    fn test_iter_zero_sized() 
test_iterator			    fn test_iterator() 
test_iterator			    fn test_iterator() 
test_iterator			    fn test_iterator() 
test_iterator_chain			    fn test_iterator_chain() 
test_iterator_clone			    fn test_iterator_clone() 
test_iterator_enumerate			    fn test_iterator_enumerate() 
test_iterator_flat_map			    fn test_iterator_flat_map() 
test_iterator_last			    fn test_iterator_last() 
test_iterator_len			    fn test_iterator_len() 
test_iterator_max			    fn test_iterator_max() 
test_iterator_min			    fn test_iterator_min() 
test_iterator_nth			    fn test_iterator_nth() 
test_iterator_peekable			    fn test_iterator_peekable() 
test_iterator_product			    fn test_iterator_product() 
test_iterator_scan			    fn test_iterator_scan() 
test_iterator_size_hint			    fn test_iterator_size_hint() 
test_iterator_skip			    fn test_iterator_skip() 
test_iterator_skip_while			    fn test_iterator_skip_while() 
test_iterator_sum			    fn test_iterator_sum() 
test_iterator_take			    fn test_iterator_take() 
test_iterator_take_while			    fn test_iterator_take_while() 
test_join			    fn test_join() 
test_join			    fn test_join() 
test_join_many			    fn test_join_many() 
test_join_many			    fn test_join_many() 
test_join_path			    fn test_join_path() 
test_join_path			    fn test_join_path() 
test_last			    fn test_last() 
test_ldexp			    fn test_ldexp() 
test_ldexp			    fn test_ldexp() 
test_le			    fn test_le() 
test_len			    fn test_len() 
test_len_divzero			    fn test_len_divzero() 
test_len_fail			    fn test_len_fail() 
test_lexical_ordering			    fn test_lexical_ordering() 
test_limit_reader_limit			    fn test_limit_reader_limit() 
test_limit_reader_limited			    fn test_limit_reader_limited() 
test_limit_reader_unlimited			    fn test_limit_reader_unlimited() 
test_line_buffer			    fn test_line_buffer() 
test_lines			    fn test_lines() 
test_lines			    fn test_lines() 
test_live			    fn test_live() 
test_loading_cosine			    fn test_loading_cosine() 
test_lt			    fn test_lt() 
test_make_non_verbatim			    fn test_make_non_verbatim() 
test_managed_clone			fn test_managed_clone() 
test_max_by			    fn test_max_by() 
test_max_nan			    fn test_max_nan() 
test_max_nan			    fn test_max_nan() 
test_maybe_owned_clone			    fn test_maybe_owned_clone() 
test_maybe_owned_into_owned			    fn test_maybe_owned_into_owned() 
test_maybe_owned_methods			    fn test_maybe_owned_methods() 
test_maybe_owned_traits			    fn test_maybe_owned_traits() 
test_mem_reader			    fn test_mem_reader() 
test_mem_writer			    fn test_mem_writer() 
test_min_by			    fn test_min_by() 
test_min_max			    fn test_min_max() 
test_min_nan			    fn test_min_nan() 
test_min_nan			    fn test_min_nan() 
test_move_from			    fn test_move_from() 
test_move_iterator			    fn test_move_iterator() 
test_move_rev_iterator			    fn test_move_rev_iterator() 
test_multi_writer			    fn test_multi_writer() 
test_mut_chunks			    fn test_mut_chunks() 
test_mut_chunks_0			    fn test_mut_chunks_0() 
test_mut_chunks_rev			    fn test_mut_chunks_rev() 
test_mut_iter			    fn test_mut_iter() 
test_mut_iterator			    fn test_mut_iterator() 
test_mut_last			    fn test_mut_last() 
test_mut_pop_ref			    fn test_mut_pop_ref() 
test_mut_rev_iterator			    fn test_mut_rev_iterator() 
test_mut_shift_ref			    fn test_mut_shift_ref() 
test_mut_slice_from			    fn test_mut_slice_from() 
test_mut_slice_to			    fn test_mut_slice_to() 
test_mut_split_at			    fn test_mut_split_at() 
test_mut_split_at			    fn test_mut_split_at() 
test_mut_splitator			    fn test_mut_splitator() 
test_mut_splitator_rev			    fn test_mut_splitator_rev() 
test_mutate			    fn test_mutate() 
test_nested_get_mut2			    fn test_nested_get_mut2() 
test_nested_get_mut3			    fn test_nested_get_mut3() 
test_nested_get_mut4			    fn test_nested_get_mut4() 
test_nested_get_set1			    fn test_nested_get_set1() 
test_nfd_chars			    fn test_nfd_chars() 
test_nfkd_chars			    fn test_nfkd_chars() 
test_not			    fn test_not() 
test_not_utf8_fail			    fn test_not_utf8_fail() 
test_null_byte			    fn test_null_byte() 
test_null_byte			    fn test_null_byte() 
test_null_reader			    fn test_null_reader() 
test_null_writer			    fn test_null_writer() 
test_num			    fn test_num() 
test_num			    fn test_num() 
test_num			    fn test_num() 
test_num			pub fn test_num<T:Num + NumCast + Show>(ten: T, two: T) 
test_num			    fn test_num() 
test_opt			    fn test_opt() 
test_opt_paths			    fn test_opt_paths() 
test_opt_paths			    fn test_opt_paths() 
test_option_dance			    fn test_option_dance() 
test_option_reader			    fn test_option_reader() 
test_option_reader_error			    fn test_option_reader_error() 
test_option_too_much_dance			    fn test_option_too_much_dance() 
test_option_while_some			    fn test_option_while_some() 
test_option_writer			    fn test_option_writer() 
test_option_writer_error			    fn test_option_writer_error() 
test_or			    fn test_or() 
test_or			    pub fn test_or() 
test_or_else			    fn test_or_else() 
test_or_else			    pub fn test_or_else() 
test_ord			    fn test_ord() 
test_ord			    fn test_ord() 
test_ordering_order			    fn test_ordering_order() 
test_overflow_does_not_cause_segfault			    fn test_overflow_does_not_cause_segfault() 
test_overflow_does_not_cause_segfault_managed			    fn test_overflow_does_not_cause_segfault_managed() 
test_overflows			    fn test_overflows() 
test_overflows			    fn test_overflows() 
test_overrun_get			    fn test_overrun_get() 
test_overrun_set			    fn test_overrun_set() 
test_owned			    fn test_owned() 
test_owned_ascii_vec			    fn test_owned_ascii_vec() 
test_owned_clone			fn test_owned_clone() 
test_owned_named_task			fn test_owned_named_task() 
test_parse_bytes			    fn test_parse_bytes() 
test_parse_bytes			    pub fn test_parse_bytes() 
test_parse_prefix			    fn test_parse_prefix() 
test_partition			    fn test_partition() 
test_partitioned			    fn test_partitioned() 
test_path_relative_from			    fn test_path_relative_from() 
test_path_relative_from			    fn test_path_relative_from() 
test_paths			    fn test_paths() 
test_paths			    fn test_paths() 
test_peekable_is_empty			    fn test_peekable_is_empty() 
test_permutations			    fn test_permutations() 
test_permute_fail			    fn test_permute_fail() 
test_pop			    fn test_pop() 
test_pop			    fn test_pop() 
test_pop			    fn test_pop() 
test_pop_byte			    fn test_pop_byte() 
test_pop_char			    fn test_pop_char() 
test_pop_char_2			    fn test_pop_char_2() 
test_pop_char_empty			    fn test_pop_char_empty() 
test_pop_ref			    fn test_pop_ref() 
test_position			    fn test_position() 
test_position			    fn test_position() 
test_position_elem			    fn test_position_elem() 
test_pow			    fn test_pow() 
test_ptr_addition			    fn test_ptr_addition() 
test_ptr_array_each			    fn test_ptr_array_each() 
test_ptr_array_each_null_ptr			    fn test_ptr_array_each_null_ptr() 
test_ptr_array_each_with_len			    fn test_ptr_array_each_with_len() 
test_ptr_array_each_with_len_null_ptr			    fn test_ptr_array_each_with_len_null_ptr() 
test_ptr_eq			    fn test_ptr_eq() 
test_ptr_subtraction			    fn test_ptr_subtraction() 
test_push			    fn test_push() 
test_push			    fn test_push() 
test_push			    fn test_push() 
test_push_byte			    fn test_push_byte() 
test_push_char			    fn test_push_char() 
test_push_many			    fn test_push_many() 
test_push_many			    fn test_push_many() 
test_push_path			    fn test_push_path() 
test_push_path			    fn test_push_path() 
test_push_str			    fn test_push_str() 
test_radix_base			    fn test_radix_base() 
test_radix_base_too_large			    fn test_radix_base_too_large() 
test_radix_digit			    fn test_radix_digit() 
test_radix_prefix			    fn test_radix_prefix() 
test_random_access_chain			    fn test_random_access_chain() 
test_random_access_cycle			    fn test_random_access_cycle() 
test_random_access_enumerate			    fn test_random_access_enumerate() 
test_random_access_inspect			    fn test_random_access_inspect() 
test_random_access_iterator			    fn test_random_access_iterator() 
test_random_access_map			    fn test_random_access_map() 
test_random_access_rev			    fn test_random_access_rev() 
test_random_access_skip			    fn test_random_access_skip() 
test_random_access_take			    fn test_random_access_take() 
test_random_access_zip			    fn test_random_access_zip() 
test_range			    fn test_range() 
test_range_inclusive			    fn test_range_inclusive() 
test_range_step			    fn test_range_step() 
test_range_step_inclusive			    fn test_range_step_inclusive() 
test_raw_from_c_str			    fn test_raw_from_c_str() 
test_read_bad_char			    fn test_read_bad_char() 
test_read_be_int_n			    fn test_read_be_int_n() 
test_read_char			    fn test_read_char() 
test_read_f32			    fn test_read_f32() 
test_read_line			    fn test_read_line() 
test_read_until			    fn test_read_until() 
test_read_whole_string_bad			    fn test_read_whole_string_bad() 
test_read_write_be			    fn test_read_write_be() 
test_read_write_f32			    fn test_read_write_f32() 
test_read_write_le_mem			    fn test_read_write_le_mem() 
test_real_consts			    fn test_real_consts() 
test_real_consts			    fn test_real_consts() 
test_remove			    fn test_remove() 
test_repeat			    fn test_repeat() 
test_replace			    fn test_replace() 
test_replace			    fn test_replace() 
test_replace_2a			    fn test_replace_2a() 
test_replace_2b			    fn test_replace_2b() 
test_replace_2c			    fn test_replace_2c() 
test_replace_2d			    fn test_replace_2d() 
test_repr			fn test_repr() 
test_reserve_additional			    fn test_reserve_additional() 
test_retain			    fn test_retain() 
test_retval			fn test_retval() 
test_rev			    fn test_rev() 
test_rev_iterator			    fn test_rev_iterator() 
test_rev_iterator			    fn test_rev_iterator() 
test_rev_split_char_iterator_no_trailing			    fn test_rev_split_char_iterator_no_trailing() 
test_reverse			    fn test_reverse() 
test_reverse			    fn test_reverse() 
test_reverse_part			    fn test_reverse_part() 
test_rfind			    fn test_rfind() 
test_root_path			    fn test_root_path() 
test_root_path			    fn test_root_path() 
test_round			    fn test_round() 
test_round			    fn test_round() 
test_rposition			    fn test_rposition() 
test_rposition_fail			    fn test_rposition_fail() 
test_rsplitator			    fn test_rsplitator() 
test_rsplitn_char_iterator			    fn test_rsplitn_char_iterator() 
test_rsplitnator			    fn test_rsplitnator() 
test_run_basic			fn test_run_basic() 
test_run_in_bare_thread			fn test_run_in_bare_thread() 
test_run_in_bare_thread_exchange			fn test_run_in_bare_thread_exchange() 
test_rx_reader			    fn test_rx_reader() 
test_same_key_type			    fn test_same_key_type() 
test_saturating_add_int			    fn test_saturating_add_int() 
test_saturating_add_uint			    fn test_saturating_add_uint() 
test_saturating_sub_int			    fn test_saturating_sub_int() 
test_saturating_sub_uint			    fn test_saturating_sub_uint() 
test_self_exe_name			    fn test_self_exe_name() 
test_self_exe_path			    fn test_self_exe_path() 
test_send_named_task			fn test_send_named_task() 
test_set_memory			    fn test_set_memory() 
test_setenv			    fn test_setenv() 
test_setenv_overwrite			    fn test_setenv_overwrite() 
test_setters			    fn test_setters() 
test_setters			    fn test_setters() 
test_shift			    fn test_shift() 
test_shift_byte			    fn test_shift_byte() 
test_shift_char			    fn test_shift_char() 
test_shift_ref			    fn test_shift_ref() 
test_short_reads			    fn test_short_reads() 
test_show			    fn test_show() 
test_show			    fn test_show() 
test_show			    fn test_show() 
test_show			    fn test_show() 
test_shrink_to_fit			    fn test_shrink_to_fit() 
test_signed_checked_div			    fn test_signed_checked_div() 
test_signum			    fn test_signum() 
test_signum			    fn test_signum() 
test_signum			    fn test_signum() 
test_simple			    fn test_simple() 
test_simple			    fn test_simple() 
test_simple_clone			    fn test_simple_clone() 
test_simple_clone			    fn test_simple_clone() 
test_simple_newsched_spawn			fn test_simple_newsched_spawn() 
test_simple_types			    fn test_simple_types() 
test_siphash			    fn test_siphash() 
test_size			    fn test_size() 
test_slice			    fn test_slice() 
test_slice			    fn test_slice() 
test_slice_2			    fn test_slice_2() 
test_slice_2			    fn test_slice_2() 
test_slice_chars			    fn test_slice_chars() 
test_slice_fail			    fn test_slice_fail() 
test_slice_from			    fn test_slice_from() 
test_slice_from			    fn test_slice_from() 
test_slice_shift_char			    fn test_slice_shift_char() 
test_slice_shift_char_2			    fn test_slice_shift_char_2() 
test_slice_to			    fn test_slice_to() 
test_slice_to			    fn test_slice_to() 
test_small_vec_struct			    fn test_small_vec_struct() 
test_sort			    fn test_sort() 
test_sort_stability			    fn test_sort_stability() 
test_spawn_sched			fn test_spawn_sched() 
test_spawn_sched_childs_on_default_sched			fn test_spawn_sched_childs_on_default_sched() 
test_split_char_iterator			    fn test_split_char_iterator() 
test_split_char_iterator_no_trailing			    fn test_split_char_iterator_no_trailing() 
test_split_strator			    fn test_split_strator() 
test_splitator			    fn test_splitator() 
test_splitn_char_iterator			    fn test_splitn_char_iterator() 
test_splitnator			    fn test_splitnator() 
test_starts_with			    fn test_starts_with() 
test_starts_with			    fn test_starts_with() 
test_static_named_task			fn test_static_named_task() 
test_static_pointer			    fn test_static_pointer() 
test_str_components			    fn test_str_components() 
test_str_components			    fn test_str_components() 
test_str_container			    fn test_str_container() 
test_str_default			    fn test_str_default() 
test_str_from_utf8			    fn test_str_from_utf8() 
test_str_from_utf8_lossy			    fn test_str_from_utf8_lossy() 
test_str_from_utf8_owned			    fn test_str_from_utf8_owned() 
test_str_multistring_parsing			    fn test_str_multistring_parsing() 
test_str_to_c_str			    fn test_str_to_c_str() 
test_str_truncate			    fn test_str_truncate() 
test_str_truncate_invalid_len			    fn test_str_truncate_invalid_len() 
test_str_truncate_split_codepoint			    fn test_str_truncate_split_codepoint() 
test_subslice_offset			    fn test_subslice_offset() 
test_subslice_offset_2			    fn test_subslice_offset_2() 
test_success			fn test_success() 
test_swap			    fn test_swap() 
test_swap_remove			    fn test_swap_remove() 
test_swap_remove_noncopyable			    fn test_swap_remove_noncopyable() 
test_tail			    fn test_tail() 
test_tail_empty			    fn test_tail_empty() 
test_tailn			    fn test_tailn() 
test_tailn_empty			    fn test_tailn_empty() 
test_tee_reader			    fn test_tee_reader() 
test_tls_cleanup_on_failure			    fn test_tls_cleanup_on_failure() 
test_tls_crust_automorestack_memorial_bug			    fn test_tls_crust_automorestack_memorial_bug() 
test_tls_modify			    fn test_tls_modify() 
test_tls_multiple_types			    fn test_tls_multiple_types() 
test_tls_multitask			    fn test_tls_multitask() 
test_tls_overwrite			    fn test_tls_overwrite() 
test_tls_overwrite_multiple_types			    fn test_tls_overwrite_multiple_types() 
test_tls_pop			    fn test_tls_pop() 
test_to_ascii_lower			    fn test_to_ascii_lower() 
test_to_ascii_upper			    fn test_to_ascii_upper() 
test_to_bit			    fn test_to_bit() 
test_to_c_str_fail			    fn test_to_c_str_fail() 
test_to_c_str_unchecked			    fn test_to_c_str_unchecked() 
test_to_digit			fn test_to_digit() 
test_to_lowercase			fn test_to_lowercase() 
test_to_option			    fn test_to_option() 
test_to_primitive			    fn test_to_primitive() 
test_to_str			    fn test_to_str() 
test_to_str			    fn test_to_str() 
test_to_str			fn test_to_str() 
test_to_str			    fn test_to_str() 
test_to_str			    pub fn test_to_str() 
test_to_str			    pub fn test_to_str() 
test_to_uppercase			fn test_to_uppercase() 
test_total_ord			    fn test_total_ord() 
test_total_ord			    fn test_total_ord() 
test_totalord			    fn test_totalord() 
test_transmute			    fn test_transmute() 
test_transmute2			    fn test_transmute2() 
test_transmute_copy			    fn test_transmute_copy() 
test_trim			    fn test_trim() 
test_trim_chars			    fn test_trim_chars() 
test_trim_left			    fn test_trim_left() 
test_trim_left_chars			    fn test_trim_left_chars() 
test_trim_right			    fn test_trim_right() 
test_trim_right_chars			    fn test_trim_right_chars() 
test_trunc			    fn test_trunc() 
test_trunc			    fn test_trunc() 
test_truncate			    fn test_truncate() 
test_truncate_utf16_at_nul			    fn test_truncate_utf16_at_nul() 
test_try_fail			fn test_try_fail() 
test_try_fail_message_any			fn test_try_fail_message_any() 
test_try_fail_message_owned_str			fn test_try_fail_message_owned_str() 
test_try_fail_message_static_str			fn test_try_fail_message_static_str() 
test_try_fail_message_unit_struct			fn test_try_fail_message_unit_struct() 
test_try_success			fn test_try_success() 
test_tuple_cmp			    fn test_tuple_cmp() 
test_u64_from_be_bytes			    fn test_u64_from_be_bytes() 
test_uint_from_str_overflow			    fn test_uint_from_str_overflow() 
test_uint_to_str_overflow			    fn test_uint_to_str_overflow() 
test_unfoldr			    fn test_unfoldr() 
test_unix			mod test_unix 
test_unnamed_task			fn test_unnamed_task() 
test_unsafe_ptrs			    fn test_unsafe_ptrs() 
test_unsafe_slice			    fn test_unsafe_slice() 
test_unsetenv			    fn test_unsetenv() 
test_unshift			    fn test_unshift() 
test_unshift_char			    fn test_unshift_char() 
test_unsigned_checked_div			    fn test_unsigned_checked_div() 
test_unwrap			    fn test_unwrap() 
test_unwrap			    fn test_unwrap() 
test_unwrap			    fn test_unwrap() 
test_unwrap_fail1			    fn test_unwrap_fail1() 
test_unwrap_fail2			    fn test_unwrap_fail2() 
test_unwrap_or			    fn test_unwrap_or() 
test_unwrap_or_else			    fn test_unwrap_or_else() 
test_utf16			    fn test_utf16() 
test_utf16_invalid			    fn test_utf16_invalid() 
test_utf16_lossy			    fn test_utf16_lossy() 
test_vec_default			    fn test_vec_default() 
test_vec_to_c_str			    fn test_vec_to_c_str() 
test_vectors			    fn test_vectors() 
test_windows			mod test_windows 
test_windowsator			    fn test_windowsator() 
test_windowsator_0			    fn test_windowsator_0() 
test_with_helpers			    fn test_with_helpers() 
test_with_helpers			    fn test_with_helpers() 
test_with_ref			    fn test_with_ref() 
test_with_ref_empty_fail			    fn test_with_ref_empty_fail() 
test_with_wrapper			fn test_with_wrapper() 
test_words			    fn test_words() 
test_write_char			    fn test_write_char() 
test_write_strings			    fn test_write_strings() 
test_writer_hasher			    fn test_writer_hasher() 
test_zero_reader			    fn test_zero_reader() 
test_zip_unzip			    fn test_zip_unzip() 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			    mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tgamma			        pub fn tgamma(n: c_double) -> c_double;
tgammaf			        pub fn tgammaf(n: c_float) -> c_float;
thread			pub mod thread;
thread_local_storage			mod thread_local_storage;
thread_local_task_smoke_test			    fn thread_local_task_smoke_test() 
thread_local_task_two_instances			    fn thread_local_task_two_instances() 
thread_start			extern fn thread_start(main: *libc::c_void) -> imp::rust_thread_return 
time_to_live			    fn time_to_live(&mut self, ttl: int) -> IoResult<()>;
timer			pub mod timer;
timer_init			    fn timer_init(&mut self) -> IoResult<~RtioTimer:Send>;
timespec			                pub struct timespec 
timeval			                pub struct timeval 
timezone			                pub enum timezone {}
tls			    fn tls() 
tls_key			    fn tls_key() -> tls::Key 
tls_smoke_test			fn tls_smoke_test() 
tmpdir			    pub fn tmpdir() -> TempDir 
tmpdir			pub fn tmpdir() -> Path 
tmpfile			                pub fn tmpfile() -> *FILE;
to_ascii			    fn to_ascii(&self) -> T 
to_ascii_lower			    fn to_ascii_lower(&self) -> ~str 
to_ascii_lower			    fn to_ascii_lower(&self) -> ~str;
to_ascii_nocheck			    unsafe fn to_ascii_nocheck(&self) -> &'a [Ascii] 
to_ascii_nocheck			    unsafe fn to_ascii_nocheck(&self) -> &'a[Ascii] 
to_ascii_nocheck			    unsafe fn to_ascii_nocheck(&self) -> Ascii 
to_ascii_nocheck			    unsafe fn to_ascii_nocheck(&self) -> T;
to_ascii_opt			    fn to_ascii_opt(&self) -> Option<T> 
to_ascii_upper			    fn to_ascii_upper(&self) -> ~str 
to_ascii_upper			    fn to_ascii_upper(&self) -> ~str;
to_bit			pub fn to_bit<N: Int>(p: bool) -> N 
to_byte			    pub fn to_byte(self) -> u8 
to_c_str			    fn to_c_str(&self) -> CString 
to_c_str			    fn to_c_str(&self) -> CString;
to_c_str			    fn to_c_str(&self) -> CString 
to_c_str			    fn to_c_str(&self) -> CString 
to_c_str_unchecked			    unsafe fn to_c_str_unchecked(&self) -> CString 
to_c_str_unchecked			    unsafe fn to_c_str_unchecked(&self) -> CString;
to_c_str_unchecked			    unsafe fn to_c_str_unchecked(&self) -> CString 
to_c_str_unchecked			    unsafe fn to_c_str_unchecked(&self) -> CString 
to_char			    pub fn to_char(self) -> char 
to_char_lossy			    pub fn to_char_lossy(&self) -> char 
to_degrees			    fn to_degrees(&self) -> f32 { *self * (180.0f32 \/ Float::pi()) }
to_degrees			    fn to_degrees(&self) -> f64 { *self * (180.0f64 \/ Float::pi()) }
to_degrees			    fn to_degrees(&self) -> Self;
to_digit			    fn to_digit(&self, radix: uint) -> Option<uint> { to_digit(*self, radix) }
to_digit			    fn to_digit(&self, radix: uint) -> Option<uint>;
to_digit			pub fn to_digit(c: char, radix: uint) -> Option<uint> 
to_f32			            fn to_f32(&self) -> Option<f32> { Some(*self as f32) }
to_f32			            fn to_f32(&self) -> Option<f32> { impl_to_primitive_float_to_float!($T, f32) }
to_f32			    fn to_f32(&self) -> Option<f32> 
to_f64			            fn to_f64(&self) -> Option<f64> { Some(*self as f64) }
to_f64			            fn to_f64(&self) -> Option<f64> { impl_to_primitive_float_to_float!($T, f64) }
to_f64			    fn to_f64(&self) -> Option<f64> 
to_hex_str			        fn to_hex_str(r: &[u8, ..8]) -> ~str 
to_i16			            fn to_i16(&self) -> Option<i16> { Some(*self as i16) }
to_i16			            fn to_i16(&self) -> Option<i16> { impl_to_primitive_int_to_int!($T, i16) }
to_i16			            fn to_i16(&self) -> Option<i16> { impl_to_primitive_uint_to_int!(i16) }
to_i16			    fn to_i16(&self) -> Option<i16> 
to_i32			            fn to_i32(&self) -> Option<i32> { Some(*self as i32) }
to_i32			            fn to_i32(&self) -> Option<i32> { impl_to_primitive_int_to_int!($T, i32) }
to_i32			            fn to_i32(&self) -> Option<i32> { impl_to_primitive_uint_to_int!(i32) }
to_i32			    fn to_i32(&self) -> Option<i32> 
to_i64			            fn to_i64(&self) -> Option<i64> { None }
to_i64			            fn to_i64(&self) -> Option<i64> { Some(*self as i64) }
to_i64			            fn to_i64(&self) -> Option<i64> { impl_to_primitive_int_to_int!($T, i64) }
to_i64			            fn to_i64(&self) -> Option<i64> { impl_to_primitive_uint_to_int!(i64) }
to_i64			        fn to_i64(&self) -> Option<i64> { self.x.to_i64() }
to_i64			    fn to_i64(&self) -> Option<i64>;
to_i8			            fn to_i8(&self) -> Option<i8> { Some(*self as i8) }
to_i8			            fn to_i8(&self) -> Option<i8> { impl_to_primitive_int_to_int!($T, i8) }
to_i8			            fn to_i8(&self) -> Option<i8> { impl_to_primitive_uint_to_int!(i8) }
to_i8			    fn to_i8(&self) -> Option<i8> 
to_int			            fn to_int(&self) -> Option<int> { Some(*self as int) }
to_int			            fn to_int(&self) -> Option<int> { impl_to_primitive_int_to_int!($T, int) }
to_int			            fn to_int(&self) -> Option<int> { impl_to_primitive_uint_to_int!(int) }
to_int			    fn to_int(&self) -> Option<int> 
to_lower			    fn to_lower(&self) -> ~[Ascii] 
to_lower			    fn to_lower(&self) -> ~[Ascii];
to_lower			    pub fn to_lower(self) -> Ascii 
to_lower			    pub fn to_lower(c: char) -> char 
to_lowercase			    fn to_lowercase(&self) -> char { to_lowercase(*self) }
to_lowercase			    fn to_lowercase(&self) -> char;
to_lowercase			pub fn to_lowercase(c: char) -> char 
to_option			    unsafe fn to_option(&self) -> Option<&T> 
to_option			    unsafe fn to_option(&self) -> Option<&T>;
to_owned			    fn to_owned(&self) -> ~[T] { self.clone() }
to_owned			    fn to_owned(&self) -> ~[T] 
to_owned			    fn to_owned(&self) -> ~[T];
to_owned			    fn to_owned(&self) -> ~str 
to_owned			    fn to_owned(&self) -> ~str;
to_radians			    fn to_radians(&self) -> f32 
to_radians			    fn to_radians(&self) -> f64 
to_radians			    fn to_radians(&self) -> Self;
to_str			pub mod to_str;
to_str			pub fn to_str(num: f32) -> ~str 
to_str			pub fn to_str(num: f64) -> ~str 
to_str			    fn to_str(&self) -> ~str { format!("{}", *self) }
to_str			    fn to_str(&self) -> ~str;
to_str_base_36			        fn to_str_base_36(bh: &mut BenchHarness) 
to_str_bin			        fn to_str_bin(bh: &mut BenchHarness) 
to_str_bytes			pub fn to_str_bytes<U>(n: $T, radix: uint, f: |v: &[u8]| -> U) -> U 
to_str_bytes			pub fn to_str_bytes<U>(n: $T, radix: uint, f: |v: &[u8]| -> U) -> U 
to_str_dec			        fn to_str_dec(bh: &mut BenchHarness) 
to_str_digits			pub fn to_str_digits(num: f32, dig: uint) -> ~str 
to_str_digits			pub fn to_str_digits(num: f64, dig: uint) -> ~str 
to_str_exact			pub fn to_str_exact(num: f32, dig: uint) -> ~str 
to_str_exact			pub fn to_str_exact(num: f64, dig: uint) -> ~str 
to_str_exp_digits			pub fn to_str_exp_digits(num: f32, dig: uint, upper: bool) -> ~str 
to_str_exp_digits			pub fn to_str_exp_digits(num: f64, dig: uint, upper: bool) -> ~str 
to_str_exp_exact			pub fn to_str_exp_exact(num: f32, dig: uint, upper: bool) -> ~str 
to_str_exp_exact			pub fn to_str_exp_exact(num: f64, dig: uint, upper: bool) -> ~str 
to_str_hex			pub fn to_str_hex(num: f32) -> ~str 
to_str_hex			pub fn to_str_hex(num: f64) -> ~str 
to_str_hex			        fn to_str_hex(bh: &mut BenchHarness) 
to_str_oct			        fn to_str_oct(bh: &mut BenchHarness) 
to_str_radix			    fn to_str_radix(&self, rdx: uint) -> ~str 
to_str_radix			    fn to_str_radix(&self, rdx: uint) -> ~str 
to_str_radix			    fn to_str_radix(&self, radix: uint) -> ~str 
to_str_radix			    fn to_str_radix(&self, radix: uint) -> ~str;
to_str_radix			    fn to_str_radix(&self, radix: uint) -> ~str 
to_str_radix1			    pub fn to_str_radix1() 
to_str_radix37			    pub fn to_str_radix37() 
to_str_radix_special			pub fn to_str_radix_special(num: f32, rdx: uint) -> (~str, bool) 
to_str_radix_special			pub fn to_str_radix_special(num: f64, rdx: uint) -> (~str, bool) 
to_u16			            fn to_u16(&self) -> Option<u16> { Some(*self as u16) }
to_u16			            fn to_u16(&self) -> Option<u16> { impl_to_primitive_int_to_uint!($T, u16) }
to_u16			            fn to_u16(&self) -> Option<u16> { impl_to_primitive_uint_to_uint!($T, u16) }
to_u16			    fn to_u16(&self) -> Option<u16> 
to_u32			            fn to_u32(&self) -> Option<u32> { Some(*self as u32) }
to_u32			            fn to_u32(&self) -> Option<u32> { impl_to_primitive_int_to_uint!($T, u32) }
to_u32			            fn to_u32(&self) -> Option<u32> { impl_to_primitive_uint_to_uint!($T, u32) }
to_u32			    fn to_u32(&self) -> Option<u32> 
to_u64			            fn to_u64(&self) -> Option<u64> { None }
to_u64			            fn to_u64(&self) -> Option<u64> { Some(*self as u64) }
to_u64			            fn to_u64(&self) -> Option<u64> { impl_to_primitive_int_to_uint!($T, u64) }
to_u64			            fn to_u64(&self) -> Option<u64> { impl_to_primitive_uint_to_uint!($T, u64) }
to_u64			        fn to_u64(&self) -> Option<u64> { self.x.to_u64() }
to_u64			    fn to_u64(&self) -> Option<u64>;
to_u8			            fn to_u8(&self) -> Option<u8> { Some(*self as u8) }
to_u8			            fn to_u8(&self) -> Option<u8> { impl_to_primitive_int_to_uint!($T, u8) }
to_u8			            fn to_u8(&self) -> Option<u8> { impl_to_primitive_uint_to_uint!($T, u8) }
to_u8			    fn to_u8(&self) -> Option<u8> 
to_uint			            fn to_uint(&self) -> Option<uint> { Some(*self as uint) }
to_uint			            fn to_uint(&self) -> Option<uint> { impl_to_primitive_int_to_uint!($T, uint) }
to_uint			            fn to_uint(&self) -> Option<uint> { impl_to_primitive_uint_to_uint!($T, uint) }
to_uint			    fn to_uint(&self) -> Option<uint> 
to_uint			    fn to_uint(&self) -> uint { *self as uint }
to_uint			    fn to_uint(&self) -> uint;
to_upper			    fn to_upper(&self) -> ~[Ascii] 
to_upper			    fn to_upper(&self) -> ~[Ascii];
to_upper			    pub fn to_upper(self) -> Ascii 
to_upper			    pub fn to_upper(c: char) -> char 
to_uppercase			    fn to_uppercase(&self) -> char { to_uppercase(*self) }
to_uppercase			    fn to_uppercase(&self) -> char;
to_uppercase			pub fn to_uppercase(c: char) -> char 
to_utf16			    fn to_utf16(&self) -> ~[u16] 
to_utf16			    fn to_utf16(&self) -> ~[u16];
tolower			                pub fn tolower(c: c_char) -> c_char;
toupper			                pub fn toupper(c: c_char) -> c_char;
trace_fn			        extern fn trace_fn(ctx: *uw::_Unwind_Context,
trailing_zeros			    fn trailing_zeros(&self) -> i16 { unsafe { intrinsics::cttz16(*self) } }
trailing_zeros			    fn trailing_zeros(&self) -> i32 { unsafe { intrinsics::cttz32(*self) } }
trailing_zeros			    fn trailing_zeros(&self) -> i64 { unsafe { intrinsics::cttz64(*self) } }
trailing_zeros			    fn trailing_zeros(&self) -> i8 { unsafe { intrinsics::cttz8(*self) } }
trailing_zeros			    fn trailing_zeros(&self) -> int { (*self as i32).trailing_zeros() as int }
trailing_zeros			    fn trailing_zeros(&self) -> int { (*self as i64).trailing_zeros() as int }
trailing_zeros			    fn trailing_zeros(&self) -> Self;
trailing_zeros			    fn trailing_zeros(&self) -> $T 
trait_static_method_call			    fn trait_static_method_call(bh: &mut BenchHarness) 
trait_vtable_method_call			    fn trait_vtable_method_call(bh: &mut BenchHarness) 
traits			pub mod traits 
traits			pub mod traits {}
traits			pub mod traits 
traits			pub mod traits {}
transmute			pub unsafe fn transmute<L, G>(thing: L) -> G 
transmute			    pub fn transmute<T,U>(e: T) -> U;
transmute_copy			pub unsafe fn transmute_copy<T, U>(src: &T) -> U 
transmute_mut			pub unsafe fn transmute_mut<'a,T>(ptr: &'a T) -> &'a mut T { transmute(ptr) }
transmute_mut_region			pub unsafe fn transmute_mut_region<'a,'b,T>(ptr: &'a mut T) -> &'b mut T 
transmute_mut_unsafe			pub unsafe fn transmute_mut_unsafe<T>(ptr: *T) -> *mut T 
transmute_region			pub unsafe fn transmute_region<'a,'b,T>(ptr: &'a T) -> &'b T 
trim			    fn trim(&self) -> &'a str 
trim			    fn trim(&self) -> &'a str;
trim_chars			    fn trim_chars<C: CharEq>(&self, to_trim: &C) -> &'a str 
trim_chars			    fn trim_chars<C: CharEq>(&self, to_trim: &C) -> &'a str;
trim_left			    fn trim_left(&self) -> &'a str 
trim_left			    fn trim_left(&self) -> &'a str;
trim_left_chars			    fn trim_left_chars<C: CharEq>(&self, to_trim: &C) -> &'a str 
trim_left_chars			    fn trim_left_chars<C: CharEq>(&self, to_trim: &C) -> &'a str;
trim_right			    fn trim_right(&self) -> &'a str 
trim_right			    fn trim_right(&self) -> &'a str;
trim_right_chars			    fn trim_right_chars<C: CharEq>(&self, to_trim: &C) -> &'a str 
trim_right_chars			    fn trim_right_chars<C: CharEq>(&self, to_trim: &C) -> &'a str;
trunc			    fn trunc(&self) -> f32 { trunc(*self) }
trunc			    fn trunc(n: f32) -> f32 = intrinsics::truncf32,
trunc			    fn trunc(&self) -> f64 { trunc(*self) }
trunc			    fn trunc(n: f64) -> f64 = intrinsics::truncf64,
trunc			    fn trunc(&self) -> Self;
truncate			    pub fn truncate(&mut self, size: i64) -> IoResult<()> 
truncate			    fn truncate(&mut self, offset: i64) -> IoResult<()>;
truncate			    fn truncate(&mut self, newlen: uint) 
truncate			    fn truncate(&mut self, newlen: uint);
truncate			    fn truncate(&mut self, len: uint) 
truncate			    fn truncate(&mut self, len: uint);
truncate			    pub fn truncate(&mut self, len: uint) 
truncate_utf16_at_nul			pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] 
truncf32			    pub fn truncf32(x: f32) -> f32;
truncf64			    pub fn truncf64(x: f64) -> f64;
try			    pub fn try(&mut self, f: ||) 
try			    pub fn try<T:Send>(mut self, f: proc:Send() -> T) -> Result<T, ~Any:Send> 
try			pub fn try<T:Send>(f: proc:Send() -> T) -> Result<T, ~Any:Send> 
try_borrow			    pub fn try_borrow<'a>(&'a self) -> Option<Ref<'a, T>> 
try_borrow_mut			    pub fn try_borrow_mut<'a>(&'a self) -> Option<RefMut<'a, T>> 
try_finally			pub fn try_finally<T,U,R>(mutate: &mut T,
try_fn			        extern fn try_fn(code: *c_void, env: *c_void) 
try_recv			    pub fn try_recv(&self) -> TryRecvResult<T> 
try_recv			    pub fn try_recv(&mut self) -> Result<T, Failure<T>> 
try_recv			    pub fn try_recv(&mut self) -> Result<T, Failure> 
try_recv			    pub fn try_recv(&mut self) -> Result<T, Failure<T>> 
try_recv			    pub fn try_recv(&self) -> Result<T, Failure> 
try_send			    pub fn try_send(&self, t: T) -> TrySendResult<T> 
try_send			    pub fn try_send(&self, t: T) -> bool 
try_send			    pub fn try_send(&self, t: T) -> super::TrySendResult<T> 
try_take			    fn try_take() -> Option<~Self>;
try_take			    fn try_take() -> Option<~Task> { unsafe { local_ptr::try_take() } }
try_take			    fn try_take() 
try_take			    pub unsafe fn try_take<T>() -> Option<~T> 
try_unsafe_borrow			    unsafe fn try_unsafe_borrow() -> Option<*mut Self>;
try_unsafe_borrow			    unsafe fn try_unsafe_borrow() -> Option<*mut Task> 
try_unsafe_borrow			    pub unsafe fn try_unsafe_borrow<T>() -> Option<*mut T> 
trylock			        pub unsafe fn trylock(&self) -> bool 
trylock			    pub unsafe fn trylock<'a>(&'a self) -> Option<LockGuard<'a>> 
trylock_noguard			    pub unsafe fn trylock_noguard(&self) -> bool 
tty_open			    fn tty_open(&mut self, fd: c_int, readable: bool)
ttyname			                pub fn ttyname(fd: c_int) -> *c_char;
tuple			pub mod tuple;
two_pi			    fn two_pi() -> f32 { 6.28318530717958647692528676655900576 }
two_pi			    fn two_pi() -> f64 { 6.28318530717958647692528676655900576 }
two_pi			    fn two_pi() -> Self;
type_id			    pub fn type_id<T: 'static>() -> TypeId;
types			pub mod types 
u16_add_with_overflow			    pub fn u16_add_with_overflow(x: u16, y: u16) -> (u16, bool);
u16_mul_with_overflow			    pub fn u16_mul_with_overflow(x: u16, y: u16) -> (u16, bool);
u16_sub_with_overflow			    pub fn u16_sub_with_overflow(x: u16, y: u16) -> (u16, bool);
u16x8			pub struct u16x8(u16, u16, u16, u16, u16, u16, u16, u16);
u32_add_with_overflow			    pub fn u32_add_with_overflow(x: u32, y: u32) -> (u32, bool);
u32_mul_with_overflow			    pub fn u32_mul_with_overflow(x: u32, y: u32) -> (u32, bool);
u32_sub_with_overflow			    pub fn u32_sub_with_overflow(x: u32, y: u32) -> (u32, bool);
u32x4			pub struct u32x4(u32, u32, u32, u32);
u64_add_with_overflow			    pub fn u64_add_with_overflow(x: u64, y: u64) -> (u64, bool);
u64_from_be_bytes			pub fn u64_from_be_bytes(data: &[u8], start: uint, size: uint) -> u64 
u64_from_be_bytes_4_aligned			    fn u64_from_be_bytes_4_aligned(bh: &mut BenchHarness) 
u64_from_be_bytes_4_unaligned			    fn u64_from_be_bytes_4_unaligned(bh: &mut BenchHarness) 
u64_from_be_bytes_7_aligned			    fn u64_from_be_bytes_7_aligned(bh: &mut BenchHarness) 
u64_from_be_bytes_7_unaligned			    fn u64_from_be_bytes_7_unaligned(bh: &mut BenchHarness) 
u64_from_be_bytes_8_aligned			    fn u64_from_be_bytes_8_aligned(bh: &mut BenchHarness) 
u64_from_be_bytes_8_unaligned			    fn u64_from_be_bytes_8_unaligned(bh: &mut BenchHarness) 
u64_mul_with_overflow			    pub fn u64_mul_with_overflow(x: u64, y: u64) -> (u64, bool);
u64_sub_with_overflow			    pub fn u64_sub_with_overflow(x: u64, y: u64) -> (u64, bool);
u64_to_be_bytes			pub fn u64_to_be_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T 
u64_to_le_bytes			pub fn u64_to_le_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T 
u64x2			pub struct u64x2(u64, u64);
u8_add_with_overflow			    pub fn u8_add_with_overflow(x: u8, y: u8) -> (u8, bool);
u8_mul_with_overflow			    pub fn u8_mul_with_overflow(x: u8, y: u8) -> (u8, bool);
u8_sub_with_overflow			    pub fn u8_sub_with_overflow(x: u8, y: u8) -> (u8, bool);
u8x16			pub struct u8x16(u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8);
udp			pub mod udp;
udp_bind			    fn udp_bind(&mut self, addr: SocketAddr) -> IoResult<~RtioUdpSocket:Send>;
uint			    mod uint 
uint			    mod uint 
ungetc			                pub fn ungetc(c: c_int, stream: *FILE) -> c_int;
unicode			mod unicode;
uninit			    pub fn uninit<T>() -> T;
uninit			pub unsafe fn uninit<T>() -> T 
unistd			        pub mod unistd 
unit			pub mod unit;
unix			pub mod unix;
unix			    pub mod unix 
unix_bind			    fn unix_bind(&mut self, path: &CString)
unix_connect			    fn unix_connect(&mut self, path: &CString) -> IoResult<~RtioPipe:Send>;
unlink			pub fn unlink(path: &Path) -> IoResult<()> 
unlink			                pub fn unlink(c: *c_char) -> c_int;
unlock			        pub unsafe fn unlock(&self) { pthread_mutex_unlock(self.lock.get()); }
unlock			        pub unsafe fn unlock(&self) 
unlock_noguard			    pub unsafe fn unlock_noguard(&self) { self.inner.unlock() }
unlock_noguard			    pub unsafe fn unlock_noguard(&self) { self.inner.unlock_noguard() }
unregister			    pub fn unregister(&mut self, signum: Signum) 
unsafe_borrow			    unsafe fn unsafe_borrow() -> *mut Self;
unsafe_borrow			    unsafe fn unsafe_borrow() -> *mut Task { local_ptr::unsafe_borrow() }
unsafe_borrow			    pub unsafe fn unsafe_borrow<T>() -> *mut T 
unsafe_get			    fn unsafe_get(xs: &[u8], i: uint) -> u8 
unsafe_mut_ref			    unsafe fn unsafe_mut_ref(self, index: uint) -> &'a mut T 
unsafe_mut_ref			    unsafe fn unsafe_mut_ref(self, index: uint) -> &'a mut T;
unsafe_ref			    unsafe fn unsafe_ref(self, index: uint) -> &'a T 
unsafe_ref			    unsafe fn unsafe_ref(self, index: uint) -> &'a T;
unsafe_set			    unsafe fn unsafe_set(self, index: uint, val: T) 
unsafe_set			    unsafe fn unsafe_set(self, index: uint, val: T);
unsafe_take			    unsafe fn unsafe_take() -> ~Self;
unsafe_take			    unsafe fn unsafe_take() -> ~Task { local_ptr::unsafe_take() }
unsafe_take			    pub unsafe fn unsafe_take<T>() -> ~T 
unsetenv			                pub fn unsetenv(name: *c_char) -> c_int;
unsetenv			pub fn unsetenv(n: &str) 
unshift			    fn unshift(&mut self, x: T) 
unshift			    fn unshift(&mut self, x: T);
unshift			    pub fn unshift(&mut self, element: T) 
unshift_char			    fn unshift_char(&mut self, ch: char) 
unshift_char			    fn unshift_char(&mut self, ch: char);
unstable			pub mod unstable;
unwind			pub mod unwind;
unwind			    fn unwind() 
unwinding			    pub fn unwinding(&self) -> bool 
unwrap			    pub unsafe fn unwrap(self) -> *libc::c_char 
unwrap			    pub unsafe fn unwrap(mut self) -> *mut T 
unwrap			    pub fn unwrap(self) -> T 
unwrap			    pub fn unwrap(mut self) -> W 
unwrap			    pub fn unwrap(self) -> R { self.inner }
unwrap			    pub fn unwrap(self) -> S 
unwrap			    pub fn unwrap(self) -> W { self.inner.unwrap() }
unwrap			    pub fn unwrap(self) -> ~[u8] { self.buf }
unwrap			    pub fn unwrap(self) -> Path 
unwrap			    pub fn unwrap(self) -> (R, W) 
unwrap			    pub fn unwrap(self) -> R { self.inner }
unwrap			    pub fn unwrap(self) -> T 
unwrap			    pub fn unwrap(self) -> V { self.inner }
unwrap			    pub fn unwrap(self) -> T 
unwrap			    pub unsafe fn unwrap(self) -> T { self.value }
unwrap_err			    pub fn unwrap_err(self) -> E 
unwrap_or			    pub fn unwrap_or(self, def: T) -> T 
unwrap_or_default			    pub fn unwrap_or_default(self) -> T 
unwrap_or_else			    pub fn unwrap_or_else(self, f: || -> T) -> T 
unzip			pub fn unzip<T, U, V: Iterator<(T, U)>>(mut iter: V) -> (~[T], ~[U]) 
update			    fn update(&mut self, _alloc: &mut AllocHeader, _orig: *AllocHeader) {}
update			    fn update(&mut self, alloc: &mut AllocHeader, orig: *AllocHeader) 
update_normalized			    fn update_normalized<S: Str>(&mut self, s: S) 
update_sepidx			    fn update_sepidx(&mut self) 
update_size			    fn update_size(&mut self, _size: u32) {}
update_size			    fn update_size(&mut self, size: u32) 
upgrade			    pub fn upgrade(&mut self, up: Receiver<T>) -> UpgradeResult 
upgrade			    pub fn upgrade(&mut self, up: Receiver<T>) -> UpgradeResult 
upgrade			    pub fn upgrade(&self) -> Option<Rc<T>> 
usleep			                pub fn usleep(secs: c_uint) -> c_int;
utf16_items			pub fn utf16_items<'a>(v: &'a [u16]) -> UTF16Items<'a> 
utf8_char_width			pub fn utf8_char_width(b: u8) -> uint 
util			pub mod util;
util			mod util;
utimbuf			                pub struct utimbuf 
utime			    fn utime() 
utime			                pub fn utime(file: *c_char, buf: *utimbuf) -> c_int;
utime_noexist			    fn utime_noexist() 
vec			pub mod vec;
vec_str_conversions			    fn vec_str_conversions() 
visit_bool			    fn visit_bool(&mut self) -> bool;
visit_bool			    fn visit_bool(&mut self) -> bool 
visit_bool			    fn visit_bool(&mut self) -> bool { self.write::<bool>() }
visit_bot			    fn visit_bot(&mut self) -> bool;
visit_bot			    fn visit_bot(&mut self) -> bool 
visit_bot			    fn visit_bot(&mut self) -> bool 
visit_box			    fn visit_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool;
visit_box			    fn visit_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool 
visit_box			    fn visit_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool 
visit_char			    fn visit_char(&mut self) -> bool;
visit_char			    fn visit_char(&mut self) -> bool 
visit_char			    fn visit_char(&mut self) -> bool 
visit_class_field			    fn visit_class_field(&mut self, i: uint, name: &str, named: bool,
visit_class_field			    fn visit_class_field(&mut self, i: uint, name: &str, named: bool, mtbl: uint,
visit_class_field			    fn visit_class_field(&mut self, i: uint, name: &str, named: bool,
visit_enter_class			    fn visit_enter_class(&mut self, name: &str, named_fields: bool, n_fields: uint,
visit_enter_class			    fn visit_enter_class(&mut self, name: &str, named_fields: bool, n_fields: uint, sz: uint,
visit_enter_class			    fn visit_enter_class(&mut self, name: &str, named_fields: bool, n_fields: uint,
visit_enter_enum			    fn visit_enter_enum(&mut self, n_variants: uint,
visit_enter_enum			    fn visit_enter_enum(&mut self, n_variants: uint,
visit_enter_enum			    fn visit_enter_enum(&mut self,
visit_enter_enum_variant			    fn visit_enter_enum_variant(&mut self, variant: uint,
visit_enter_enum_variant			    fn visit_enter_enum_variant(&mut self, variant: uint,
visit_enter_enum_variant			    fn visit_enter_enum_variant(&mut self, _variant: uint,
visit_enter_fn			    fn visit_enter_fn(&mut self, purity: uint, proto: uint,
visit_enter_fn			    fn visit_enter_fn(&mut self, purity: uint, proto: uint,
visit_enter_fn			    fn visit_enter_fn(&mut self, _purity: uint, _proto: uint,
visit_enter_rec			    fn visit_enter_rec(&mut self, n_fields: uint,
visit_enter_rec			    fn visit_enter_rec(&mut self, n_fields: uint, sz: uint, align: uint) -> bool 
visit_enter_rec			    fn visit_enter_rec(&mut self, _n_fields: uint,
visit_enter_tup			    fn visit_enter_tup(&mut self, n_fields: uint,
visit_enter_tup			    fn visit_enter_tup(&mut self, n_fields: uint, sz: uint, align: uint) -> bool 
visit_enter_tup			    fn visit_enter_tup(&mut self, _n_fields: uint,
visit_enum_variant_field			    fn visit_enum_variant_field(&mut self, i: uint, offset: uint, inner: *TyDesc) -> bool;
visit_enum_variant_field			    fn visit_enum_variant_field(&mut self, i: uint, offset: uint, inner: *TyDesc) -> bool 
visit_enum_variant_field			    fn visit_enum_variant_field(&mut self,
visit_estr_box			    fn visit_estr_box(&mut self) -> bool;
visit_estr_box			    fn visit_estr_box(&mut self) -> bool 
visit_estr_box			    fn visit_estr_box(&mut self) -> bool 
visit_estr_fixed			    fn visit_estr_fixed(&mut self, n: uint, sz: uint, align: uint) -> bool;
visit_estr_fixed			    fn visit_estr_fixed(&mut self, n: uint,
visit_estr_fixed			    fn visit_estr_fixed(&mut self, _n: uint, _sz: uint,
visit_estr_slice			    fn visit_estr_slice(&mut self) -> bool;
visit_estr_slice			    fn visit_estr_slice(&mut self) -> bool 
visit_estr_slice			    fn visit_estr_slice(&mut self) -> bool 
visit_estr_uniq			    fn visit_estr_uniq(&mut self) -> bool;
visit_estr_uniq			    fn visit_estr_uniq(&mut self) -> bool 
visit_estr_uniq			    fn visit_estr_uniq(&mut self) -> bool 
visit_evec_box			    fn visit_evec_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool;
visit_evec_box			    fn visit_evec_box(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool 
visit_evec_box			    fn visit_evec_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool 
visit_evec_fixed			    fn visit_evec_fixed(&mut self, n: uint, sz: uint, align: uint,
visit_evec_fixed			    fn visit_evec_fixed(&mut self, n: uint, sz: uint, align: uint,
visit_evec_fixed			    fn visit_evec_fixed(&mut self, n: uint, sz: uint, _align: uint,
visit_evec_slice			    fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool;
visit_evec_slice			    fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool 
visit_evec_slice			    fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool 
visit_evec_uniq			    fn visit_evec_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool;
visit_evec_uniq			    fn visit_evec_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool 
visit_evec_uniq			    fn visit_evec_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool 
visit_f32			    fn visit_f32(&mut self) -> bool;
visit_f32			    fn visit_f32(&mut self) -> bool 
visit_f32			    fn visit_f32(&mut self) -> bool { self.write::<f32>() }
visit_f64			    fn visit_f64(&mut self) -> bool;
visit_f64			    fn visit_f64(&mut self) -> bool 
visit_f64			    fn visit_f64(&mut self) -> bool { self.write::<f64>() }
visit_fn_input			    fn visit_fn_input(&mut self, i: uint, mode: uint, inner: *TyDesc) -> bool;
visit_fn_input			    fn visit_fn_input(&mut self, i: uint, mode: uint, inner: *TyDesc) -> bool 
visit_fn_input			    fn visit_fn_input(&mut self, i: uint, _mode: uint, inner: *TyDesc) -> bool 
visit_fn_output			    fn visit_fn_output(&mut self, retstyle: uint, variadic: bool, inner: *TyDesc) -> bool;
visit_fn_output			    fn visit_fn_output(&mut self, retstyle: uint, variadic: bool, inner: *TyDesc) -> bool 
visit_fn_output			    fn visit_fn_output(&mut self, _retstyle: uint, variadic: bool,
visit_i16			    fn visit_i16(&mut self) -> bool;
visit_i16			    fn visit_i16(&mut self) -> bool 
visit_i16			    fn visit_i16(&mut self) -> bool { self.write::<i16>() }
visit_i32			    fn visit_i32(&mut self) -> bool;
visit_i32			    fn visit_i32(&mut self) -> bool 
visit_i32			    fn visit_i32(&mut self) -> bool { self.write::<i32>()  }
visit_i64			    fn visit_i64(&mut self) -> bool;
visit_i64			    fn visit_i64(&mut self) -> bool 
visit_i64			    fn visit_i64(&mut self) -> bool { self.write::<i64>() }
visit_i8			    fn visit_i8(&mut self) -> bool;
visit_i8			    fn visit_i8(&mut self) -> bool 
visit_i8			    fn visit_i8(&mut self) -> bool { self.write::<i8>() }
visit_inner			    pub fn visit_inner(&mut self, inner: *TyDesc) -> bool 
visit_int			    fn visit_int(&mut self) -> bool;
visit_int			    fn visit_int(&mut self) -> bool 
visit_int			    fn visit_int(&mut self) -> bool { self.write::<int>() }
visit_leave_class			    fn visit_leave_class(&mut self, name: &str, named_fields: bool, n_fields: uint,
visit_leave_class			    fn visit_leave_class(&mut self, name: &str, named_fields: bool, n_fields: uint, sz: uint,
visit_leave_class			    fn visit_leave_class(&mut self, _name: &str, named_fields: bool, n_fields: uint,
visit_leave_enum			    fn visit_leave_enum(&mut self, n_variants: uint,
visit_leave_enum			    fn visit_leave_enum(&mut self, n_variants: uint,
visit_leave_enum			    fn visit_leave_enum(&mut self,
visit_leave_enum_variant			    fn visit_leave_enum_variant(&mut self, variant: uint,
visit_leave_enum_variant			    fn visit_leave_enum_variant(&mut self, variant: uint,
visit_leave_enum_variant			    fn visit_leave_enum_variant(&mut self, _variant: uint,
visit_leave_fn			    fn visit_leave_fn(&mut self, purity: uint, proto: uint,
visit_leave_fn			    fn visit_leave_fn(&mut self, purity: uint, proto: uint,
visit_leave_fn			    fn visit_leave_fn(&mut self, _purity: uint, _proto: uint,
visit_leave_rec			    fn visit_leave_rec(&mut self, n_fields: uint,
visit_leave_rec			    fn visit_leave_rec(&mut self, n_fields: uint, sz: uint, align: uint) -> bool 
visit_leave_rec			    fn visit_leave_rec(&mut self, _n_fields: uint,
visit_leave_tup			    fn visit_leave_tup(&mut self, n_fields: uint,
visit_leave_tup			    fn visit_leave_tup(&mut self, n_fields: uint, sz: uint, align: uint) -> bool 
visit_leave_tup			    fn visit_leave_tup(&mut self, _n_fields: uint,
visit_nil			    fn visit_nil(&mut self) -> bool;
visit_nil			    fn visit_nil(&mut self) -> bool 
visit_nil			    fn visit_nil(&mut self) -> bool { self.write::<()>() }
visit_param			    fn visit_param(&mut self, i: uint) -> bool;
visit_param			    fn visit_param(&mut self, i: uint) -> bool 
visit_param			    fn visit_param(&mut self, _i: uint) -> bool { true }
visit_ptr			    fn visit_ptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool;
visit_ptr			    fn visit_ptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool 
visit_ptr			    fn visit_ptr(&mut self, mtbl: uint, _inner: *TyDesc) -> bool 
visit_ptr_inner			    pub fn visit_ptr_inner(&mut self, ptr: *u8, inner: *TyDesc) -> bool 
visit_rec_field			    fn visit_rec_field(&mut self, i: uint, name: &str,
visit_rec_field			    fn visit_rec_field(&mut self, i: uint, name: &str,
visit_rec_field			    fn visit_rec_field(&mut self, i: uint, name: &str,
visit_rptr			    fn visit_rptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool;
visit_rptr			    fn visit_rptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool 
visit_rptr			    fn visit_rptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool 
visit_self			    fn visit_self(&mut self) -> bool;
visit_self			    fn visit_self(&mut self) -> bool 
visit_self			    fn visit_self(&mut self) -> bool { true }
visit_trait			    fn visit_trait(&mut self, name: &str) -> bool;
visit_trait			    fn visit_trait(&mut self, name: &str) -> bool 
visit_trait			    fn visit_trait(&mut self, name: &str) -> bool 
visit_tup_field			    fn visit_tup_field(&mut self, i: uint, inner: *TyDesc) -> bool;
visit_tup_field			    fn visit_tup_field(&mut self, i: uint, inner: *TyDesc) -> bool 
visit_tup_field			    fn visit_tup_field(&mut self, i: uint, inner: *TyDesc) -> bool 
visit_tydesc			    pub fn visit_tydesc(td: *TyDesc, tv: &mut TyVisitor);
visit_u16			    fn visit_u16(&mut self) -> bool;
visit_u16			    fn visit_u16(&mut self) -> bool 
visit_u16			    fn visit_u16(&mut self) -> bool { self.write::<u16>() }
visit_u32			    fn visit_u32(&mut self) -> bool;
visit_u32			    fn visit_u32(&mut self) -> bool 
visit_u32			    fn visit_u32(&mut self) -> bool { self.write::<u32>() }
visit_u64			    fn visit_u64(&mut self) -> bool;
visit_u64			    fn visit_u64(&mut self) -> bool 
visit_u64			    fn visit_u64(&mut self) -> bool { self.write::<u64>() }
visit_u8			    fn visit_u8(&mut self) -> bool;
visit_u8			    fn visit_u8(&mut self) -> bool 
visit_u8			    fn visit_u8(&mut self) -> bool { self.write::<u8>() }
visit_uint			    fn visit_uint(&mut self) -> bool;
visit_uint			    fn visit_uint(&mut self) -> bool 
visit_uint			    fn visit_uint(&mut self) -> bool { self.write::<uint>() }
visit_unboxed_vec			    fn visit_unboxed_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool;
visit_unboxed_vec			    fn visit_unboxed_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool 
visit_unboxed_vec			    fn visit_unboxed_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool 
visit_uniq			    fn visit_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool;
visit_uniq			    fn visit_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool 
visit_uniq			    fn visit_uniq(&mut self, _mtbl: uint, inner: *TyDesc) -> bool 
visit_vec			    fn visit_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool;
visit_vec			    fn visit_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool 
visit_vec			    fn visit_vec(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { fail!(); }
volatile_load			    pub fn volatile_load<T>(src: *T) -> T;
volatile_store			    pub fn volatile_store<T>(dst: *mut T, val: T);
wait			    pub fn wait(&self) -> uint 
wait			fn wait(slot: &mut Blocker, f: fn(BlockedTask) -> Blocker,
wait			    pub fn wait(&mut self) -> ProcessExit 
wait			        pub mod wait 
wait			    fn wait(&mut self) -> ProcessExit;
wait			        pub unsafe fn wait(&self) 
wait			    pub unsafe fn wait(&self) 
wait2			    fn wait2(&self, do_preflight_checks: bool) -> uint 
wait_for_other_tasks			pub fn wait_for_other_tasks() 
wait_noguard			    pub unsafe fn wait_noguard(&self) { self.inner.wait() }
wait_noguard			    pub unsafe fn wait_noguard(&self) { self.inner.wait_noguard() }
wait_with_output			    pub fn wait_with_output(&mut self) -> ProcessOutput 
waitpid			                pub fn waitpid(pid: pid_t, status: *mut c_int, options: c_int)
wake			    pub fn wake(self) -> Option<~Task> 
wakeup			fn wakeup(task: BlockedTask, guard: LockGuard) 
wakeup_senders			    fn wakeup_senders(&self, waited: bool,
walk_dir			pub fn walk_dir(path: &Path) -> IoResult<Directories> 
wchmod			                pub fn wchmod(path: *wchar_t, mode: c_int) -> c_int;
wcslen			                pub fn wcslen(buf: *wchar_t) -> size_t;
weak			    fn weak(&self) -> uint { self.inner().weak.get() }
weak_self_cyclic			    fn weak_self_cyclic() 
while_some			    pub fn while_some(self, f: |v: T| -> Option<T>) 
win32			    pub mod win32 
win32			pub mod win32 
windows			    pub mod windows 
windows			pub mod windows;
windows			    fn windows(self, size: uint) -> Windows<'a, T> 
windows			    fn windows(self, size: uint) -> Windows<'a, T>;
winsize			    pub fn winsize(&mut self) -> IoResult<(int, int)> 
with			    pub unsafe fn with<U>(&self, f: |x: &mut T| -> U) -> U 
with_c_str			    fn with_c_str<T>(&self, f: |*libc::c_char| -> T) -> T 
with_c_str			unsafe fn with_c_str<T>(v: &[u8], checked: bool, f: |*libc::c_char| -> T) -> T 
with_c_str_unchecked			    unsafe fn with_c_str_unchecked<T>(&self, f: |*libc::c_char| -> T) -> T 
with_capacities			    pub fn with_capacities(reader_cap: uint, writer_cap: uint, inner: S)
with_capacity			    pub fn with_capacity(cap: uint, inner: R) -> BufferedReader<R> 
with_capacity			    pub fn with_capacity(cap: uint, inner: W) -> BufferedWriter<W> 
with_capacity			    pub fn with_capacity(n: uint) -> MemWriter 
with_capacity			pub fn with_capacity<T>(capacity: uint) -> ~[T] 
with_capacity			pub fn with_capacity(capacity: uint) -> ~str 
with_capacity			    fn with_capacity(capacity: uint) -> State<T> 
with_capacity			    pub fn with_capacity(capacity: uint) -> Queue<T> 
with_capacity			    pub fn with_capacity(capacity: uint) -> Vec<T> 
with_env_lock			fn with_env_lock<T>(f: || -> T) -> T 
with_extension			    fn with_extension<T: BytesContainer>(&self, extension: T) -> Self 
with_filename			    fn with_filename<T: BytesContainer>(&self, filename: T) -> Self 
with_imm			    pub unsafe fn with_imm<U>(&self, f: |x: &T| -> U) -> U 
with_lock			    fn with_lock<T>(f: || -> T) -> T 
with_mut_ref			    pub fn with_mut_ref<T>(&mut self, f: |*mut libc::c_char| -> T) -> T 
with_padding			    fn with_padding(&mut self,
with_ref			    pub fn with_ref<T>(&self, f: |*libc::c_char| -> T) -> T 
with_task_name			pub fn with_task_name<U>(blk: |Option<&str>| -> U) -> U 
with_task_stdout			fn with_task_stdout(f: |&mut Writer| -> IoResult<()> ) 
with_wrapper			    pub fn with_wrapper(mut self,
wopen			                pub fn wopen(path: *wchar_t, oflag: c_int, mode: c_int)
word			    fn word(&mut self) -> &'a str 
words			    fn words(&self) -> Words<'a> 
words			    fn words(&self) -> Words<'a>;
wrap			    fn wrap(~self) -> ~Any;
write			pub fn write(output: &mut io::Writer, args: &Arguments) -> Result 
write			        fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			    fn write(&mut self, msg: &[u8]) -> IoResult<()> 
write			            fn write(&mut self, _: &[u8]) -> io::IoResult<()> { Ok(()) }
write			        fn write(&mut self, _: &[u8]) -> io::IoResult<()> { Ok(()) }
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			    fn write(&mut self, _buf: &[u8]) { fail!() }
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.fd.write(buf) }
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.inner.write(buf) }
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.write(buf) }
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()>;
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.obj.write(buf) }
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.obj.write(buf) }
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.obj.write(buf) }
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			                fn write(&mut self, data: &[u8]) -> IoResult<()> 
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			            fn write(&mut self, _buf: &[u8]) -> io::IoResult<()> 
write			    fn write(&mut self, _buf: &[u8]) -> io::IoResult<()> { Ok(()) }
write			    fn write(&mut self, buf: &[u8]) -> io::IoResult<()> 
write			                pub fn write(fd: c_int, buf: *c_void, count: c_uint) -> c_int;
write			                pub fn write(fd: c_int, buf: *c_void, count: size_t)
write			    pub fn write<T:Repr>(&mut self) -> bool 
write			    pub fn write(w: &mut Writer) -> IoResult<()> 
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()>;
write			    fn write(&mut self, data: &[u8]) -> IoResult<()> 
write_be_f32			    fn write_be_f32(&mut self, f: f32) -> IoResult<()> 
write_be_f64			    fn write_be_f64(&mut self, f: f64) -> IoResult<()> 
write_be_i16			    fn write_be_i16(&mut self, n: i16) -> IoResult<()> 
write_be_i32			    fn write_be_i32(&mut self, n: i32) -> IoResult<()> 
write_be_i64			    fn write_be_i64(&mut self, n: i64) -> IoResult<()> 
write_be_int			    fn write_be_int(&mut self, n: int) -> IoResult<()> 
write_be_u16			    fn write_be_u16(&mut self, n: u16) -> IoResult<()> 
write_be_u32			    fn write_be_u32(&mut self, n: u32) -> IoResult<()> 
write_be_u64			    fn write_be_u64(&mut self, n: u64) -> IoResult<()> 
write_be_uint			    fn write_be_uint(&mut self, n: uint) -> IoResult<()> 
write_char			    fn write_char(&mut self, c: char) -> IoResult<()> 
write_escaped_char			    fn write_escaped_char(&mut self, ch: char, is_str: bool) -> bool 
write_escaped_slice			    pub fn write_escaped_slice(&mut self, slice: &str) -> bool 
write_i8			    fn write_i8(&mut self, n: i8) -> IoResult<()> 
write_int			    fn write_int(&mut self, n: int) -> IoResult<()> 
write_le_f32			    fn write_le_f32(&mut self, f: f32) -> IoResult<()> 
write_le_f64			    fn write_le_f64(&mut self, f: f64) -> IoResult<()> 
write_le_i16			    fn write_le_i16(&mut self, n: i16) -> IoResult<()> 
write_le_i32			    fn write_le_i32(&mut self, n: i32) -> IoResult<()> 
write_le_i64			    fn write_le_i64(&mut self, n: i64) -> IoResult<()> 
write_le_int			    fn write_le_int(&mut self, n: int) -> IoResult<()> 
write_le_u16			    fn write_le_u16(&mut self, n: u16) -> IoResult<()> 
write_le_u32			    fn write_le_u32(&mut self, n: u32) -> IoResult<()> 
write_le_u64			    fn write_le_u64(&mut self, n: u64) -> IoResult<()> 
write_le_uint			    fn write_le_uint(&mut self, n: uint) -> IoResult<()> 
write_line			    fn write_line(&mut self, s: &str) -> IoResult<()> 
write_mut_qualifier			    pub fn write_mut_qualifier(&mut self, mtbl: uint) -> bool 
write_repr			    fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()> 
write_repr			    fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()>;
write_repr			pub fn write_repr<T>(writer: &mut io::Writer, object: &T) -> io::IoResult<()> 
write_str			    fn write_str(&mut self, s: &str) -> IoResult<()> 
write_u8			    fn write_u8(&mut self, n: u8) -> IoResult<()> 
write_uint			    fn write_uint(&mut self, n: uint) -> IoResult<()> 
write_unboxed_vec_repr			    pub fn write_unboxed_vec_repr(&mut self, _: uint, v: &raw::Vec<()>, inner: *TyDesc) -> bool 
write_unsafe			pub unsafe fn write_unsafe(output: &mut io::Writer,
write_vec_range			    pub fn write_vec_range(&mut self, ptr: *(), len: uint, inner: *TyDesc) -> bool 
writeln			pub fn writeln(output: &mut io::Writer, args: &Arguments) -> Result 
wrmdir			                pub fn wrmdir(path: *wchar_t) -> c_int;
ws			    fn ws(&mut self) 
wsconsume			    fn wsconsume(&mut self, c: char) -> bool 
wstat			                pub fn wstat(path: *wchar_t, buf: *mut stat) -> c_int;
wutime			                pub fn wutime(file: *wchar_t, buf: *utimbuf) -> c_int;
x86			    pub mod x86 
x86_64			    pub mod x86_64 
y0			        pub fn y0(n: c_double) -> c_double;
y1			        pub fn y1(n: c_double) -> c_double;
yield_now			    fn yield_now(~self, cur_task: ~Task);
yield_now			    pub fn yield_now(mut ~self) 
yield_now			    pub fn yield_now() 
yield_now			    pub unsafe fn yield_now() { assert_eq!(pthread_yield(), 0); }
yield_now			    pub unsafe fn yield_now() { assert_eq!(sched_yield(), 0); }
yield_now			    pub unsafe fn yield_now() 
yn			        pub fn yn(i: c_int, n: c_double) -> c_double;
zero			    fn zero() -> f32 { 0.0 }
zero			    fn zero() -> f64 { 0.0 }
zero			    fn zero() -> $T { 0 }
zero			    fn zero() -> Self;
zero			    fn zero() -> $T { 0 }
zero_1kb_fixed_repeat			    fn zero_1kb_fixed_repeat(bh: &mut BenchHarness) 
zero_1kb_from_elem			    fn zero_1kb_from_elem(bh: &mut BenchHarness) 
zero_1kb_loop_set			    fn zero_1kb_loop_set(bh: &mut BenchHarness) 
zero_1kb_mut_iter			    fn zero_1kb_mut_iter(bh: &mut BenchHarness) 
zero_1kb_set_memory			    fn zero_1kb_set_memory(bh: &mut BenchHarness) 
zero_byte			        fn zero_byte(val: u32, byte: uint) -> u32 
zero_byte			        fn zero_byte(val: u64, byte: uint) -> u64 
zero_memory			pub unsafe fn zero_memory<T>(dst: *mut T, count: uint) 
zip			    fn zip<B, U: Iterator<B>>(self, other: U) -> Zip<Self, U> 
