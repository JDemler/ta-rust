ADDRESS64			    struct ADDRESS64 
ADDRESS_MODE			    enum ADDRESS_MODE 
Acceptor			pub trait Acceptor<T> 
Acceptor			impl Acceptor<TcpStream> for TcpAcceptor 
Acceptor			impl Acceptor<UnixStream> for UnixAcceptor 
Adaptor			        struct Adaptor<'a, T> 
Ascii			impl Ascii 
Ascii			pub struct Ascii { chr: u8 }
AsciiCast			impl AsciiCast<Ascii> for char 
AsciiCast			impl AsciiCast<Ascii> for u8 
AsciiCast			pub trait AsciiCast<T> 
AsciiStr			pub trait AsciiStr 
BadReader			    struct BadReader<T> 
BadReaderBehavior			    enum BadReaderBehavior 
BitAnd			        impl BitAnd<
BitOr			        impl BitOr<
Bomb			        struct Bomb(Sender<bool>);
BucketState			    pub enum BucketState 
BufReader			pub struct BufReader<'a> 
BufWriter			pub struct BufWriter<'a> 
Buffer			impl Buffer for MemReader 
Buffer			pub trait Buffer: Reader 
Buffer			impl Buffer for NullReader 
Buffer			impl Buffer for ZeroReader 
BufferedReader			pub struct BufferedReader<R> 
BufferedStream			pub struct BufferedStream<S> 
BufferedWriter			pub struct BufferedWriter<W> 
Bytes			pub struct Bytes<'r, T> 
BytesContainer			impl BytesContainer for CString 
BytesContainer			impl BytesContainer for String 
BytesContainer			impl BytesContainer for Vec<u8> 
BytesContainer			pub trait BytesContainer 
BytesContainer			impl BytesContainer for Path 
BytesContainer			impl BytesContainer for Path 
CONTEXT			        pub struct CONTEXT 
CVec			pub struct CVec<T> 
Callback			        impl Callback for SignalCallback 
Callback			impl Callback for TimerCallback 
ChainedReader			pub struct ChainedReader<I, R> 
ChanReader			impl ChanReader 
ChanReader			pub struct ChanReader 
ChanWriter			impl ChanWriter 
ChanWriter			pub struct ChanWriter 
Chars			pub struct Chars<'r, T> 
Cleanup			    struct Cleanup 
Clone			impl Clone for ChanWriter 
Clone			impl Clone for TcpStream 
Clone			impl Clone for UdpSocket 
Clone			impl Clone for UnixStream 
Clone			impl Clone for PipeStream 
Closer			        struct Closer { fd: libc::c_int }
Command			impl Command 
Command			pub struct Command 
CommandLineToArgvW			    fn CommandLineToArgvW(lpCmdLine: LPCWSTR,
ConstRng			    struct ConstRng { i: u64 }
Context			        struct Context<'a> 
CryptAcquireContextA			        fn CryptAcquireContextA(phProv: *mut HCRYPTPROV,
CryptGenRandom			        fn CryptGenRandom(hProv: HCRYPTPROV,
CryptReleaseContext			        fn CryptReleaseContext(hProv: HCRYPTPROV, dwFlags: DWORD) -> BOOL;
Default			impl Default for RandomSipHasher 
DefaultResizePolicy			impl DefaultResizePolicy 
DefaultResizePolicy			struct DefaultResizePolicy 
Directories			pub struct Directories 
Display			pub struct Display<'a, P> 
Dl_info			        struct Dl_info 
Drop			    impl Drop for Dropable 
Drop			impl Drop for DynamicLibrary 
Drop			    impl Drop for TempDir 
Drop			        impl Drop for Closer 
Drop			impl Drop for Process 
Drop			impl Drop for TempDir 
Drop			impl Drop for MemoryMap 
Drop			    impl Drop for OsRng 
Drop			    impl Drop for Cleanup 
Drop			        impl Drop for Bomb 
Dropable			    impl Dropable 
Dropable			    struct Dropable 
DynamicLibrary			impl DynamicLibrary 
DynamicLibrary			pub struct DynamicLibrary { handle: *mut u8 }
EmptyIndex			    pub struct EmptyIndex 
Entries			    pub struct Entries<'a, K, V> 
EofReader			    struct EofReader;
Eq			impl Eq for Path {}
Eq			impl Eq for Path {}
Equiv			    impl Equiv<int> for KindaIntLike 
ErroringLaterReader			    struct ErroringLaterReader 
ErroringReader			    struct ErroringReader;
ExponentFormat			pub enum ExponentFormat 
FLOATING_SAVE_AREA			        pub struct FLOATING_SAVE_AREA 
FailFlushWriter			        struct FailFlushWriter;
File			impl File 
File			pub struct File 
FileAccess			pub enum FileAccess 
FileMode			pub enum FileMode 
FileStat			pub struct FileStat 
FileType			pub enum FileType 
Flag			pub enum Flag 
FloatMath			impl FloatMath for f32 
FloatMath			impl FloatMath for f64 
FloatMath			pub trait FloatMath: Float 
FormatMessageW			            fn FormatMessageW(flags: DWORD,
FreeLibrary			        fn FreeLibrary(handle: *mut libc::c_void);
FromPrimitive			    impl FromPrimitive for Value 
FromStr			impl FromStr for String 
FromStr			impl FromStr for bool 
FromStr			pub trait FromStr 
FromStr			impl FromStr for IpAddr 
FromStr			impl FromStr for SocketAddr 
FromStr			impl FromStr for f32 
FromStr			impl FromStr for f64 
FromStr			impl FromStr for 
FromStr			impl FromStr for 
FromStr			impl FromStr for Path 
FromStr			impl FromStr for Path 
FromStrRadix			impl FromStrRadix for 
FromStrRadix			pub trait FromStrRadix 
FromStrRadix			impl FromStrRadix for 
FullIndex			    impl FullIndex 
FullIndex			    pub struct FullIndex 
Future			pub struct Future<A> 
FutureState			enum FutureState<A> 
Gc			pub struct Gc<T> 
GenericPath			pub trait GenericPath: Clone + GenericPathUnsafe 
GenericPath			impl GenericPath for Path 
GenericPath			impl GenericPath for Path 
GenericPathUnsafe			pub trait GenericPathUnsafe 
GenericPathUnsafe			impl GenericPathUnsafe for Path 
GenericPathUnsafe			impl GenericPathUnsafe for Path 
GetCommandLineW			    fn GetCommandLineW() -> LPCWSTR;
GetCurrentProcess			        fn GetCurrentProcess() -> libc::HANDLE;
GetCurrentThread			        fn GetCurrentThread() -> libc::HANDLE;
GetLastError			        fn GetLastError() -> DWORD;
GetModuleHandleExW			        fn GetModuleHandleExW(dwFlags: libc::DWORD, name: *const u16,
GetProcAddress			        fn GetProcAddress(handle: *mut libc::c_void,
HashMap			pub struct HashMap<K, V, H = RandomSipHasher> 
HashSet			pub struct HashSet<T, H = RandomSipHasher> 
Hasher			impl Hasher<sip::SipState> for RandomSipHasher 
Hint			pub struct Hint 
IncomingConnections			pub struct IncomingConnections<'a, A> 
Info			pub struct Info 
InitialZeroByteReader			    struct InitialZeroByteReader 
InternalBufferedWriter			struct InternalBufferedWriter<W>(BufferedWriter<W>);
IntoBytes			impl IntoBytes for Vec<Ascii> 
IntoBytes			pub trait IntoBytes 
IntoStr			impl IntoStr for Vec<Ascii> 
IntoStr			pub trait IntoStr 
IoError			impl IoError 
IoError			pub struct IoError 
IoErrorKind			pub enum IoErrorKind 
IpAddr			pub enum IpAddr 
IterReader			pub struct IterReader<T> 
Iterator			impl Iterator<Path> for Directories 
Juju			        struct Juju;
KDHELP64			    struct KDHELP64 
KeyRef			struct KeyRef<K> { k: *const K }
KindaIntLike			    struct KindaIntLike(int);
LimitReader			pub struct LimitReader<R> 
LineBufferedWriter			pub struct LineBufferedWriter<W> 
Lines			pub struct Lines<'r, T> 
Listener			pub trait Listener<T, A: Acceptor<T>> 
Listener			impl Listener<TcpStream, TcpAcceptor> for TcpListener 
Listener			impl Listener<UnixStream, UnixAcceptor> for UnixListener 
Listener			impl Listener 
Listener			pub struct Listener 
LoadLibraryW			        fn LoadLibraryW(name: *const libc::c_void) -> *mut libc::c_void;
LocalFree			    fn LocalFree(ptr: *mut c_void);
LruCache			pub struct LruCache<K, V> 
LruEntry			struct LruEntry<K, V> 
M128A			        pub struct M128A 
MapError			pub enum MapError 
MapOption			pub enum MapOption 
MemReader			impl MemReader 
MemReader			pub struct MemReader 
MemWriter			impl MemWriter 
MemWriter			pub struct MemWriter 
MemoryMap			impl MemoryMap 
MemoryMap			pub struct MemoryMap 
MemoryMapKind			pub enum MemoryMapKind 
MoveEntries			    pub struct MoveEntries<K, V> 
Msg			enum Msg<T> 
MultiWriter			impl MultiWriter 
MultiWriter			pub struct MultiWriter 
MutEntries			    pub struct MutEntries<'a, K, V> 
Not			        impl Not<
NullReader			pub struct NullReader;
NullStream			    pub struct NullStream;
NullWriter			pub struct NullWriter;
NumStrConv			    impl NumStrConv for 
NumStrConv			pub trait NumStrConv 
OsRng			    impl OsRng 
OsRng			    pub struct OsRng 
OwnedAsciiCast			impl OwnedAsciiCast for String 
OwnedAsciiCast			impl OwnedAsciiCast for Vec<u8> 
OwnedAsciiCast			pub trait OwnedAsciiCast 
OwnedStrAsciiExt			impl OwnedStrAsciiExt for String 
OwnedStrAsciiExt			pub trait OwnedStrAsciiExt 
Parser			struct Parser<'a> 
PartialEq			impl PartialEq for Path 
PartialEq			impl PartialEq for Path 
PartialReader			    struct PartialReader 
Path			impl Path 
Path			pub struct Path 
Path			impl Path 
Path			pub struct Path 
PathPrefix			pub enum PathPrefix 
Pipe			pub struct Pipe 
PipePair			pub struct PipePair 
PipeStream			impl PipeStream 
PipeStream			pub struct PipeStream 
Process			impl Process 
Process			pub struct Process 
ProcessExit			impl ProcessExit 
ProcessExit			pub enum ProcessExit 
ProcessOutput			pub struct ProcessOutput 
Protocol			pub enum Protocol 
RTLD			    pub enum RTLD 
RandomSipHasher			impl RandomSipHasher 
RandomSipHasher			pub struct RandomSipHasher 
RawTable			    pub struct RawTable<K, V> 
Reader			    impl Reader for NullStream 
Reader			    impl Reader for ShortReader 
Reader			impl Reader for ChanReader 
Reader			    impl Reader for EofReader 
Reader			    impl Reader for ErroringLaterReader 
Reader			    impl Reader for ErroringReader 
Reader			    impl Reader for InitialZeroByteReader 
Reader			    impl Reader for PartialReader 
Reader			    impl Reader for ThreeChunkReader 
Reader			impl Reader for File 
Reader			impl Reader for MemReader 
Reader			impl Reader for Box<Reader> 
Reader			pub trait Reader 
Reader			impl Reader for TcpStream 
Reader			impl Reader for UdpStream 
Reader			impl Reader for UnixStream 
Reader			impl Reader for PipeStream 
Reader			impl Reader for StdReader 
Reader			impl Reader for NullReader 
Reader			impl Reader for ZeroReader 
ReaderRng			pub struct ReaderRng<R> 
RefReader			pub struct RefReader<'a, R> 
RefWriter			pub struct RefWriter<'a, W> 
Rng			    impl Rng for ConstRng 
Rng			impl Rng for StdRng 
Rng			impl Rng for TaskRng 
Rng			    impl Rng for OsRng 
RtlCaptureContext			        fn RtlCaptureContext(ctx: *mut arch::CONTEXT);
S			        struct S;
STACKFRAME64			    struct STACKFRAME64 
SYMBOL_INFO			    struct SYMBOL_INFO 
SafeHash			    impl SafeHash 
SafeHash			    pub struct SafeHash 
SecRandom			    struct SecRandom;
SecRandomCopyBytes			        fn SecRandomCopyBytes(rnd: *const SecRandom,
Seek			impl Seek for File 
Seek			impl Seek for MemReader 
Seek			impl Seek for MemWriter 
Seek			pub trait Seek 
SeekStyle			pub enum SeekStyle 
SetLastError			        fn SetLastError(error: libc::size_t);
ShortReader			    pub struct ShortReader 
SiblingSpawner			pub struct SiblingSpawner;
SignFormat			pub enum SignFormat 
SignalCallback			        struct SignalCallback 
SignificantDigits			pub enum SignificantDigits 
Signum			pub enum Signum 
SocketAddr			pub struct SocketAddr 
SocketType			pub enum SocketType 
Spawner			impl Spawner for SiblingSpawner 
Spawner			pub trait Spawner 
StdReader			impl StdReader 
StdReader			pub struct StdReader 
StdRng			impl StdRng 
StdRng			pub struct StdRng { rng: IsaacWordRng }
StdSource			enum StdSource 
StdWriter			impl StdWriter 
StdWriter			pub struct StdWriter 
StdioContainer			pub enum StdioContainer 
StrAsciiExt			pub trait StrAsciiExt 
Stream			pub trait Stream: Reader + Writer { }
Sub			        impl Sub<
TaskBuilder			impl TaskBuilder<SiblingSpawner> 
TaskBuilder			pub struct TaskBuilder<S = SiblingSpawner> 
TaskPool			pub struct TaskPool<T> 
TaskRng			pub struct TaskRng 
TaskRngReseeder			struct TaskRngReseeder;
TcpAcceptor			impl TcpAcceptor 
TcpAcceptor			pub struct TcpAcceptor 
TcpListener			impl TcpListener 
TcpListener			pub struct TcpListener 
TcpStream			impl TcpStream 
TcpStream			pub struct TcpStream 
TeeReader			pub struct TeeReader<R, W> 
TempDir			    impl TempDir 
TempDir			    struct TempDir(Path);
TempDir			impl TempDir 
TempDir			pub struct TempDir 
TestWriter			        struct TestWriter;
ThreeChunkReader			    struct ThreeChunkReader 
Timer			impl Timer 
Timer			pub struct Timer 
TimerCallback			struct TimerCallback { tx: Sender<()> }
ToCStr			impl ToCStr for Path 
ToCStr			impl ToCStr for Path 
ToPrimitive			    impl ToPrimitive for Value 
ToStr			pub trait ToStr 
ToStrRadix			impl ToStrRadix for 
ToStrRadix			pub trait ToStrRadix 
ToStrRadix			impl ToStrRadix for 
UdpSocket			impl UdpSocket 
UdpSocket			pub struct UdpSocket 
UdpStream			impl UdpStream 
UdpStream			pub struct UdpStream 
UnixAcceptor			impl UnixAcceptor 
UnixAcceptor			pub struct UnixAcceptor 
UnixListener			impl UnixListener 
UnixListener			pub struct UnixListener 
UnixStream			impl UnixStream 
UnixStream			pub struct UnixStream 
UnstableFileStat			pub struct UnstableFileStat 
UpdateIoError			trait UpdateIoError<T> 
Value			    struct Value { x: int }
Vector2D			struct Vector2D 
Writer			impl Writer for Stdio 
Writer			        impl Writer for FailFlushWriter 
Writer			    impl Writer for NullStream 
Writer			impl Writer for ChanWriter 
Writer			impl Writer for File 
Writer			impl Writer for MemWriter 
Writer			impl Writer for Box<Writer> 
Writer			pub trait Writer 
Writer			impl Writer for TcpStream 
Writer			impl Writer for UdpStream 
Writer			impl Writer for UnixStream 
Writer			impl Writer for PipeStream 
Writer			impl Writer for StdWriter 
Writer			        impl Writer for TestWriter 
Writer			impl Writer for MultiWriter 
Writer			impl Writer for NullWriter 
ZeroReader			pub struct ZeroReader;
_NSGetArgc			    pub fn _NSGetArgc() -> *mut c_int;
_NSGetArgv			    pub fn _NSGetArgv() -> *mut *mut *mut c_char;
_Unwind_Backtrace			            pub fn _Unwind_Backtrace(trace: _Unwind_Trace_Fn,
_Unwind_Context			        pub enum _Unwind_Context {}
_Unwind_FindEnclosingFunction			            pub fn _Unwind_FindEnclosingFunction(pc: *mut libc::c_void)
_Unwind_FindEnclosingFunction			        pub unsafe fn _Unwind_FindEnclosingFunction(pc: *mut libc::c_void)
_Unwind_GetIP			            pub fn _Unwind_GetIP(ctx: *mut _Unwind_Context) -> libc::uintptr_t;
_Unwind_GetIP			        pub unsafe fn _Unwind_GetIP(ctx: *mut _Unwind_Context) -> libc::uintptr_t 
_Unwind_Reason_Code			        pub enum _Unwind_Reason_Code 
_Unwind_VRS_DataRepresentation			            enum _Unwind_VRS_DataRepresentation 
_Unwind_VRS_Get			                fn _Unwind_VRS_Get(ctx: *mut _Unwind_Context,
_Unwind_VRS_RegClass			            enum _Unwind_VRS_RegClass 
_Unwind_VRS_Result			            enum _Unwind_VRS_Result 
__errno_location			            fn __errno_location() -> *const c_int;
__error			            fn __error() -> *const c_int;
__xpg_strerror_r			                fn __xpg_strerror_r(errnum: c_int,
_homedir			    fn _homedir() -> Option<Path> 
_join_paths			    fn _join_paths<T: BytesContainer>(paths: &[T]) -> Result<Vec<u8>, &'static str> 
_pipe			    unsafe fn _pipe() -> IoResult<Pipe> 
_setenv			    fn _setenv(n: &str, v: &[u8]) 
_split_paths			    fn _split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> 
_unsetenv			    fn _unsetenv(n: &str) 
accept			    fn accept(&mut self) -> IoResult<T>;
accept			    fn accept(&mut self) -> IoResult<TcpStream> 
accept			    fn accept(&mut self) -> IoResult<UnixStream> 
accept			    fn accept(&mut self) -> IoResult<T> 
access_string			fn access_string(access: FileAccess) -> &'static str 
acos			    fn acos(self) -> f32 
acos			        pub fn acos(n: c_double) -> c_double;
acos			    fn acos(self) -> f64 
acos			    fn acos(self) -> Self;
acosf			        pub fn acosf(n: c_float) -> c_float;
acosh			    fn acosh(self) -> f32 
acosh			    fn acosh(self) -> f64 
acosh			    fn acosh(self) -> Self;
addrinfo			pub mod addrinfo;
all			            pub fn all() -> 
append_path			        fn append_path(me: &mut Path, path: &str) 
arch			    mod arch 
arch_consts			mod arch_consts 
arg			    pub fn arg<'a, T:ToCStr>(&'a mut self, arg: T) -> &'a mut Command 
args			    pub fn args<'a, T:ToCStr>(&'a mut self, args: &[T]) -> &'a mut Command 
args			pub fn args() -> Vec<String> 
args_as_bytes			pub fn args_as_bytes() -> Vec<Vec<u8>> 
as_maybe_owned			    pub fn as_maybe_owned(&self) -> MaybeOwned<'a> 
as_mut_slice			    pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] 
as_slice			    pub fn as_slice<'a>(&'a self) -> &'a [T] 
as_socket			    pub fn as_socket<T>(&mut self, f: |&mut UdpSocket| -> T) -> T 
as_str			    fn as_str<'a>(&'a self) -> Option<&'a str> 
as_str			    fn as_str<'a>(&'a self) -> Option<&'a str> 
as_str_ascii			    fn as_str_ascii<'a>(&'a self) -> &'a str 
as_str_ascii			    fn as_str_ascii<'a>(&'a self) -> &'a str;
as_vec			    fn as_vec<'a>(&'a self) -> &'a [u8];
as_vec			    fn as_vec<'a>(&'a self) -> &'a [u8] 
as_vec			    fn as_vec<'a>(&'a self) -> &'a [u8] 
ascii			pub mod ascii;
asin			    fn asin(self) -> f32 
asin			        pub fn asin(n: c_double) -> c_double;
asin			    fn asin(self) -> f64 
asin			    fn asin(self) -> Self;
asinf			        pub fn asinf(n: c_float) -> c_float;
asinh			    fn asinh(self) -> f32 
asinh			    fn asinh(self) -> f64 
asinh			    fn asinh(self) -> Self;
assert_opt_eq			    fn assert_opt_eq<V: PartialEq>(opt: Option<&V>, v: V) 
atan			    fn atan(self) -> f32 
atan			        pub fn atan(n: c_double) -> c_double;
atan			    fn atan(self) -> f64 
atan			    fn atan(self) -> Self;
atan2			    fn atan2(self, other: f32) -> f32 
atan2			        pub fn atan2(a: c_double, b: c_double) -> c_double;
atan2			    fn atan2(self, other: f64) -> f64 
atan2			    fn atan2(self, other: Self) -> Self;
atan2f			        pub fn atan2f(a: c_float, b: c_float) -> c_float;
atanf			        pub fn atanf(n: c_float) -> c_float;
atanh			    fn atanh(self) -> f32 
atanh			    fn atanh(self) -> f64 
atanh			    fn atanh(self) -> Self;
attach			    fn attach(&mut self, node: *mut LruEntry<K, V>) 
aux_homedir			    fn aux_homedir(home_name: &str) -> Option<Path> 
avoid_copying_the_body			    fn avoid_copying_the_body(spawnfn: |v: proc():Send|) 
backtrace			            fn backtrace(buf: *mut *mut libc::c_void,
backtrace			pub mod backtrace;
backtrace_create_state			            fn backtrace_create_state(filename: *const libc::c_char,
backtrace_state			        enum backtrace_state {}
backtrace_syminfo			            fn backtrace_syminfo(state: *mut backtrace_state,
base_port			fn base_port() -> u16 
bench			mod bench 
bench			mod bench 
bench			mod bench 
bench			mod bench 
bench			mod bench 
bench			mod bench 
bench_buf_reader			    fn bench_buf_reader(b: &mut Bencher) 
bench_buf_writer			    fn bench_buf_writer(b: &mut Bencher) 
bench_buffered_reader			    fn bench_buffered_reader(b: &mut Bencher) 
bench_buffered_stream			    fn bench_buffered_stream(b: &mut Bencher) 
bench_buffered_writer			    fn bench_buffered_writer(b: &mut Bencher) 
bench_mem_reader			    fn bench_mem_reader(b: &mut Bencher) 
bench_mem_writer			    fn bench_mem_writer(b: &mut Bencher) 
bench_pow_function			    fn bench_pow_function(b: &mut Bencher) 
bind			    pub fn bind(addr: &str, port: u16) -> IoResult<TcpListener> 
bind			    pub fn bind(addr: SocketAddr) -> IoResult<UdpSocket> 
bind			    pub fn bind<P: ToCStr>(path: &P) -> IoResult<UnixListener> 
bitand			            fn bitand(&self, other: &
bitflags			pub mod bitflags;
bitor			            fn bitor(&self, other: &
bits			            pub fn bits(&self) -> 
bucket_distance			    fn bucket_distance(&self, index_of_elem: &table::FullIndex) -> uint 
buffered			mod buffered;
builtin			pub mod builtin 
by_ref			    fn by_ref<'a>(&'a mut self) -> RefReader<'a, Self> 
by_ref			    fn by_ref<'a>(&'a mut self) -> RefWriter<'a, Self> 
bytes			    fn bytes<'r>(&'r mut self) -> extensions::Bytes<'r, Self> 
bytes_0_bytes			    fn bytes_0_bytes() 
bytes_eof			    fn bytes_eof() 
bytes_error			    fn bytes_error() 
c_vec			pub mod c_vec;
calculate_offsets			    fn calculate_offsets(
call			            fn call(&mut self) { self.tx.send(self.signum) }
call			    fn call(&mut self) 
can_alias_safehash_as_u64			    fn can_alias_safehash_as_u64() 
capacity			        pub fn capacity(&self) -> uint 
capacity			    pub fn capacity(&self) -> uint 
capacity_range			    fn capacity_range(&self, new_size: uint) -> (uint, uint) 
cbrt			    fn cbrt(self) -> f32 
cbrt			        pub fn cbrt(n: c_double) -> c_double;
cbrt			    fn cbrt(self) -> f64 
cbrt			    fn cbrt(self) -> Self;
cbrtf			        pub fn cbrtf(n: c_float) -> c_float;
change_capacity			    pub fn change_capacity(&mut self, capacity: uint) 
change_dir			pub fn change_dir(p: &Path) -> bool 
change_file_times			pub fn change_file_times(path: &Path, atime: u64, mtime: u64) -> IoResult<()> 
chars			    fn chars<'r>(&'r mut self) -> Chars<'r, Self> 
chdir			    fn chdir(p: &Path) -> bool 
check_for_errors_in			    pub fn check_for_errors_in<T>(f: || -> T) -> Result<T, String> 
check_parse			        fn check_parse(unparsed: &str, parsed: &[&str]) -> bool 
check_word_size			        fn check_word_size() 
child_no			        fn child_no(x: uint) -> proc(): Send 
chmod			pub fn chmod(path: &Path, mode: io::FilePermission) -> IoResult<()> 
chown			pub fn chown(path: &Path, uid: int, gid: int) -> IoResult<()> 
cleanup			pub unsafe fn cleanup() 
cleanup_dir			    fn cleanup_dir(&mut self) -> IoResult<()> 
clear			    fn clear(&mut self) { self.map.clear() }
clear			    fn clear(&mut self) 
clear			    fn clear(&mut self) 
clone			        fn clone(&self) -> RawTable<K, V> 
clone			    fn clone(&self) -> Gc<T> { *self }
clone			    fn clone(&self) -> ChanWriter 
clone			    fn clone(&self) -> TcpStream 
clone			    fn clone(&self) -> UdpSocket 
clone			    fn clone(&self) -> UnixStream 
clone			    fn clone(&self) -> PipeStream 
close			    pub unsafe fn close(handle: *mut u8) 
close			    pub fn close(mut self) -> IoResult<()> 
close_read			    pub fn close_read(&mut self) -> IoResult<()> 
close_read			    pub fn close_read(&mut self) -> IoResult<()> 
close_write			    pub fn close_write(&mut self) -> IoResult<()> 
close_write			    pub fn close_write(&mut self) -> IoResult<()> 
cmath			mod cmath 
cmath			mod cmath 
cmp			    fn cmp(&self, other: &Gc<T>) -> Ordering { (**self).cmp(&**other) }
collections			pub mod collections;
combine			fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i64) -> IoResult<u64> 
comm_adapters			mod comm_adapters;
comp_requires_verbatim			        fn comp_requires_verbatim(s: &str) -> bool 
components			    pub fn components<'a>(&'a self) -> Components<'a> 
components			    pub fn components<'a>(&'a self) -> Components<'a> 
connect			        fn connect(i: int, addr: SocketAddr) 
connect			    pub fn connect(host: &str, port: u16) -> IoResult<TcpStream> 
connect			    pub fn connect(self, other: SocketAddr) -> UdpStream 
connect			    pub fn connect<P: ToCStr>(path: &P) -> IoResult<UnixStream> 
connect_timeout			    pub fn connect_timeout(addr: SocketAddr,
connect_timeout			    pub fn connect_timeout<P: ToCStr>(path: &P,
consts			pub mod consts 
consume			    fn consume(&mut self, amt: uint) { self.inner.consume(amt) }
consume			    fn consume(&mut self, amt: uint) 
consume			    fn consume(&mut self, amt: uint) { self.pos += amt; }
consume			    fn consume(&mut self, amt: uint) { self.inner.consume(amt) }
consume			    fn consume(&mut self, amt: uint);
consume			    fn consume(&mut self, _amt: uint) {}
consume			    fn consume(&mut self, amt: uint) 
container_as_bytes			    fn container_as_bytes<'a>(&'a self) -> &'a [u8] 
container_as_bytes			    fn container_as_bytes<'a>(&'a self) -> &'a [u8];
container_as_bytes			    fn container_as_bytes<'b>(&'b self) -> &'b [u8] 
container_as_bytes			    fn container_as_bytes<'a>(&'a self) -> &'a [u8] 
container_as_bytes			    fn container_as_bytes<'a>(&'a self) -> &'a [u8] 
container_as_str			    fn container_as_str<'a>(&'a self) -> Option<&'a str> 
container_as_str			    fn container_as_str<'b>(&'b self) -> Option<&'b str> 
container_as_str			    fn container_as_str<'a>(&'a self) -> Option<&'a str> 
container_into_owned_bytes			    fn container_into_owned_bytes(self) -> Vec<u8> 
container_into_owned_bytes			    fn container_into_owned_bytes(self) -> Vec<u8> 
container_into_owned_bytes			    fn container_into_owned_bytes(self) -> Vec<u8> 
contains			            pub fn contains(&self, other: 
contains			    fn contains(&self, value: &T) -> bool { self.map.contains_key(value) }
contains_equiv			    pub fn contains_equiv<Q: Hash<S> + Equiv<T>>(&self, value: &Q) -> bool 
contains_key			    fn contains_key(&self, k: &K) -> bool 
contains_key_equiv			    pub fn contains_key_equiv<Q: Hash<S> + Equiv<K>>(&self, key: &Q) -> bool 
contains_nul			fn contains_nul<T: BytesContainer>(v: &T) -> bool 
convert			        fn convert<'a>(x: Option<&'a str>) -> &'a [u8] 
copy			pub fn copy(from: &Path, to: &Path) -> IoResult<()> 
copy			pub fn copy<R: Reader, W: Writer>(r: &mut R, w: &mut W) -> io::IoResult<()> 
cos			    fn cos(self) -> f32 
cos			    fn cos(self) -> f64 
cos			    fn cos(self) -> Self;
cosh			    fn cosh(self) -> f32 
cosh			        pub fn cosh(n: c_double) -> c_double;
cosh			    fn cosh(self) -> f64 
cosh			    fn cosh(self) -> Self;
coshf			        pub fn coshf(n: c_float) -> c_float;
create			    pub fn create(path: &Path) -> IoResult<File> 
create_path			    pub fn create_path(path: &[Path]) -> Vec<u8> 
cwd			    pub fn cwd<'a>(&'a mut self, dir: &Path) -> &'a mut Command 
darwin_fd_limit			mod darwin_fd_limit 
datasync			    pub fn datasync(&mut self) -> IoResult<()> 
default			    fn default() -> HashMap<K, V, H> 
default			    fn default() -> HashSet<T, H> 
default			    fn default() -> Gc<T> 
default			    fn default() -> RandomSipHasher 
default_sched_threads			pub fn default_sched_threads() -> uint 
demangle			    fn demangle() 
demangle			fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> 
demangle_dollars			    fn demangle_dollars() 
demangle_many_dollars			    fn demangle_many_dollars() 
deref			    fn deref<'a>(&'a self) -> &'a T { &**self }
deschedule			pub fn deschedule() 
detach			    fn detach(&mut self, node: *mut LruEntry<K, V>) 
detached			    pub fn detached<'a>(&'a mut self) -> &'a mut Command 
difference			    pub fn difference<'a>(&'a self, other: &'a HashSet<T, H>) -> SetAlgebraItems<'a, T, H> 
dir_path			    fn dir_path(&self) -> Self 
dir_path			    fn dir_path(&self) -> Path 
dirname			    fn dirname<'a>(&'a self) -> &'a [u8];
dirname			    fn dirname<'a>(&'a self) -> &'a [u8] 
dirname			    fn dirname<'a>(&'a self) -> &'a [u8] 
dirname_str			    fn dirname_str<'a>(&'a self) -> Option<&'a str> 
dirname_str			    fn dirname_str<'a>(&'a self) -> Option<&'a str> 
disconnect			    pub fn disconnect(self) -> UdpSocket 
display			    fn display<'a>(&'a self) -> Display<'a, Self> 
dl			pub mod dl 
dladdr			            fn dladdr(addr: *const libc::c_void,
dlclose			        fn dlclose(handle: *mut libc::c_void) -> libc::c_int;
dlerror			        fn dlerror() -> *mut libc::c_char;
dll_filename			pub fn dll_filename(base: &str) -> String 
dlopen			        fn dlopen(filename: *const libc::c_char,
dlsym			        fn dlsym(handle: *mut libc::c_void,
dont_fail_in_drop_on_failed_flush			    fn dont_fail_in_drop_on_failed_flush() 
drop			    fn drop(&mut self) 
drop			        fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			        fn drop(&mut self) 
drop			            fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			        fn drop(&mut self) 
drop			        fn drop(&mut self) { (self.SymCleanup)(self.handle); }
drop			            fn drop(&mut self) 
drop			    fn drop(&mut self) 
dynamic_lib			pub mod dynamic_lib;
empty			            pub fn empty() -> 
ends_with_path			    fn ends_with_path(&self, child: &Self) -> bool;
ends_with_path			    fn ends_with_path(&self, child: &Path) -> bool 
ends_with_path			    fn ends_with_path(&self, child: &Path) -> bool 
ends_with_path_home_dir			    fn ends_with_path_home_dir(b: &mut Bencher) 
ends_with_path_missmatch_jome_home			    fn ends_with_path_missmatch_jome_home(b: &mut Bencher) 
env			    pub fn env<'a, T:ToCStr>(&'a mut self, env: &[(T,T)]) -> &'a mut Command 
env			pub fn env() -> Vec<(String,String)> 
env_as_bytes			pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> 
env_cmd			    pub fn env_cmd() -> Command 
env_convert			        fn env_convert(input: Vec<Vec<u8>>) -> Vec<(Vec<u8>, Vec<u8>)> 
envvar			    pub fn envvar() -> &'static str 
eof			    pub fn eof(&self) -> bool 
eof			    pub fn eof(&self) -> bool { self.pos >= self.buf.len() }
eq			    fn eq(&self, other: &HashMap<K, V, H>) -> bool 
eq			    fn eq(&self, other: &HashSet<T, H>) -> bool 
eq			    fn eq(&self, other: &KeyRef<K>) -> bool 
eq			    fn eq(&self, other: &Gc<T>) -> bool { *(*self) == *(*other) }
eq			    fn eq(&self, other: &Path) -> bool 
eq			    fn eq(&self, other: &Path) -> bool 
eq_ignore_ascii_case			    fn eq_ignore_ascii_case(&self, other: &str) -> bool 
eq_ignore_ascii_case			    fn eq_ignore_ascii_case(&self, other: &str) -> bool;
eq_ignore_case			    fn eq_ignore_case(self, other: &[Ascii]) -> bool 
eq_ignore_case			    fn eq_ignore_case(self, other: &[Ascii]) -> bool;
eq_ignore_case			    pub fn eq_ignore_case(self, other: Ascii) -> bool 
equiv			        fn equiv(&self, other: &int) -> bool 
equiv_prefix			    fn equiv_prefix(&self, other: &Path) -> bool 
erf			        pub fn erf(n: c_double) -> c_double;
erfc			        pub fn erfc(n: c_double) -> c_double;
erfcf			        pub fn erfcf(n: c_float) -> c_float;
erff			        pub fn erff(n: c_float) -> c_float;
errno			pub fn errno() -> int 
errno			pub fn errno() -> uint 
errno_location			    fn errno_location() -> *const c_int 
error_cb			        extern fn error_cb(_data: *mut libc::c_void, _msg: *const libc::c_char,
error_string			pub fn error_string(errnum: uint) -> String 
execute			    pub fn execute(&mut self, f: proc(&T):Send) 
exists			    pub fn exists(&self) -> bool 
exp_m1			    fn exp_m1(self) -> f32 
exp_m1			    fn exp_m1(self) -> f64 
exp_m1			    fn exp_m1(self) -> Self;
expm1			        pub fn expm1(n: c_double) -> c_double;
expm1f			        pub fn expm1f(n: c_float) -> c_float;
extend			    fn extend<I: Iterator<T>>(&mut self, mut iter: I) 
extend			    fn extend<T: Iterator<(K, V)>>(&mut self, mut iter: T) 
extend_sign			fn extend_sign(val: u64, nbytes: uint) -> i64 
extension			    fn extension<'a>(&'a self) -> Option<&'a [u8]> 
extension_str			    fn extension_str<'a>(&'a self) -> Option<&'a str> 
extension_str			    fn extension_str<'a>(&'a self) -> Option<&'a str> 
extensions			pub mod extensions;
extra_io			    pub fn extra_io<'a>(&'a mut self, cfg: StdioContainer) -> &'a mut Command 
f			            fn f() 
f			        fn f(i: int, tx: Sender<()>) 
f64			    mod f64 
failing			pub fn failing() -> bool 
failure			mod failure;
fdim			        pub fn fdim(a: c_double, b: c_double) -> c_double;
fdimf			        pub fn fdimf(a: c_float, b: c_float) -> c_float;
file_product			fn file_product(p: &Path) -> IoResult<u32> 
filename			    fn filename<'a>(&'a self) -> Option<&'a [u8]>;
filename			    fn filename<'a>(&'a self) -> Option<&'a [u8]> 
filename			    fn filename<'a>(&'a self) -> Option<&'a [u8]> 
filename_display			    fn filename_display<'a>(&'a self) -> Display<'a, Self> 
filename_str			    fn filename_str<'a>(&'a self) -> Option<&'a str> 
filename_str			    fn filename_str<'a>(&'a self) -> Option<&'a str> 
filestem			    fn filestem<'a>(&'a self) -> Option<&'a [u8]> 
filestem_str			    fn filestem_str<'a>(&'a self) -> Option<&'a str> 
filestem_str			    fn filestem_str<'a>(&'a self) -> Option<&'a str> 
fill_buf			    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> { self.inner.fill_buf() }
fill_buf			    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> 
fill_buf			    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> 
fill_buf			    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> { self.inner.fill_buf() }
fill_buf			    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]>;
fill_buf			    fn fill_buf<'a>(&'a mut self) -> io::IoResult<&'a [u8]> 
fill_bytes			    fn fill_bytes(&mut self, bytes: &mut [u8]) 
fill_bytes			        fn fill_bytes(&mut self, v: &mut [u8]) 
fill_bytes			    fn fill_bytes(&mut self, v: &mut [u8]) 
fill_utf16_buf_and_decode			    pub fn fill_utf16_buf_and_decode(f: |*mut u16, DWORD| -> DWORD)
find			    fn find<'a>(&'a self, k: &K) -> Option<&'a V> 
find_copy			    pub fn find_copy(&self, k: &K) -> Option<V> 
find_equiv			    pub fn find_equiv<'a, Q: Hash<S> + Equiv<K>>(&'a self, k: &Q) -> Option<&'a V> 
find_existing			    fn find_existing(b: &mut Bencher) 
find_mut			    fn find_mut<'a>(&'a mut self, k: &K) -> Option<&'a mut V> 
find_nonexisting			    fn find_nonexisting(b: &mut Bencher) 
find_or_insert			    pub fn find_or_insert<'a>(&'a mut self, k: K, v: V) -> &'a mut V 
find_or_insert_with			    pub fn find_or_insert_with<'a>(&'a mut self, k: K, f: |&K| -> V)
find_pop_insert			    fn find_pop_insert(b: &mut Bencher) 
find_with_or_insert_with			    pub fn find_with_or_insert_with<'a, A>(&'a mut self,
float_to_str			        fn float_to_str(b: &mut Bencher) 
float_to_str_bytes_common			pub fn float_to_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Float+
float_to_str_common			pub fn float_to_str_common<T:NumCast+Zero+One+PartialEq+PartialOrd+NumStrConv+Float+
flush			            fn flush(&mut self) -> IoResult<()> { Err(io::standard_error(EndOfFile)) }
flush			    fn flush(&mut self) -> IoResult<()> { self.inner.flush() }
flush			    fn flush(&mut self) -> IoResult<()> 
flush			    fn flush(&mut self) -> IoResult<()> { Ok(()) }
flush			    fn flush(&mut self) -> IoResult<()> { self.flush() }
flush			    fn flush(&mut self) -> IoResult<()> { self.inner.flush() }
flush			    fn flush(&mut self) -> IoResult<()> 
flush			pub fn flush() 
flush			            fn flush(&mut self) -> io::IoResult<()> 
flush			    fn flush(&mut self) -> io::IoResult<()> 
flush_buf			    fn flush_buf(&mut self) -> IoResult<()> 
fmax			        pub fn fmax(a: c_double, b: c_double) -> c_double;
fmaxf			        pub fn fmaxf(a: c_float, b: c_float) -> c_float;
fmin			        pub fn fmin(a: c_double, b: c_double) -> c_double;
fminf			        pub fn fminf(a: c_float, b: c_float) -> c_float;
fmod			        pub fn fmod(a: c_double, b: c_double) -> c_double;
fmodf			        pub fn fmodf(a: c_float, b: c_float) -> c_float;
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			fn fmt(&self, f: &mut std::fmt::Formatter) -> fmt::Result;
fmt			impl fmt::Binary for Vector2D 
fmt			impl fmt::Show for Vector2D 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result 
fmt			impl fmt::Show for IoError 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result 
fmt			impl fmt::Show for IpAddr 
fmt			impl fmt::Show for SocketAddr 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			impl fmt::Show for Command 
fmt			impl fmt::Show for ProcessExit 
fmt			pub mod fmt;
fmt			    fn fmt(&self, out: &mut fmt::Formatter) -> fmt::Result 
fmt			impl fmt::Show for MapError 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt_write			        fn fmt_write<F: fmt::FormatWriter>(f: &mut F, bytes: &[u8]) 
forget			    pub fn forget(mut self) 
format			pub fn format(args: &Arguments) -> string::String
fractional_part			        fn fractional_part(&self) -> 
fractional_part			    fn fractional_part(&self) -> Self;
frexp			    fn frexp(self) -> (f32, int) 
frexp			        pub fn frexp(n: c_double, value: &mut c_int) -> c_double;
frexp			    fn frexp(self) -> (f64, int) 
frexp			    fn frexp(self) -> (Self, int);
frexpf			        pub fn frexpf(n: c_float, value: &mut c_int) -> c_float;
from_bits			            pub fn from_bits(bits: 
from_bits_truncate			            pub fn from_bits_truncate(bits: 
from_errno			    pub fn from_errno(errno: uint, detail: bool) -> IoError 
from_fn			    pub fn from_fn(f: proc():Send -> A) -> Future<A> 
from_i64			        fn from_i64(n: i64) -> Option<Value> { Some(Value { x: n as int }) }
from_iter			    fn from_iter<I: Iterator<T>>(iter: I) -> HashSet<T, H> 
from_iter			    fn from_iter<T: Iterator<(K, V)>>(iter: T) -> HashMap<K, V, H> 
from_receiver			    pub fn from_receiver(rx: Receiver<A>) -> Future<A> 
from_rtio			fn from_rtio(s: rtio::FileStat) -> FileStat 
from_rtio			fn from_rtio(ip: rtio::IpAddr) -> IpAddr 
from_rtio_error			    fn from_rtio_error(err: rtio::IoError) -> IoError 
from_seed			    fn from_seed(seed: &'a [uint]) -> StdRng 
from_str			    fn from_str(s: &str) -> Option<Self>;
from_str			    fn from_str(s: &str) -> Option<String> 
from_str			    fn from_str(s: &str) -> Option<bool> 
from_str			pub fn from_str<A: FromStr>(s: &str) -> Option<A> 
from_str			    fn from_str(s: &str) -> Option<IpAddr> 
from_str			    fn from_str(s: &str) -> Option<SocketAddr> 
from_str			pub mod from_str;
from_str			    fn from_str(val: &str) -> Option<f32> 
from_str			    fn from_str(val: &str) -> Option<f64> 
from_str			    fn from_str(s: &str) -> Option<
from_str			    fn from_str(s: &str) -> Option<
from_str			    fn from_str(s: &str) -> Option<Path> 
from_str			    fn from_str(s: &str) -> Option<Path> 
from_str_bytes_common			pub fn from_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Div<T,T>+
from_str_common			pub fn from_str_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Div<T,T>+Mul<T,T>+
from_str_hex			pub fn from_str_hex(num: &str) -> Option<f32> 
from_str_hex			pub fn from_str_hex(num: &str) -> Option<f64> 
from_str_ignore_underscores			    fn from_str_ignore_underscores() 
from_str_issue5770			    fn from_str_issue5770() 
from_str_issue7588			    fn from_str_issue7588() 
from_str_radix			    fn from_str_radix(val: &str, rdx: uint) -> Option<f32> 
from_str_radix			    fn from_str_radix(val: &str, rdx: uint) -> Option<f64> 
from_str_radix			    fn from_str_radix(s: &str, radix: uint) -> Option<
from_str_radix			    fn from_str_radix(str: &str, radix: uint) -> Option<Self>;
from_str_radix			pub fn from_str_radix<T: FromStrRadix>(str: &str, radix: uint) -> Option<T> 
from_str_radix			    fn from_str_radix(s: &str, radix: uint) -> Option<
from_u64			        fn from_u64(n: u64) -> Option<Value> { Some(Value { x: n as int }) }
from_value			    pub fn from_value(val: A) -> Future<A> 
fs			pub mod fs;
fsync			    pub fn fsync(&mut self) -> IoResult<()> 
future			mod future;
gc			pub mod gc;
ge			    fn ge(&self, other: &Gc<T>) -> bool { *(*self) >= *(*other) }
get			    pub fn get<'a>(&'a self, ofs: uint) -> Option<&'a T> 
get			    pub fn get<'a>(&'a self, k: &K) -> &'a V 
get			    pub fn get<'a>(&'a mut self, k: &K) -> Option<&'a V> 
get			    pub fn get(&mut self) -> A 
get_copy			    pub fn get_copy(&self, k: &K) -> V 
get_env_pairs			        unsafe fn get_env_pairs() -> Vec<Vec<u8>> 
get_err			        fn get_err(errno: i32) -> (IoErrorKind, &'static str) 
get_exit_status			pub fn get_exit_status() -> int 
get_host_addresses			pub fn get_host_addresses(host: &str) -> IoResult<Vec<IpAddr>> 
get_mut			    pub fn get_mut<'a>(&'a mut self, ofs: uint) -> Option<&'a mut T> 
get_mut			    pub fn get_mut<'a>(&'a mut self, k: &K) -> &'a mut V 
get_mut_ref			    fn get_mut_ref<'a>(&'a mut self) -> &'a mut BufferedWriter<W> 
get_ref			    pub fn get_ref<'a>(&'a self) -> &'a R { &self.inner }
get_ref			    pub fn get_ref<'a>(&'a self) -> &'a S 
get_ref			    pub fn get_ref<'a>(&'a self) -> &'a W { self.inner.get_ref() }
get_ref			    pub fn get_ref<'a>(&'a self) -> &'a [u8] { self.buf.as_slice() }
get_ref			    pub fn get_ref<'a>(&'a mut self) -> &'a A 
getcwd			pub fn getcwd() -> Path 
getenv			pub fn getenv(n: &str) -> Option<String> 
getenv_as_bytes			pub fn getenv_as_bytes(n: &str) -> Option<Vec<u8>> 
getenv_nonempty			    fn getenv_nonempty(v: &str) -> Option<Path> 
getrlimit			        fn getrlimit(resource: libc::c_int, rlp: *mut rlimit) -> libc::c_int;
gid			    pub fn gid<'a>(&'a mut self, id: uint) -> &'a mut Command 
granularity			    pub fn granularity() -> uint 
gt			    fn gt(&self, other: &Gc<T>) -> bool { *(*self) > *(*other) }
handle_client			    fn handle_client(mut stream: TcpStream) 
has_nonsemantic_trailing_slash			    fn has_nonsemantic_trailing_slash(&self) -> bool 
hash			        fn hash(&self, state: &mut S) 
hash			        pub fn hash(&self) -> SafeHash { self.hash }
hash			    fn hash(&self, state: &mut S) 
hash			    fn hash(&self, s: &mut S) 
hash			    fn hash<T: Hash<sip::SipState>>(&self, value: &T) -> u64 
hash			pub mod hash;
hash			    fn hash(&self, state: &mut S) 
hash			    fn hash(&self, _: &mut S) 
hash			    fn hash(&self, state: &mut S) 
hashmap			pub mod hashmap;
hashmap_as_queue			    fn hashmap_as_queue(b: &mut Bencher) 
homedir			    fn homedir() 
homedir			pub fn homedir() -> Option<Path> 
hypot			    fn hypot(self, other: f32) -> f32 
hypot			        pub fn hypot(x: c_double, y: c_double) -> c_double;
hypot			    fn hypot(self, other: f64) -> f64 
hypot			    fn hypot(self, other: Self) -> Self;
hypotf			        pub fn hypotf(x: c_float, y: c_float) -> c_float;
id			    pub fn id(&self) -> libc::pid_t { self.handle.id() }
ilogb			        pub fn ilogb(n: c_double) -> c_int;
ilogbf			        pub fn ilogbf(n: c_float) -> c_int;
imp			mod imp 
imp			mod imp 
incoming			    fn incoming<'r>(&'r mut self) -> IncomingConnections<'r, Self> 
inf			        fn inf()      -> Option<
inf			    fn inf()      -> Option<Self>;
init			pub fn init(argc: int, argv: *const *const u8) 
init_frame			        pub fn init_frame(frame: &mut super::STACKFRAME64,
init_state			        unsafe fn init_state() -> *mut backtrace_state 
insert			            pub fn insert(&mut self, other: 
insert			    fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }
insert			    fn insert(b: &mut Bencher) 
insert_hashed			    fn insert_hashed<'a>(&'a mut self, hash: table::SafeHash, k: K, v: V) -> &'a mut V 
insert_hashed_nocheck			    fn insert_hashed_nocheck<'a>(
insert_or_update_with			    pub fn insert_or_update_with<'a>(
inspect			        pub fn inspect(&self) -> u64 { self.hash }
int			    mod int 
int_to_str_bytes_common			pub fn int_to_str_bytes_common<T: Int>(num: T, radix: uint, sign: SignFormat, f: |u8|) 
intersection			    pub fn intersection<'a>(&'a self, other: &'a HashSet<T, H>)
intersects			            pub fn intersects(&self, other: 
into_ascii			    fn into_ascii(self) -> Vec<Ascii> 
into_ascii_lower			    fn into_ascii_lower(self) -> String 
into_ascii_lower			    fn into_ascii_lower(self) -> String;
into_ascii_nocheck			    unsafe fn into_ascii_nocheck(self) -> Vec<Ascii> 
into_ascii_nocheck			    unsafe fn into_ascii_nocheck(self) -> Vec<Ascii>;
into_ascii_opt			    fn into_ascii_opt(self) -> Option<Vec<Ascii>> 
into_ascii_upper			    fn into_ascii_upper(self) -> String 
into_ascii_upper			    fn into_ascii_upper(self) -> String;
into_bytes			    fn into_bytes(self) -> Vec<u8> 
into_bytes			    fn into_bytes(self) -> Vec<u8>;
into_str			    fn into_str(self) -> String 
into_str			    fn into_str(self) -> String;
into_vec			    fn into_vec(self) -> Vec<u8>;
into_vec			    fn into_vec(self) -> Vec<u8> 
into_vec			    fn into_vec(self) -> Vec<u8> 
io			        impl io::Reader for S 
io			        impl io::Writer for S 
io			pub mod io;
io_read_at_least			    fn io_read_at_least() 
ip			pub mod ip;
ipv6_addr_from_head_tail			        fn ipv6_addr_from_head_tail(head: &[u16], tail: &[u16]) -> IpAddr 
ipv6_addr_to_str			    fn ipv6_addr_to_str() 
is_absolute			    fn is_absolute(&self) -> bool;
is_absolute			    fn is_absolute(&self) -> bool 
is_absolute			    fn is_absolute(&self) -> bool 
is_all			            pub fn is_all(&self) -> bool 
is_alnum			    pub fn is_alnum(&self) -> bool 
is_alpha			    pub fn is_alpha(&self) -> bool 
is_alphabetic			    pub fn is_alphabetic(&self) -> bool 
is_alphanumeric			    pub fn is_alphanumeric(&self) -> bool 
is_ancestor_of			    fn is_ancestor_of(&self, other: &Self) -> bool;
is_ancestor_of			    fn is_ancestor_of(&self, other: &Path) -> bool 
is_ancestor_of			    fn is_ancestor_of(&self, other: &Path) -> bool 
is_ancestor_of_path_with_10_dirs			    fn is_ancestor_of_path_with_10_dirs(b: &mut Bencher) 
is_ascii			    fn is_ascii(&self) -> bool 
is_ascii			    fn is_ascii(&self) -> bool;
is_blank			    pub fn is_blank(&self) -> bool 
is_control			    pub fn is_control(&self) -> bool 
is_cwd_relative			pub fn is_cwd_relative(path: &Path) -> bool 
is_digit			    pub fn is_digit(&self) -> bool 
is_dir			    pub fn is_dir(&self) -> bool 
is_disjoint			    fn is_disjoint(&self, other: &HashSet<T, H>) -> bool 
is_empty			            pub fn is_empty(&self) -> bool 
is_eof			    fn is_eof(&self) -> bool 
is_file			    pub fn is_file(&self) -> bool 
is_graph			    pub fn is_graph(&self) -> bool 
is_hex			    pub fn is_hex(&self) -> bool 
is_lower			    pub fn is_lower(&self) -> bool 
is_lowercase			    pub fn is_lowercase(&self) -> bool 
is_print			    pub fn is_print(&self) -> bool 
is_punctuation			    pub fn is_punctuation(&self) -> bool 
is_relative			    fn is_relative(&self) -> bool 
is_relative			    fn is_relative(&self) -> bool 
is_sep			pub fn is_sep(c: char) -> bool 
is_sep			pub fn is_sep(c: char) -> bool 
is_sep_			        fn is_sep_(prefix: Option<PathPrefix>, u: u8) -> bool 
is_sep_byte			pub fn is_sep_byte(u: &u8) -> bool 
is_sep_byte			pub fn is_sep_byte(u: &u8) -> bool 
is_sep_byte_verbatim			pub fn is_sep_byte_verbatim(u: &u8) -> bool 
is_sep_verbatim			pub fn is_sep_verbatim(c: char) -> bool 
is_str			    fn is_str(_: Option<&'a str>) -> bool { true }
is_str			    fn is_str(_: Option<Self>) -> bool { false }
is_str			    fn is_str(_: Option<String>) -> bool { true }
is_str			    fn is_str(_: Option<str::MaybeOwned>) -> bool { true }
is_str			    fn is_str(_: Option<&'a Path>) -> bool { true }
is_str			    fn is_str(_: Option<Path>) -> bool { true }
is_subset			    fn is_subset(&self, other: &HashSet<T, H>) -> bool 
is_upper			    pub fn is_upper(&self) -> bool 
is_uppercase			    pub fn is_uppercase(&self) -> bool 
is_verbatim			pub fn is_verbatim(path: &Path) -> bool 
is_vol_abs			        fn is_vol_abs(path: &str, prefix: Option<PathPrefix>) -> bool 
is_vol_relative			pub fn is_vol_relative(path: &Path) -> bool 
isatty			    pub fn isatty(&self) -> bool 
iter			        pub fn iter<'a>(&'a self) -> Entries<'a, K, V> 
iter			    pub fn iter<'a>(&'a self) -> Entries<'a, K, V> 
iter			    pub fn iter<'a>(&'a self) -> SetItems<'a, T> 
j0			        pub fn j0(n: c_double) -> c_double;
j1			        pub fn j1(n: c_double) -> c_double;
jn			        pub fn jn(i: c_int, n: c_double) -> c_double;
join			        fn join(&self, path: &str) -> Path 
join			    fn join<T: BytesContainer>(&self, path: T) -> Self 
join_abs_path_home_dir			    fn join_abs_path_home_dir(b: &mut Bencher) 
join_home_dir			    fn join_home_dir(b: &mut Bencher) 
join_many			    fn join_many<T: BytesContainer>(&self, paths: &[T]) -> Self 
join_many_abs_path_home_dir			    fn join_many_abs_path_home_dir(b: &mut Bencher) 
join_many_home_dir			    fn join_many_home_dir(b: &mut Bencher) 
join_multicast			    pub fn join_multicast(&mut self, multi: IpAddr) -> IoResult<()> 
join_paths			pub fn join_paths<T: BytesContainer>(paths: &[T]) -> Result<Vec<u8>, &'static str> 
join_paths_unix			    fn join_paths_unix() 
join_paths_windows			    fn join_paths_windows() 
keys			    pub fn keys<'a>(&'a self) -> Keys<'a, K, V> 
kill			    pub fn kill(id: libc::pid_t, signal: int) -> IoResult<()> 
last_error			    pub fn last_error() -> IoError 
last_os_error			    pub fn last_os_error() 
last_os_error			pub fn last_os_error() -> String 
ldexp			    fn ldexp(x: f32, exp: int) -> f32 
ldexp			        pub fn ldexp(x: c_double, n: c_int) -> c_double;
ldexp			    fn ldexp(x: f64, exp: int) -> f64 
ldexp			    fn ldexp(x: Self, exp: int) -> Self;
ldexpf			        pub fn ldexpf(x: c_float, n: c_int) -> c_float;
le			    fn le(&self, other: &Gc<T>) -> bool { *(*self) <= *(*other) }
leave_multicast			    pub fn leave_multicast(&mut self, multi: IpAddr) -> IoResult<()> 
len			    fn len(&self) -> uint { self.len }
len			    fn len(&self) -> uint { self.map.len() }
len			    fn len(&self) -> uint { self.table.size() }
len			    fn len(&self) -> uint 
lgamma_r			        pub fn lgamma_r(n: c_double, sign: &mut c_int) -> c_double;
lgammaf_r			        pub fn lgammaf_r(n: c_float, sign: &mut c_int) -> c_float;
limit			    pub fn limit(&self) -> uint { self.limit }
limit_reader_buffer			    fn limit_reader_buffer() 
limit_thread_creation_due_to_osx_and_valgrind			pub fn limit_thread_creation_due_to_osx_and_valgrind() -> bool 
lines			    fn lines<'r>(&'r mut self) -> Lines<'r, Self> 
link			pub fn link(src: &Path, dst: &Path) -> IoResult<()> 
listen			    fn listen(self) -> IoResult<A>;
listen			    fn listen(self) -> IoResult<TcpAcceptor> 
listen			    fn listen(self) -> IoResult<UnixAcceptor> 
listen			    fn listen(self) -> IoResult<A> 
ln_1p			    fn ln_1p(self) -> f32 
ln_1p			    fn ln_1p(self) -> f64 
ln_1p			    fn ln_1p(self) -> Self;
load_argc_and_argv			unsafe fn load_argc_and_argv(argc: int,
load_self			    fn load_self() -> Option<Vec<u8>> 
log1p			        pub fn log1p(n: c_double) -> c_double;
log1pf			        pub fn log1pf(n: c_float) -> c_float;
log_enabled			pub fn log_enabled() -> bool 
logb			        pub fn logb(n: c_double) -> c_double;
logbf			        pub fn logbf(n: c_float) -> c_float;
lookup			fn lookup(hostname: Option<&str>, servname: Option<&str>, hint: Option<Hint>)
lookup			    fn lookup() -> Path 
lru_cache			pub mod lru_cache;
lseek_			        fn lseek_(fd: c_int, size: uint) 
lstat			    pub fn lstat(&self) -> IoResult<FileStat> { lstat(self) }
lstat			pub fn lstat(path: &Path) -> IoResult<FileStat> 
lt			    fn lt(&self, other: &Gc<T>) -> bool { *(*self) < *(*other) }
macros			pub mod macros;
main			fn main() 
make_absolute			pub fn make_absolute(p: &Path) -> Path 
make_hash			    fn make_hash<X: Hash<S>>(&self, x: &X) -> table::SafeHash 
make_hash			    pub fn make_hash<T: Hash<S>, S, H: Hasher<S>>(hasher: &H, t: &T) -> SafeHash 
make_non_verbatim			pub fn make_non_verbatim(path: &Path) -> Option<Path> 
make_rand_name			    fn make_rand_name() -> String 
make_some_room			    fn make_some_room(&mut self, new_size: uint) 
malloc			    fn malloc(n: uint) -> CVec<u8> 
matches_exit_status			    pub fn matches_exit_status(&self, wanted: int) -> bool 
max			    fn max(self, other: f32) -> f32 
max			    fn max(self, other: f64) -> f64 
max			    fn max(self, other: Self) -> Self;
mem			mod mem;
memory_map_file			    fn memory_map_file() 
memory_map_rw			    fn memory_map_rw() 
min			    fn min(self, other: f32) -> f32 
min			    fn min(self, other: f64) -> f64 
min			    fn min(self, other: Self) -> Self;
min_stack			pub fn min_stack() -> uint 
mkdir			pub fn mkdir(path: &Path, mode: FilePermission) -> IoResult<()> 
mkdir_recursive			pub fn mkdir_recursive(path: &Path, mode: FilePermission) -> IoResult<()> 
mode_string			fn mode_string(mode: FileMode) -> &'static str 
modf			        pub fn modf(n: c_double, iptr: &mut c_double) -> c_double;
modff			        pub fn modff(n: c_float, iptr: &mut c_float) -> c_float;
move_iter			        pub fn move_iter(self) -> MoveEntries<K, V> 
move_iter			    pub fn move_iter(self) -> MoveEntries<K, V> 
move_iter			    pub fn move_iter(self) -> SetMoveItems<T> 
mut_iter			        pub fn mut_iter<'a>(&'a mut self) -> MutEntries<'a, K, V> 
mut_iter			    pub fn mut_iter<'a>(&'a mut self) -> MutEntries<'a, K, V> 
my_fmt_fn			fn my_fmt_fn(args: &fmt::Arguments) 
naive_pow			        fn naive_pow<T: One + Mul<T, T>>(base: T, exp: uint) -> T 
named			    pub fn named<T: IntoMaybeOwned<'static>>(mut self, name: T) -> TaskBuilder<S> 
nan			        fn nan()      -> Option<
nan			    fn nan()      -> Option<Self>;
ne			    fn ne(&self, other: &Gc<T>) -> bool { *(*self) != *(*other) }
neg_inf			        fn neg_inf()  -> Option<
neg_inf			    fn neg_inf()  -> Option<Self>;
neg_zero			        fn neg_zero() -> Option<
neg_zero			    fn neg_zero() -> Option<Self>;
net			pub mod net;
new			    pub unsafe fn new(base: *mut T, len: uint) -> CVec<T> 
new			        fn new(k: uint) -> Dropable 
new			        pub fn new(capacity: uint) -> RawTable<K, V> 
new			    fn new(new_capacity: uint) -> DefaultResizePolicy 
new			    pub fn new() -> HashMap<K, V, RandomSipHasher> 
new			    pub fn new() -> HashSet<T, RandomSipHasher> 
new			    fn new(k: K, v: V) -> LruEntry<K, V> 
new			    pub fn new(capacity: uint) -> LruCache<K, V> 
new			    pub fn new() -> RandomSipHasher 
new			    pub fn new(inner: R) -> BufferedReader<R> 
new			    pub fn new(inner: S) -> BufferedStream<S> 
new			    pub fn new(inner: W) -> BufferedWriter<W> 
new			    pub fn new(inner: W) -> LineBufferedWriter<W> 
new			    pub fn new(rx: Receiver<Vec<u8>>) -> ChanReader 
new			    pub fn new(tx: Sender<Vec<u8>>) -> ChanWriter 
new			    pub fn new(r: &'r mut R) -> Bytes<'r, R> 
new			    pub fn new() -> MemWriter 
new			    pub fn new(buf: Vec<u8>) -> MemReader 
new			    pub fn new<'a>(buf: &'a [u8]) -> BufReader<'a> 
new			    pub fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a> 
new			        fn new(r: T, behavior: Vec<BadReaderBehavior>) -> BadReader<T> 
new			    fn new(s: &'a str) -> Parser<'a> 
new			    fn new(s: Box<RtioTcpStream + Send>) -> TcpStream 
new			    pub fn new(inner: Box<RtioPipe + Send>) -> PipeStream 
new			    pub fn new<T:ToCStr>(program: T) -> Command 
new			    pub fn new() -> Listener 
new			    pub fn new(suffix: &str) -> Option<TempDir> 
new			    pub fn new() -> IoResult<Timer> 
new			    pub fn new(iter: T) -> IterReader<T> 
new			    pub fn new(mut readers: I) -> ChainedReader<I, R> 
new			    pub fn new(r: R, limit: uint) -> LimitReader<R> 
new			    pub fn new(r: R, w: W) -> TeeReader<R, W> 
new			    pub fn new(writers: Vec<Box<Writer>>) -> MultiWriter 
new			    pub fn new(min_len: uint, options: &[MapOption]) -> Result<MemoryMap, MapError> 
new			    fn new<T: BytesContainer>(path: T) -> Self 
new			    pub fn new<T: BytesContainer>(path: T) -> Path 
new			    pub fn new<T: BytesContainer>(path: T) -> Path 
new			    pub fn new() -> IoResult<StdRng> 
new			        pub fn new() -> IoResult<OsRng> 
new			    pub fn new(r: R) -> ReaderRng<R> 
new			    pub fn new(n_tasks: uint,
new			    pub fn new() -> TaskBuilder<SiblingSpawner> 
new_drop			    fn new_drop(b : &mut Bencher) 
new_in			    pub fn new_in(tmpdir: &Path, suffix: &str) -> Option<TempDir> 
new_insert_drop			    fn new_insert_drop(b : &mut Bencher) 
new_opt			    fn new_opt<T: BytesContainer>(path: T) -> Option<Self> 
new_opt			    pub fn new_opt<T: BytesContainer>(path: T) -> Option<Path> 
new_opt			    fn new_opt<T: BytesContainer>(path: T) -> Option<Path> 
new_opt			    pub fn new_opt<T: BytesContainer>(path: T) -> Option<Path> 
new_unchecked			    unsafe fn new_unchecked<T: BytesContainer>(path: T) -> Self;
new_unchecked			    unsafe fn new_unchecked<T: BytesContainer>(path: T) -> Path 
new_unchecked			    unsafe fn new_unchecked<T: BytesContainer>(path: T) -> Path 
new_uninitialized			        unsafe fn new_uninitialized(capacity: uint) -> RawTable<K, V> 
new_with_dtor			    pub unsafe fn new_with_dtor(base: *mut T, len: uint,
next			        fn next(&mut self) -> Option<(&'a K, &'a V)> 
next			        fn next(&mut self) -> Option<(&'a K, &'a mut V)> 
next			        fn next(&mut self) -> Option<(SafeHash, K, V)> 
next			    fn next(&mut self) -> Option<IoResult<u8>> 
next			    fn next(&mut self) -> Option<Path> 
next			    fn next(&mut self) -> Option<IoResult<String>> 
next			    fn next(&mut self) -> Option<IoResult<T>> 
next			    fn next(&mut self) -> Option<IoResult<char>> 
next_after			    fn next_after(self, other: f32) -> f32 
next_after			    fn next_after(self, other: f64) -> f64 
next_after			    fn next_after(self, other: Self) -> Self;
next_test_ip4			pub fn next_test_ip4() -> SocketAddr 
next_test_ip6			pub fn next_test_ip6() -> SocketAddr 
next_test_port			pub fn next_test_port() -> u16 
next_test_unix			pub fn next_test_unix() -> Path 
next_u32			        fn next_u32(&mut self) -> u32 { self.i as u32 }
next_u32			    fn next_u32(&mut self) -> u32 
next_u32			        fn next_u32(&mut self) -> u32 
next_u32			    fn next_u32(&mut self) -> u32 
next_u64			        fn next_u64(&mut self) -> u64 { self.i }
next_u64			    fn next_u64(&mut self) -> u64 
next_u64			        fn next_u64(&mut self) -> u64 
next_u64			    fn next_u64(&mut self) -> u64 
nextafter			        pub fn nextafter(x: c_double, y: c_double) -> c_double;
nextafterf			        pub fn nextafterf(x: c_float, y: c_float) -> c_float;
normalize			    fn normalize<V: Vector<u8>+CloneableVector<u8>>(v: V) -> Vec<u8> 
normalize_			    fn normalize_<S: StrAllocating>(s: S) -> (Option<PathPrefix>, String) 
normalize__			    fn normalize__(s: &str, prefix: Option<PathPrefix>) -> Option<String> 
normalize_helper			fn normalize_helper<'a>(v: &'a [u8], is_abs: bool) -> Option<Vec<&'a [u8]>> 
normalize_helper			fn normalize_helper<'a>(s: &'a str, prefix: Option<PathPrefix>) -> (bool, Option<Vec<&'a str>>) 
not			            fn not(&self) -> 
num			pub mod num;
num			impl num::FromStrRadix for f32 
num			impl num::ToStrRadix for f32 
num			impl num::FromStrRadix for f64 
num			impl num::ToStrRadix for f64 
num_cpus			pub fn num_cpus() -> uint 
objc_getClass			        fn objc_getClass(class_name: *const libc::c_uchar) -> NsId;
objc_msgSend			        fn objc_msgSend(obj: NsId, sel: Sel, ...) -> NsId;
on_fail			pub fn on_fail(obj: &Any + Send, file: &'static str, line: uint) 
oneshot			    pub fn oneshot(&mut self, msecs: u64) -> Receiver<()> 
open			    pub fn open<T: ToCStr>(filename: Option<T>)
open			    pub fn open(path: &Path) -> IoResult<File> 
open			    pub fn open(fd: libc::c_int) -> IoResult<PipeStream> 
open_external			    pub unsafe fn open_external<T: ToCStr>(filename: T) -> *mut u8 
open_internal			    pub unsafe fn open_internal() -> *mut u8 
open_mode			    pub fn open_mode(path: &Path,
os			pub mod os;
os			pub mod os;
output			    pub fn output(&self) -> IoResult<ProcessOutput> 
output			    fn output(w: &mut Writer, idx: int, addr: *mut libc::c_void,
page_size			pub fn page_size() -> uint 
pair			    pub fn pair() -> IoResult<PipePair> 
parse_bytes			pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<
parse_bytes			pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<
parse_digit			        fn parse_digit(c: char, radix: u8) -> Option<u8> 
parse_prefix			fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> 
parse_two_comps			    fn parse_two_comps<'a>(mut path: &'a str, f: |char| -> bool)
partial_cmp			    fn partial_cmp(&self, other: &Gc<T>) -> Option<Ordering> 
path			        fn path<'a>(&'a self) -> &'a Path 
path			    pub fn path<'a>(&'a self) -> &'a Path 
path			impl path::Path 
path			    pub fn path<'a>(&'a self) -> &'a Path 
path			pub mod path;
path_relative_from			    fn path_relative_from(&self, base: &Self) -> Option<Self>;
path_relative_from			    fn path_relative_from(&self, base: &Path) -> Option<Path> 
path_relative_from			    fn path_relative_from(&self, base: &Path) -> Option<Path> 
path_relative_from_backward			    fn path_relative_from_backward(b: &mut Bencher) 
path_relative_from_forward			    fn path_relative_from_forward(b: &mut Bencher) 
path_relative_from_same_level			    fn path_relative_from_same_level(b: &mut Bencher) 
peek			        pub fn peek(&self, index: uint) -> BucketState 
peer_name			    pub fn peer_name(&mut self) -> IoResult<SocketAddr> 
peer_name			    pub fn peer_name(addr: SocketAddr) 
periodic			    pub fn periodic(&mut self, msecs: u64) -> Receiver<()> 
pipe			pub mod pipe;
pipe			pub unsafe fn pipe() -> IoResult<Pipe> 
pop			    fn pop(&mut self, k: &K) -> Option<V> 
pop			    pub fn pop(&mut self, k: &K) -> Option<V> 
pop			    fn pop(&mut self) -> bool;
pop			    fn pop(&mut self) -> bool 
pop			    fn pop(&mut self) -> bool 
pop_equiv			    pub fn pop_equiv<Q:Hash<S> + Equiv<K>>(&mut self, k: &Q) -> Option<V> 
pop_internal			    fn pop_internal(&mut self, starting_index: table::FullIndex) -> Option<V> 
posix			pub mod posix;
prefix			pub fn prefix(path: &Path) -> Option<PathPrefix> 
prefix_is_verbatim			fn prefix_is_verbatim(p: Option<PathPrefix>) -> bool 
prefix_len			    fn prefix_len(&self) -> uint 
prefix_len			fn prefix_len(p: Option<PathPrefix>) -> uint 
prelude			pub mod prelude;
prepend_search_path			    pub fn prepend_search_path(path: &Path) 
print			pub fn print(s: &str) 
print			    fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> 
print_args			pub fn print_args(fmt: &fmt::Arguments) 
println			pub fn println(s: &str) 
println_args			pub fn println_args(fmt: &fmt::Arguments) 
probe			    fn probe(&self, hash: &table::SafeHash, idx: uint) -> uint 
probe_next			    fn probe_next(&self, probe: uint) -> uint 
process			pub mod process;
push			    fn push(&mut self, len: uint, buf: &mut Vec<u8>) -> IoResult<uint> 
push			    fn push<T: BytesContainer>(&mut self, path: T) 
push_abs_path_home_dir			    fn push_abs_path_home_dir(b: &mut Bencher) 
push_at_least			    fn push_at_least() 
push_at_least			    fn push_at_least(&mut self, min: uint, len: uint, buf: &mut Vec<u8>) -> IoResult<uint> 
push_at_least_eof			    fn push_at_least_eof() 
push_at_least_error			    fn push_at_least_error() 
push_at_least_partial			    fn push_at_least_partial() 
push_home_dir			    fn push_home_dir(b: &mut Bencher) 
push_many			    fn push_many<T: BytesContainer>(&mut self, paths: &[T]) 
push_many_abs_path_home_dir			    fn push_many_abs_path_home_dir(b: &mut Bencher) 
push_many_home_dir			    fn push_many_home_dir(b: &mut Bencher) 
push_unchecked			    unsafe fn push_unchecked<T: BytesContainer>(&mut self, path: T);
push_unchecked			    unsafe fn push_unchecked<T: BytesContainer>(&mut self, path: T) 
push_unchecked			    unsafe fn push_unchecked<T: BytesContainer>(&mut self, path: T) 
put			        pub fn put(&mut self, index: EmptyIndex, hash: SafeHash, k: K, v: V) -> FullIndex 
put			    pub fn put(&mut self, k: K, v: V) 
pwd_cmd			    pub fn pwd_cmd() -> Command 
raise_fd_limit			    pub unsafe fn raise_fd_limit() 
raise_fd_limit			    pub unsafe fn raise_fd_limit() {}
raise_fd_limit			pub fn raise_fd_limit() 
rand			pub mod rand;
rand_isaac			    fn rand_isaac(b: &mut Bencher) 
rand_isaac64			    fn rand_isaac64(b: &mut Bencher) 
rand_shuffle_100			    fn rand_shuffle_100(b: &mut Bencher) 
rand_std			    fn rand_std(b: &mut Bencher) 
rand_xorshift			    fn rand_xorshift(b: &mut Bencher) 
random			pub fn random<T: Rand>() -> T 
raw_index			        pub fn raw_index(&self) -> uint { self.idx as uint }
read			        pub fn read<'a>(&'a self, index: &FullIndex) -> (&'a K, &'a V) 
read			            fn read(&mut self, _: &mut [u8]) -> io::IoResult<uint> 
read			        fn read(&mut self, _: &mut [u8]) -> io::IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			        fn read(&mut self, _: &mut [u8]) -> io::IoResult<uint> 
read			        fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			        fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { self.inner.read(buf) }
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { self.read(buf) }
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint>;
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			        fn read(stream: Option<io::PipeStream>) -> Receiver<IoResult<Vec<u8>>> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    fn read(&mut self, _buf: &mut [u8]) -> io::IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> 
read_all			    pub fn read_all(input: &mut Reader) -> String 
read_all_mut			        pub fn read_all_mut<'a>(&'a mut self, index: &FullIndex)
read_at_least			    fn read_at_least(&mut self, min: uint, buf: &mut [u8]) -> IoResult<uint> 
read_atomically			    fn read_atomically<T>(&mut self, cb: |&mut Parser| -> Option<T>)
read_be_f32			    fn read_be_f32(&mut self) -> IoResult<f32> 
read_be_f64			    fn read_be_f64(&mut self) -> IoResult<f64> 
read_be_i16			    fn read_be_i16(&mut self) -> IoResult<i16> 
read_be_i32			    fn read_be_i32(&mut self) -> IoResult<i32> 
read_be_i64			    fn read_be_i64(&mut self) -> IoResult<i64> 
read_be_int			    fn read_be_int(&mut self) -> IoResult<int> 
read_be_int_n			    fn read_be_int_n(&mut self, nbytes: uint) -> IoResult<i64> 
read_be_u16			    fn read_be_u16(&mut self) -> IoResult<u16> 
read_be_u32			    fn read_be_u32(&mut self) -> IoResult<u32> 
read_be_u64			    fn read_be_u64(&mut self) -> IoResult<u64> 
read_be_uint			    fn read_be_uint(&mut self) -> IoResult<uint> 
read_be_uint_n			    fn read_be_uint_n(&mut self, nbytes: uint) -> IoResult<u64> 
read_byte			    fn read_byte() 
read_byte			    fn read_byte(&mut self) -> IoResult<u8> 
read_byte_0_bytes			    fn read_byte_0_bytes() 
read_byte_eof			    fn read_byte_eof() 
read_byte_error			    fn read_byte_error() 
read_bytes			    fn read_bytes() 
read_bytes_eof			    fn read_bytes_eof() 
read_bytes_partial			    fn read_bytes_partial() 
read_char			    fn read_char(&mut self) -> IoResult<char> 
read_char			    fn read_char(&mut self) -> Option<char> 
read_char_buffered			    fn read_char_buffered() 
read_digit			    fn read_digit(&mut self, radix: u8) -> Option<u8> 
read_exact			    fn read_exact(&mut self, len: uint) -> IoResult<Vec<u8>> 
read_given_char			    fn read_given_char(&mut self, c: char) -> Option<char> 
read_groups			        fn read_groups(p: &mut Parser, groups: &mut [u16, ..8], limit: uint) -> (uint, bool) 
read_i8			    fn read_i8(&mut self) -> IoResult<i8> 
read_ip_addr			    fn read_ip_addr(&mut self) -> Option<IpAddr> 
read_ipv4_addr			    fn read_ipv4_addr(&mut self) -> Option<IpAddr> 
read_ipv4_addr_impl			    fn read_ipv4_addr_impl(&mut self) -> Option<IpAddr> 
read_ipv6_addr			    fn read_ipv6_addr(&mut self) -> Option<IpAddr> 
read_ipv6_addr_impl			    fn read_ipv6_addr_impl(&mut self) -> Option<IpAddr> 
read_le_f32			    fn read_le_f32(&mut self) -> IoResult<f32> 
read_le_f64			    fn read_le_f64(&mut self) -> IoResult<f64> 
read_le_i16			    fn read_le_i16(&mut self) -> IoResult<i16> 
read_le_i32			    fn read_le_i32(&mut self) -> IoResult<i32> 
read_le_i64			    fn read_le_i64(&mut self) -> IoResult<i64> 
read_le_int			    fn read_le_int(&mut self) -> IoResult<int> 
read_le_int_n			    fn read_le_int_n(&mut self, nbytes: uint) -> IoResult<i64> 
read_le_u16			    fn read_le_u16(&mut self) -> IoResult<u16> 
read_le_u32			    fn read_le_u32(&mut self) -> IoResult<u32> 
read_le_u64			    fn read_le_u64(&mut self) -> IoResult<u64> 
read_le_uint			    fn read_le_uint(&mut self) -> IoResult<uint> 
read_le_uint_n			    fn read_le_uint_n(&mut self, nbytes: uint) -> IoResult<u64> 
read_line			    fn read_line(&mut self) -> IoResult<String> 
read_mut			        pub fn read_mut<'a>(&'a mut self, index: &FullIndex) -> (&'a K, &'a mut V) 
read_number			    fn read_number(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> 
read_number_impl			    fn read_number_impl(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> 
read_or			    fn read_or<T>(&mut self, parsers: &mut [|&mut Parser| -> Option<T>])
read_seq_3			    fn read_seq_3<A,
read_socket_addr			    fn read_socket_addr(&mut self) -> Option<SocketAddr> 
read_till_eof			    fn read_till_eof<T>(&mut self, cb: |&mut Parser| -> Option<T>)
read_to_end			    fn read_to_end() 
read_to_end			    fn read_to_end(&mut self) -> IoResult<Vec<u8>> 
read_to_end_error			    fn read_to_end_error() 
read_to_str			    fn read_to_str(&mut self) -> IoResult<String> 
read_u8			    fn read_u8(&mut self) -> IoResult<u8> 
read_until			    fn read_until(&mut self, byte: u8) -> IoResult<Vec<u8>> 
readdir			pub fn readdir(path: &Path) -> IoResult<Vec<Path>> 
reader			pub mod reader;
readlink			pub fn readlink(path: &Path) -> IoResult<Path> 
real_args			fn real_args() -> Vec<String> 
real_args_as_bytes			fn real_args_as_bytes() -> Vec<Vec<u8>> 
recv_from			    pub fn recv_from(&mut self, buf: &mut [u8])
recvfrom			    pub fn recvfrom(&mut self, buf: &mut [u8])
register			    pub fn register(&mut self, signum: Signum) -> io::IoResult<()> 
remove			            pub fn remove(&mut self, other: 
remove			    fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }
remove_lru			    fn remove_lru(&mut self) 
rename			pub fn rename(from: &Path, to: &Path) -> IoResult<()> 
replace_path			        fn replace_path(me: &mut Path, path: &str, prefix: Option<PathPrefix>) 
reseed			    fn reseed(&mut self, rng: &mut StdRng) 
reseed			    fn reseed(&mut self, seed: &'a [uint]) 
reseeding			impl reseeding::Reseeder<StdRng> for TaskRngReseeder 
reserve			    fn reserve(&mut self, new_capacity: uint) 
reserve			    pub fn reserve(&mut self, n: uint) 
reserve			    pub fn reserve(&mut self, new_minimum_capacity: uint) 
resize			    fn resize(&mut self, new_capacity: uint) 
result			mod result;
rlimit			    struct rlimit 
rmdir			pub fn rmdir(path: &Path) -> IoResult<()> 
rmdir_failed			    fn rmdir_failed(err: &IoError, path: &Path) -> String 
rmdir_recursive			pub fn rmdir_recursive(path: &Path) -> IoResult<()> 
robin_hood			    fn robin_hood(&mut self, mut index: table::FullIndex, mut dib_param: uint,
root_path			    fn root_path(&self) -> Option<Self>;
root_path			    fn root_path(&self) -> Option<Path> 
root_path			    fn root_path(&self) -> Option<Path> 
round_to_zero			        fn round_to_zero(&self) -> 
round_to_zero			    fn round_to_zero(&self)   -> Self;
round_up			fn round_up(from: uint, to: uint) -> uint 
round_up_to_next			    fn round_up_to_next(unrounded: uint, target_alignment: uint) -> uint 
rt			pub mod rt;
rtdeps			mod rtdeps;
run_fmt			        fn run_fmt(fmt: &::std::fmt::Arguments) -> ! 
run_output			    pub fn run_output(cmd: Command) -> String 
running_on_valgrind			pub fn running_on_valgrind() -> bool 
rust_env_pairs			                fn rust_env_pairs() -> *const *const c_char;
rust_get_num_cpus			        fn rust_get_num_cpus() -> libc::uintptr_t;
rust_running_on_valgrind			        fn rust_running_on_valgrind() -> uintptr_t;
sample			pub fn sample<T, I: Iterator<T>, R: Rng>(rng: &mut R,
search			    fn search(&self, k: &K) -> Option<table::FullIndex> 
search_equiv			    fn search_equiv<Q: Hash<S> + Equiv<K>>(&self, q: &Q) -> Option<table::FullIndex> 
search_hashed			    fn search_hashed(&self, hash: &table::SafeHash, k: &K) -> Option<table::FullIndex> 
search_hashed_generic			    fn search_hashed_generic(&self, hash: &table::SafeHash, is_match: |&K| -> bool)
search_path			    pub fn search_path() -> Vec<Path> 
seek			    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> 
seek			    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> 
seek			    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()>;
seek			    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> 
seek_before_0			    fn seek_before_0() 
seek_past_end			    fn seek_past_end() 
sel_registerName			        fn sel_registerName(name: *const libc::c_uchar) -> Sel;
self_exe_name			pub fn self_exe_name() -> Option<Path> 
self_exe_path			pub fn self_exe_path() -> Option<Path> 
send_to			    pub fn send_to(&mut self, buf: &[u8], dst: SocketAddr) -> IoResult<()> 
sendto			    pub fn sendto(&mut self, buf: &[u8], dst: SocketAddr) -> IoResult<()> 
separator			    fn separator() -> u8 
sepidx_or_prefix_len			    fn sepidx_or_prefix_len(&self) -> Option<(uint,uint,uint)> 
set_broadast			    pub fn set_broadast(&mut self, broadcast: bool) -> IoResult<()> 
set_broadcast			    pub fn set_broadcast(&mut self, broadcast: bool) -> IoResult<()> 
set_exit_status			pub fn set_exit_status(code: int) 
set_extension			    fn set_extension<T: BytesContainer>(&mut self, extension: T) 
set_filename			    fn set_filename<T: BytesContainer>(&mut self, filename: T) 
set_filename_unchecked			    unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T);
set_filename_unchecked			    unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T) 
set_filename_unchecked			    unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T) 
set_keepalive			    pub fn set_keepalive(&mut self, delay_in_seconds: Option<uint>) -> IoResult<()> 
set_multicast_loop			    pub fn set_multicast_loop(&mut self, on: bool) -> IoResult<()> 
set_multicast_ttl			    pub fn set_multicast_ttl(&mut self, ttl: int) -> IoResult<()> 
set_nodelay			    pub fn set_nodelay(&mut self, nodelay: bool) -> IoResult<()> 
set_raw			    pub fn set_raw(&mut self, raw: bool) -> IoResult<()> 
set_read_timeout			    pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) 
set_read_timeout			    pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) 
set_read_timeout			    pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) 
set_stderr			pub fn set_stderr(stderr: Box<Writer + Send>) -> Option<Box<Writer + Send>> 
set_stdout			pub fn set_stdout(stdout: Box<Writer + Send>) -> Option<Box<Writer + Send>> 
set_timeout			    pub fn set_timeout(&mut self, ms: Option<u64>) { self.obj.set_timeout(ms); }
set_timeout			    pub fn set_timeout(&mut self, timeout_ms: Option<u64>) 
set_timeout			    pub fn set_timeout(&mut self, timeout_ms: Option<u64>) 
set_timeout			    pub fn set_timeout(&mut self, timeout_ms: Option<u64>) 
set_timeout			    pub fn set_timeout(&mut self, timeout_ms: Option<u64>) 
set_ttl			    pub fn set_ttl(&mut self, ttl: int) -> IoResult<()> 
set_write_timeout			    pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) 
set_write_timeout			    pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) 
set_write_timeout			    pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) 
setenv			pub fn setenv<T: BytesContainer>(n: &str, v: T) 
setrlimit			        fn setrlimit(resource: libc::c_int, rlp: *const rlimit) -> libc::c_int;
shares_volume			        fn shares_volume(me: &Path, path: &str) -> bool 
sigint			    fn sigint() 
signal			pub mod signal;
signal			    pub fn signal(&mut self, signal: int) -> IoResult<()> 
signal_exit			    pub fn signal_exit(&mut self) -> IoResult<()> 
signal_kill			    pub fn signal_kill(&mut self) -> IoResult<()> 
sin			    fn sin(self) -> f32 
sin			    fn sin(self) -> f64 
sin			    fn sin(self) -> Self;
sin_cos			    fn sin_cos(self) -> (f32, f32) 
sin_cos			    fn sin_cos(self) -> (f64, f64) 
sin_cos			    fn sin_cos(self) -> (Self, Self);
sinh			    fn sinh(self) -> f32 
sinh			        pub fn sinh(n: c_double) -> c_double;
sinh			    fn sinh(self) -> f64 
sinh			    fn sinh(self) -> Self;
sinhf			        pub fn sinhf(n: c_float) -> c_float;
size			        pub fn size(&self) -> uint 
size_hint			        fn size_hint(&self) -> (uint, Option<uint>) 
sleep			    pub fn sleep(&mut self, msecs: u64) 
sleep			pub fn sleep(msecs: u64) 
sleeper			    pub fn sleeper() -> Process 
slice_vec_capacity			unsafe fn slice_vec_capacity<'a, T>(v: &'a mut Vec<T>, start: uint, end: uint) -> &'a mut [T] 
smalltest			    pub fn smalltest(server: proc(UnixStream):Send, client: proc(UnixStream):Send) 
socket_name			    pub fn socket_name(&mut self) -> IoResult<SocketAddr> 
socket_name			    pub fn socket_name(addr: SocketAddr) 
socket_name			    pub fn socket_name(&mut self) -> IoResult<SocketAddr> 
socket_name			    pub fn socket_name(addr: SocketAddr) 
spawn			    pub fn spawn(&self) -> IoResult<Process> 
spawn			    pub fn spawn(blk: proc():Send -> A) -> Future<A> 
spawn			    fn spawn(self, opts: task::TaskOpts, f: proc():Send) 
spawn			    fn spawn(self, opts: task::TaskOpts, f: proc():Send);
spawn			    pub fn spawn(self, f: proc():Send) 
spawn			pub fn spawn(f: proc(): Send) 
spawn_internal			    fn spawn_internal(self, f: proc():Send,
spawner			    pub fn spawner<T: Spawner>(self, spawner: T) -> TaskBuilder<T> 
split_paths			pub fn split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> 
split_paths_unix			    fn split_paths_unix() 
split_paths_windows			    fn split_paths_windows() 
src			fn src<T>(fd: libc::c_int, readable: bool, f: |StdSource| -> T) -> T 
stack_size			    pub fn stack_size(mut self, size: uint) -> TaskBuilder<S> 
standard_error			pub fn standard_error(kind: IoErrorKind) -> IoError 
start			fn start(argc: int, argv: *const *const u8) -> int 
stat			    pub fn stat(&mut self) -> IoResult<FileStat> 
stat			    pub fn stat(&self) -> IoResult<FileStat> { stat(self) }
stat			pub fn stat(path: &Path) -> IoResult<FileStat> 
status			    pub fn status(&self) -> IoResult<ProcessExit> 
std			mod std 
stderr			    pub fn stderr<'a>(&'a mut self, cfg: StdioContainer) -> &'a mut Command 
stderr			pub fn stderr() -> LineBufferedWriter<StdWriter> 
stderr			    pub fn stderr(mut self, stderr: Box<Writer + Send>) -> TaskBuilder<S> 
stderr_raw			pub fn stderr_raw() -> StdWriter 
stdin			    pub fn stdin<'a>(&'a mut self, cfg: StdioContainer) -> &'a mut Command 
stdin			pub fn stdin() -> BufferedReader<StdReader> 
stdin_raw			pub fn stdin_raw() -> StdReader 
stdio			pub mod stdio;
stdout			    pub fn stdout<'a>(&'a mut self, cfg: StdioContainer) -> &'a mut Command 
stdout			pub fn stdout() -> LineBufferedWriter<StdWriter> 
stdout			    pub fn stdout(mut self, stdout: Box<Writer + Send>) -> TaskBuilder<S> 
stdout_raw			pub fn stdout_raw() -> StdWriter 
str_components			    pub fn str_components<'a>(&'a self) -> StrComponents<'a> 
str_components			    pub fn str_components<'a>(&'a self) -> StrComponents<'a> 
str_copy_map_bytes			unsafe fn str_copy_map_bytes(string: &str, map: &'static [u8]) -> String 
str_map_bytes			unsafe fn str_map_bytes(string: String, map: &'static [u8]) -> String 
strconv			pub mod strconv;
strerror			    fn strerror(errnum: uint) -> String 
strerror_r			                fn strerror_r(errnum: c_int, buf: *mut c_char,
strerror_r			        fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: libc::size_t)
strerror_r			        fn strerror_r(errnum: c_int, buf: *mut c_char,
sub			            fn sub(&self, other: &
success			    pub fn success(&self) -> bool 
swap			    fn swap(&mut self, k: K, v: V) -> Option<V> 
symbol			    pub unsafe fn symbol(handle: *mut u8, symbol: *const libc::c_char) -> *mut u8 
symbol			    pub unsafe fn symbol(handle: *mut u8,
symbol			    pub unsafe fn symbol<T>(&self, symbol: &str) -> Result<*mut T, String> 
syminfo_cb			        extern fn syminfo_cb(data: *mut libc::c_void,
symlink			pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> 
symmetric_difference			    pub fn symmetric_difference<'a>(&'a self, other: &'a HashSet<T, H>)
sync			pub mod sync;
sysctl			        fn sysctl(name: *mut libc::c_int, namelen: libc::c_uint,
table			mod table 
take			        pub fn take(&mut self, index: FullIndex) -> (EmptyIndex, K, V) 
tan			    fn tan(self) -> f32 
tan			        pub fn tan(n: c_double) -> c_double;
tan			    fn tan(self) -> f64 
tan			    fn tan(self) -> Self;
tanf			        pub fn tanf(n: c_float) -> c_float;
tanh			    fn tanh(self) -> f32 
tanh			        pub fn tanh(n: c_double) -> c_double;
tanh			    fn tanh(self) -> f64 
tanh			    fn tanh(self) -> Self;
tanhf			        pub fn tanhf(n: c_float) -> c_float;
task			pub mod task;
task_abort_no_kill_runtime			fn task_abort_no_kill_runtime() 
task_pool			mod task_pool;
task_rng			pub fn task_rng() -> TaskRng 
tcp			pub mod tcp;
tell			    fn tell(&self) -> IoResult<u64> 
tell			    fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }
tell			    fn tell(&self) -> IoResult<u64>;
tell			    fn tell(&self) -> IoResult<u64> 
tempfile			mod tempfile;
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			pub mod test;
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			    fn test() 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tgamma			        pub fn tgamma(n: c_double) -> c_double;
tgammaf			        pub fn tgammaf(n: c_float) -> c_float;
timer			pub mod timer;
tmpdir			    pub fn tmpdir() -> TempDir 
tmpdir			pub fn tmpdir() -> Path 
to_ascii			    fn to_ascii(&self) -> T 
to_ascii_lower			    fn to_ascii_lower(&self) -> String 
to_ascii_lower			    fn to_ascii_lower(&self) -> String;
to_ascii_nocheck			    unsafe fn to_ascii_nocheck(&self) -> &'a [Ascii] 
to_ascii_nocheck			    unsafe fn to_ascii_nocheck(&self) -> &'a[Ascii] 
to_ascii_nocheck			    unsafe fn to_ascii_nocheck(&self) -> Ascii 
to_ascii_nocheck			    unsafe fn to_ascii_nocheck(&self) -> T;
to_ascii_opt			    fn to_ascii_opt(&self) -> Option<T> 
to_ascii_upper			    fn to_ascii_upper(&self) -> String 
to_ascii_upper			    fn to_ascii_upper(&self) -> String;
to_byte			    pub fn to_byte(self) -> u8 
to_c_str			    fn to_c_str(&self) -> CString 
to_c_str			    fn to_c_str(&self) -> CString 
to_c_str_unchecked			    unsafe fn to_c_str_unchecked(&self) -> CString 
to_c_str_unchecked			    unsafe fn to_c_str_unchecked(&self) -> CString 
to_char			    pub fn to_char(self) -> char 
to_i64			        fn to_i64(&self) -> Option<i64> { self.x.to_i64() }
to_lower			    fn to_lower(&self) -> Vec<Ascii> 
to_lower			    fn to_lower(&self) -> Vec<Ascii>;
to_lower			    pub fn to_lower(self) -> Ascii 
to_lowercase			    pub fn to_lowercase(self) -> Ascii 
to_rtio			fn to_rtio(ip: IpAddr) -> rtio::IpAddr 
to_rtio			        fn to_rtio(p: StdioContainer) -> rtio::StdioContainer 
to_str			pub mod to_str;
to_str			pub fn to_str(num: f32) -> String 
to_str			pub fn to_str(num: f64) -> String 
to_str			    fn to_str(&self) -> String 
to_str			    fn to_str(&self) -> String;
to_str_base_36			        fn to_str_base_36(b: &mut Bencher) 
to_str_bin			        fn to_str_bin(b: &mut Bencher) 
to_str_bytes			pub fn to_str_bytes<U>(n: 
to_str_bytes			pub fn to_str_bytes<U>(n: 
to_str_dec			        fn to_str_dec(b: &mut Bencher) 
to_str_digits			pub fn to_str_digits(num: f32, dig: uint) -> String 
to_str_digits			pub fn to_str_digits(num: f64, dig: uint) -> String 
to_str_exact			pub fn to_str_exact(num: f32, dig: uint) -> String 
to_str_exact			pub fn to_str_exact(num: f64, dig: uint) -> String 
to_str_exp_digits			pub fn to_str_exp_digits(num: f32, dig: uint, upper: bool) -> String 
to_str_exp_digits			pub fn to_str_exp_digits(num: f64, dig: uint, upper: bool) -> String 
to_str_exp_exact			pub fn to_str_exp_exact(num: f32, dig: uint, upper: bool) -> String 
to_str_exp_exact			pub fn to_str_exp_exact(num: f64, dig: uint, upper: bool) -> String 
to_str_hex			pub fn to_str_hex(num: f32) -> String 
to_str_hex			pub fn to_str_hex(num: f64) -> String 
to_str_hex			        fn to_str_hex(b: &mut Bencher) 
to_str_oct			        fn to_str_oct(b: &mut Bencher) 
to_str_radix			    fn to_str_radix(&self, rdx: uint) -> String 
to_str_radix			    fn to_str_radix(&self, rdx: uint) -> String 
to_str_radix			    fn to_str_radix(&self, radix: uint) -> String 
to_str_radix			    fn to_str_radix(&self, radix: uint) -> String;
to_str_radix			    fn to_str_radix(&self, radix: uint) -> String 
to_str_radix1			    pub fn to_str_radix1() 
to_str_radix37			    pub fn to_str_radix37() 
to_str_radix_special			pub fn to_str_radix_special(num: f32, rdx: uint) -> (String, bool) 
to_str_radix_special			pub fn to_str_radix_special(num: f64, rdx: uint) -> (String, bool) 
to_u64			        fn to_u64(&self) -> Option<u64> { self.x.to_u64() }
to_upper			    fn to_upper(&self) -> Vec<Ascii> 
to_upper			    fn to_upper(&self) -> Vec<Ascii>;
to_upper			    pub fn to_upper(self) -> Ascii 
to_uppercase			    pub fn to_uppercase(self) -> Ascii 
trace_fn			        extern fn trace_fn(ctx: *mut uw::_Unwind_Context,
truncate			    pub fn truncate(&mut self, size: i64) -> IoResult<()> 
try			    pub fn try<T:Send>(self, f: proc():Send -> T) -> Result<T, Box<Any + Send>> 
try			pub fn try<T: Send>(f: proc(): Send -> T) -> Result<T, Box<Any + Send>> 
try_future			    pub fn try_future<T:Send>(self, f: proc():Send -> T)
try_future			pub fn try_future<T:Send>(f: proc():Send -> T) -> Future<Result<T, Box<Any + Send>>> 
u64_from_be_bytes			pub fn u64_from_be_bytes(data: &[u8], start: uint, size: uint) -> u64 
u64_from_be_bytes_4_aligned			    fn u64_from_be_bytes_4_aligned(b: &mut Bencher) 
u64_from_be_bytes_4_unaligned			    fn u64_from_be_bytes_4_unaligned(b: &mut Bencher) 
u64_from_be_bytes_7_aligned			    fn u64_from_be_bytes_7_aligned(b: &mut Bencher) 
u64_from_be_bytes_7_unaligned			    fn u64_from_be_bytes_7_unaligned(b: &mut Bencher) 
u64_from_be_bytes_8_aligned			    fn u64_from_be_bytes_8_aligned(b: &mut Bencher) 
u64_from_be_bytes_8_unaligned			    fn u64_from_be_bytes_8_unaligned(b: &mut Bencher) 
u64_to_be_bytes			pub fn u64_to_be_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T 
u64_to_le_bytes			pub fn u64_to_le_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T 
udp			pub mod udp;
uid			    pub fn uid<'a>(&'a mut self, id: uint) -> &'a mut Command 
uint			    mod uint 
union			    pub fn union<'a>(&'a self, other: &'a HashSet<T, H>)
unix			pub mod unix;
unlink			pub fn unlink(path: &Path) -> IoResult<()> 
unregister			    pub fn unregister(&mut self, signum: Signum) 
unsetenv			pub fn unsetenv(n: &str) 
unstable			pub mod unstable 
unwrap			    pub unsafe fn unwrap(mut self) -> *mut T 
unwrap			    pub fn unwrap(mut self) -> W 
unwrap			    pub fn unwrap(self) -> R { self.inner }
unwrap			    pub fn unwrap(self) -> S 
unwrap			    pub fn unwrap(self) -> W { self.inner.unwrap() }
unwrap			    pub fn unwrap(self) -> Vec<u8> { self.buf }
unwrap			    pub fn unwrap(self) -> Path 
unwrap			    pub fn unwrap(self) -> (R, W) 
unwrap			    pub fn unwrap(self) -> R { self.inner }
unwrap			    pub fn unwrap(mut self) -> A 
update_desc			    fn update_desc(self, desc: &'static str) -> IoResult<T> 
update_desc			    fn update_desc(self, desc: &'static str) -> Self;
update_detail			    fn update_detail(self, detail: |&IoError| -> String) -> IoResult<T> 
update_detail			    fn update_detail(self, detail: |&IoError| -> String) -> Self;
update_err			        fn update_err<T>(result: IoResult<T>, file: &File) -> IoResult<T> 
update_err			    fn update_err<T>(err: IoResult<T>, path: &Path) -> IoResult<T> 
update_err			    fn update_err<T>(result: IoResult<T>, from: &Path, to: &Path) -> IoResult<T> 
update_err			    fn update_err(self, desc: &'static str, detail: |&IoError| -> String) -> IoResult<T> 
update_err			    fn update_err(self, desc: &'static str, detail: |&IoError| -> String) -> Self;
update_normalized			    fn update_normalized<S: Str>(&mut self, s: S) 
update_sepidx			    fn update_sepidx(&mut self) 
util			pub mod util;
util			mod util;
utime			    fn utime() 
utime_noexist			    fn utime_noexist() 
uw			    mod uw 
values			    pub fn values<'a>(&'a self) -> Values<'a, K, V> 
wait			    pub fn wait(&mut self) -> IoResult<ProcessExit> 
wait_with_output			    pub fn wait_with_output(mut self) -> IoResult<ProcessOutput> 
walk_dir			pub fn walk_dir(path: &Path) -> IoResult<Directories> 
weak_rng			pub fn weak_rng() -> XorShiftRng 
win32			pub mod win32 
windows			pub mod windows;
winsize			    pub fn winsize(&mut self) -> IoResult<(int, int)> 
with_capacities			    pub fn with_capacities(reader_cap: uint, writer_cap: uint, inner: S)
with_capacity			    pub fn with_capacity(capacity: uint) -> HashMap<K, V, RandomSipHasher> 
with_capacity			    pub fn with_capacity(capacity: uint) -> HashSet<T, RandomSipHasher> 
with_capacity			    pub fn with_capacity(cap: uint, inner: R) -> BufferedReader<R> 
with_capacity			    pub fn with_capacity(cap: uint, inner: W) -> BufferedWriter<W> 
with_capacity			    pub fn with_capacity(n: uint) -> MemWriter 
with_capacity_and_hasher			    pub fn with_capacity_and_hasher(capacity: uint, hasher: H) -> HashMap<K, V, H> 
with_capacity_and_hasher			    pub fn with_capacity_and_hasher(capacity: uint, hasher: H) -> HashSet<T, H> 
with_env_lock			fn with_env_lock<T>(f: || -> T) -> T 
with_extension			    fn with_extension<T: BytesContainer>(&self, extension: T) -> Self 
with_filename			    fn with_filename<T: BytesContainer>(&self, filename: T) -> Self 
with_hasher			    pub fn with_hasher(hasher: H) -> HashMap<K, V, H> 
with_hasher			    pub fn with_hasher(hasher: H) -> HashSet<T, H> 
with_task_name			pub fn with_task_name<U>(blk: |Option<&str>| -> U) -> U 
with_task_stdout			fn with_task_stdout(f: |&mut Writer| -> IoResult<()>) 
with_wrapper			    pub fn with_wrapper(mut self, wrapper: proc(v: proc():Send):Send -> proc():Send)
write			    fn write(&mut self, bytes: &[u8]) -> IoResult<()> 
write			    fn write(&mut self, b: &[u8]) -> io::IoResult<()> 
write			            fn write(&mut self, _: &[u8]) -> io::IoResult<()> { Ok(()) }
write			            fn write(&mut self, _buf: &[u8]) -> IoResult<()> { Ok(()) }
write			        fn write(&mut self, _: &[u8]) -> io::IoResult<()> { Ok(()) }
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			            fn write(&mut self, bytes: &[u8]) -> fmt::Result 
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.inner.write(buf) }
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.write(buf) }
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()>;
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			            fn write(&mut self, _buf: &[u8]) -> io::IoResult<()> 
write			    fn write(&mut self, _buf: &[u8]) -> io::IoResult<()> { Ok(()) }
write			    fn write(&mut self, buf: &[u8]) -> io::IoResult<()> 
write			    pub fn write(w: &mut Writer) -> IoResult<()> 
write_be_f32			    fn write_be_f32(&mut self, f: f32) -> IoResult<()> 
write_be_f64			    fn write_be_f64(&mut self, f: f64) -> IoResult<()> 
write_be_i16			    fn write_be_i16(&mut self, n: i16) -> IoResult<()> 
write_be_i32			    fn write_be_i32(&mut self, n: i32) -> IoResult<()> 
write_be_i64			    fn write_be_i64(&mut self, n: i64) -> IoResult<()> 
write_be_int			    fn write_be_int(&mut self, n: int) -> IoResult<()> 
write_be_u16			    fn write_be_u16(&mut self, n: u16) -> IoResult<()> 
write_be_u32			    fn write_be_u32(&mut self, n: u32) -> IoResult<()> 
write_be_u64			    fn write_be_u64(&mut self, n: u64) -> IoResult<()> 
write_be_uint			    fn write_be_uint(&mut self, n: uint) -> IoResult<()> 
write_char			    fn write_char(&mut self, c: char) -> IoResult<()> 
write_fmt			    fn write_fmt(&mut self, fmt: &fmt::Arguments) -> IoResult<()> 
write_i8			    fn write_i8(&mut self, n: i8) -> IoResult<()> 
write_int			    fn write_int(&mut self, n: int) -> IoResult<()> 
write_le_f32			    fn write_le_f32(&mut self, f: f32) -> IoResult<()> 
write_le_f64			    fn write_le_f64(&mut self, f: f64) -> IoResult<()> 
write_le_i16			    fn write_le_i16(&mut self, n: i16) -> IoResult<()> 
write_le_i32			    fn write_le_i32(&mut self, n: i32) -> IoResult<()> 
write_le_i64			    fn write_le_i64(&mut self, n: i64) -> IoResult<()> 
write_le_int			    fn write_le_int(&mut self, n: int) -> IoResult<()> 
write_le_u16			    fn write_le_u16(&mut self, n: u16) -> IoResult<()> 
write_le_u32			    fn write_le_u32(&mut self, n: u32) -> IoResult<()> 
write_le_u64			    fn write_le_u64(&mut self, n: u64) -> IoResult<()> 
write_le_uint			    fn write_le_uint(&mut self, n: uint) -> IoResult<()> 
write_line			    fn write_line(&mut self, s: &str) -> IoResult<()> 
write_str			    fn write_str(&mut self, s: &str) -> IoResult<()> 
write_u8			    fn write_u8(&mut self, n: u8) -> IoResult<()> 
write_uint			    fn write_uint(&mut self, n: uint) -> IoResult<()> 
y0			        pub fn y0(n: c_double) -> c_double;
y1			        pub fn y1(n: c_double) -> c_double;
yn			        pub fn yn(i: c_int, n: c_double) -> c_double;
