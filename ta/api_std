ADDRESS64			struct ADDRESS64 
ADDRESS_MODE			enum ADDRESS_MODE 
Acceptor			pub trait Acceptor<T> 
Acceptor for TcpAcceptor			impl Acceptor<TcpStream> for TcpAcceptor 
Acceptor for UnixAcceptor			impl Acceptor<UnixStream> for UnixAcceptor 
AcceptorInner			struct AcceptorInner 
AcceptorInner			struct AcceptorInner 
AcceptorInner			struct AcceptorInner 
AcceptorState			struct AcceptorState 
AcquireSRWLockExclusive			    pub fn AcquireSRWLockExclusive(SRWLock: PSRWLOCK);
AcquireSRWLockShared			    pub fn AcquireSRWLockShared(SRWLock: PSRWLOCK);
Adaptor			        struct Adaptor<'a, T: ?Sized + 'a> 
Adaptor			        struct Adaptor<'a, T: ?Sized +'a> 
Add for Duration			impl Add for Duration 
AddVectoredExceptionHandler			    fn AddVectoredExceptionHandler(FirstHandler: ULONG,
AnonPipe			impl AnonPipe 
AnonPipe			pub struct AnonPipe(FileDesc);
AnonPipe			impl AnonPipe 
AnonPipe			pub struct AnonPipe 
Args			pub struct Args { inner: ArgsOs }
Args			pub struct Args 
Args			pub struct Args 
ArgsOs			pub struct ArgsOs { inner: os_imp::Args }
AsInner			pub trait AsInner<Inner: ?Sized> 
AsInner for Command			impl AsInner<CommandImp> for Command 
AsInner for ExitStatus			impl AsInner<ExitStatusImp> for ExitStatus 
AsInner for File			impl AsInner<fs_imp::File> for File 
AsInner for FileDesc			impl AsInner<c_int> for FileDesc 
AsInner for Ipv4Addr			impl AsInner<libc::in_addr> for Ipv4Addr 
AsInner for Ipv6Addr			impl AsInner<libc::in6_addr> for Ipv6Addr 
AsInner for OsStr			impl AsInner<Slice> for OsStr 
AsInner for Permissions			impl AsInner<fs_imp::FilePermissions> for Permissions 
AsInner for Socket			impl AsInner<c_int> for Socket 
AsInner for Socket			impl AsInner<libc::SOCKET> for Socket 
AsInner for TcpListener			impl AsInner<net_imp::TcpListener> for TcpListener 
AsInner for TcpStream			impl AsInner<net_imp::TcpStream> for TcpStream 
AsInner for UdpSocket			impl AsInner<net_imp::UdpSocket> for UdpSocket 
AsInner for Wtf8			impl AsInner<[u8]> for Wtf8 
AsInnerMut			pub trait AsInnerMut<Inner: ?Sized> 
AsInnerMut for Command			impl AsInnerMut<CommandImp> for Command 
AsInnerMut for OpenOptions			impl AsInnerMut<fs_imp::OpenOptions> for OpenOptions 
AsOsStr			pub trait AsOsStr 
AsOsStr			impl<'a, T: AsOsStr + ?Sized> AsOsStr for &'a T 
AsOsStr for OsStr			impl AsOsStr for OsStr 
AsOsStr for OsString			impl AsOsStr for OsString 
AsOsStr for Path			impl AsOsStr for Path 
AsOsStr for Path			impl AsOsStr for Path 
AsOsStr for PathBuf			impl AsOsStr for PathBuf 
AsOsStr for String			impl AsOsStr for String 
AsOsStr for str			impl AsOsStr for str 
AsPath			pub trait AsPath 
AsPath for T			impl<T: AsOsStr + ?Sized> AsPath for T 
AsRawFd			pub trait AsRawFd 
AsRawFd for fs			impl AsRawFd for fs::File 
AsRawFd for net			impl AsRawFd for net::TcpListener 
AsRawFd for net			impl AsRawFd for net::TcpStream 
AsRawFd for net			impl AsRawFd for net::UdpSocket 
AsRawFd for old_io			impl AsRawFd for old_io::fs::File 
AsRawFd for old_io			impl AsRawFd for old_io::net::pipe::UnixAcceptor 
AsRawFd for old_io			impl AsRawFd for old_io::net::pipe::UnixListener 
AsRawFd for old_io			impl AsRawFd for old_io::net::pipe::UnixStream 
AsRawFd for old_io			impl AsRawFd for old_io::net::tcp::TcpAcceptor 
AsRawFd for old_io			impl AsRawFd for old_io::net::tcp::TcpListener 
AsRawFd for old_io			impl AsRawFd for old_io::net::tcp::TcpStream 
AsRawFd for old_io			impl AsRawFd for old_io::net::udp::UdpSocket 
AsRawFd for old_io			impl AsRawFd for old_io::pipe::PipeStream 
AsRawHandle			pub trait AsRawHandle 
AsRawHandle for fs			impl AsRawHandle for fs::File 
AsRawHandle for old_io			impl AsRawHandle for old_io::fs::File 
AsRawHandle for old_io			impl AsRawHandle for old_io::net::pipe::UnixAcceptor 
AsRawHandle for old_io			impl AsRawHandle for old_io::net::pipe::UnixListener 
AsRawHandle for old_io			impl AsRawHandle for old_io::net::pipe::UnixStream 
AsRawHandle for old_io			impl AsRawHandle for old_io::pipe::PipeStream 
AsRawSocket			pub trait AsRawSocket 
AsRawSocket for net			impl AsRawSocket for net::TcpListener 
AsRawSocket for net			impl AsRawSocket for net::TcpStream 
AsRawSocket for net			impl AsRawSocket for net::UdpSocket 
AsRawSocket for old_io			impl AsRawSocket for old_io::net::tcp::TcpAcceptor 
AsRawSocket for old_io			impl AsRawSocket for old_io::net::tcp::TcpListener 
AsRawSocket for old_io			impl AsRawSocket for old_io::net::tcp::TcpStream 
AsRawSocket for old_io			impl AsRawSocket for old_io::net::udp::UdpSocket 
AsciiExt			impl AsciiExt for [u8] 
AsciiExt			pub trait AsciiExt 
AsciiExt for Wtf8			impl AsciiExt for Wtf8 
AsciiExt for char			impl AsciiExt for char 
AsciiExt for str			impl AsciiExt for str 
AsciiExt for u8			impl AsciiExt for u8 
BY_HANDLE_FILE_INFORMATION			pub struct BY_HANDLE_FILE_INFORMATION 
BadReader			    impl<T: Reader> BadReader<T> 
BadReader			    struct BadReader<T> 
BadReaderBehavior			    enum BadReaderBehavior 
Barrier			impl Barrier 
Barrier			pub struct Barrier 
BarrierState			struct BarrierState 
BarrierWaitResult			impl BarrierWaitResult 
BarrierWaitResult			pub struct BarrierWaitResult(bool);
BitAnd			impl<'a, 'b, T, S> BitAnd<&'b HashSet<T, S>> for &'a HashSet<T, S>
BitOr			impl<'a, 'b, T, S> BitOr<&'b HashSet<T, S>> for &'a HashSet<T, S>
BitXor			impl<'a, 'b, T, S> BitXor<&'b HashSet<T, S>> for &'a HashSet<T, S>
Blocker			enum Blocker 
Borrow for OsString			impl Borrow<OsStr> for OsString 
Borrow for PathBuf			impl Borrow<Path> for PathBuf 
Broadcast			pub struct Broadcast<T, U> 
Bucket			impl<K, V, M> Bucket<K, V, M> 
Bucket			pub struct Bucket<K, V, M> 
BucketState			impl<K, V, M> BucketState<K, V, M> 
BucketState			pub enum BucketState<K, V, M> 
Buf			impl Buf 
Buf			pub struct Buf 
Buf			impl Buf 
Buf			pub struct Buf 
BufRead			impl<'a, B: BufRead + ?Sized> BufRead for &'a mut B 
BufRead			impl<'a> BufRead for &'a [u8] 
BufRead			pub trait BufRead: Read 
BufRead for Box			impl<B: BufRead + ?Sized> BufRead for Box<B> 
BufRead for BufReader			impl<R: Read> BufRead for BufReader<R> 
BufRead for BufStream			impl<S: Read + Write> BufRead for BufStream<S> 
BufRead for Cursor			impl<'a> BufRead for Cursor<&'a [u8]> { buffer!(); }
BufRead for Cursor			impl<'a> BufRead for Cursor<&'a mut [u8]> { buffer!(); }
BufRead for Cursor			impl<'a> BufRead for Cursor<Vec<u8>> { buffer!(); }
BufRead for Take			impl<T: BufRead> BufRead for Take<T> 
BufReadExt			pub trait BufReadExt: BufRead + Sized 
BufReadExt for T			impl<T: BufRead> BufReadExt for T {}
BufReader			impl<R: Read> BufReader<R> 
BufReader			pub struct BufReader<R> 
BufReader			impl<'a> BufReader<'a> 
BufReader			pub struct BufReader<'a> 
BufStream			impl<S: Read + Write> BufStream<S> 
BufStream			pub struct BufStream<S> 
BufWriter			impl<W: Write> BufWriter<W> 
BufWriter			pub struct BufWriter<W> 
BufWriter			impl<'a> BufWriter<'a> 
BufWriter			pub struct BufWriter<'a> 
BufWriter			    struct BufWriter<'a> 
Buffer			impl<'a> Buffer for &'a [u8] 
Buffer			pub trait Buffer: Reader 
Buffer			impl<T> Buffer<T> 
Buffer			struct Buffer<T> 
Buffer for BufReader			impl<'a> Buffer for BufReader<'a> 
Buffer for BufferedReader			impl<R: Reader> Buffer for BufferedReader<R> 
Buffer for BufferedStream			impl<S: Stream> Buffer for BufferedStream<S> 
Buffer for ChanReader			impl Buffer for ChanReader 
Buffer for LimitReader			impl<R: Buffer> Buffer for LimitReader<R> 
Buffer for MemReader			impl Buffer for MemReader 
Buffer for NullReader			impl Buffer for NullReader 
Buffer for RefReader			impl<'a, R: Buffer> Buffer for RefReader<'a, R> 
Buffer for ZeroReader			impl Buffer for ZeroReader 
BufferPrelude			pub trait BufferPrelude 
BufferPrelude for T			impl<T: Buffer> BufferPrelude for T 
BufferedReader			impl<R: Reader> BufferedReader<R> 
BufferedReader			pub struct BufferedReader<R> 
BufferedStream			impl<S: Stream> BufferedStream<S> 
BufferedStream			pub struct BufferedStream<S> 
BufferedWriter			impl<W: Writer> BufferedWriter<W> 
BufferedWriter			pub struct BufferedWriter<W> 
Builder			impl Builder 
Builder			pub struct Builder 
ByRefReader			pub trait ByRefReader 
ByRefReader for T			impl<T: Reader> ByRefReader for T 
ByRefWriter			pub trait ByRefWriter 
ByRefWriter for T			impl<T: Writer> ByRefWriter for T 
Bytes			pub struct Bytes<R> 
Bytes			impl<'r, R: Reader> Bytes<'r, R> 
Bytes			pub struct Bytes<'r, T:'r> 
BytesContainer			impl BytesContainer for [u8] 
BytesContainer			impl<'a, T: ?Sized + BytesContainer> BytesContainer for &'a T 
BytesContainer			pub trait BytesContainer 
BytesContainer for CString			impl BytesContainer for CString 
BytesContainer for EnvKey			impl BytesContainer for EnvKey 
BytesContainer for Path			impl BytesContainer for Path 
BytesContainer for Path			impl BytesContainer for Path 
BytesContainer for String			impl BytesContainer for String 
BytesContainer for Vec			impl BytesContainer for Vec<u8> 
BytesContainer for str			impl BytesContainer for str 
BytesReader			pub trait BytesReader 
BytesReader for T			impl<T: Reader> BytesReader for T 
CONDITION_VARIABLE			pub struct CONDITION_VARIABLE { pub ptr: LPVOID }
CONSOLE_SCREEN_BUFFER_INFO			pub struct CONSOLE_SCREEN_BUFFER_INFO 
CONTEXT			    pub struct CONTEXT;
CONTEXT			    pub struct CONTEXT 
COORD			pub struct COORD 
CStr			impl CStr 
CStr			pub struct CStr 
CString			impl CString 
CString			pub struct CString 
Callback			pub trait Callback 
Callback			pub trait Callback 
Callback for TimerCallback			impl Callback for TimerCallback 
CancelIo			    pub fn CancelIo(hFile: libc::HANDLE) -> libc::BOOL;
CancelIoEx			    pub fn CancelIoEx(hFile: libc::HANDLE,
Chain			pub struct Chain<T, U> 
ChainedReader			pub struct ChainedReader<I, R> 
ChanReader			impl ChanReader 
ChanReader			pub struct ChanReader 
ChanWriter			impl ChanWriter 
ChanWriter			pub struct ChanWriter 
Chars			pub struct Chars<R> 
Chars			pub struct Chars<'r, T:'r> 
CharsError			pub enum CharsError 
Child			impl Child 
Child			pub struct Child 
ChildStderr			pub struct ChildStderr 
ChildStdin			pub struct ChildStdin 
ChildStdout			pub struct ChildStdout 
Cleanup			struct Cleanup 
Clone for ChanWriter			impl Clone for ChanWriter 
Clone for DefaultState			impl<H> Clone for DefaultState<H> 
Clone for Dropable			    impl Clone for Dropable 
Clone for Ipv4Addr			impl Clone for Ipv4Addr 
Clone for Ipv6Addr			impl Clone for Ipv6Addr 
Clone for Iter			impl<'a, K, V> Clone for Iter<'a, K, V> 
Clone for Iter			impl<'a, K, V> Clone for Iter<'a, K, V> 
Clone for Keys			impl<'a, K, V> Clone for Keys<'a, K, V> 
Clone for PipeStream			impl Clone for PipeStream 
Clone for RawBuckets			impl<'a, K, V> Clone for RawBuckets<'a, K, V> 
Clone for RawTable			impl<K: Clone, V: Clone> Clone for RawTable<K, V> 
Clone for Repr			impl Clone for Repr 
Clone for Sender			impl<T: Send> Clone for Sender<T> 
Clone for SyncSender			impl<T: Send> Clone for SyncSender<T> 
Clone for TcpAcceptor			impl Clone for TcpAcceptor 
Clone for TcpAcceptor			impl Clone for TcpAcceptor 
Clone for TcpAcceptor			impl Clone for TcpAcceptor 
Clone for TcpStream			impl Clone for TcpStream 
Clone for TcpStream			impl Clone for TcpStream 
Clone for UdpSocket			impl Clone for UdpSocket 
Clone for UdpSocket			impl Clone for UdpSocket 
Clone for UnixAcceptor			impl Clone for UnixAcceptor 
Clone for UnixAcceptor			impl Clone for UnixAcceptor 
Clone for UnixAcceptor			impl Clone for UnixAcceptor 
Clone for UnixStream			impl Clone for UnixStream 
Clone for UnixStream			impl Clone for UnixStream 
Clone for UnixStream			impl Clone for UnixStream 
Clone for Values			impl<'a, K, V> Clone for Values<'a, K, V> 
CodePoint			impl CodePoint 
CodePoint			pub struct CodePoint 
Command			impl Command 
Command			pub struct Command 
Command			impl Command 
Command			pub struct Command 
Command			impl Command 
Command			pub struct Command 
Command			impl Command 
Command			pub struct Command 
CommandExt			pub trait CommandExt 
CommandExt			pub struct CommandExt 
CommandExt for process			impl CommandExt for process::Command 
CommandLineToArgvW			    fn CommandLineToArgvW(lpCmdLine: LPCWSTR,
CommandLineToArgvW			    pub fn CommandLineToArgvW(lpCmdLine: *mut libc::LPCWSTR,
Component			impl<'a> Component<'a> 
Component			pub enum Component<'a> 
Components			impl<'a> Components<'a> 
Components			pub struct Components<'a> 
Condvar			impl Condvar 
Condvar			pub struct Condvar { inner: Box<StaticCondvar> }
Condvar			impl Condvar 
Condvar			pub struct Condvar(imp::Condvar);
Condvar			impl Condvar 
Condvar			pub struct Condvar { inner: UnsafeCell<ffi::pthread_cond_t> }
Condvar			impl Condvar 
Condvar			pub struct Condvar { inner: UnsafeCell<ffi::CONDITION_VARIABLE> }
ConstRng			    struct ConstRng { i: u64 }
Context			    struct Context<'a> 
Copy for Bucket			impl<K,V,M:Copy> Copy for Bucket<K,V,M> {}
Copy for RawBucket			impl<K,V> Copy for RawBucket<K,V> {}
CreateEventA			    fn CreateEventA(lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
CreateThread			    fn CreateThread(lpThreadAttributes: LPSECURITY_ATTRIBUTES,
CreateWaitableTimerA			        pub fn CreateWaitableTimerA(lpTimerAttributes: LPSECURITY_ATTRIBUTES,
CryptAcquireContextA			        fn CryptAcquireContextA(phProv: *mut HCRYPTPROV,
CryptGenRandom			        fn CryptGenRandom(hProv: HCRYPTPROV,
CryptReleaseContext			        fn CryptReleaseContext(hProv: HCRYPTPROV, dwFlags: DWORD) -> BOOL;
Cursor			impl<T> Cursor<T> 
Cursor			pub struct Cursor<T> 
Custom			struct Custom 
DISPATCHER_CONTEXT			    pub struct DISPATCHER_CONTEXT;
Debug for Buf			impl Debug for Buf 
Debug for Buf			impl Debug for Buf 
Debug for HashMap			impl<K, V, S> Debug for HashMap<K, V, S>
Debug for OsStr			impl Debug for OsStr 
Debug for OsString			impl Debug for OsString 
Debug for Slice			impl Debug for Slice 
Debug for Slice			impl Debug for Slice 
Default for DefaultState			impl<H> Default for DefaultState<H> 
Default for FilePermission			impl Default for FilePermission 
Default for HashMap			impl<K, V, S> Default for HashMap<K, V, S>
Default for HashSet			impl<T, S> Default for HashSet<T, S>
Default for RandomState			impl Default for RandomState 
DefaultResizePolicy			impl DefaultResizePolicy 
DefaultResizePolicy			struct DefaultResizePolicy;
DefaultState			pub struct DefaultState<H>(marker::PhantomData<H>);
Deref for CString			impl Deref for CString 
Deref for MutexGuard			impl<'mutex, T> Deref for MutexGuard<'mutex, T> 
Deref for RwLockReadGuard			impl<'rwlock, T> Deref for RwLockReadGuard<'rwlock, T> 
Deref for RwLockWriteGuard			impl<'rwlock, T> Deref for RwLockWriteGuard<'rwlock, T> 
Deref for StdinReaderGuard			impl<'a> Deref for StdinReaderGuard<'a> 
DerefMut for MutexGuard			impl<'mutex, T> DerefMut for MutexGuard<'mutex, T> 
DerefMut for RwLockWriteGuard			impl<'rwlock, T> DerefMut for RwLockWriteGuard<'rwlock, T> 
DerefMut for StdinReaderGuard			impl<'a> DerefMut for StdinReaderGuard<'a> 
Difference			pub struct Difference<'a, T: 'a, S: 'a> 
Dir			struct Dir(*mut libc::DIR);
DirEntry			impl DirEntry 
DirEntry			pub struct DirEntry(fs_imp::DirEntry);
DirEntry			impl DirEntry 
DirEntry			pub struct DirEntry 
DirEntry			impl DirEntry 
DirEntry			pub struct DirEntry 
Directories			pub struct Directories 
Display			impl<'a, P: GenericPath> Display<'a, P> 
Display			pub struct Display<'a, P:'a> 
Display			pub struct Display<'a> 
Div for Duration			impl Div<i32> for Duration 
Dl_info			    struct Dl_info 
DoubleEndedIterator for Components			impl<'a> DoubleEndedIterator for Components<'a> 
DoubleEndedIterator for EscapeDefault			impl DoubleEndedIterator for EscapeDefault 
DoubleEndedIterator for Iter			impl<'a> DoubleEndedIterator for Iter<'a> 
Drain			pub struct Drain<'a, K: 'a, V: 'a> 
Drain			pub struct Drain<'a, K: 'a> 
Drain			pub struct Drain<'a, K: 'a, V: 'a> 
Drop for AnonPipe			impl Drop for AnonPipe 
Drop for Args			impl Drop for Args 
Drop for BufWriter			impl<W: Write> Drop for BufWriter<W> 
Drop for BufferedWriter			impl<W: Writer> Drop for BufferedWriter<W> 
Drop for Cleanup			impl Drop for Cleanup 
Drop for Condvar			impl Drop for Condvar 
Drop for Dir			impl Drop for Dir 
Drop for Drain			impl<'a, K: 'a, V: 'a> Drop for Drain<'a, K, V> 
Drop for Dropable			    impl Drop for Dropable 
Drop for DynamicLibrary			impl Drop for DynamicLibrary 
Drop for Env			impl Drop for Env 
Drop for Event			impl Drop for Event 
Drop for Event			impl Drop for Event 
Drop for FileDesc			impl Drop for FileDesc 
Drop for FileDesc			impl Drop for FileDesc 
Drop for FileDesc			impl Drop for FileDesc 
Drop for FindNextFileHandle			impl Drop for FindNextFileHandle 
Drop for Foo			        impl Drop for Foo 
Drop for Foo			    impl Drop for Foo 
Drop for Guard			    impl<'a> Drop for Guard<'a> 
Drop for Guard			impl<'a> Drop for Guard<'a> 
Drop for Handle			impl<'rx, T: Send> Drop for Handle<'rx, T> 
Drop for Handle			impl Drop for Handle 
Drop for Handler			impl Drop for Handler 
Drop for Handler			impl Drop for Handler 
Drop for Inner			impl Drop for Inner 
Drop for Inner			impl Drop for Inner 
Drop for Inner			impl Drop for Inner 
Drop for JoinGuard			impl<'a, T: Send + 'a> Drop for JoinGuard<'a, T> 
Drop for JoinHandle			impl Drop for JoinHandle 
Drop for Key			impl Drop for Key 
Drop for LookupHost			impl Drop for LookupHost 
Drop for MemoryMap			impl Drop for MemoryMap 
Drop for Mutex			impl<T: Send> Drop for Mutex<T> 
Drop for MutexGuard			impl<'a, T> Drop for MutexGuard<'a, T> 
Drop for OsRng			    impl Drop for OsRng 
Drop for Packet			impl<T: Send> Drop for Packet<T> 
Drop for Packet			impl<T: Send> Drop for Packet<T> 
Drop for Packet			impl<T: Send> Drop for Packet<T> 
Drop for Packet			impl<T: Send> Drop for Packet<T> 
Drop for Process			impl Drop for Process 
Drop for Process			impl Drop for Process 
Drop for Queue			impl<T: Send> Drop for Queue<T> 
Drop for Queue			impl<T: Send> Drop for Queue<T> 
Drop for RawTable			impl<K, V> Drop for RawTable<K, V> 
Drop for Receiver			impl<T: Send> Drop for Receiver<T> 
Drop for Reset			        impl<'a, T> Drop for Reset<'a, T> 
Drop for RwLock			impl<T> Drop for RwLock<T> 
Drop for RwLockReadGuard			impl<'a, T> Drop for RwLockReadGuard<'a, T> 
Drop for RwLockWriteGuard			impl<'a, T> Drop for RwLockWriteGuard<'a, T> 
Drop for S1			        impl Drop for S1 
Drop for S2			        impl Drop for S2 
Drop for Select			impl Drop for Select 
Drop for SemaphoreGuard			impl<'a> Drop for SemaphoreGuard<'a> 
Drop for Sender			impl<T: Send> Drop for Sender<T> 
Drop for Sentinel			impl<'a> Drop for Sentinel<'a> 
Drop for Socket			impl Drop for Socket 
Drop for SyncSender			impl<T: Send> Drop for SyncSender<T> 
Drop for TTY			impl Drop for TTY 
Drop for TcpListener			impl Drop for TcpListener 
Drop for TempDir			    impl Drop for TempDir 
Drop for TempDir			impl Drop for TempDir 
Drop for TempDir			    impl Drop for TempDir 
Drop for TempDir			impl Drop for TempDir 
Drop for Timer			impl Drop for Timer 
Drop for Timer			impl Drop for Timer 
Drop for UnixListener			impl Drop for UnixListener 
Drop for UnixListener			impl Drop for UnixListener 
Drop for Unwinder			            impl Drop for Unwinder 
Drop for Unwinder			            impl Drop for Unwinder 
Dropable			    impl Dropable 
Dropable			    struct Dropable 
Dummy			struct Dummy(UnsafeCell<()>);
Dummy			struct Dummy(UnsafeCell<()>);
Duration			impl Duration 
Duration			pub struct Duration 
DynamicLibrary			impl DynamicLibrary 
DynamicLibrary			pub struct DynamicLibrary 
EXCEPTION_DISPOSITION			    pub enum EXCEPTION_DISPOSITION 
EXCEPTION_POINTERS			pub struct EXCEPTION_POINTERS 
EXCEPTION_RECORD			    pub struct EXCEPTION_RECORD;
EXCEPTION_RECORD			pub struct EXCEPTION_RECORD 
Empty			pub struct Empty { _priv: () }
EmptyBucket			impl<K, V, M> EmptyBucket<K, V, M> 
EmptyBucket			pub struct EmptyBucket<K, V, M> 
EncodeWide			pub struct EncodeWide<'a> 
Entry			impl<'a, K, V> Entry<'a, K, V> 
Entry			pub enum Entry<'a, K: 'a, V: 'a> 
Env			pub struct Env 
Env			pub struct Env 
EnvKey			struct EnvKey(CString);
EofReader			    struct EofReader;
Eq for CStr			impl Eq for CStr {}
Eq for HashMap			impl<K, V, S> Eq for HashMap<K, V, S>
Eq for HashSet			impl<T, S> Eq for HashSet<T, S>
Eq for Ipv4Addr			impl Eq for Ipv4Addr {}
Eq for Ipv6Addr			impl Eq for Ipv6Addr {}
Eq for OsStr			impl Eq for OsStr {}
Eq for OsString			impl Eq for OsString {}
Eq for Path			impl Eq for Path {}
Eq for Path			impl Eq for Path {}
Eq for Repr			impl Eq for Repr {}
Eq for Wtf8			impl Eq for Wtf8 {}
Error			impl Error 
Error			pub struct Error 
Error for IoError			impl Error for IoError 
Error for JoinPathsError			impl Error for JoinPathsError 
Error for MapError			impl Error for MapError 
Error for NulError			impl Error for NulError 
Error for PoisonError			impl<T> Error for PoisonError<T> 
Error for TryLockError			impl<T> Error for TryLockError<T> 
Error for VarError			impl Error for VarError 
ErrorKind			pub enum ErrorKind 
ErroringLaterReader			    struct ErroringLaterReader 
ErroringReader			    struct ErroringReader;
EscapeDefault			pub struct EscapeDefault 
Event			impl Event 
Event			struct Event(libc::HANDLE);
Event			impl Event 
Event			pub struct Event(c::WSAEVENT);
ExactSizeIterator for Args			impl ExactSizeIterator for Args 
ExactSizeIterator for Args			impl ExactSizeIterator for Args 
ExactSizeIterator for Args			impl ExactSizeIterator for Args 
ExactSizeIterator for ArgsOs			impl ExactSizeIterator for ArgsOs 
ExactSizeIterator for Drain			impl<'a, K, V> ExactSizeIterator for Drain<'a, K, V> 
ExactSizeIterator for Drain			impl<'a, K> ExactSizeIterator for Drain<'a, K> 
ExactSizeIterator for Drain			impl<'a, K, V> ExactSizeIterator for Drain<'a, K, V> 
ExactSizeIterator for EscapeDefault			impl ExactSizeIterator for EscapeDefault {}
ExactSizeIterator for IntoIter			impl<K, V> ExactSizeIterator for IntoIter<K, V> 
ExactSizeIterator for IntoIter			impl<K> ExactSizeIterator for IntoIter<K> 
ExactSizeIterator for IntoIter			impl<K, V> ExactSizeIterator for IntoIter<K, V> 
ExactSizeIterator for Iter			impl<'a, K, V> ExactSizeIterator for Iter<'a, K, V> 
ExactSizeIterator for Iter			impl<'a, K> ExactSizeIterator for Iter<'a, K> 
ExactSizeIterator for Iter			impl<'a, K, V> ExactSizeIterator for Iter<'a, K, V> 
ExactSizeIterator for IterMut			impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> 
ExactSizeIterator for IterMut			impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> 
ExactSizeIterator for Keys			impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> 
ExactSizeIterator for Values			impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> 
Exception			struct Exception 
ExitStatus			impl ExitStatus 
ExitStatus			pub struct ExitStatus(ExitStatusImp);
ExitStatus			impl ExitStatus 
ExitStatus			pub enum ExitStatus 
ExitStatus			impl ExitStatus 
ExitStatus			pub struct ExitStatus(i32);
ExitStatusExt			pub trait ExitStatusExt 
ExitStatusExt for process			impl ExitStatusExt for process::ExitStatus 
ExponentFormat			pub enum ExponentFormat 
Extend for HashMap			impl<K, V, S> Extend<(K, V)> for HashMap<K, V, S>
Extend for HashSet			impl<T, S> Extend<T> for HashSet<T, S>
Extend for Wtf8Buf			impl Extend<CodePoint> for Wtf8Buf 
FILE_END_OF_FILE_INFO			pub struct FILE_END_OF_FILE_INFO 
FILE_INFO_BY_HANDLE_CLASS			pub enum FILE_INFO_BY_HANDLE_CLASS 
FLOATING_SAVE_AREA			    pub struct FLOATING_SAVE_AREA 
FailFlushWriter			        struct FailFlushWriter;
FailFlushWriter			        struct FailFlushWriter;
Failure			pub enum Failure<T> 
Failure			pub enum Failure 
Failure			pub enum Failure<T> 
Failure			pub enum Failure 
File			impl File 
File			pub struct File 
File			impl File 
File			pub struct File 
File			impl File 
File			pub struct File(FileDesc);
File			impl File 
File			pub struct File { handle: RawHandle }
FileAccess			pub enum FileAccess 
FileAttr			impl FileAttr 
FileAttr			pub struct FileAttr 
FileAttr			impl FileAttr 
FileAttr			pub struct FileAttr { data: c::WIN32_FILE_ATTRIBUTE_DATA }
FileDesc			impl FileDesc 
FileDesc			pub struct FileDesc 
FileDesc			impl FileDesc 
FileDesc			pub struct FileDesc 
FileDesc			impl FileDesc 
FileDesc			pub struct FileDesc 
FileMode			pub enum FileMode 
FilePermissions			impl FilePermissions 
FilePermissions			pub struct FilePermissions { mode: mode_t }
FilePermissions			impl FilePermissions 
FilePermissions			pub struct FilePermissions { attrs: libc::DWORD }
FileStat			pub struct FileStat 
FileType			pub enum FileType 
FindNextFileHandle			struct FindNextFileHandle(libc::HANDLE);
Flag			pub enum Flag 
Flag			impl Flag 
Flag			pub struct Flag { failed: UnsafeCell<bool> }
Flavor			enum Flavor<T> 
Float			pub trait Float
Float for f32			impl Float for f32 
Float for f64			impl Float for f64 
Foo			        struct Foo;
Foo			    struct Foo(Sender<()>);
FormatMessageW			        fn FormatMessageW(flags: DWORD,
FreeLibrary			        fn FreeLibrary(handle: *mut libc::c_void);
FromError			impl<W> FromError<IntoInnerError<W>> for Error 
FromError			impl<T> FromError<PoisonError<T>> for TryLockError<T> 
FromError for io			impl FromError<NulError> for io::Error 
FromError for old_io			impl FromError<NulError> for old_io::IoError 
FromInner			pub trait FromInner<Inner> 
FromInner for FilePermissions			impl FromInner<i32> for FilePermissions 
FromInner for Ipv4Addr			impl FromInner<libc::in_addr> for Ipv4Addr 
FromInner for Ipv6Addr			impl FromInner<libc::in6_addr> for Ipv6Addr 
FromInner for OsString			impl FromInner<Buf> for OsString 
FromInner for Permissions			impl FromInner<fs_imp::FilePermissions> for Permissions 
FromInner for SocketAddr			impl FromInner<libc::sockaddr_in6> for SocketAddr 
FromInner for SocketAddr			impl FromInner<libc::sockaddr_in> for SocketAddr 
FromIterator for HashMap			impl<K, V, S> FromIterator<(K, V)> for HashMap<K, V, S>
FromIterator for HashSet			impl<T, S> FromIterator<T> for HashSet<T, S>
FromIterator for Wtf8Buf			impl FromIterator<CodePoint> for Wtf8Buf 
FromPrimitive for Value			    impl FromPrimitive for Value 
FromStr for IpAddr			impl FromStr for IpAddr 
FromStr for IpAddr			impl FromStr for IpAddr 
FromStr for Ipv4Addr			impl FromStr for Ipv4Addr 
FromStr for Ipv6Addr			impl FromStr for Ipv6Addr 
FromStr for Path			impl FromStr for Path 
FromStr for Path			impl FromStr for Path 
FromStr for SocketAddr			impl FromStr for SocketAddr 
FromStr for SocketAddr			impl FromStr for SocketAddr 
FullBucket			impl<K, V, M> FullBucket<K, V, M> 
FullBucket			pub struct FullBucket<K, V, M> 
Future			impl<A:Clone> Future<A> 
Future			impl<A:Send+'static> Future<A> 
Future			impl<A> Future<A> 
Future			pub struct Future<A> 
FutureState			enum FutureState<A> 
GET_FILEEX_INFO_LEVELS			pub enum GET_FILEEX_INFO_LEVELS 
GapThenFull			struct GapThenFull<K, V, M> 
GenericPath			pub trait GenericPath: Clone + GenericPathUnsafe 
GenericPath for Path			impl GenericPath for Path 
GenericPath for Path			impl GenericPath for Path 
GenericPathUnsafe			pub trait GenericPathUnsafe 
GenericPathUnsafe for Path			impl GenericPathUnsafe for Path 
GenericPathUnsafe for Path			impl GenericPathUnsafe for Path 
GetCommandLineW			    fn GetCommandLineW() -> LPCWSTR;
GetCommandLineW			    pub fn GetCommandLineW() -> *mut libc::LPCWSTR;
GetConsoleMode			    pub fn GetConsoleMode(hConsoleHandle: libc::HANDLE,
GetConsoleScreenBufferInfo			    pub fn GetConsoleScreenBufferInfo(
GetCurrentProcess			    fn GetCurrentProcess() -> libc::HANDLE;
GetCurrentProcess			    pub fn GetCurrentProcess() -> libc::HANDLE;
GetCurrentProcessId			    pub fn GetCurrentProcessId() -> libc::DWORD;
GetCurrentThread			    fn GetCurrentThread() -> libc::HANDLE;
GetFileAttributesExW			    pub fn GetFileAttributesExW(lpFileName: libc::LPCWSTR,
GetFileAttributesW			    pub fn GetFileAttributesW(lpFileName: libc::LPCWSTR) -> libc::DWORD;
GetFileInformationByHandle			    pub fn GetFileInformationByHandle(hFile: libc::HANDLE,
GetModuleHandleExW			        fn GetModuleHandleExW(dwFlags: libc::DWORD, name: *const u16,
GetModuleHandleW			        fn GetModuleHandleW(lpModuleName: LPCWSTR) -> HMODULE;
GetProcAddress			        fn GetProcAddress(handle: *mut libc::c_void,
GetProcAddress			        fn GetProcAddress(hModule: HMODULE, lpProcName: LPCSTR) -> LPVOID;
GetTempPathW			    pub fn GetTempPathW(nBufferLength: libc::DWORD,
GetUserProfileDirectoryW			    pub fn GetUserProfileDirectoryW(hToken: libc::HANDLE,
Guard			    struct Guard<'a> { s: &'a mut Vec<u8>, len: usize }
Guard			pub struct Guard 
Guard			pub struct Guard<'a> 
Handle			impl<'rx, T: Send> Handle<'rx, T> 
Handle			pub struct Handle<'rx, T:'rx> 
Handle			impl Handle 
Handle			pub struct Handle(HANDLE);
Handler			impl Handler 
Handler			pub struct Handler 
Handler			impl Handler 
Handler			pub struct Handler 
Hash for CodePoint			impl Hash for CodePoint 
Hash for OsStr			impl Hash for OsStr 
Hash for OsString			impl Hash for OsString 
Hash for Wtf8			impl Hash for Wtf8 
Hash for Wtf8Buf			impl Hash for Wtf8Buf 
HashMap			impl<K, V, S> HashMap<K, V, S>
HashMap			impl<K: Hash + Eq, V> HashMap<K, V, RandomState> 
HashMap			pub struct HashMap<K, V, S = RandomState> 
HashSet			impl<T, S> HashSet<T, S>
HashSet			impl<T: Hash + Eq> HashSet<T, RandomState> 
HashSet			pub struct HashSet<T, S = RandomState> 
HashState			pub trait HashState 
HashState for DefaultState			impl<H: Default + hash::Hasher> HashState for DefaultState<H> 
HashState for RandomState			impl HashState for RandomState 
Helper			impl<M: Send> Helper<M> 
Helper			pub struct Helper<M> 
Hint			pub struct Hint 
InAddr			pub enum InAddr 
Incoming			pub struct Incoming<'a> { listener: &'a TcpListener }
IncomingConnections			pub struct IncomingConnections<'a, A: ?Sized +'a> 
Index for HashMap			impl<K, Q: ?Sized, V, S> Index<Q> for HashMap<K, V, S>
IndexMut for HashMap			impl<K, V, S, Q: ?Sized> IndexMut<Q> for HashMap<K, V, S>
Info			pub struct Info 
InitialZeroByteReader			    struct InitialZeroByteReader 
Inner			struct Inner 
Inner			impl Inner 
Inner			struct Inner 
Inner			impl Inner 
Inner			struct Inner 
Inner			pub struct Inner 
Inner			impl Inner 
Inner			struct Inner 
Inner			struct Inner 
InternalBufWriter			impl<W> InternalBufWriter<W> 
InternalBufWriter			struct InternalBufWriter<W>(BufWriter<W>);
InternalBufferedWriter			impl<W> InternalBufferedWriter<W> 
InternalBufferedWriter			struct InternalBufferedWriter<W>(BufferedWriter<W>);
Intersection			pub struct Intersection<'a, T: 'a, S: 'a> 
IntoBytes			impl<'a> IntoBytes for &'a [u8] 
IntoBytes			impl<'a> IntoBytes for &'a str 
IntoBytes			pub trait IntoBytes 
IntoBytes for String			impl IntoBytes for String 
IntoBytes for Vec			impl IntoBytes for Vec<u8> 
IntoInner			impl<'a> IntoInner<(*const libc::sockaddr, socklen_t)> for &'a SocketAddr 
IntoInner			pub trait IntoInner<Inner> 
IntoInner for OsString			impl IntoInner<Buf> for OsString 
IntoInnerError			impl<W> IntoInnerError<W> 
IntoInnerError			pub struct IntoInnerError<W>(W, Error);
IntoIter			pub struct IntoIter<K, V> 
IntoIter			pub struct IntoIter<K> 
IntoIter			pub struct IntoIter<K, V> 
IntoIterator			impl<'a, K, V, S> IntoIterator for &'a HashMap<K, V, S>
IntoIterator			impl<'a, K, V, S> IntoIterator for &'a mut HashMap<K, V, S>
IntoIterator			impl<'a, T, S> IntoIterator for &'a HashSet<T, S>
IntoIterator for HashMap			impl<K, V, S> IntoIterator for HashMap<K, V, S>
IntoIterator for HashSet			impl<T, S> IntoIterator for HashSet<T, S>
Invoke			pub trait Invoke<A=(),R=()> 
Invoke for F			impl<A,R,F> Invoke<A,R> for F
IoError			impl IoError 
IoError			pub struct IoError 
IoErrorKind			pub enum IoErrorKind 
IpAddr			impl IpAddr 
IpAddr			pub enum IpAddr 
IpAddr			pub enum IpAddr 
Ipv4Addr			impl Ipv4Addr 
Ipv4Addr			pub struct Ipv4Addr 
Ipv6Addr			impl Ipv6Addr 
Ipv6Addr			pub struct Ipv6Addr 
Ipv6MulticastScope			pub enum Ipv6MulticastScope 
Iter			pub struct Iter<'a, K: 'a, V: 'a> 
Iter			pub struct Iter<'a, K: 'a> 
Iter			pub struct Iter<'a, K: 'a, V: 'a> 
Iter			impl<'a> Iter<'a> 
Iter			pub struct Iter<'a> 
Iter			pub struct Iter<'a, T:'a> 
IterMut			pub struct IterMut<'a, K: 'a, V: 'a> 
IterMut			pub struct IterMut<'a, K: 'a, V: 'a> 
IterReader			pub struct IterReader<T> 
Iterator for Args			impl Iterator for Args 
Iterator for Args			impl Iterator for Args 
Iterator for Args			impl Iterator for Args 
Iterator for ArgsOs			impl Iterator for ArgsOs 
Iterator for Bytes			impl<R: Read> Iterator for Bytes<R> 
Iterator for Bytes			impl<'r, R: Reader> Iterator for Bytes<'r, R> 
Iterator for Chars			impl<R: Read> Iterator for Chars<R> 
Iterator for Chars			impl<'r, T: Buffer> Iterator for Chars<'r, T> 
Iterator for Components			impl<'a> Iterator for Components<'a> 
Iterator for Difference			impl<'a, T, S> Iterator for Difference<'a, T, S>
Iterator for Directories			impl Iterator for Directories 
Iterator for Drain			impl<'a, K, V> Iterator for Drain<'a, K, V> 
Iterator for Drain			impl<'a, K> Iterator for Drain<'a, K> 
Iterator for Drain			impl<'a, K, V> Iterator for Drain<'a, K, V> 
Iterator for EncodeWide			impl<'a> Iterator for EncodeWide<'a> 
Iterator for Env			impl Iterator for Env 
Iterator for Env			impl Iterator for Env 
Iterator for EscapeDefault			impl Iterator for EscapeDefault 
Iterator for Incoming			impl<'a> Iterator for Incoming<'a> 
Iterator for Intersection			impl<'a, T, S> Iterator for Intersection<'a, T, S>
Iterator for IntoIter			impl<K, V> Iterator for IntoIter<K, V> 
Iterator for IntoIter			impl<K> Iterator for IntoIter<K> 
Iterator for IntoIter			impl<K, V> Iterator for IntoIter<K, V> 
Iterator for Iter			impl<'a, K, V> Iterator for Iter<'a, K, V> 
Iterator for Iter			impl<'a, K> Iterator for Iter<'a, K> 
Iterator for Iter			impl<'a, K, V> Iterator for Iter<'a, K, V> 
Iterator for Iter			impl<'a> Iterator for Iter<'a> 
Iterator for Iter			impl<'a, T: Send> Iterator for Iter<'a, T> 
Iterator for IterMut			impl<'a, K, V> Iterator for IterMut<'a, K, V> 
Iterator for IterMut			impl<'a, K, V> Iterator for IterMut<'a, K, V> 
Iterator for Keys			impl<'a, K, V> Iterator for Keys<'a, K, V> 
Iterator for Lines			impl<B: BufRead> Iterator for Lines<B> 
Iterator for Lines			impl<'r, T: Buffer> Iterator for Lines<'r, T> 
Iterator for LookupHost			impl Iterator for LookupHost 
Iterator for LookupHost			impl Iterator for LookupHost 
Iterator for Packets			impl Iterator for Packets 
Iterator for RawBuckets			impl<'a, K, V> Iterator for RawBuckets<'a, K, V> 
Iterator for ReadDir			impl Iterator for ReadDir 
Iterator for ReadDir			impl Iterator for ReadDir 
Iterator for ReadDir			impl Iterator for ReadDir 
Iterator for RevMoveBuckets			impl<'a, K, V> Iterator for RevMoveBuckets<'a, K, V> 
Iterator for Split			impl<B: BufRead> Iterator for Split<B> 
Iterator for SplitPaths			impl<'a> Iterator for SplitPaths<'a> 
Iterator for SplitPaths			impl<'a> Iterator for SplitPaths<'a> 
Iterator for SplitPaths			impl<'a> Iterator for SplitPaths<'a> 
Iterator for SymmetricDifference			impl<'a, T, S> Iterator for SymmetricDifference<'a, T, S>
Iterator for Union			impl<'a, T, S> Iterator for Union<'a, T, S>
Iterator for Values			impl<'a, K, V> Iterator for Values<'a, K, V> 
Iterator for Vars			impl Iterator for Vars 
Iterator for VarsOs			impl Iterator for VarsOs 
Iterator for WalkDir			impl Iterator for WalkDir 
Iterator for Wtf8CodePoints			impl<'a> Iterator for Wtf8CodePoints<'a> 
JoinGuard			impl<'a, T: Send + 'a> JoinGuard<'a, T> 
JoinGuard			impl<T: Send> JoinGuard<'static, T> 
JoinGuard			pub struct JoinGuard<'a, T: 'a> 
JoinHandle			impl JoinHandle 
JoinHandle			pub struct JoinHandle(JoinInner<()>);
JoinInner			impl<T> JoinInner<T> 
JoinInner			struct JoinInner<T> 
JoinPathsError			pub struct JoinPathsError 
JoinPathsError			pub struct JoinPathsError;
JoinPathsError			pub struct JoinPathsError;
Juju			        struct Juju;
KDHELP64			struct KDHELP64 
Key			impl Key 
Key			pub struct Key 
Key			    impl<T> Key<T> 
Key			    pub struct Key<T> 
Key			impl<T: 'static> Key<T> 
Key			pub struct Key<T> 
Key			impl<T> Key<T> 
Key			pub struct Key<T> { #[doc(hidden)] pub inner: __impl::KeyInner<T> }
KeyInner			    impl<T> KeyInner<T> 
KeyInner			    pub struct KeyInner<T> { pub inner: UnsafeCell<*mut T> }
KeyInner			    pub struct KeyInner<T> 
Keys			pub struct Keys<'a, K: 'a, V: 'a> 
LimitReader			impl<R: Reader> LimitReader<R> 
LimitReader			pub struct LimitReader<R> 
LineBufferedWriter			impl<W: Writer> LineBufferedWriter<W> 
LineBufferedWriter			pub struct LineBufferedWriter<W> 
LineWriter			impl<W: Write> LineWriter<W> 
LineWriter			pub struct LineWriter<W> 
Lines			pub struct Lines<B> 
Lines			pub struct Lines<'r, T:'r> 
Listener			pub trait Listener<T, A: Acceptor<T>>
Listener for TcpListener			impl Listener<TcpStream, TcpAcceptor> for TcpListener 
Listener for UnixListener			impl Listener<UnixStream, UnixAcceptor> for UnixListener 
LoadLibraryW			        fn LoadLibraryW(name: *const libc::c_void) -> *mut libc::c_void;
LocalFree			    fn LocalFree(ptr: *mut c_void);
LocalFree			    pub fn LocalFree(ptr: *mut libc::c_void);
LookupHost			pub struct LookupHost(net_imp::LookupHost);
LookupHost			pub struct LookupHost 
M128A			    pub struct M128A 
MapError			pub enum MapError 
MapOption			pub enum MapOption 
MemReader			impl MemReader 
MemReader			pub struct MemReader 
MemWriter			impl MemWriter 
MemWriter			pub struct MemWriter 
MemoryMap			impl MemoryMap 
MemoryMap			pub struct MemoryMap 
MemoryMapKind			pub enum MemoryMapKind 
Message			enum Message<T> 
Metadata			impl Metadata 
Metadata			pub struct Metadata(fs_imp::FileAttr);
Mul for Duration			impl Mul<i32> for Duration 
MultiWriter			impl<W> MultiWriter<W> where W: Writer 
MultiWriter			pub struct MultiWriter<W> 
Mutex			impl<T: Send> Mutex<T> 
Mutex			pub struct Mutex<T> 
Mutex			impl Mutex 
Mutex			pub struct Mutex(imp::Mutex);
Mutex			impl Mutex 
Mutex			pub struct Mutex { inner: UnsafeCell<ffi::pthread_mutex_t> }
Mutex			impl Mutex 
Mutex			pub struct Mutex { inner: UnsafeCell<ffi::SRWLOCK> }
MutexGuard			impl<'mutex, T> MutexGuard<'mutex, T> 
MutexGuard			pub struct MutexGuard<'a, T: 'a> 
MyUpgrade			enum MyUpgrade<T> 
Neg for Duration			impl Neg for Duration 
NewThread			pub trait NewThread 
Node			impl<T> Node<T> 
Node			struct Node<T> 
Node			impl<T: Send> Node<T> 
Node			struct Node<T> 
Node			struct Node 
NulError			impl NulError 
NulError			pub struct NulError(usize, Vec<u8>);
NullReader			pub struct NullReader;
NullStream			    pub struct NullStream;
NullWriter			pub struct NullWriter;
OccupiedEntry			impl<'a, K, V> OccupiedEntry<'a, K, V> 
OccupiedEntry			pub struct OccupiedEntry<'a, K: 'a, V: 'a> 
Once			impl Once 
Once			pub struct Once 
OpenOptions			impl OpenOptions 
OpenOptions			pub struct OpenOptions(fs_imp::OpenOptions);
OpenOptions			impl OpenOptions 
OpenOptions			pub struct OpenOptions 
OpenOptions			impl OpenOptions 
OpenOptions			pub struct OpenOptions 
OpenOptionsExt			pub trait OpenOptionsExt 
OpenOptionsExt			pub trait OpenOptionsExt 
OpenOptionsExt for OpenOptions			impl OpenOptionsExt for OpenOptions 
OpenOptionsExt for OpenOptions			impl OpenOptionsExt for OpenOptions 
OpenProcessToken			    pub fn OpenProcessToken(ProcessHandle: libc::HANDLE,
Ord for CStr			impl Ord for CStr 
Ord for Ipv4Addr			impl Ord for Ipv4Addr 
Ord for Ipv6Addr			impl Ord for Ipv6Addr 
Ord for OsStr			impl Ord for OsStr 
Ord for OsString			impl Ord for OsString 
Ord for Path			impl Ord for Path 
Ord for Path			impl Ord for Path 
Ord for Wtf8			impl Ord for Wtf8 
OsRng			    impl OsRng 
OsRng			    pub struct OsRng 
OsRngInner			    enum OsRngInner 
OsStr			impl OsStr 
OsStr			pub struct OsStr 
OsStrExt			pub trait OsStrExt 
OsStrExt			pub trait OsStrExt 
OsStrExt for OsStr			impl OsStrExt for OsStr 
OsStrExt for OsStr			impl OsStrExt for OsStr 
OsString			impl OsString 
OsString			pub struct OsString 
OsStringExt			pub trait OsStringExt 
OsStringExt			pub trait OsStringExt 
OsStringExt for OsString			impl OsStringExt for OsString 
OsStringExt for OsString			impl OsStringExt for OsString 
Output			pub struct Output 
OwnedAsciiExt			pub trait OwnedAsciiExt 
OwnedAsciiExt for String			impl OwnedAsciiExt for String 
OwnedAsciiExt for Vec			impl OwnedAsciiExt for Vec<u8> 
Packet			impl<T: Send> Packet<T> 
Packet			pub struct Packet<T> 
Packet			pub trait Packet 
Packet			impl<T: Send> Packet<T> 
Packet			pub struct Packet<T> 
Packet			impl<T: Send> Packet<T> 
Packet			pub struct Packet<T> 
Packet			impl<T: Send> Packet<T> 
Packet			pub struct Packet<T> 
Packet			    struct Packet<T>(Arc<(Mutex<T>, Condvar)>);
Packet			struct Packet<T>(Arc<UnsafeCell<Option<Result<T>>>>);
Packets			struct Packets { cur: *mut Handle<'static, ()> }
ParseError			pub struct ParseError;
ParseError			pub struct ParseError;
ParsePathError			pub struct ParsePathError;
ParsePathError			pub struct ParsePathError;
Parser			impl<'a> Parser<'a> 
Parser			struct Parser<'a> 
Parser			impl<'a> Parser<'a> 
Parser			struct Parser<'a> 
PartialEq for CStr			impl PartialEq for CStr 
PartialEq for EnvKey			impl PartialEq for EnvKey 
PartialEq for HashMap			impl<K, V, S> PartialEq for HashMap<K, V, S>
PartialEq for HashSet			impl<T, S> PartialEq for HashSet<T, S>
PartialEq for Ipv4Addr			impl PartialEq for Ipv4Addr 
PartialEq for Ipv6Addr			impl PartialEq for Ipv6Addr 
PartialEq for OsStr			impl PartialEq for OsStr 
PartialEq for OsStr			impl PartialEq<str> for OsStr 
PartialEq for OsString			impl PartialEq for OsString 
PartialEq for OsString			impl PartialEq<str> for OsString 
PartialEq for Path			impl PartialEq for Path 
PartialEq for Path			impl PartialEq for Path 
PartialEq for Repr			impl PartialEq for Repr 
PartialEq for Wtf8			impl PartialEq for Wtf8 
PartialEq for str			impl PartialEq<OsStr> for str 
PartialEq for str			impl PartialEq<OsString> for str 
PartialOrd for CStr			impl PartialOrd for CStr 
PartialOrd for Ipv4Addr			impl PartialOrd for Ipv4Addr 
PartialOrd for Ipv6Addr			impl PartialOrd for Ipv6Addr 
PartialOrd for OsStr			impl PartialOrd for OsStr 
PartialOrd for OsStr			impl PartialOrd<str> for OsStr 
PartialOrd for OsString			impl PartialOrd for OsString 
PartialOrd for OsString			impl PartialOrd<str> for OsString 
PartialOrd for Path			impl PartialOrd for Path 
PartialOrd for Path			impl PartialOrd for Path 
PartialOrd for Wtf8			impl PartialOrd for Wtf8 
PartialReader			    struct PartialReader 
Path			impl Path 
Path			pub struct Path 
Path			impl Path 
Path			pub struct Path 
Path			impl Path 
Path			pub struct Path 
PathBuf			impl PathBuf 
PathBuf			pub struct PathBuf 
PathExt			pub trait PathExt 
PathExt for Path			impl PathExt for Path 
PathExtensions			pub trait PathExtensions 
PathExtensions for old_path			impl PathExtensions for old_path::Path 
PathPrefix			pub enum PathPrefix 
Permissions			impl Permissions 
Permissions			pub struct Permissions(fs_imp::FilePermissions);
PermissionsExt			pub trait PermissionsExt 
PermissionsExt for Permissions			impl PermissionsExt for Permissions 
Pipe			pub struct Pipe 
PipePair			pub struct PipePair 
PipeStream			impl PipeStream 
PipeStream			pub struct PipeStream 
PoisonError			impl<T> PoisonError<T> 
PoisonError			pub struct PoisonError<T> 
PopResult			pub enum PopResult<T> 
Prefix			impl<'a> Prefix<'a> 
Prefix			pub enum Prefix<'a> 
Process			impl Process 
Process			pub struct Process 
Process			impl Process 
Process			pub struct Process 
Process			impl Process 
Process			pub struct Process 
Process			impl Process 
Process			pub struct Process 
Process			impl Process 
Process			pub struct Process 
ProcessConfig			pub trait ProcessConfig<K: BytesContainer, V: BytesContainer> 
ProcessExit			impl ProcessExit 
ProcessExit			pub enum ProcessExit 
ProcessOutput			pub struct ProcessOutput 
Protocol			pub enum Protocol 
Queue			impl<T: Send> Queue<T> 
Queue			pub struct Queue<T> 
Queue			impl<T: Send> Queue<T> 
Queue			pub struct Queue<T> 
Queue			impl Queue 
Queue			struct Queue 
R			        struct R;
RWLock			impl RWLock 
RWLock			pub struct RWLock(imp::RWLock);
RWLock			impl RWLock 
RWLock			pub struct RWLock { inner: UnsafeCell<ffi::pthread_rwlock_t> }
RWLock			impl RWLock 
RWLock			pub struct RWLock { inner: UnsafeCell<ffi::SRWLOCK> }
RaceBox			struct RaceBox(BufferedReader<StdReader>);
RaceBox			struct RaceBox(helper_signal::signal);
RandomState			impl RandomState 
RandomState			pub struct RandomState 
RawBucket			impl<K, V> RawBucket<K, V> 
RawBucket			struct RawBucket<K, V> 
RawBuckets			struct RawBuckets<'a, K, V> 
RawTable			impl<K, V> RawTable<K, V> 
RawTable			pub struct RawTable<K, V> 
Read			impl<'a> Read for &'a File 
Read			impl<'a, R: Read + ?Sized> Read for &'a mut R 
Read			impl<'a> Read for &'a [u8] 
Read			pub trait Read 
Read			impl<'a> Read for &'a TcpStream 
Read for Box			impl<R: Read + ?Sized> Read for Box<R> 
Read for BufReader			impl<R: Read> Read for BufReader<R> 
Read for BufStream			impl<S: Read + Write> Read for BufStream<S> 
Read for Chain			impl<T: Read, U: Read> Read for Chain<T, U> 
Read for ChildStderr			impl Read for ChildStderr 
Read for ChildStdout			impl Read for ChildStdout 
Read for Cursor			impl Read for Cursor<Vec<u8>> { read!(); }
Read for Cursor			impl<'a> Read for Cursor<&'a [u8]> { read!(); }
Read for Cursor			impl<'a> Read for Cursor<&'a mut [u8]> { read!(); }
Read for Empty			impl Read for Empty 
Read for File			impl Read for File 
Read for InternalBufWriter			impl<W: Read> Read for InternalBufWriter<W> 
Read for R			        impl Read for R 
Read for Repeat			impl Read for Repeat 
Read for S			        impl Read for S 
Read for ShortReader			    impl Read for ShortReader 
Read for Take			impl<T: Read> Read for Take<T> 
Read for TcpStream			impl Read for TcpStream 
Read for Tee			impl<R: Read, W: Write> Read for Tee<R, W> 
ReadConsoleW			    pub fn ReadConsoleW(hConsoleInput: libc::HANDLE,
ReadDir			pub struct ReadDir(fs_imp::ReadDir);
ReadDir			pub struct ReadDir 
ReadDir			pub struct ReadDir 
ReadExt			pub trait ReadExt: Read + Sized 
ReadExt for T			impl<T: Read> ReadExt for T {}
Reader			impl<'a> Reader for &'a [u8] 
Reader			impl<'a> Reader for &'a mut (Reader+'a) 
Reader			pub trait Reader 
Reader for BadReader			    impl<T: Reader> Reader for BadReader<T> 
Reader for Box			impl<'a> Reader for Box<Reader+'a> 
Reader for BufReader			impl<'a> Reader for BufReader<'a> 
Reader for BufferedReader			impl<R: Reader> Reader for BufferedReader<R> 
Reader for BufferedStream			impl<S: Stream> Reader for BufferedStream<S> 
Reader for ChanReader			impl Reader for ChanReader 
Reader for EofReader			    impl Reader for EofReader 
Reader for ErroringLaterReader			    impl Reader for ErroringLaterReader 
Reader for ErroringReader			    impl Reader for ErroringReader 
Reader for File			impl Reader for File 
Reader for InitialZeroByteReader			    impl Reader for InitialZeroByteReader 
Reader for InternalBufferedWriter			impl<W: Reader> Reader for InternalBufferedWriter<W> 
Reader for IoResult			impl<R: Reader> Reader for IoResult<R> 
Reader for LimitReader			impl<R: Reader> Reader for LimitReader<R> 
Reader for MemReader			impl Reader for MemReader 
Reader for NullReader			impl Reader for NullReader 
Reader for NullStream			    impl Reader for NullStream 
Reader for PartialReader			    impl Reader for PartialReader 
Reader for PipeStream			impl Reader for PipeStream 
Reader for RefReader			impl<'a, R: Reader> Reader for RefReader<'a, R> 
Reader for ShortReader			    impl Reader for ShortReader 
Reader for StdReader			impl Reader for StdReader 
Reader for StdinReader			impl Reader for StdinReader 
Reader for TcpStream			impl Reader for TcpStream 
Reader for TeeReader			impl<R: Reader, W: Writer> Reader for TeeReader<R, W> 
Reader for ThreeChunkReader			    impl Reader for ThreeChunkReader 
Reader for UnixStream			impl Reader for UnixStream 
Reader for ZeroReader			impl Reader for ZeroReader 
ReaderRng			impl<R: Reader> ReaderRng<R> 
ReaderRng			pub struct ReaderRng<R> 
Receiver			impl<T: Send> Receiver<T> 
Receiver			pub struct Receiver<T> 
RecvError			pub struct RecvError;
RefReader			pub struct RefReader<'a, R:'a> 
RefWriter			pub struct RefWriter<'a, W:'a> 
ReleaseSRWLockExclusive			    pub fn ReleaseSRWLockExclusive(SRWLock: PSRWLOCK);
ReleaseSRWLockShared			    pub fn ReleaseSRWLockShared(SRWLock: PSRWLOCK);
RemoveDirectoryW			    pub fn RemoveDirectoryW(lpPathName: libc::LPCWSTR) -> libc::BOOL;
Repeat			pub struct Repeat { byte: u8 }
Repr			enum Repr 
Repr			enum Repr 
Req			enum Req 
Req			pub enum Req 
Req			pub enum Req 
Reset			        struct Reset<'a, T: 'a> 
RevMoveBuckets			struct RevMoveBuckets<'a, K, V> 
Rng for ConstRng			    impl Rng for ConstRng 
Rng for OsRng			    impl Rng for OsRng 
Rng for ReaderRng			impl<R: Reader> Rng for ReaderRng<R> 
Rng for StdRng			impl Rng for StdRng 
Rng for ThreadRng			impl Rng for ThreadRng 
RtlCaptureContext			    fn RtlCaptureContext(ctx: *mut arch::CONTEXT);
RwLock			impl<T: Send + Sync> RwLock<T> 
RwLock			pub struct RwLock<T> 
RwLockReadGuard			impl<'rwlock, T> RwLockReadGuard<'rwlock, T> 
RwLockReadGuard			pub struct RwLockReadGuard<'a, T: 'a> 
RwLockWriteGuard			impl<'rwlock, T> RwLockWriteGuard<'rwlock, T> 
RwLockWriteGuard			pub struct RwLockWriteGuard<'a, T: 'a> 
S			        struct S;
S			        struct S;
S1			        struct S1(Sender<()>);
S1			        struct S1;
S2			        struct S2;
SMALL_RECT			pub struct SMALL_RECT 
SRWLOCK			pub struct SRWLOCK { pub ptr: LPVOID }
STACKFRAME64			struct STACKFRAME64 
SYMBOL_INFO			struct SYMBOL_INFO 
SafeHash			impl SafeHash 
SafeHash			pub struct SafeHash 
SearchResult			enum SearchResult<K, V, M> 
SearchResult			impl<K, V, M> SearchResult<K, V, M> 
SecRandom			    struct SecRandom;
SecRandomCopyBytes			        fn SecRandomCopyBytes(rnd: *const SecRandom,
SeedableRng for StdRng			impl<'a> SeedableRng<&'a [usize]> for StdRng 
Seek			impl<'a> Seek for &'a File 
Seek			impl<'a, S: Seek + ?Sized> Seek for &'a mut S 
Seek			pub trait Seek 
Seek			pub trait Seek 
Seek for Box			impl<S: Seek + ?Sized> Seek for Box<S> 
Seek for BufReader			impl<'a> Seek for BufReader<'a> 
Seek for BufWriter			impl<'a> Seek for BufWriter<'a> 
Seek for File			impl Seek for File 
Seek for File			impl Seek for File 
Seek for IoResult			impl<S: Seek> Seek for IoResult<S> 
Seek for MemReader			impl Seek for MemReader 
SeekFrom			pub enum SeekFrom 
SeekStyle			pub enum SeekStyle 
Select			impl Select 
Select			pub struct Select 
SelectionResult			pub enum SelectionResult<T> 
SelectionResult			pub enum SelectionResult<T> 
Semaphore			impl Semaphore 
Semaphore			pub struct Semaphore 
SemaphoreGuard			pub struct SemaphoreGuard<'a> 
SendError			pub struct SendError<T>(pub T);
Sender			impl<T: Send> Sender<T> 
Sender			pub struct Sender<T> 
Sentinel			impl<'a> Sentinel<'a> 
Sentinel			struct Sentinel<'a> 
SetConsoleMode			    pub fn SetConsoleMode(hConsoleHandle: libc::HANDLE,
SetErrorMode			        fn SetErrorMode(uMode: libc::c_uint) -> libc::c_uint;
SetEvent			    pub fn SetEvent(hEvent: libc::HANDLE) -> libc::BOOL;
SetEvent			    fn SetEvent(hEvent: HANDLE) -> BOOL;
SetFileAttributesW			    pub fn SetFileAttributesW(lpFileName: libc::LPCWSTR,
SetFileInformationByHandle			    pub fn SetFileInformationByHandle(hFile: libc::HANDLE,
SetFileTime			    pub fn SetFileTime(hFile: libc::HANDLE,
SetLastError			        fn SetLastError(error: libc::size_t);
SetLastError			    pub fn SetLastError(dwErrCode: libc::DWORD);
SetThreadStackGuarantee			    fn SetThreadStackGuarantee(StackSizeInBytes: *mut ULONG) -> BOOL;
SetWaitableTimer			        pub fn SetWaitableTimer(hTimer: HANDLE,
ShortReader			    pub struct ShortReader 
ShortReader			    pub struct ShortReader 
Shutdown			pub enum Shutdown 
SignFormat			pub enum SignFormat 
SignalToken			impl SignalToken 
SignalToken			pub struct SignalToken 
SignificantDigits			pub enum SignificantDigits 
Sink			pub struct Sink { _priv: () }
SleepConditionVariableSRW			    pub fn SleepConditionVariableSRW(ConditionVariable: PCONDITION_VARIABLE,
Slice			impl Slice 
Slice			pub struct Slice 
Slice			impl Slice 
Slice			pub struct Slice 
Socket			impl Socket 
Socket			pub struct Socket(FileDesc);
Socket			impl Socket 
Socket			pub struct Socket(libc::SOCKET);
SocketAddr			impl SocketAddr 
SocketAddr			pub struct SocketAddr 
SocketAddr			pub struct SocketAddr 
SocketStatus			pub enum SocketStatus 
SocketType			pub enum SocketType 
Split			pub struct Split<B> 
SplitPaths			pub struct SplitPaths<'a> { inner: os_imp::SplitPaths<'a> }
SplitPaths			pub struct SplitPaths<'a> 
SplitPaths			pub struct SplitPaths<'a> 
StartResult			pub enum StartResult 
State			enum State 
State			struct State<T> 
State			pub enum State 
StaticCondvar			impl StaticCondvar 
StaticCondvar			pub struct StaticCondvar 
StaticKey			impl StaticKey 
StaticKey			pub struct StaticKey 
StaticKeyInner			pub struct StaticKeyInner 
StaticMutex			impl StaticMutex 
StaticMutex			pub struct StaticMutex 
StaticRwLock			impl StaticRwLock 
StaticRwLock			pub struct StaticRwLock 
StdError for CharsError			impl StdError for CharsError 
StdError for Error			impl StdError for Error 
StdError for IntoInnerError			impl<W> StdError for IntoInnerError<W> 
StdError for JoinPathsError			impl StdError for JoinPathsError 
StdError for JoinPathsError			impl StdError for JoinPathsError 
StdReader			impl StdReader 
StdReader			pub struct StdReader 
StdRng			impl StdRng 
StdRng			pub struct StdRng 
StdSource			enum StdSource 
StdWriter			impl StdWriter 
StdWriter			pub struct StdWriter 
StdinReader			impl StdinReader 
StdinReader			pub struct StdinReader 
StdinReaderGuard			pub struct StdinReaderGuard<'a> 
Stdio			impl Stdio 
Stdio			pub struct Stdio(StdioImp);
Stdio			impl Stdio 
Stdio			pub struct Stdio(libc::c_int);
StdioContainer			pub enum StdioContainer 
StdioImp			enum StdioImp 
SteadyTime			    impl SteadyTime 
SteadyTime			    pub struct SteadyTime 
SteadyTime			impl SteadyTime 
SteadyTime			pub struct SteadyTime 
Stream			pub trait Stream: Reader + Writer { }
Stream for T			impl<T: Reader + Writer> Stream for T {}
Sub			impl<'a, 'b, T, S> Sub<&'b HashSet<T, S>> for &'a HashSet<T, S>
Sub			    impl<'a> Sub for &'a SteadyTime 
Sub			impl<'a> Sub for &'a SteadyTime 
Sub for Duration			impl Sub for Duration 
SwitchToThread			    fn SwitchToThread() -> BOOL;
SymmetricDifference			pub struct SymmetricDifference<'a, T: 'a, S: 'a> 
SyncSender			impl<T: Send> SyncSender<T> 
SyncSender			pub struct SyncSender<T> 
TTY			impl TTY 
TTY			pub struct TTY 
TTY			impl TTY 
TTY			pub struct TTY 
Take			impl<T> Take<T> 
Take			pub struct Take<T> 
TaskPool			impl TaskPool 
TaskPool			pub struct TaskPool 
TcpAcceptor			impl TcpAcceptor 
TcpAcceptor			pub struct TcpAcceptor 
TcpAcceptor			impl TcpAcceptor 
TcpAcceptor			pub struct TcpAcceptor 
TcpAcceptor			impl TcpAcceptor 
TcpAcceptor			pub struct TcpAcceptor 
TcpListener			impl TcpListener 
TcpListener			pub struct TcpListener(net_imp::TcpListener);
TcpListener			impl TcpListener 
TcpListener			pub struct TcpListener 
TcpListener			impl TcpListener 
TcpListener			pub struct TcpListener 
TcpListener			impl TcpListener 
TcpListener			pub struct TcpListener 
TcpListener			impl TcpListener 
TcpListener			pub struct TcpListener { sock: sock_t }
TcpStream			impl TcpStream 
TcpStream			pub struct TcpStream(net_imp::TcpStream);
TcpStream			impl TcpStream 
TcpStream			pub struct TcpStream 
TcpStream			impl TcpStream 
TcpStream			pub struct TcpStream 
TcpStream			impl TcpStream 
TcpStream			pub struct TcpStream 
Tee			pub struct Tee<R, W> 
TeeReader			impl<R: Reader, W: Writer> TeeReader<R, W> 
TeeReader			pub struct TeeReader<R, W> 
TempDir			    impl TempDir 
TempDir			    pub struct TempDir(PathBuf);
TempDir			impl TempDir 
TempDir			pub struct TempDir 
TempDir			    impl TempDir 
TempDir			    pub struct TempDir(Path);
TempDir			impl TempDir 
TempDir			pub struct TempDir 
TestWriter			        struct TestWriter;
Thread			impl Thread 
Thread			pub struct Thread 
ThreadInfo			impl ThreadInfo 
ThreadInfo			struct ThreadInfo 
ThreadRng			pub struct ThreadRng 
ThreadRngReseeder			struct ThreadRngReseeder;
ThreeChunkReader			    struct ThreeChunkReader 
Thunk			impl<'a, R> Thunk<'a,(),R> 
Thunk			impl<'a,A,R> Thunk<'a,A,R> 
Thunk			pub struct Thunk<'a, A=(),R=()> 
Timer			impl Timer 
Timer			pub struct Timer 
Timer			impl Timer 
Timer			pub struct Timer 
Timer			impl Timer 
Timer			pub struct Timer 
TimerCallback			struct TimerCallback { tx: Sender<()> }
TlsAlloc			    fn TlsAlloc() -> DWORD;
TlsFree			    fn TlsFree(dwTlsIndex: DWORD) -> BOOL;
TlsGetValue			    fn TlsGetValue(dwTlsIndex: DWORD) -> LPVOID;
TlsSetValue			    fn TlsSetValue(dwTlsIndex: DWORD, lpTlsvalue: LPVOID) -> BOOL;
ToOwned for OsStr			impl ToOwned for OsStr 
ToOwned for Path			impl ToOwned for Path 
ToPrimitive for Value			    impl ToPrimitive for Value 
ToSocketAddr			impl ToSocketAddr for (IpAddr, u16) 
ToSocketAddr			impl<'a> ToSocketAddr for &'a str 
ToSocketAddr			impl<'a> ToSocketAddr for (&'a str, u16) 
ToSocketAddr			pub trait ToSocketAddr 
ToSocketAddr for SocketAddr			impl ToSocketAddr for SocketAddr 
ToSocketAddrs			impl ToSocketAddrs for (IpAddr, u16) 
ToSocketAddrs			impl<'a, T: ToSocketAddrs + ?Sized> ToSocketAddrs for &'a T 
ToSocketAddrs			impl<'a> ToSocketAddrs for (&'a str, u16) 
ToSocketAddrs			pub trait ToSocketAddrs 
ToSocketAddrs for SocketAddr			impl ToSocketAddrs for SocketAddr 
ToSocketAddrs for str			impl ToSocketAddrs for str 
TryAcquireSRWLockExclusive			    pub fn TryAcquireSRWLockExclusive(SRWLock: PSRWLOCK) -> BOOLEAN;
TryAcquireSRWLockShared			    pub fn TryAcquireSRWLockShared(SRWLock: PSRWLOCK) -> BOOLEAN;
TryLockError			pub enum TryLockError<T> 
TryRecvError			pub enum TryRecvError 
TrySendError			pub enum TrySendError<T> 
UdpSocket			impl UdpSocket 
UdpSocket			pub struct UdpSocket(net_imp::UdpSocket);
UdpSocket			impl UdpSocket 
UdpSocket			pub struct UdpSocket 
UdpSocket			impl UdpSocket 
UdpSocket			pub struct UdpSocket 
UdpSocket			impl UdpSocket 
UdpSocket			pub struct UdpSocket 
Union			pub struct Union<'a, T: 'a, S: 'a> 
UnixAcceptor			impl UnixAcceptor 
UnixAcceptor			pub struct UnixAcceptor 
UnixAcceptor			impl UnixAcceptor 
UnixAcceptor			pub struct UnixAcceptor 
UnixAcceptor			impl UnixAcceptor 
UnixAcceptor			pub struct UnixAcceptor 
UnixListener			impl UnixListener 
UnixListener			pub struct UnixListener 
UnixListener			impl UnixListener 
UnixListener			pub struct UnixListener 
UnixListener			impl UnixListener 
UnixListener			pub struct UnixListener 
UnixStream			impl UnixStream 
UnixStream			pub struct UnixStream 
UnixStream			impl UnixStream 
UnixStream			pub struct UnixStream 
UnixStream			impl UnixStream 
UnixStream			pub struct UnixStream 
UnsafeFlavor			trait UnsafeFlavor<T> 
UnsafeFlavor for Receiver			impl<T> UnsafeFlavor<T> for Receiver<T> 
UnsafeFlavor for Sender			impl<T> UnsafeFlavor<T> for Sender<T> 
UnstableFileStat			pub struct UnstableFileStat 
Unwinder			            struct Unwinder 
Unwinder			            struct Unwinder 
UpdateIoError			trait UpdateIoError 
UpdateIoError for IoResult			impl<T> UpdateIoError for IoResult<T> 
UpgradeResult			pub enum UpgradeResult 
UpgradeResult			pub enum UpgradeResult 
VacantEntry			impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> 
VacantEntry			pub struct VacantEntry<'a, K: 'a, V: 'a> 
VacantEntryState			enum VacantEntryState<K, V, M> 
Value			    struct Value { x: isize }
Value			    struct Value<T: 'static> 
Values			pub struct Values<'a, K: 'a, V: 'a> 
VarError			pub enum VarError 
Vars			pub struct Vars { inner: VarsOs }
VarsOs			pub struct VarsOs { inner: os_imp::Env }
WEXITSTATUS			        pub fn WEXITSTATUS(status: i32) -> i32 { (status >> 8) & 0xff }
WEXITSTATUS			        pub fn WEXITSTATUS(status: i32) -> i32 { status >> 8 }
WEXITSTATUS			        pub fn WEXITSTATUS(status: i32) -> i32 { (status >> 8) & 0xff }
WEXITSTATUS			        pub fn WEXITSTATUS(status: i32) -> i32 { status >> 8 }
WIFEXITED			        pub fn WIFEXITED(status: i32) -> bool { (status & 0x7f) == 0 }
WIFEXITED			        pub fn WIFEXITED(status: i32) -> bool { (status & 0xff) == 0 }
WIFEXITED			        pub fn WIFEXITED(status: i32) -> bool { (status & 0x7f) == 0 }
WIFEXITED			        pub fn WIFEXITED(status: i32) -> bool { (status & 0xff) == 0 }
WIN32_FILE_ATTRIBUTE_DATA			pub struct WIN32_FILE_ATTRIBUTE_DATA 
WSACleanup			    pub fn WSACleanup() -> libc::c_int;
WSACloseEvent			    pub fn WSACloseEvent(hEvent: WSAEVENT) -> libc::BOOL;
WSACreateEvent			    pub fn WSACreateEvent() -> WSAEVENT;
WSADATA			pub struct WSADATA 
WSADuplicateSocketW			    pub fn WSADuplicateSocketW(s: libc::SOCKET,
WSAEnumNetworkEvents			    pub fn WSAEnumNetworkEvents(s: libc::SOCKET,
WSAEventSelect			    pub fn WSAEventSelect(s: libc::SOCKET,
WSAGetLastError			    pub fn WSAGetLastError() -> libc::c_int;
WSANETWORKEVENTS			pub struct WSANETWORKEVENTS 
WSAPROTOCOL_INFO			pub struct WSAPROTOCOL_INFO 
WSASetEvent			    pub fn WSASetEvent(hEvent: WSAEVENT) -> libc::BOOL;
WSASocketW			    pub fn WSASocketW(af: libc::c_int,
WSAStartup			    pub fn WSAStartup(wVersionRequested: libc::WORD,
WSAWaitForMultipleEvents			    pub fn WSAWaitForMultipleEvents(cEvents: libc::DWORD,
WTERMSIG			        pub fn WTERMSIG(status: i32) -> i32 { status & 0o177 }
WTERMSIG			        pub fn WTERMSIG(status: i32) -> i32 { status & 0x7f }
WTERMSIG			        pub fn WTERMSIG(status: i32) -> i32 { status & 0o177 }
WTERMSIG			        pub fn WTERMSIG(status: i32) -> i32 { status & 0x7f }
WaitForMultipleObjects			    pub fn WaitForMultipleObjects(nCount: libc::DWORD,
WaitForMultipleObjects			        pub fn WaitForMultipleObjects(nCount: DWORD,
WaitForSingleObject			    fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;
WaitForSingleObject			        pub fn WaitForSingleObject(hHandle: HANDLE,
WaitToken			impl WaitToken 
WaitToken			pub struct WaitToken 
WakeAllConditionVariable			    pub fn WakeAllConditionVariable(ConditionVariable: PCONDITION_VARIABLE);
WakeConditionVariable			    pub fn WakeConditionVariable(ConditionVariable: PCONDITION_VARIABLE);
WalkDir			pub struct WalkDir 
Write			impl<'a> Write for &'a File 
Write			impl<'a, W: Write + ?Sized> Write for &'a mut W 
Write			impl<'a> Write for &'a mut [u8] 
Write			pub trait Write 
Write			impl<'a> Write for &'a TcpStream 
Write for Box			impl<W: Write + ?Sized> Write for Box<W> 
Write for Broadcast			impl<T: Write, U: Write> Write for Broadcast<T, U> 
Write for BufStream			impl<S: Read + Write> Write for BufStream<S> 
Write for BufWriter			impl<W: Write> Write for BufWriter<W> 
Write for ChildStdin			impl Write for ChildStdin 
Write for Cursor			impl Write for Cursor<Vec<u8>> 
Write for Cursor			impl<'a> Write for Cursor<&'a mut [u8]> 
Write for FailFlushWriter			        impl Write for FailFlushWriter 
Write for File			impl Write for File 
Write for LineWriter			impl<W: Write> Write for LineWriter<W> 
Write for S			        impl Write for S 
Write for Sink			impl Write for Sink 
Write for TcpStream			impl Write for TcpStream 
Write for Vec			impl Write for Vec<u8> 
WriteConsoleW			    pub fn WriteConsoleW(hConsoleOutput: libc::HANDLE,
WriteExt			pub trait WriteExt: Write + Sized 
WriteExt for T			impl<T: Write> WriteExt for T {}
Writer			impl<'a> Writer for &'a mut (Writer+'a) 
Writer			pub trait Writer 
Writer for Box			impl<'a> Writer for Box<Writer+'a> 
Writer for BufWriter			impl<'a> Writer for BufWriter<'a> 
Writer for BufferedStream			impl<S: Stream> Writer for BufferedStream<S> 
Writer for BufferedWriter			impl<W: Writer> Writer for BufferedWriter<W> 
Writer for ChanWriter			impl Writer for ChanWriter 
Writer for FailFlushWriter			        impl Writer for FailFlushWriter 
Writer for File			impl Writer for File 
Writer for IoResult			impl<W: Writer> Writer for IoResult<W> 
Writer for LineBufferedWriter			impl<W: Writer> Writer for LineBufferedWriter<W> 
Writer for MemWriter			impl Writer for MemWriter 
Writer for MultiWriter			impl<W> Writer for MultiWriter<W> where W: Writer 
Writer for NullStream			    impl Writer for NullStream 
Writer for NullWriter			impl Writer for NullWriter 
Writer for PipeStream			impl Writer for PipeStream 
Writer for RefWriter			impl<'a, W: Writer> Writer for RefWriter<'a, W> 
Writer for StdWriter			impl Writer for StdWriter 
Writer for Stdio			impl Writer for Stdio 
Writer for TcpStream			impl Writer for TcpStream 
Writer for TestWriter			        impl Writer for TestWriter 
Writer for UnixStream			impl Writer for UnixStream 
Writer for Vec			impl Writer for Vec<u8> 
Wtf8			impl Wtf8 
Wtf8			pub struct Wtf8 
Wtf8Buf			impl Wtf8Buf 
Wtf8Buf			pub struct Wtf8Buf 
Wtf8CodePoints			pub struct Wtf8CodePoints<'a> 
ZeroReader			pub struct ZeroReader;
_GCC_specific_handler			        fn _GCC_specific_handler(
_NSGetArgc			    fn _NSGetArgc() -> *mut c_int;
_NSGetArgc			        fn _NSGetArgc() -> *mut c_int;
_NSGetArgv			    fn _NSGetArgv() -> *mut *mut *mut c_char;
_NSGetArgv			        fn _NSGetArgv() -> *mut *mut *mut c_char;
_Unwind_Action			pub enum _Unwind_Action 
_Unwind_Backtrace			        pub fn _Unwind_Backtrace(trace: _Unwind_Trace_Fn,
_Unwind_Context			pub enum _Unwind_Context {}
_Unwind_Context			    pub enum _Unwind_Context {}
_Unwind_DeleteException			    pub fn _Unwind_DeleteException(exception: *mut _Unwind_Exception);
_Unwind_Exception			pub struct _Unwind_Exception 
_Unwind_FindEnclosingFunction			        pub fn _Unwind_FindEnclosingFunction(pc: *mut libc::c_void)
_Unwind_FindEnclosingFunction			    pub unsafe fn _Unwind_FindEnclosingFunction(pc: *mut libc::c_void)
_Unwind_GetIP			        pub fn _Unwind_GetIP(ctx: *mut _Unwind_Context) -> libc::uintptr_t;
_Unwind_GetIP			    pub unsafe fn _Unwind_GetIP(ctx: *mut _Unwind_Context) -> libc::uintptr_t 
_Unwind_RaiseException			    pub fn _Unwind_RaiseException(exception: *mut _Unwind_Exception)
_Unwind_RaiseException			pub unsafe fn _Unwind_RaiseException(exc: *mut _Unwind_Exception)
_Unwind_Reason_Code			pub enum _Unwind_Reason_Code 
_Unwind_Reason_Code			    pub enum _Unwind_Reason_Code 
_Unwind_SjLj_RaiseException			    fn _Unwind_SjLj_RaiseException(e: *mut _Unwind_Exception)
_Unwind_State			pub enum _Unwind_State 
_Unwind_VRS_DataRepresentation			        enum _Unwind_VRS_DataRepresentation 
_Unwind_VRS_Get			            fn _Unwind_VRS_Get(ctx: *mut _Unwind_Context,
_Unwind_VRS_RegClass			        enum _Unwind_VRS_RegClass 
_Unwind_VRS_Result			        enum _Unwind_VRS_Result 
__errno			            fn __errno() -> *const c_int;
__gcc_personality_seh0			        fn __gcc_personality_seh0(
__gcc_personality_sj0			        fn __gcc_personality_sj0(version: c_int,
__gcc_personality_v0			        fn __gcc_personality_v0(state: uw::_Unwind_State,
__gcc_personality_v0			        fn __gcc_personality_v0(version: c_int,
__getit			            fn __getit() -> &'static __KeyInner<__UnsafeCell<__Option<
__impl			pub mod __impl 
__impl			pub mod __impl 
__init			            fn __init() -> 
_ensure_buffer_is_object_safe			    fn _ensure_buffer_is_object_safe<T: Buffer>(x: &T) -> &Buffer 
_homedir			    fn _homedir() -> Option<Path> 
_setenv			    fn _setenv(n: &str, v: &[u8]) 
_tlv_atexit			            fn _tlv_atexit(dtor: unsafe extern fn(*mut u8),
abort			pub fn abort(args: fmt::Arguments) -> ! 
abort_selection			    fn abort_selection(&self) -> bool 
abort_selection			    pub fn abort_selection(&mut self) -> Result<bool, Receiver<T>> 
abort_selection			    fn abort_selection(&self) -> bool;
abort_selection			    pub fn abort_selection(&mut self, _was_upgrade: bool) -> bool 
abort_selection			    pub fn abort_selection(&mut self,
abort_selection			    pub fn abort_selection(&self) -> bool 
abs			    fn abs(self) -> f32 { num::Float::abs(self) }
abs			    fn abs(self) -> f64 { num::Float::abs(self) }
abs			    fn abs(self) -> Self;
abs_sub			    fn abs_sub(self, other: f32) -> f32 
abs_sub			    fn abs_sub(self, other: f64) -> f64 
abs_sub			    fn abs_sub(self, other: Self) -> Self;
accept			    pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> 
accept			    fn accept(&mut self) -> IoResult<T>;
accept			    fn accept(&mut self) -> IoResult<UnixStream> 
accept			    fn accept(&mut self) -> IoResult<TcpStream> 
accept			    fn accept(&mut self) -> IoResult<T> 
accept			    pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> 
accept			    pub fn accept(&self, storage: *mut libc::sockaddr,
accept			    pub fn accept(&mut self) -> IoResult<UnixStream> 
accept			    pub fn accept(&mut self) -> IoResult<TcpStream> 
accept			    pub fn accept(&self, storage: *mut libc::sockaddr,
accept			    pub fn accept(&mut self) -> IoResult<UnixStream> 
accept			    pub fn accept(&mut self) -> IoResult<TcpStream> 
accept_lots			    fn accept_lots() 
accept_timeout			    fn accept_timeout() 
accept_timeout			    fn accept_timeout() 
access			    pub fn access(&self) -> SemaphoreGuard 
access_string			fn access_string(access: FileAccess) -> &'static str 
accessed			    pub fn accessed(&self) -> u64 { self.0.accessed() }
accessed			    pub fn accessed(&self) -> u64 
accessed			    pub fn accessed(&self) -> u64 { self.to_ms(&self.data.ftLastAccessTime) }
acos			    fn acos(self) -> f32 
acos			        pub fn acos(n: c_double) -> c_double;
acos			    fn acos(self) -> f64 
acos			    fn acos(self) -> Self;
acosf			        pub fn acosf(n: c_float) -> c_float;
acosh			    fn acosh(self) -> f32 
acosh			    fn acosh(self) -> f64 
acosh			    fn acosh(self) -> Self;
acquire			    pub fn acquire(&self) 
acquire_send_slot			    fn acquire_send_slot(&self) -> MutexGuard<State<T>> 
add			    pub unsafe fn add(&mut self) 
add			    fn add(self, rhs: Duration) -> Duration 
addr			mod addr;
addr_to_sockaddr			pub fn addr_to_sockaddr(addr: SocketAddr,
addr_to_sockaddr_un			fn addr_to_sockaddr_un(addr: &CString,
addrinfo			pub mod addrinfo;
addrinfo			pub mod addrinfo 
addrinfo			pub mod addrinfo 
alloc			    unsafe fn alloc(&self) -> *mut Node<T> 
anon_pipe			pub unsafe fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> 
anon_pipe			pub unsafe fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> 
append			    pub fn append(&mut self, append: bool) -> &mut OpenOptions 
append			    pub fn append(&mut self, append: bool) 
append			    pub fn append(&mut self, append: bool) { self.append = append; }
append_arg			    fn append_arg(cmd: &mut String, arg: &str) 
append_arg			    fn append_arg(cmd: &mut Vec<u16>, arg: &OsStr) 
append_char_at			    fn append_char_at(cmd: &mut String, arg: &[char], i: uint) 
append_path			        fn append_path(me: &mut Path, path: &str) 
append_to_string			fn append_to_string<F>(buf: &mut String, f: F) -> Result<()>
arch			mod arch 
arch_consts			mod arch_consts 
arch_consts			mod arch_consts 
arg			    pub fn arg<'a, T: BytesContainer>(&'a mut self, arg: T) -> &'a mut Command 
arg			    pub fn arg<S: AsOsStr + ?Sized>(&mut self, arg: &S) -> &mut Command 
arg			    pub fn arg(&mut self, arg: &OsStr) 
arg			    pub fn arg(&mut self, arg: &OsStr) 
args			pub fn args() -> Args 
args			    fn args(&self) -> &[CString] 
args			    pub fn args<'a, T: BytesContainer>(&'a mut self, args: &[T]) -> &'a mut Command 
args			pub fn args() -> Vec<String> 
args			    pub fn args<S: AsOsStr>(&mut self, args: &[S]) -> &mut Command 
args			pub mod args;
args			    fn args(&self) -> &[CString];
args			pub fn args() -> Args 
args			    pub fn args<'a, I: Iterator<Item = &'a OsStr>>(&mut self, args: I) 
args			pub fn args() -> Args 
args			    pub fn args<'a, I: Iterator<Item = &'a OsStr>>(&mut self, args: I) 
args_as_bytes			pub fn args_as_bytes() -> Vec<Vec<u8>> 
args_os			pub fn args_os() -> ArgsOs 
as_bytes			    pub fn as_bytes(&self) -> &[u8] 
as_bytes			    fn as_bytes(&self) -> &[u8] 
as_bytes			    fn as_bytes(&self) -> &[u8];
as_bytes_with_nul			    pub fn as_bytes_with_nul(&self) -> &[u8] 
as_cow			    pub fn as_cow(&self) -> CowString<'a> 
as_inner			    fn as_inner(&self) -> &Slice 
as_inner			    fn as_inner(&self) -> &fs_imp::File { &self.inner }
as_inner			    fn as_inner(&self) -> &fs_imp::FilePermissions { &self.0 }
as_inner			    fn as_inner(&self) -> &libc::in6_addr { &self.inner }
as_inner			    fn as_inner(&self) -> &libc::in_addr { &self.inner }
as_inner			    fn as_inner(&self) -> &net_imp::TcpListener { &self.0 }
as_inner			    fn as_inner(&self) -> &net_imp::TcpStream { &self.0 }
as_inner			    fn as_inner(&self) -> &net_imp::UdpSocket { &self.0 }
as_inner			    fn as_inner(&self) -> &fs_imp::FileDesc 
as_inner			    fn as_inner(&self) -> &UnixAcceptorImp 
as_inner			    fn as_inner(&self) -> &UnixListenerImp 
as_inner			    fn as_inner(&self) -> &UnixStreamImp 
as_inner			    fn as_inner(&self) -> &TcpAcceptorImp 
as_inner			    fn as_inner(&self) -> &TcpListenerImp 
as_inner			    fn as_inner(&self) -> &TcpStreamImp 
as_inner			    fn as_inner(&self) -> &UdpSocketImp 
as_inner			    fn as_inner(&self) -> &sys::fs::FileDesc 
as_inner			    fn as_inner(&self) -> &CommandImp { &self.inner }
as_inner			    fn as_inner(&self) -> &ExitStatusImp { &self.0 }
as_inner			    fn as_inner(&self) -> &Inner;
as_inner			    fn as_inner(&self) -> &[u8] { &self.bytes }
as_inner			    fn as_inner(&self) -> &c_int { &self.fd }
as_inner			    fn as_inner(&self) -> &c_int { self.0.as_inner() }
as_inner			    fn as_inner(&self) -> &libc::SOCKET { &self.0 }
as_inner_mut			    fn as_inner_mut(&mut self) -> &mut fs_imp::OpenOptions { &mut self.0 }
as_inner_mut			    fn as_inner_mut(&mut self) -> &mut CommandImp { &mut self.inner }
as_inner_mut			    fn as_inner_mut(&mut self) -> &mut Inner;
as_mut_vec			    fn as_mut_vec(&mut self) -> &mut Vec<u8> 
as_os_str			    fn as_os_str(&self) -> &OsStr;
as_os_str			    fn as_os_str(&self) -> &OsStr 
as_os_str			    fn as_os_str(&self) -> &OsStr 
as_os_str			    pub fn as_os_str(self) -> &'a OsStr 
as_path			    fn as_path(&self) -> &Path { Path::new(self.as_os_str()) }
as_path			    fn as_path(&self) -> &Path;
as_path			    pub fn as_path(&self) -> &'a Path 
as_ptr			    pub fn as_ptr(&self) -> *const libc::c_char 
as_raw_fd			    fn as_raw_fd(&self) -> Fd { *self.as_inner().socket().as_inner() }
as_raw_fd			    fn as_raw_fd(&self) -> Fd 
as_raw_fd			    fn as_raw_fd(&self) -> Fd;
as_raw_handle			    fn as_raw_handle(&self) -> Handle 
as_raw_handle			    fn as_raw_handle(&self) -> Handle;
as_raw_socket			    fn as_raw_socket(&self) -> Socket { *self.as_inner().socket().as_inner() }
as_raw_socket			    fn as_raw_socket(&self) -> Socket 
as_raw_socket			    fn as_raw_socket(&self) -> Socket;
as_slice			    pub fn as_slice(&self) -> &Wtf8 
as_slice			    pub fn as_slice(&self) -> &Slice 
as_slice			    pub fn as_slice(&self) -> &Slice 
as_str			    fn as_str<'a>(&'a self) -> Option<&'a str> 
as_str			    fn as_str<'a>(&'a self) -> Option<&'a str> 
as_str			    pub fn as_str(&self) -> Option<&str> 
as_u8_slice			    fn as_u8_slice(&self) -> &[u8] 
as_vec			    fn as_vec<'a>(&'a self) -> &'a [u8];
as_vec			    fn as_vec<'a>(&'a self) -> &'a [u8] 
as_vec			    fn as_vec<'a>(&'a self) -> &'a [u8] 
ascii			pub mod ascii;
ascii_byte_at			    pub fn ascii_byte_at(&self, position: uint) -> u8 
asin			    fn asin(self) -> f32 
asin			        pub fn asin(n: c_double) -> c_double;
asin			    fn asin(self) -> f64 
asin			    fn asin(self) -> Self;
asinf			        pub fn asinf(n: c_float) -> c_float;
asinh			    fn asinh(self) -> f32 
asinh			    fn asinh(self) -> f64 
asinh			    fn asinh(self) -> Self;
assert_send			    fn assert_send<T: Send>() {}
assert_sync			    fn assert_sync<T: Sync>() {}
at_exit			pub fn at_exit<F:FnOnce()+Send+'static>(f: F) 
at_exit_imp			mod at_exit_imp;
at_index			    pub fn at_index(table: M, ib_index: usize) -> Bucket<K, V, M> 
atan			    fn atan(self) -> f32 
atan			        pub fn atan(n: c_double) -> c_double;
atan			    fn atan(self) -> f64 
atan			    fn atan(self) -> Self;
atan2			    fn atan2(self, other: f32) -> f32 
atan2			        pub fn atan2(a: c_double, b: c_double) -> c_double;
atan2			    fn atan2(self, other: f64) -> f64 
atan2			    fn atan2(self, other: Self) -> Self;
atan2f			        pub fn atan2f(a: c_float, b: c_float) -> c_float;
atanf			        pub fn atanf(n: c_float) -> c_float;
atanh			    fn atanh(self) -> f32 
atanh			    fn atanh(self) -> f64 
atanh			    fn atanh(self) -> Self;
atime			    fn atime(stat: &libc::stat) -> u64 
aux_homedir			    fn aux_homedir(home_name: &str) -> Option<Path> 
avoid_copying_the_body			    fn avoid_copying_the_body<F>(spawnfn: F) where F: FnOnce(Thunk<'static>) 
await			    fn await(_fd: sock_t, set: &mut c::fd_set, timeout: u64) -> libc::c_int 
await			    fn await(fd: sock_t, set: &mut c::fd_set, timeout: u64) -> libc::c_int 
await			pub fn await(fds: &[sock_t], deadline: Option<u64>,
await			pub fn await(handle: libc::HANDLE, deadline: u64,
backslash_run_ends_in_quote			    fn backslash_run_ends_in_quote(s: &[char], mut i: uint) -> bool 
backtrace			pub mod backtrace;
backtrace			pub mod backtrace;
backtrace			        fn backtrace(buf: *mut *mut libc::c_void,
backtrace			pub mod backtrace;
backtrace			pub mod backtrace;
backtrace_create_state			        fn backtrace_create_state(filename: *const libc::c_char,
backtrace_state			    enum backtrace_state {}
backtrace_syminfo			        fn backtrace_syminfo(state: *mut backtrace_state,
barrier			mod barrier;
base_port			fn base_port() -> u16 
base_port			fn base_port() -> u16 
begin_unwind			pub fn begin_unwind<M: Any + Send>(msg: M, file_line: &(&'static str, uint)) -> ! 
begin_unwind_fmt			pub fn begin_unwind_fmt(msg: fmt::Arguments, file_line: &(&'static str, uint)) -> ! 
begin_unwind_inner			fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) -> ! 
bench			mod bench;
bench			mod bench 
bench			mod bench 
bench			mod bench 
bench			mod bench 
bench			mod bench 
bench_buf_reader			    fn bench_buf_reader(b: &mut Bencher) 
bench_buf_writer			    fn bench_buf_writer(b: &mut Bencher) 
bench_buffered_reader			    fn bench_buffered_reader(b: &mut test::Bencher) 
bench_buffered_reader			    fn bench_buffered_reader(b: &mut Bencher) 
bench_buffered_stream			    fn bench_buffered_stream(b: &mut test::Bencher) 
bench_buffered_stream			    fn bench_buffered_stream(b: &mut Bencher) 
bench_buffered_writer			    fn bench_buffered_writer(b: &mut test::Bencher) 
bench_buffered_writer			    fn bench_buffered_writer(b: &mut Bencher) 
bench_mem_reader			    fn bench_mem_reader(b: &mut Bencher) 
bench_mem_writer_001_0000			    fn bench_mem_writer_001_0000(b: &mut Bencher) 
bench_mem_writer_001_0010			    fn bench_mem_writer_001_0010(b: &mut Bencher) 
bench_mem_writer_001_0100			    fn bench_mem_writer_001_0100(b: &mut Bencher) 
bench_mem_writer_001_1000			    fn bench_mem_writer_001_1000(b: &mut Bencher) 
bench_mem_writer_100_0000			    fn bench_mem_writer_100_0000(b: &mut Bencher) 
bench_mem_writer_100_0010			    fn bench_mem_writer_100_0010(b: &mut Bencher) 
bench_mem_writer_100_0100			    fn bench_mem_writer_100_0100(b: &mut Bencher) 
bench_mem_writer_100_1000			    fn bench_mem_writer_100_1000(b: &mut Bencher) 
bench_pow_function			    fn bench_pow_function(b: &mut Bencher) 
binary_file			    fn binary_file() 
binary_file			    fn binary_file() 
bind			    pub fn bind<A: ToSocketAddrs + ?Sized>(addr: &A) -> io::Result<TcpListener> 
bind			    pub fn bind<A: ToSocketAddrs + ?Sized>(addr: &A) -> io::Result<UdpSocket> 
bind			    pub fn bind<P: BytesContainer>(path: P) -> IoResult<UnixListener> 
bind			    pub fn bind<A: ToSocketAddr>(addr: A) -> IoResult<TcpListener> 
bind			    pub fn bind<A: ToSocketAddr>(addr: A) -> IoResult<UdpSocket> 
bind			    pub fn bind(addr: SocketAddr) -> IoResult<UdpSocket> 
bind			    pub fn bind(addr: &SocketAddr) -> io::Result<TcpListener> 
bind			    pub fn bind(addr: &SocketAddr) -> io::Result<UdpSocket> 
bind			    pub fn bind(addr: &CString) -> IoResult<UnixListener> 
bind			fn bind(addr: &CString, ty: libc::c_int) -> IoResult<Inner> 
bind			    pub fn bind(addr: ip::SocketAddr) -> IoResult<TcpListener> 
bind			    pub fn bind(addr: &CString) -> IoResult<UnixListener> 
bind			    pub fn bind(addr: ip::SocketAddr) -> IoResult<TcpListener> 
bind_error			    fn bind_error() 
bind_error			    fn bind_error() 
bind_error			    fn bind_error() 
bind_error			    fn bind_error() 
bind_error			    fn bind_error() 
bitand			    fn bitand(self, rhs: &HashSet<T, S>) -> HashSet<T, S> 
bitor			    fn bitor(self, rhs: &HashSet<T, S>) -> HashSet<T, S> 
bitxor			    fn bitxor(self, rhs: &HashSet<T, S>) -> HashSet<T, S> 
black_box			    unsafe fn black_box<T>(mut dummy: T) -> T 
blocking			mod blocking;
bool			mod bool;
boot			    pub fn boot<T, F>(&'static self, f: F, helper: fn(helper_signal::signal, Receiver<M>, T)) where
borrow			    fn borrow(&self) -> &OsStr { &self[..] }
borrow			    fn borrow(&self) -> &Path 
borrow			    pub fn borrow(&self) -> LockResult<Guard> 
borrowed			    fn borrowed() 
both_ready			    fn both_ready() 
broadcast			    fn broadcast<W: Write>(self, other: W) -> Broadcast<Self, W> 
broadcast			    fn broadcast() 
buffered			mod buffered;
buffered			mod buffered;
build_with_zero1			    fn build_with_zero1() 
build_with_zero2			    fn build_with_zero2() 
build_with_zero3			    fn build_with_zero3() 
builtin			pub mod builtin 
bump			    fn bump(&mut self, amt: int) -> int 
bump			    fn bump(&mut self, amt: isize) -> isize 
by_ref			    fn by_ref(&mut self) -> &mut Self { self }
by_ref			    fn by_ref<'a>(&'a mut self) -> RefReader<'a, Self>;
by_ref			    fn by_ref<'a>(&'a mut self) -> RefReader<'a, T> 
by_ref			    fn by_ref<'a>(&'a mut self) -> RefWriter<'a, Self>;
by_ref			    fn by_ref<'a>(&'a mut self) -> RefWriter<'a, T> 
byteify			fn byteify(s: OsString) -> Vec<u8> 
bytes			    fn bytes(&self) -> &[u8] 
bytes			    fn bytes(self) -> Bytes<Self> 
bytes			    fn bytes<'r>(&'r mut self) -> extensions::Bytes<'r, Self>;
bytes			    fn bytes<'r>(&'r mut self) -> extensions::Bytes<'r, T> 
bytes2path			fn bytes2path(b: &[u8]) -> PathBuf 
bytes_0_bytes			    fn bytes_0_bytes() 
bytes_eof			    fn bytes_eof() 
bytes_error			    fn bytes_error() 
c			        fn c<T: Clone>(t: &T) -> T { t.clone() }
c			            fn c(value: &u32) -> CodePoint { CodePoint::from_u32(*value).unwrap() }
c			        fn c(value: u32) -> CodePoint { CodePoint::from_u32(value).unwrap() }
c			pub mod c;
c			pub mod c;
c_str			mod c_str;
c_str_to_bytes			pub unsafe fn c_str_to_bytes<'a>(raw: &'a *const libc::c_char) -> &'a [u8] 
c_str_to_bytes_with_nul			pub unsafe fn c_str_to_bytes_with_nul<'a>(raw: &'a *const libc::c_char)
c_to_rust			    fn c_to_rust() 
calculate_allocation			fn calculate_allocation(hash_size: usize, hash_align: usize,
calculate_offsets			fn calculate_offsets(hashes_size: usize,
call			    fn call(&mut self) 
call			    fn call(&mut self);
call			    fn call(&mut self);
call_once			    pub fn call_once<F>(&'static self, f: F) where F: FnOnce() 
can_alias_safehash_as_u64			fn can_alias_safehash_as_u64() 
can_recv			    fn can_recv(&self) -> bool 
can_recv			    pub fn can_recv(&mut self) -> Result<bool, Receiver<T>> 
can_recv			    fn can_recv(&self) -> bool;
can_recv			    pub fn can_recv(&mut self) -> bool 
can_recv			    pub fn can_recv(&mut self) -> Result<bool, Receiver<T>> 
can_recv			    pub fn can_recv(&self) -> bool 
cancel			    fn cancel(mut self) 
cancel_io			    fn cancel_io(&self) -> IoResult<()> 
cap			    fn cap(&self) -> usize { self.buf.len() }
capacity			    pub fn capacity(&self) -> usize 
capacity			    pub fn capacity(&self) -> usize 
capacity			    pub fn capacity(&self) -> usize 
capacity			    pub fn capacity(&self) -> uint 
capture			    pub fn capture() -> Stdio { Stdio(StdioImp::Capture) }
capture_stderr			    fn capture_stderr() 
capture_stdout			    fn capture_stdout() 
cast_from_usize			    pub unsafe fn cast_from_usize(signal_ptr: usize) -> SignalToken 
cast_to_usize			    pub unsafe fn cast_to_usize(self) -> usize 
cause			    fn cause(&self) -> Option<&StdError> 
cause			    fn cause(&self) -> Option<&Error> 
cbrt			    fn cbrt(self) -> f32 
cbrt			        pub fn cbrt(n: c_double) -> c_double;
cbrt			    fn cbrt(self) -> f64 
cbrt			    fn cbrt(self) -> Self;
cbrtf			        pub fn cbrtf(n: c_float) -> c_float;
ceil			    fn ceil(self) -> f32 { num::Float::ceil(self) }
ceil			    fn ceil(self) -> f64 { num::Float::ceil(self) }
ceil			    fn ceil(self) -> Self;
cell_allowed			    fn cell_allowed() 
chain			    fn chain<R: Read>(self, next: R) -> Chain<Self, R> 
chan_gone_concurrent			    fn chan_gone_concurrent() 
change_dir			pub fn change_dir(p: &Path) -> IoResult<()> 
change_file_times			pub fn change_file_times(path: &Path, atime: u64, mtime: u64) -> IoResult<()> 
channel			pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) 
chars			    fn chars(self) -> Chars<Self> 
chars			    fn chars<'r>(&'r mut self) -> Chars<'r, Self>;
chars			    fn chars<'r>(&'r mut self) -> Chars<'r, T> 
chdir			pub fn chdir(p: &path::Path) -> io::Result<()> 
chdir			pub fn chdir(p: &path::Path) -> io::Result<()> 
check			        fn check(m: &HashMap<isize, ()>) 
check			        fn check(octets: &[u8; 4], unspec: bool, loopback: bool,
check			        fn check(str_addr: &str, unspec: bool, loopback: bool,
check_for_errors_in			    pub fn check_for_errors_in<T, F>(f: F) -> Result<T, String> where
check_parse			        fn check_parse(unparsed: &str, parsed: &[&str]) -> bool 
check_parse			        fn check_parse(unparsed: &str, parsed: &[&str]) -> bool 
check_word_size			        fn check_word_size() 
checked_add			    pub fn checked_add(&self, rhs: &Duration) -> Option<Duration> 
checked_sub			    pub fn checked_sub(&self, rhs: &Duration) -> Option<Duration> 
child_no			        fn child_no(x: uint) -> Thunk<'static> 
chmod			pub fn chmod(path: &Path, mode: old_io::FilePermission) -> IoResult<()> 
chmod			pub fn chmod(p: &Path, mode: uint) -> IoResult<()> 
chmod			pub fn chmod(p: &Path, mode: uint) -> IoResult<()> 
chmod_works			    fn chmod_works() 
chmod_works			    fn chmod_works() 
chown			pub fn chown(path: &Path, uid: int, gid: int) -> IoResult<()> 
chown			pub fn chown(p: &Path, uid: int, gid: int) -> IoResult<()> 
chown			pub fn chown(p: &Path, uid: isize, gid: isize) -> io::Result<()> 
chown			pub fn chown(_p: &Path, _uid: int, _gid: int) -> IoResult<()> 
circular			    fn circular() 
classify			    fn classify(self) -> FpCategory { num::Float::classify(self) }
classify			    fn classify(self) -> FpCategory { num::Float::classify(self) }
classify			    fn classify(self) -> FpCategory;
cleanup			    pub fn cleanup() 
cleanup			    pub unsafe fn cleanup() 
cleanup			pub unsafe fn cleanup() { imp::cleanup() }
cleanup			pub fn cleanup() 
cleanup			pub unsafe fn cleanup() 
cleanup			    pub unsafe fn cleanup() 
cleanup			pub unsafe fn cleanup() 
cleanup_dir			    fn cleanup_dir(&mut self) -> io::Result<()> 
cleanup_dir			    fn cleanup_dir(&mut self) -> IoResult<()> 
clear			    pub fn clear(&mut self) 
clear			    pub fn clear(&mut self) { self.map.clear() }
clock_gettime			        fn clock_gettime(clk_id: libc::c_int, tp: *mut libc::timespec) -> libc::c_int;
clone			        fn clone(&self) -> Dropable 
clone			    fn clone(&self) -> Iter<'a, K, V> 
clone			    fn clone(&self) -> Keys<'a, K, V> 
clone			    fn clone(&self) -> Values<'a, K, V> 
clone			    fn clone(&self) -> DefaultState<H> { DefaultState(marker::PhantomData) }
clone			    fn clone(&self) -> Iter<'a, K, V> 
clone			    fn clone(&self) -> RawBuckets<'a, K, V> 
clone			    fn clone(&self) -> RawTable<K, V> 
clone			    fn clone(&self) -> Repr { *self }
clone			    fn clone(&self) -> Ipv4Addr { *self }
clone			    fn clone(&self) -> Ipv6Addr { *self }
clone			    fn clone(&self) -> ChanWriter 
clone			    fn clone(&self) -> UnixAcceptor 
clone			    fn clone(&self) -> UnixStream 
clone			    fn clone(&self) -> TcpAcceptor 
clone			    fn clone(&self) -> TcpStream 
clone			    fn clone(&self) -> UdpSocket 
clone			    fn clone(&self) -> PipeStream 
clone			    pub fn clone() -> Option<Vec<Vec<u8>>> 
clone			pub fn clone() -> Option<Vec<Vec<u8>>> { imp::clone() }
clone			    fn clone(&self) -> Sender<T> 
clone			    fn clone(&self) -> SyncSender<T> 
clone			    fn clone(&self) -> TcpStream 
clone			    fn clone(&self) -> UdpSocket 
clone			    fn clone(&self) -> UnixAcceptor 
clone			    fn clone(&self) -> UnixStream 
clone			    fn clone(&self) -> TcpAcceptor 
clone			    fn clone(&self) -> UnixAcceptor 
clone			    fn clone(&self) -> UnixStream 
clone			    fn clone(&self) -> TcpAcceptor 
clone_accept_concurrent			    fn clone_accept_concurrent() 
clone_accept_concurrent			    fn clone_accept_concurrent() 
clone_accept_concurrent			    fn clone_accept_concurrent() 
clone_accept_smoke			    fn clone_accept_smoke() 
clone_accept_smoke			    fn clone_accept_smoke() 
clone_accept_smoke			    fn clone_accept_smoke() 
clone_chan			    pub fn clone_chan(&mut self) 
clone_chan			    pub fn clone_chan(&self) 
clone_while_reading			    fn clone_while_reading() 
clone_while_reading			    fn clone_while_reading() 
cloning			    fn cloning() 
cloning2			    fn cloning2() 
cloning3			    fn cloning3() 
close			    pub unsafe fn close(handle: *mut u8) 
close			    pub fn close(mut self) -> io::Result<()> 
close			    pub fn close(mut self) -> IoResult<()> 
close			pub fn close(fd: libc::c_int) 
close			pub fn close(handle: HANDLE) 
close_accept			    pub fn close_accept(&mut self) -> IoResult<()> 
close_accept			    pub fn close_accept(&mut self) -> IoResult<()> 
close_accept			    pub fn close_accept(&mut self) -> IoResult<()> 
close_accept			    pub fn close_accept(&mut self) -> IoResult<()> 
close_accept			    pub fn close_accept(&mut self) -> IoResult<()> 
close_accept			    pub fn close_accept(&mut self) -> IoResult<()> 
close_accept_concurrent			    fn close_accept_concurrent() 
close_accept_concurrent			    fn close_accept_concurrent() 
close_accept_smoke			    fn close_accept_smoke() 
close_accept_smoke			    fn close_accept_smoke() 
close_read			    pub fn close_read(&mut self) -> IoResult<()> 
close_read			    pub fn close_read(&mut self) -> IoResult<()> 
close_read			    pub fn close_read(&mut self) -> IoResult<()> 
close_read			    pub fn close_read(&mut self) -> IoResult<()> 
close_read			    pub fn close_read(&mut self) -> IoResult<()> 
close_read_wakes_up			    fn close_read_wakes_up() 
close_read_wakes_up			    fn close_read_wakes_up() 
close_read_wakes_up			    fn close_read_wakes_up() 
close_readwrite_smoke			    fn close_readwrite_smoke() 
close_readwrite_smoke			    fn close_readwrite_smoke() 
close_readwrite_smoke			    fn close_readwrite_smoke() 
close_sock			pub unsafe fn close_sock(sock: sock_t) { let _ = libc::close(sock); }
close_sock			pub unsafe fn close_sock(sock: sock_t) { let _ = libc::closesocket(sock); }
close_write			    pub fn close_write(&mut self) -> IoResult<()> 
close_write			    pub fn close_write(&mut self) -> IoResult<()> 
close_write			    pub fn close_write(&mut self) -> IoResult<()> 
close_write			    pub fn close_write(&mut self) -> IoResult<()> 
close_write			    pub fn close_write(&mut self) -> IoResult<()> 
closed			    fn closed() 
closing_channel_during_drop_doesnt_kill_everything			    fn closing_channel_during_drop_doesnt_kill_everything() 
cmath			mod cmath 
cmath			mod cmath 
cmp			    fn cmp(&self, other: &CStr) -> Ordering 
cmp			    fn cmp(&self, other: &OsStr) -> cmp::Ordering { self.bytes().cmp(other.bytes()) }
cmp			    fn cmp(&self, other: &OsString) -> cmp::Ordering 
cmp			    fn cmp(&self, other: &Ipv4Addr) -> Ordering 
cmp			    fn cmp(&self, other: &Ipv6Addr) -> Ordering 
cmp			    fn cmp(&self, other: &Path) -> Ordering 
cmp			    fn cmp(&self, other: &Path) -> Ordering 
cmp			    fn cmp(&self, other: &Components<'a>) -> cmp::Ordering 
cmp			    fn cmp(&self, other: &Path) -> cmp::Ordering 
cmp			    fn cmp(&self, other: &PathBuf) -> cmp::Ordering 
cmp			    fn cmp(&self, other: &Wtf8) -> cmp::Ordering { self.bytes.cmp(&other.bytes) }
cmp::Eq for Components			impl<'a> cmp::Eq for Components<'a> {}
cmp::Eq for Path			impl cmp::Eq for Path {}
cmp::Eq for PathBuf			impl cmp::Eq for PathBuf {}
cmp::Ord for Components			impl<'a> cmp::Ord for Components<'a> 
cmp::Ord for Path			impl cmp::Ord for Path 
cmp::Ord for PathBuf			impl cmp::Ord for PathBuf 
cmp::PartialEq for Components			impl<'a> cmp::PartialEq for Components<'a> 
cmp::PartialEq for Path			impl cmp::PartialEq for Path 
cmp::PartialEq for PathBuf			impl cmp::PartialEq for PathBuf 
cmp::PartialOrd for Components			impl<'a> cmp::PartialOrd for Components<'a> 
cmp::PartialOrd for Path			impl cmp::PartialOrd for Path 
cmp::PartialOrd for PathBuf			impl cmp::PartialOrd for PathBuf 
code			    pub fn code(&self) -> Option<i32> 
code			    pub fn code(&self) -> Option<i32> 
code			    pub fn code(&self) -> Option<i32> 
code_point_at			    pub fn code_point_at(&self, position: uint) -> CodePoint 
code_point_from_char			    fn code_point_from_char() 
code_point_from_u32			    fn code_point_from_u32() 
code_point_range_at			    pub fn code_point_range_at(&self, position: uint) -> (CodePoint, uint) 
code_point_to_char			    fn code_point_to_char() 
code_point_to_char_lossy			    fn code_point_to_char_lossy() 
code_point_to_string			    fn code_point_to_string() 
code_point_to_u32			    fn code_point_to_u32() 
code_points			    pub fn code_points(&self) -> Wtf8CodePoints 
collections			pub mod collections;
combine			fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i64) -> IoResult<u64> 
combine			                    fn combine(arr: &[u8]) -> i32 
combine			                    fn combine(arr: &[u8]) -> i32 
comm_adapters			mod comm_adapters;
comp_requires_verbatim			        fn comp_requires_verbatim(s: &str) -> bool 
compat			pub mod compat 
components			    pub fn components<'a>(&'a self) -> Components<'a> 
components			    pub fn components<'a>(&'a self) -> Components<'a> 
components			    pub fn components(&self) -> Components 
condvar			mod condvar;
condvar			pub mod condvar;
condvar			pub mod condvar;
condvar			pub mod condvar;
connect			        fn connect(i: usize, addr: SocketAddr) 
connect			    pub fn connect<A: ToSocketAddrs + ?Sized>(addr: &A) -> io::Result<TcpStream> 
connect			    pub fn connect<P: BytesContainer>(path: P) -> IoResult<UnixStream> 
connect			        fn connect(i: int, addr: SocketAddr) 
connect			    pub fn connect<A: ToSocketAddr>(addr: A) -> IoResult<TcpStream> 
connect			    pub fn connect(addr: SocketAddr, timeout: Option<u64>) -> IoResult<TcpStream> 
connect			    pub fn connect(addr: &SocketAddr) -> io::Result<TcpStream> 
connect			    pub fn connect(addr: &CString,
connect			fn connect(addr: &CString, ty: libc::c_int,
connect			    pub fn connect(addr: &CString, timeout: Option<u64>) -> IoResult<UnixStream> 
connect_error			    fn connect_error() 
connect_error			    fn connect_error() 
connect_error			    fn connect_error() 
connect_ip4_loopback			    fn connect_ip4_loopback() 
connect_ip4_loopback			    fn connect_ip4_loopback() 
connect_ip6_loopback			    fn connect_ip6_loopback() 
connect_ip6_loopback			    fn connect_ip6_loopback() 
connect_localhost			    fn connect_localhost() 
connect_timeout			    pub fn connect_timeout<P>(path: P, timeout: Duration)
connect_timeout			    pub fn connect_timeout<A: ToSocketAddr>(addr: A,
connect_timeout			pub fn connect_timeout(fd: sock_t,
connect_timeout_error			    fn connect_timeout_error() 
connect_timeout_negative			    fn connect_timeout_negative() 
connect_timeout_success			    fn connect_timeout_success() 
connect_timeout_zero			    fn connect_timeout_zero() 
consts			pub mod consts 
consts			pub mod consts 
consume			    fn consume(&mut self, amt: uint) { self.inner.consume(amt) }
consume			    fn consume(&mut self, amt: uint) 
consume			        fn consume(&mut self, amt: usize) { self.pos += amt as u64; }
consume			    fn consume(&mut self, amt: usize) { (**self).consume(amt) }
consume			    fn consume(&mut self, amt: usize) { *self = &self[amt..]; }
consume			    fn consume(&mut self, amt: usize) 
consume			    fn consume(&mut self, amt: usize);
consume			    fn consume(&mut self, amt: uint) { self.inner.consume(amt) }
consume			    fn consume(&mut self, amt: uint) 
consume			    fn consume(&mut self, amt: uint) 
consume			    fn consume(&mut self, amt: uint) { self.pos += amt; }
consume			    fn consume(&mut self, amt: uint) 
consume			    fn consume(&mut self, amt: uint) { self.inner.consume(amt) }
consume			    fn consume(&mut self, amt: uint);
consume			    fn consume(&mut self, _amt: uint) {}
consume			    fn consume(&mut self, amt: uint) 
container_as_bytes			    fn container_as_bytes<'a>(&'a self) -> &'a [u8] 
container_as_bytes			    fn container_as_bytes(&self) -> &[u8] 
container_as_bytes			    fn container_as_bytes<'a>(&'a self) -> &'a [u8] 
container_as_bytes			    fn container_as_bytes<'a>(&'a self) -> &'a [u8];
container_as_bytes			    fn container_as_bytes<'a>(&'a self) -> &'a [u8] 
container_as_bytes			    fn container_as_bytes<'a>(&'a self) -> &'a [u8] 
container_as_str			    fn container_as_str(&self) -> Option<&str> 
container_as_str			    fn container_as_str<'a>(&'a self) -> Option<&'a str> 
container_as_str			    fn container_as_str<'a>(&'a self) -> Option<&'a str> 
contains			    pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool
contains_key			    pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool
contains_nul			fn contains_nul<T: BytesContainer>(v: &T) -> bool 
convert			        fn convert<'a>(x: Option<&'a str>) -> &'a [u8] 
copy			pub fn copy<P: AsPath + ?Sized, Q: AsPath + ?Sized>(from: &P, to: &Q)
copy			pub fn copy<R: Read, W: Write>(r: &mut R, w: &mut W) -> io::Result<u64> 
copy			pub fn copy(from: &Path, to: &Path) -> IoResult<()> 
copy			pub fn copy<R: Reader, W: Writer>(r: &mut R, w: &mut W) -> old_io::IoResult<()> 
copy_file_does_not_exist			    fn copy_file_does_not_exist() 
copy_file_does_not_exist			    fn copy_file_does_not_exist() 
copy_file_dst_dir			    fn copy_file_dst_dir() 
copy_file_dst_dir			    fn copy_file_dst_dir() 
copy_file_dst_exists			    fn copy_file_dst_exists() 
copy_file_dst_exists			    fn copy_file_dst_exists() 
copy_file_ok			    fn copy_file_ok() 
copy_file_ok			    fn copy_file_ok() 
copy_file_preserves_perm_bits			    fn copy_file_preserves_perm_bits() 
copy_file_preserves_perm_bits			    fn copy_file_preserves_perm_bits() 
copy_file_src_dir			    fn copy_file_src_dir() 
copy_file_src_dir			    fn copy_file_src_dir() 
cos			    fn cos(self) -> f32 
cos			    fn cos(self) -> f64 
cos			    fn cos(self) -> Self;
cosh			    fn cosh(self) -> f32 
cosh			        pub fn cosh(n: c_double) -> c_double;
cosh			    fn cosh(self) -> f64 
cosh			    fn cosh(self) -> Self;
coshf			        pub fn coshf(n: c_float) -> c_float;
cp			        fn cp(string: &Wtf8Buf) -> Vec<Option<char>> 
create			    pub fn create(&mut self, create: bool) -> &mut OpenOptions 
create			    pub fn create<P: AsPath + ?Sized>(path: &P) -> io::Result<File> 
create			    pub fn create(path: &Path) -> IoResult<File> 
create			    pub fn create(&mut self, create: bool) 
create			pub unsafe fn create(stack: uint, p: Thunk) -> io::Result<rust_thread> 
create			pub unsafe fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key 
create			    pub fn create(&mut self, create: bool) { self.create = create; }
create			pub unsafe fn create(stack: uint, p: Thunk) -> io::Result<rust_thread> 
create			pub unsafe fn create(dtor: Option<Dtor>) -> Key 
create_dir			pub fn create_dir<P: AsPath + ?Sized>(path: &P) -> io::Result<()> 
create_dir_all			pub fn create_dir_all<P: AsPath + ?Sized>(path: &P) -> io::Result<()> 
create_path			    pub fn create_path(path: &[Path]) -> Vec<u8> 
creation_disposition			    fn creation_disposition(&mut self, access: i32) -> &mut OpenOptions 
creation_disposition			    fn creation_disposition(&mut self, val: i32) -> &mut Self;
creation_disposition			    pub fn creation_disposition(&mut self, val: i32) 
cstr			fn cstr(path: &Path) -> IoResult<CString> 
cstr			fn cstr(path: &Path) -> io::Result<CString> 
ctime			    fn ctime(stat: &libc::stat) -> u64 
current			    pub unsafe fn current() -> uint 
current			    pub unsafe fn current() -> uint 
current			    pub fn current() -> Thread 
current			pub fn current() -> Thread 
current_dir			pub fn current_dir() -> io::Result<PathBuf> 
current_dir			    pub fn current_dir<P: AsPath + ?Sized>(&mut self, dir: &P) -> &mut Command 
current_exe			pub fn current_exe() -> io::Result<PathBuf> 
current_exe			pub fn current_exe() -> io::Result<PathBuf> 
current_exe			pub fn current_exe() -> io::Result<PathBuf> 
current_thread			pub fn current_thread() -> Thread 
cursor			mod cursor;
cvt			pub fn cvt<T: SignedInt>(t: T) -> io::Result<T> 
cvt			fn cvt<I: Int>(i: I) -> io::Result<I> 
cvt			pub fn cvt<T: SignedInt>(t: T) -> io::Result<T> 
cvt_gai			pub fn cvt_gai(err: c_int) -> io::Result<()> 
cvt_gai			pub fn cvt_gai(err: c_int) -> io::Result<()> 
cvt_r			pub fn cvt_r<T, F>(mut f: F) -> io::Result<T>
cvt_r			pub fn cvt_r<T: SignedInt, F>(mut f: F) -> io::Result<T> where F: FnMut() -> T 
cwd			    fn cwd(&self) -> Option<&CString> 
cwd			    pub fn cwd<'a>(&'a mut self, dir: &Path) -> &'a mut Command 
cwd			    fn cwd(&self) -> Option<&CString>;
cwd			    pub fn cwd(&mut self, dir: &OsStr) 
cwd			    pub fn cwd(&mut self, dir: &OsStr) 
darwin_fd_limit			mod darwin_fd_limit 
data			    pub fn data(&self) -> *mut u8 { self.data }
datasync			    pub fn datasync(&mut self) -> IoResult<()> 
datasync			    pub fn datasync(&self) -> IoResult<()> 
datasync			    pub fn datasync(&self) -> io::Result<()> 
datasync			    pub fn datasync(&mut self) -> IoResult<()> { return self.fsync(); }
datasync			    pub fn datasync(&self) -> io::Result<()> { self.fsync() }
days			    pub fn days(days: i64) -> Duration 
decode_error			pub fn decode_error(errno: i32) -> IoError 
decode_error			pub fn decode_error(errno: i32) -> IoError 
decode_error_detailed			pub fn decode_error_detailed(errno: i32) -> IoError 
decode_error_detailed			pub fn decode_error_detailed(errno: i32) -> IoError 
decode_error_kind			pub fn decode_error_kind(errno: i32) -> ErrorKind 
decode_error_kind			pub fn decode_error_kind(errno: i32) -> ErrorKind 
decode_surrogate			fn decode_surrogate(second_byte: u8, third_byte: u8) -> u16 
decode_surrogate_pair			fn decode_surrogate_pair(lead: u16, trail: u16) -> char 
decrement			    fn decrement(&mut self, token: SignalToken) -> StartResult 
decrement			    fn decrement(&mut self, token: SignalToken) -> Result<(), SignalToken> 
default			    fn default() -> HashMap<K, V, S> 
default			    fn default() -> RandomState 
default			    fn default() -> HashSet<T, S> 
default			    fn default() -> DefaultState<H> { DefaultState(marker::PhantomData) }
default			    fn default() -> FilePermission { FilePermission::empty() }
default_sched_threads			pub fn default_sched_threads() -> uint 
demangle			    fn demangle() 
demangle			pub fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> 
demangle_dollars			    fn demangle_dollars() 
demangle_many_dollars			    fn demangle_many_dollars() 
demangle_windows			    fn demangle_windows() 
dequeue			    fn dequeue(&mut self) -> Option<SignalToken> 
dequeue			    fn dequeue(&mut self) -> T 
deref			    fn deref(&self) -> &CStr 
deref			    fn deref(&self) -> &OsStr 
deref			    fn deref(&self) -> &BufferedReader<StdReader> 
deref			    fn deref(&self) -> &Path 
deref			    fn deref<'a>(&'a self) -> &'a T 
deref			    fn deref(&self) -> &T { unsafe { &*self.__data.get() } }
deref			    fn deref(&self) -> &Wtf8 
deref_mut			    fn deref_mut(&mut self) -> &mut BufferedReader<StdReader> 
deref_mut			    fn deref_mut<'a>(&'a mut self) -> &'a mut T 
deref_mut			    fn deref_mut(&mut self) -> &mut T 
description			    fn description(&self) -> &str { self.inner.description() }
description			    fn description(&self) -> &str 
description			    fn description(&self) -> &str { "nul byte found in data" }
description			    fn description(&self) -> &str { self.error().description() }
description			    fn description(&self) -> &str 
description			    pub fn description(&self) -> &str 
description			    fn description(&self) -> &str 
description			    fn description(&self) -> &str { self.desc }
description			    fn description(&self) -> &str { "memory map error" }
description			    fn description(&self) -> &str 
description			    fn description(&self) -> &str { "failed to join paths" }
description			    fn description(&self) -> &str { "failed to join paths" }
desired_access			    fn desired_access(&mut self, access: i32) -> &mut OpenOptions 
desired_access			    fn desired_access(&mut self, access: i32) -> &mut Self;
desired_access			    pub fn desired_access(&mut self, val: i32) 
destroy			    pub unsafe fn destroy(&'static self) 
destroy			    pub unsafe fn destroy(&'static self) 
destroy			    pub unsafe fn destroy(&'static self) 
destroy			    pub unsafe fn destroy(&self) { self.0.destroy() }
destroy			    pub unsafe fn destroy(&self) { self.0.destroy() }
destroy			    pub unsafe fn destroy(&self) { self.0.destroy() }
destroy			    pub unsafe fn destroy(&self) 
destroy			    pub unsafe fn destroy(&self) 
destroy			    pub unsafe fn destroy(&self) 
destroy			    pub unsafe fn destroy(&self) 
destroy			pub unsafe fn destroy(key: Key) 
destroy			    pub unsafe fn destroy(&self) 
destroy			    pub unsafe fn destroy(&self) 
destroy			    pub unsafe fn destroy(&self) 
destroy			pub unsafe fn destroy(key: Key) 
destroy_upgraded_shared_port_when_sender_still_active			    fn destroy_upgraded_shared_port_when_sender_still_active() 
destroyed			    pub fn destroyed(&'static self) -> bool { self.state() == State::Destroyed }
detach			    fn detach(&self) -> bool 
detach			    fn detach(&self) -> bool;
detach			pub unsafe fn detach(native: rust_thread) 
detach			pub unsafe fn detach(native: rust_thread) 
detach			    pub fn detach(mut self) 
detach_works			    fn detach_works() 
detached			    pub fn detached<'a>(&'a mut self) -> &'a mut Command 
detail			    pub fn detail(&self) -> Option<String> 
difference			    pub fn difference<'a>(&'a self, other: &'a HashSet<T, S>) -> Difference<'a, T, S> 
digits			    fn digits(unused_self: Option<f32>) -> uint { num::Float::digits(unused_self) }
digits			    fn digits(unused_self: Option<f64>) -> uint { num::Float::digits(unused_self) }
digits			    fn digits(unused_self: Option<Self>) -> usize;
dir_path			    fn dir_path(&self) -> Self 
dir_path			    fn dir_path(&self) -> Path 
dirent			    fn dirent(&self) -> *mut libc::dirent_t 
dirname			    fn dirname<'a>(&'a self) -> &'a [u8];
dirname			    fn dirname<'a>(&'a self) -> &'a [u8] 
dirname			    fn dirname<'a>(&'a self) -> &'a [u8] 
dirname_str			    fn dirname_str<'a>(&'a self) -> Option<&'a str> 
dirname_str			    fn dirname_str<'a>(&'a self) -> Option<&'a str> 
display			    fn display<'a>(&'a self) -> Display<'a, Self> 
display			    pub fn display(&self) -> Display 
distance			    pub fn distance(&self) -> usize 
div			    fn div(self, rhs: i32) -> Duration 
div_floor_64			fn div_floor_64(this: i64, other: i64) -> i64 
div_mod_floor_64			fn div_mod_floor_64(this: i64, other: i64) -> (i64, i64) 
div_rem_64			fn div_rem_64(this: i64, other: i64) -> (i64, i64) 
dl			mod dl 
dladdr			        fn dladdr(addr: *const libc::c_void,
dlclose			        fn dlclose(handle: *mut libc::c_void) -> libc::c_int;
dlerror			        fn dlerror() -> *mut libc::c_char;
dll_filename			pub fn dll_filename(base: &str) -> String 
dlopen			        fn dlopen(filename: *const libc::c_char,
dlsym			        fn dlsym(handle: *mut libc::c_void,
dns_smoke_test			    fn dns_smoke_test() 
do_bench_mem_writer			    fn do_bench_mem_writer(b: &mut Bencher, times: uint, len: uint) 
do_send			    fn do_send(&mut self, t: Message<T>) -> UpgradeResult 
do_unlink			    fn do_unlink(p_utf16: &Vec<u16>) -> IoResult<()> 
done			    pub fn done(&self, guard: &Guard) 
dont_close_fd_on_command_spawn			    fn dont_close_fd_on_command_spawn() 
dont_panic_in_drop_on_panicked_flush			    fn dont_panic_in_drop_on_panicked_flush() 
dont_panic_in_drop_on_panicked_flush			    fn dont_panic_in_drop_on_panicked_flush() 
double_bind			    fn double_bind() 
double_bind			    fn double_bind() 
drain			    pub fn drain(&mut self) -> Drain<K, V> 
drain			    pub fn drain(&mut self) -> Drain<T> 
drain			    pub fn drain(&mut self) -> Drain<K, V> 
drain			        fn drain(fd: libc::c_int) -> bool 
drop			        fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			        fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			        fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			        fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			        fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			                fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			                fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) { unsafe { close_sock(self.fd); } }
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) { unsafe { let _ = libc::close(self.fd); } }
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) { (self.SymCleanup)(self.handle); }
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) {}
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			            fn drop(&mut self) 
drop			        fn drop(&mut self) 
drop			            fn drop(&mut self) 
drop_chan			    pub fn drop_chan(&mut self) 
drop_chan			    pub fn drop_chan(&mut self) 
drop_chan			    pub fn drop_chan(&mut self) 
drop_chan			    pub fn drop_chan(&self) 
drop_full			    fn drop_full() 
drop_full			    fn drop_full() 
drop_full_shared			    fn drop_full_shared() 
drop_handler			    pub unsafe fn drop_handler(_handler: &mut super::Handler) 
drop_handler			    pub unsafe fn drop_handler(handler: &mut Handler) 
drop_port			    pub fn drop_port(&mut self) 
drop_port			    pub fn drop_port(&mut self) 
drop_port			    pub fn drop_port(&mut self) 
drop_port			    pub fn drop_port(&self) 
drop_removes_acceptor_path			    fn drop_removes_acceptor_path() 
drop_removes_listener_path			    fn drop_removes_listener_path() 
dtors_in_dtors_in_dtors			    fn dtors_in_dtors_in_dtors() 
dumb_print			pub fn dumb_print(args: fmt::Arguments) 
duplicate			    pub fn duplicate(&self) -> io::Result<TcpListener> 
duplicate			    pub fn duplicate(&self) -> io::Result<TcpStream> 
duplicate			    pub fn duplicate(&self) -> io::Result<UdpSocket> 
duplicate			    pub fn duplicate(&self) -> io::Result<Socket> 
duplicate			    pub fn duplicate(&self) -> io::Result<Socket> 
duration			pub mod duration;
dynamic_lib			pub mod dynamic_lib;
dynamic_tests			mod dynamic_tests 
e			        fn e(initial: &[u32], extended: &[u32]) -> Wtf8Buf 
eabi			pub mod eabi 
each_addr			fn each_addr<A: ToSocketAddrs + ?Sized, F, T>(addr: &A, mut f: F) -> io::Result<T>
each_ip			    fn each_ip(f: &mut FnMut(SocketAddr)) 
each_ip			    fn each_ip(f: &mut FnMut(SocketAddr, SocketAddr)) 
empty			pub fn empty() -> Empty { Empty { _priv: () } }
empty_reads			    fn empty_reads() 
encode_wide			    pub fn encode_wide(&self) -> EncodeWide 
encode_wide			    fn encode_wide(&self) -> EncodeWide 
encode_wide			    fn encode_wide(&self) -> EncodeWide;
ends_with			    pub fn ends_with<P: ?Sized>(&self, child: &P) -> bool where P: AsPath 
ends_with_path			    fn ends_with_path(&self, child: &Self) -> bool;
ends_with_path			    fn ends_with_path(&self, child: &Path) -> bool 
ends_with_path			    fn ends_with_path(&self, child: &Path) -> bool 
ends_with_path_home_dir			    fn ends_with_path_home_dir(b: &mut Bencher) 
ends_with_path_missmatch_jome_home			    fn ends_with_path_missmatch_jome_home(b: &mut Bencher) 
enqueue			    fn enqueue(&mut self, node: &mut Node) -> WaitToken 
enqueue			    fn enqueue(&mut self, t: T) 
entry			    pub fn entry(&mut self, key: K) -> Entry<K, V> 
env			pub mod env;
env			    fn env(&self) -> Option<&EnvMap> 
env			    pub fn env<'a, T, U>(&'a mut self, key: T, val: U)
env			pub fn env() -> Vec<(String,String)> 
env			    pub fn env<S: ?Sized, T: ?Sized>(&mut self, key: &S, val: &T) -> &mut Command where
env			    fn env(&self) -> Option<&collections::HashMap<K, V>>;
env			pub fn env() -> Env 
env			    pub fn env(&mut self, key: &OsStr, val: &OsStr) 
env			pub fn env() -> Env 
env			    pub fn env(&mut self, key: &OsStr, val: &OsStr) 
env_as_bytes			pub fn env_as_bytes() -> Vec<(Vec<u8>, Vec<u8>)> 
env_clear			    pub fn env_clear(&mut self) -> &mut Command 
env_clear			    pub fn env_clear(&mut self) 
env_clear			    pub fn env_clear(&mut self) 
env_cmd			    pub fn env_cmd() -> Command 
env_cmd			    pub fn env_cmd() -> Command 
env_map_keys_ci			    fn env_map_keys_ci() 
env_remove			    pub fn env_remove<'a, T>(&'a mut self, key: T) -> &'a mut Command
env_remove			    pub fn env_remove<S: ?Sized + AsOsStr>(&mut self, key: &S) -> &mut Command 
env_remove			    pub fn env_remove(&mut self, key: &OsStr) 
env_remove			    pub fn env_remove(&mut self, key: &OsStr) 
env_set_all			    pub fn env_set_all<'a, T, U>(&'a mut self, env: &[(T,U)])
environ			pub unsafe fn environ() -> *mut *const *const c_char 
envvar			    pub fn envvar() -> &'static str 
eof			    pub fn eof(&self) -> bool 
eof			    pub fn eof(&self) -> bool { self.pos >= self.buf.len() }
eof			pub fn eof() -> IoError 
epipe			fn epipe() -> IoError 
epsilon			    fn epsilon() -> f32 { num::Float::epsilon() }
epsilon			    fn epsilon() -> f64 { num::Float::epsilon() }
epsilon			    fn epsilon() -> Self;
eq			    fn eq(&self, other: &HashMap<K, V, S>) -> bool 
eq			    fn eq(&self, other: &HashSet<T, S>) -> bool 
eq			    fn eq(a: Option<OsString>, b: Option<&str>) 
eq			    fn eq(&self, other: &CStr) -> bool 
eq			    fn eq(&self, other: &OsStr) -> bool 
eq			    fn eq(&self, other: &OsString) -> bool 
eq			    fn eq(&self, other: &str) -> bool 
eq			    fn eq(&self, other: &Repr) -> bool 
eq			    fn eq(&self, other: &Ipv4Addr) -> bool 
eq			    fn eq(&self, other: &Ipv6Addr) -> bool 
eq			    fn eq(&self, other: &EnvKey) -> bool 
eq			    fn eq(&self, other: &Path) -> bool 
eq			    fn eq(&self, other: &Path) -> bool 
eq			    fn eq(&self, other: &Components<'a>) -> bool 
eq			    fn eq(&self, other: &Path) -> bool 
eq			    fn eq(&self, other: &PathBuf) -> bool 
eq			    fn eq(&self, other: &Wtf8) -> bool { self.bytes.eq(&other.bytes) }
eq_ignore_ascii_case			    fn eq_ignore_ascii_case(&self, other: &Self) -> bool;
eq_ignore_ascii_case			    fn eq_ignore_ascii_case(&self, other: &[u8]) -> bool 
eq_ignore_ascii_case			    fn eq_ignore_ascii_case(&self, other: &char) -> bool 
eq_ignore_ascii_case			    fn eq_ignore_ascii_case(&self, other: &str) -> bool 
eq_ignore_ascii_case			    fn eq_ignore_ascii_case(&self, other: &u8) -> bool 
eq_ignore_ascii_case			    fn eq_ignore_ascii_case(&self, other: &Wtf8) -> bool 
equiv_prefix			    fn equiv_prefix(&self, other: &Path) -> bool 
erf			        pub fn erf(n: c_double) -> c_double;
erfc			        pub fn erfc(n: c_double) -> c_double;
erfcf			        pub fn erfcf(n: c_float) -> c_float;
erff			        pub fn erff(n: c_float) -> c_float;
err2old			fn err2old(new: ::io::Error) -> IoError 
errno			pub fn errno() -> i32 
errno			pub fn errno() -> i32 
errno			pub fn errno() -> i32 
errno_location			    fn errno_location() -> *const c_int 
errno_location			    unsafe fn errno_location() -> *const c_int 
error			    pub fn error(&self) -> &Error { &self.1 }
error			mod error;
error_cb			    extern fn error_cb(_data: *mut libc::c_void, _msg: *const libc::c_char,
error_string			pub fn error_string(errnum: i32) -> String 
error_string			pub fn error_string(errno: i32) -> String 
error_string			pub fn error_string(errnum: i32) -> String 
escape_default			pub fn escape_default(c: u8) -> EscapeDefault 
exception_cleanup			    extern fn exception_cleanup(_unwind_code: uw::_Unwind_Reason_Code,
execute			    pub fn execute<F>(&self, job: F)
exists			    fn exists(&self) -> bool { metadata(self).is_ok() }
exists			    fn exists(&self) -> bool;
exists			    fn exists(&self) -> bool 
exists			    fn exists(&self) -> bool;
exit_reported_right			    fn exit_reported_right() 
exit_reported_right			    fn exit_reported_right() 
exp			    fn exp(self) -> f32 { num::Float::exp(self) }
exp			    fn exp(self) -> f64 { num::Float::exp(self) }
exp			    fn exp(self) -> Self;
exp2			    fn exp2(self) -> f32 { num::Float::exp2(self) }
exp2			    fn exp2(self) -> f64 { num::Float::exp2(self) }
exp2			    fn exp2(self) -> Self;
exp_m1			    fn exp_m1(self) -> f32 
exp_m1			    fn exp_m1(self) -> f64 
exp_m1			    fn exp_m1(self) -> Self;
expect_full			    pub fn expect_full(self) -> FullBucket<K, V, M> 
expm1			        pub fn expm1(n: c_double) -> c_double;
expm1f			        pub fn expm1f(n: c_float) -> c_float;
ext			pub mod ext;
ext			pub mod ext;
extend			    fn extend<T: IntoIterator<Item=(K, V)>>(&mut self, iter: T) 
extend			    fn extend<I: IntoIterator<Item=T>>(&mut self, iter: I) 
extend			    fn extend<I: IntoIterator<Item = &'a P>>(&mut self, iter: I) 
extend			    fn extend<T: IntoIterator<Item=CodePoint>>(&mut self, iterable: T) 
extend_sign			fn extend_sign(val: u64, nbytes: uint) -> i64 
extension			    fn extension<'a>(&'a self) -> Option<&'a [u8]> 
extension			    pub fn extension(&self) -> Option<&OsStr> 
extension_str			    fn extension_str<'a>(&'a self) -> Option<&'a str> 
extension_str			    fn extension_str<'a>(&'a self) -> Option<&'a str> 
extensions			pub mod extensions;
f			        fn f(values: &[u32]) -> Wtf8Buf 
f			        fn f(i: int, tx: Sender<()>) 
f64			    mod f64 
fail			                fn fail(output: &mut FileDesc) -> ! 
fail			                fn fail(output: &mut AnonPipe) -> ! 
fallback			    unsafe fn fallback() -> Option<OsString> { None }
fallback			    unsafe fn fallback() -> Option<OsString> 
fallback			                extern "system" fn fallback(
fast_rebind			    fn fast_rebind() 
fast_rebind			    fn fast_rebind() 
fd			    pub fn fd(&self) -> sock_t { self.inner.fd }
fd			    pub fn fd(&self) -> fd_t { self.fd }
fd			    pub fn fd(&self) -> &FileDesc { &self.0 }
fd			pub mod fd;
fd			    pub fn fd(&self) -> fd_t { self.inner.fd }
fd			    pub fn fd(&self) -> fd_t { self.inner.listener.fd() }
fd			    pub fn fd(&self) -> sock_t { self.inner.fd() }
fd			    pub fn fd(&self) -> sock_t { self.inner.listener.fd() }
fd			    pub fn fd(&self) -> fd_t { self.fd }
fd_set			    pub fn fd_set(set: &mut fd_set, fd: i32) 
fd_set			    pub struct fd_set 
fd_set			pub fn fd_set(set: &mut fd_set, s: libc::SOCKET) 
fd_set			pub struct fd_set 
fdim			        pub fn fdim(a: c_double, b: c_double) -> c_double;
fdimf			        pub fn fdimf(a: c_float, b: c_float) -> c_float;
ffi			pub mod ffi;
file_attr			    pub fn file_attr(&self) -> io::Result<FileAttr> 
file_attr			    pub fn file_attr(&self) -> io::Result<FileAttr> 
file_name			    pub fn file_name(&self) -> Option<&OsStr> 
file_stem			    pub fn file_stem(&self) -> Option<&OsStr> 
file_test_directoryinfo_check_exists_before_and_after_mkdir			    fn file_test_directoryinfo_check_exists_before_and_after_mkdir() 
file_test_directoryinfo_check_exists_before_and_after_mkdir			    fn file_test_directoryinfo_check_exists_before_and_after_mkdir() 
file_test_directoryinfo_readdir			    fn file_test_directoryinfo_readdir() 
file_test_directoryinfo_readdir			    fn file_test_directoryinfo_readdir() 
file_test_fileinfo_check_exists_before_and_after_file_creation			    fn file_test_fileinfo_check_exists_before_and_after_file_creation() 
file_test_fileinfo_check_exists_before_and_after_file_creation			    fn file_test_fileinfo_check_exists_before_and_after_file_creation() 
file_test_fileinfo_false_when_checking_is_file_on_a_directory			    fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() 
file_test_fileinfo_false_when_checking_is_file_on_a_directory			    fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() 
file_test_io_non_positional_read			    fn file_test_io_non_positional_read() 
file_test_io_non_positional_read			    fn file_test_io_non_positional_read() 
file_test_io_seek_and_tell_smoke_test			    fn file_test_io_seek_and_tell_smoke_test() 
file_test_io_seek_and_tell_smoke_test			    fn file_test_io_seek_and_tell_smoke_test() 
file_test_io_seek_and_write			    fn file_test_io_seek_and_write() 
file_test_io_seek_and_write			    fn file_test_io_seek_and_write() 
file_test_io_seek_shakedown			    fn file_test_io_seek_shakedown() 
file_test_io_seek_shakedown			    fn file_test_io_seek_shakedown() 
file_test_io_smoke_test			    fn file_test_io_smoke_test() 
file_test_io_smoke_test			    fn file_test_io_smoke_test() 
file_test_iounlinking_invalid_path_should_raise_condition			    fn file_test_iounlinking_invalid_path_should_raise_condition() 
file_test_iounlinking_invalid_path_should_raise_condition			    fn file_test_iounlinking_invalid_path_should_raise_condition() 
file_test_stat_is_correct_on_is_dir			    fn file_test_stat_is_correct_on_is_dir() 
file_test_stat_is_correct_on_is_dir			    fn file_test_stat_is_correct_on_is_dir() 
file_test_stat_is_correct_on_is_file			    fn file_test_stat_is_correct_on_is_file() 
file_test_stat_is_correct_on_is_file			    fn file_test_stat_is_correct_on_is_file() 
file_test_walk_dir			    fn file_test_walk_dir() 
file_test_walk_dir			    fn file_test_walk_dir() 
filename			    fn filename<'a>(&'a self) -> Option<&'a [u8]>;
filename			    fn filename<'a>(&'a self) -> Option<&'a [u8]> 
filename			    fn filename<'a>(&'a self) -> Option<&'a [u8]> 
filename_display			    fn filename_display<'a>(&'a self) -> Display<'a, Self> 
filename_str			    fn filename_str<'a>(&'a self) -> Option<&'a str> 
filename_str			    fn filename_str<'a>(&'a self) -> Option<&'a str> 
filestem			    fn filestem<'a>(&'a self) -> Option<&'a [u8]> 
filestem_str			    fn filestem_str<'a>(&'a self) -> Option<&'a str> 
filestem_str			    fn filestem_str<'a>(&'a self) -> Option<&'a str> 
fill_buf			    fn fill_buf(&mut self) -> io::Result<&[u8]> { self.inner.fill_buf() }
fill_buf			    fn fill_buf(&mut self) -> io::Result<&[u8]> 
fill_buf			        fn fill_buf(&mut self) -> io::Result<&[u8]> 
fill_buf			    fn fill_buf(&mut self) -> io::Result<&[u8]> { (**self).fill_buf() }
fill_buf			    fn fill_buf(&mut self) -> io::Result<&[u8]> { Ok(*self) }
fill_buf			    fn fill_buf(&mut self) -> Result<&[u8]> 
fill_buf			    fn fill_buf(&mut self) -> Result<&[u8]>;
fill_buf			    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> { self.inner.fill_buf() }
fill_buf			    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> 
fill_buf			    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> 
fill_buf			    fn fill_buf(&mut self) -> IoResult<&[u8]> 
fill_buf			    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> 
fill_buf			    fn fill_buf(&mut self) -> IoResult<&[u8]> { self.inner.fill_buf() }
fill_buf			    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]>;
fill_buf			    fn fill_buf<'a>(&'a mut self) -> old_io::IoResult<&'a [u8]> 
fill_bytes			    fn fill_bytes(&mut self, bytes: &mut [u8]) 
fill_bytes			        fn fill_bytes(&mut self, v: &mut [u8]) 
fill_bytes			    fn fill_bytes(&mut self, v: &mut [u8]) 
fill_utf16_buf			fn fill_utf16_buf<F1, F2, T>(f1: F1, f2: F2) -> IoResult<T>
fill_utf16_buf_base			fn fill_utf16_buf_base<F1, F2, T>(mut f1: F1, f2: F2) -> Result<T, ()>
fill_utf16_buf_new			fn fill_utf16_buf_new<F1, F2, T>(f1: F1, f2: F2) -> io::Result<T>
final_lead_surrogate			    fn final_lead_surrogate(&self) -> Option<u16> 
find_existing			fn find_existing(b: &mut Bencher) 
find_nonexisting			fn find_nonexisting(b: &mut Bencher) 
find_zero_slice			                fn find_zero_slice(segments: &[u16; 8]) -> (usize, usize) 
finished			    fn finished(&self) -> bool 
first			        fn first<A, B>((a, _): (A, B)) -> A { a }
first			        fn first<A, B>((a, _): (A, B)) -> A { a }
first			    pub fn first(table: M) -> Bucket<K, V, M> 
first_bucket_raw			    fn first_bucket_raw(&self) -> RawBucket<K, V> 
flag			    fn flag(&mut self, bit: c_int, on: bool) 
flags			    fn flags(_stat: &libc::stat) -> u64 { 0 }
flags			    fn flags(stat: &libc::stat) -> u64 { stat.st_flags as u64 }
flags_and_attributes			    fn flags_and_attributes(&mut self, access: i32) -> &mut OpenOptions 
flags_and_attributes			    fn flags_and_attributes(&mut self, val: i32) -> &mut Self;
flags_and_attributes			    pub fn flags_and_attributes(&mut self, val: i32) 
float_macros			mod float_macros;
float_to_str_bytes_common			pub fn float_to_str_bytes_common<T: Float>(
float_to_str_common			pub fn float_to_str_common<T: Float>(
float_to_string			        fn float_to_string(b: &mut Bencher) 
floor			    fn floor(self) -> f32 { num::Float::floor(self) }
floor			    fn floor(self) -> f64 { num::Float::floor(self) }
floor			    fn floor(self) -> Self;
flush			    fn flush(&mut self) -> io::Result<()> { self.inner.flush() }
flush			            fn flush(&mut self) -> io::Result<()> { Ok(()) }
flush			            fn flush(&mut self) -> io::Result<()> 
flush			    fn flush(&mut self) -> io::Result<()> { self.inner.flush() }
flush			    fn flush(&mut self) -> io::Result<()> 
flush			    fn flush(&mut self) -> io::Result<()> { Ok(()) }
flush			    fn flush(&mut self) -> io::Result<()> { (**self).flush() }
flush			    fn flush(&mut self) -> io::Result<()> { Ok(()) }
flush			    fn flush(&mut self) -> Result<()> 
flush			    fn flush(&mut self) -> Result<()>;
flush			    fn flush(&mut self) -> io::Result<()> { Ok(()) }
flush			    fn flush(&mut self) -> io::Result<()> { Ok(()) }
flush			            fn flush(&mut self) -> IoResult<()> { Err(old_io::standard_error(EndOfFile)) }
flush			    fn flush(&mut self) -> IoResult<()> { self.inner.flush() }
flush			    fn flush(&mut self) -> IoResult<()> 
flush			    fn flush(&mut self) -> IoResult<()> { (**self).flush() }
flush			    fn flush(&mut self) -> IoResult<()> { Ok(()) }
flush			    fn flush(&mut self) -> IoResult<()> { self.inner.flush() }
flush			    fn flush(&mut self) -> IoResult<()> 
flush			    fn flush(&mut self) -> IoResult<()> 
flush			pub fn flush() 
flush			            fn flush(&mut self) -> old_io::IoResult<()> 
flush			    fn flush(&mut self) -> old_io::IoResult<()> 
flush			    fn flush(&mut self) -> io::Result<()> 
flush			    pub fn flush(&self) -> io::Result<()> { Ok(()) }
flush			    pub fn flush(&self) -> io::Result<()> { Ok(()) }
flush_buf			    fn flush_buf(&mut self) -> io::Result<()> 
flush_buf			    fn flush_buf(&mut self) -> IoResult<()> 
fmax			        pub fn fmax(a: c_double, b: c_double) -> c_double;
fmaxf			        pub fn fmaxf(a: c_float, b: c_float) -> c_float;
fmin			        pub fn fmin(a: c_double, b: c_double) -> c_double;
fminf			        pub fn fminf(a: c_float, b: c_float) -> c_float;
fmod			        pub fn fmod(a: c_double, b: c_double) -> c_double;
fmodf			        pub fn fmodf(a: c_float, b: c_float) -> c_float;
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, out: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt::Debug for BufReader			impl<R> fmt::Debug for BufReader<R> where R: fmt::Debug 
fmt::Debug for BufStream			impl<S> fmt::Debug for BufStream<S> where S: fmt::Debug 
fmt::Debug for BufWriter			impl<W> fmt::Debug for BufWriter<W> where W: fmt::Debug 
fmt::Debug for BufferedReader			impl<R> fmt::Debug for BufferedReader<R> where R: fmt::Debug 
fmt::Debug for BufferedStream			impl<S> fmt::Debug for BufferedStream<S> where S: fmt::Debug 
fmt::Debug for BufferedWriter			impl<W> fmt::Debug for BufferedWriter<W> where W: fmt::Debug 
fmt::Debug for CString			impl fmt::Debug for CString 
fmt::Debug for CodePoint			impl fmt::Debug for CodePoint 
fmt::Debug for Command			impl fmt::Debug for Command 
fmt::Debug for Command			impl fmt::Debug for Command 
fmt::Debug for Display			impl<'a, P: GenericPath> fmt::Debug for Display<'a, P> 
fmt::Debug for Display			impl<'a> fmt::Debug for Display<'a> 
fmt::Debug for HashSet			impl<T, S> fmt::Debug for HashSet<T, S>
fmt::Debug for Ipv4Addr			impl fmt::Debug for Ipv4Addr 
fmt::Debug for Ipv6Addr			impl fmt::Debug for Ipv6Addr 
fmt::Debug for LineBufferedWriter			impl<W> fmt::Debug for LineBufferedWriter<W> where W: fmt::Debug 
fmt::Debug for LineWriter			impl<W> fmt::Debug for LineWriter<W> where W: fmt::Debug 
fmt::Debug for Path			impl fmt::Debug for Path 
fmt::Debug for Path			impl fmt::Debug for Path 
fmt::Debug for Path			impl fmt::Debug for Path 
fmt::Debug for PathBuf			impl fmt::Debug for PathBuf 
fmt::Debug for PoisonError			impl<T> fmt::Debug for PoisonError<T> 
fmt::Debug for SendError			impl<T> fmt::Debug for SendError<T> 
fmt::Debug for SocketAddr			impl fmt::Debug for SocketAddr 
fmt::Debug for Thread			impl fmt::Debug for Thread 
fmt::Debug for TryLockError			impl<T> fmt::Debug for TryLockError<T> 
fmt::Debug for TrySendError			impl<T> fmt::Debug for TrySendError<T> 
fmt::Debug for Wtf8			impl fmt::Debug for Wtf8 
fmt::Debug for Wtf8Buf			impl fmt::Debug for Wtf8Buf 
fmt::Display for CharsError			impl fmt::Display for CharsError 
fmt::Display for Display			impl<'a, P: GenericPath> fmt::Display for Display<'a, P> 
fmt::Display for Display			impl<'a> fmt::Display for Display<'a> 
fmt::Display for Duration			impl fmt::Display for Duration 
fmt::Display for Error			impl fmt::Display for Error 
fmt::Display for ExitStatus			impl fmt::Display for ExitStatus 
fmt::Display for ExitStatus			impl fmt::Display for ExitStatus 
fmt::Display for ExitStatus			impl fmt::Display for ExitStatus 
fmt::Display for FilePermission			impl fmt::Display for FilePermission 
fmt::Display for IntoInnerError			impl<W> fmt::Display for IntoInnerError<W> 
fmt::Display for IoError			impl fmt::Display for IoError 
fmt::Display for IpAddr			impl fmt::Display for IpAddr 
fmt::Display for IpAddr			impl fmt::Display for IpAddr 
fmt::Display for Ipv4Addr			impl fmt::Display for Ipv4Addr 
fmt::Display for Ipv6Addr			impl fmt::Display for Ipv6Addr 
fmt::Display for JoinPathsError			impl fmt::Display for JoinPathsError 
fmt::Display for JoinPathsError			impl fmt::Display for JoinPathsError 
fmt::Display for JoinPathsError			impl fmt::Display for JoinPathsError 
fmt::Display for MapError			impl fmt::Display for MapError 
fmt::Display for NulError			impl fmt::Display for NulError 
fmt::Display for PoisonError			impl<T> fmt::Display for PoisonError<T> 
fmt::Display for ProcessExit			impl fmt::Display for ProcessExit 
fmt::Display for RecvError			impl fmt::Display for RecvError 
fmt::Display for SendError			impl<T> fmt::Display for SendError<T> 
fmt::Display for SocketAddr			impl fmt::Display for SocketAddr 
fmt::Display for SocketAddr			impl fmt::Display for SocketAddr 
fmt::Display for TryLockError			impl<T> fmt::Display for TryLockError<T> 
fmt::Display for TryRecvError			impl fmt::Display for TryRecvError 
fmt::Display for TrySendError			impl<T> fmt::Display for TrySendError<T> 
fmt::Display for VarError			impl fmt::Display for VarError 
fmt::Write for Adaptor			        impl<'a, T: Write + ?Sized> fmt::Write for Adaptor<'a, T> 
fmt::Write for Adaptor			        impl<'a, T: ?Sized + Writer> fmt::Write for Adaptor<'a, T> 
fmt::Write for BufWriter			    impl<'a> fmt::Write for BufWriter<'a> 
fmt::Write for Stdio			impl fmt::Write for Stdio 
fmt_subslice			                    fn fmt_subslice(segments: &[u16]) -> String 
foo			        fn foo() -> Foo 
forget			    fn forget() 
forget			    pub fn forget(mut self) 
formatted			    fn formatted() 
fract			    fn fract(self) -> f32 { num::Float::fract(self) }
fract			    fn fract(self) -> f64 { num::Float::fract(self) }
fract			    fn fract(self) -> Self;
free_handle			fn free_handle(handle: *mut ()) 
freeaddrinfo			    fn freeaddrinfo(res: *mut libc::addrinfo);
freeaddrinfo			    fn freeaddrinfo(res: *mut libc::addrinfo);
frequency			fn frequency() -> libc::LARGE_INTEGER 
frexp			    fn frexp(self) -> (f32, int) 
frexp			        pub fn frexp(n: c_double, value: &mut c_int) -> c_double;
frexp			    fn frexp(self) -> (f64, int) 
frexp			    fn frexp(self) -> (Self, isize);
frexpf			        pub fn frexpf(n: c_float, value: &mut c_int) -> c_float;
frob			    fn frob() 
from_bytes			    fn from_bytes(slice: &[u8]) -> &OsStr 
from_bytes			    fn from_bytes(slice: &[u8]) -> &OsStr;
from_char			    pub fn from_char(value: char) -> CodePoint 
from_errno			    pub fn from_errno(errno: i32, detail: bool) -> IoError 
from_error			    fn from_error(_: NulError) -> io::Error 
from_error			    fn from_error(_: NulError) -> old_io::IoError 
from_error			    fn from_error(iie: IntoInnerError<W>) -> Error { iie.1 }
from_error			    fn from_error(err: PoisonError<T>) -> TryLockError<T> 
from_fd			    pub fn from_fd(fd: libc::c_int) -> AnonPipe 
from_fd			    pub fn from_fd(fd: libc::c_int) -> AnonPipe 
from_filedesc			    pub fn from_filedesc(fd: FileDesc) -> PipeStream 
from_fn			    pub fn from_fn<F>(f: F) -> Future<A>
from_i64			        fn from_i64(n: i64) -> Option<Value> { Some(Value { x: n as isize }) }
from_inner			    fn from_inner(buf: Buf) -> OsString 
from_inner			    fn from_inner(f: fs_imp::FilePermissions) -> Permissions 
from_inner			    fn from_inner(addr: libc::sockaddr_in) -> SocketAddr 
from_inner			    fn from_inner(addr: libc::sockaddr_in6) -> SocketAddr 
from_inner			    fn from_inner(addr: libc::in6_addr) -> Ipv6Addr 
from_inner			    fn from_inner(addr: libc::in_addr) -> Ipv4Addr 
from_inner			    fn from_inner(inner: Inner) -> Self;
from_inner			    fn from_inner(mode: i32) -> FilePermissions 
from_iter			    fn from_iter<T: IntoIterator<Item=(K, V)>>(iterable: T) -> HashMap<K, V, S> 
from_iter			    fn from_iter<I: IntoIterator<Item=T>>(iterable: I) -> HashSet<T, S> 
from_iter			    fn from_iter<I: IntoIterator<Item = &'a P>>(iter: I) -> PathBuf 
from_iter			    fn from_iter<T: IntoIterator<Item=CodePoint>>(iter: T) -> Wtf8Buf 
from_os_error			    pub fn from_os_error(code: i32) -> Error 
from_ptr			    pub unsafe fn from_ptr<'a>(ptr: *const libc::c_char) -> &'a CStr 
from_receiver			    pub fn from_receiver(rx: Receiver<A>) -> Future<A> 
from_seed			    fn from_seed(seed: &'a [usize]) -> StdRng 
from_slice			    pub fn from_slice(v: &[u8]) -> CString 
from_str			    pub fn from_str(s: &str) -> &OsStr 
from_str			    pub fn from_str(s: &str) -> OsString 
from_str			    fn from_str(s: &str) -> Result<IpAddr, ParseError> 
from_str			    fn from_str(s: &str) -> Result<Ipv4Addr, ParseError> 
from_str			    fn from_str(s: &str) -> Result<Ipv6Addr, ParseError> 
from_str			    fn from_str(s: &str) -> Result<SocketAddr, ParseError> 
from_str			    fn from_str<T: ::str::FromStr>(t: &str) -> Option<T> 
from_str			    fn from_str<T: ::str::FromStr>(t: &str) -> Option<T> 
from_str			    fn from_str(s: &str) -> Result<IpAddr, ParseError> 
from_str			    fn from_str(s: &str) -> Result<SocketAddr, ParseError> 
from_str			    fn from_str(s: &str) -> Result<Path, ParsePathError> 
from_str			    fn from_str(s: &str) -> Result<Path, ParsePathError> 
from_str			    pub fn from_str(str: &str) -> Wtf8Buf 
from_str			    pub fn from_str(value: &str) -> &Wtf8 
from_str			    pub fn from_str(s: &str) -> &Slice 
from_str			    pub fn from_str(s: &str) -> Buf 
from_str			    pub fn from_str(s: &str) -> &Slice 
from_str			    pub fn from_str(s: &str) -> Buf 
from_string			    pub fn from_string(s: String) -> OsString 
from_string			    pub fn from_string(string: String) -> Wtf8Buf 
from_string			    pub fn from_string(s: String) -> Buf 
from_string			    pub fn from_string(s: String) -> Buf 
from_u32			    pub fn from_u32(value: u32) -> Option<CodePoint> 
from_u32_unchecked			    pub unsafe fn from_u32_unchecked(value: u32) -> CodePoint 
from_u64			        fn from_u64(n: u64) -> Option<Value> { Some(Value { x: n as isize }) }
from_u8_slice			    unsafe fn from_u8_slice(s: &[u8]) -> &Path 
from_u8_slice			    fn from_u8_slice(s: &[u8]) -> &Slice 
from_utf8			        fn from_utf8(s: &[u8]) -> Option<&str> 
from_value			    pub fn from_value(val: A) -> Future<A> 
from_vec			    pub fn from_vec(v: Vec<u8>) -> CString 
from_vec			    pub fn from_vec(buf: Vec<u8>) -> MemWriter 
from_vec			    fn from_vec(vec: Vec<u8>) -> OsString 
from_vec			    fn from_vec(vec: Vec<u8>) -> Self;
from_vec_unchecked			    pub unsafe fn from_vec_unchecked(mut v: Vec<u8>) -> CString 
from_wide			    pub fn from_wide(v: &[u16]) -> Wtf8Buf 
from_wide			    fn from_wide(wide: &[u16]) -> OsString 
from_wide			    fn from_wide(wide: &[u16]) -> Self;
fs			pub mod fs;
fs			pub mod fs;
fs			pub mod fs;  \/\/ support for std::old_io
fs			pub mod fs;
fs2			pub mod fs2; \/\/ support for std::fs
fs2			pub mod fs2;
fstat			    pub fn fstat(&self) -> IoResult<FileStat> 
fstat			    pub fn fstat(&self) -> IoResult<old_io::FileStat> 
fsync			    pub fn fsync(&mut self) -> IoResult<()> 
fsync			    pub fn fsync(&self) -> IoResult<()> 
fsync			    pub fn fsync(&self) -> io::Result<()> 
fsync			    pub fn fsync(&mut self) -> IoResult<()> 
fsync			    pub fn fsync(&self) -> io::Result<()> 
full			    pub fn full(&self) -> &FullBucket<K, V, M> 
future			mod future;
gai_strerror			    pub fn gai_strerror(errcode: libc::c_int) -> *const libc::c_char;
gai_strerror			    fn gai_strerror(errcode: libc::c_int) -> *const libc::c_char;
gap_peek			    pub fn gap_peek(self) -> Option<GapThenFull<K, V, M>> 
ge			    fn ge(&self, other: &OsStr) -> bool { self.bytes().ge(other.bytes()) }
ge			    fn ge(&self, other: &OsString) -> bool { &**self >= &**other }
ge			    fn ge(&self, other: &Wtf8) -> bool { self.bytes.ge(&other.bytes) }
gen			    fn gen(_stat: &libc::stat) -> u64 { 0 }
gen			    fn gen(stat: &libc::stat) -> u64 { stat.st_gen as u64 }
get			    pub fn get(&self) -> &V 
get			    pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, K, V>> 
get			    pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>
get			    pub fn get(&mut self) -> A 
get			    pub fn get(&self) -> bool 
get			    pub fn get(&self) -> *mut u8 
get			    pub unsafe fn get(&self) -> *mut u8 { imp::get(self.key()) }
get			pub unsafe fn get(key: Key) -> *mut u8 
get			pub unsafe fn get(key: Key) -> *mut u8 
get			        pub unsafe fn get(&'static self) -> Option<&'static T> 
get			        pub unsafe fn get(&self) -> *mut T { *self.inner.get() }
get			        pub unsafe fn get(&self) -> *mut T { self.inner.get() as *mut _ }
get_address_name			pub fn get_address_name(addr: IpAddr) -> IoResult<String> 
get_address_name			pub fn get_address_name(addr: IpAddr) -> Result<String, IoError> 
get_creation_disposition			    fn get_creation_disposition(&self) -> libc::DWORD 
get_desired_access			    fn get_desired_access(&self) -> libc::DWORD 
get_env_map			    fn get_env_map<'a>(&'a mut self) -> &'a mut EnvMap 
get_exit_status			pub fn get_exit_status() -> i32 
get_exit_status			pub fn get_exit_status() -> int 
get_fd			        fn get_fd(file: &File) -> libc::HANDLE 
get_fd			        fn get_fd(file: &File) -> libc::c_int 
get_flags_and_attributes			    fn get_flags_and_attributes(&self) -> libc::DWORD 
get_global_ptr			    fn get_global_ptr() -> *mut Option<Box<Vec<Vec<u8>>>> 
get_host_addresses			pub fn get_host_addresses(host: &str) -> IoResult<Vec<IpAddr>> 
get_host_addresses			pub fn get_host_addresses(host: Option<&str>, servname: Option<&str>,
get_mut			    pub fn get_mut(&mut self) -> &mut V 
get_mut			    pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>
get_mut			    fn get_mut(&mut self) -> &mut BufWriter<W> 
get_mut			    pub fn get_mut(&mut self) -> &mut R { &mut self.inner }
get_mut			    pub fn get_mut(&mut self) -> &mut S 
get_mut			    pub fn get_mut(&mut self) -> &mut W { self.inner.as_mut().unwrap() }
get_mut			    pub fn get_mut(&mut self) -> &mut T { &mut self.inner }
get_mut			    fn get_mut<'a>(&'a mut self) -> &'a mut BufferedWriter<W> 
get_mut			    pub fn get_mut(&mut self) -> &mut R { &mut self.inner }
get_mut			    pub fn get_mut(&mut self) -> &mut S 
get_mut			    pub fn get_mut(&mut self) -> &mut W { self.inner.as_mut().unwrap() }
get_mut			    pub fn get_mut(&mut self) -> &mut T { &mut self.guard }
get_ref			    pub fn get_ref(&self) -> &R { &self.inner }
get_ref			    pub fn get_ref(&self) -> &S 
get_ref			    pub fn get_ref(&self) -> &W { self.inner.as_ref().unwrap() }
get_ref			    pub fn get_ref<'a>(&'a self) -> &'a W { self.inner.get_ref() }
get_ref			    pub fn get_ref(&self) -> &T { &self.inner }
get_ref			    pub fn get_ref(&self) -> &S 
get_ref			    pub fn get_ref(&self) -> &W { self.inner.as_ref().unwrap() }
get_ref			    pub fn get_ref<'a>(&'a self) -> &'a W { self.inner.get_ref() }
get_ref			    pub fn get_ref<'a>(&self) -> &R { &self.inner }
get_ref			    pub fn get_ref<'a>(&'a self) -> &'a [u8] { &self.buf }
get_ref			    pub fn get_ref<'a>(&'a mut self) -> &'a A 
get_ref			    pub fn get_ref(&self) -> &T { &self.guard }
get_remove_insert			fn get_remove_insert(b: &mut Bencher) 
get_share_mode			    fn get_share_mode(&self) -> libc::DWORD 
get_sp_limit			            fn get_sp_limit() -> *const c_void;
get_sp_limit			pub unsafe fn get_sp_limit() -> uint 
get_stack_start			    unsafe fn get_stack_start() -> *mut libc::c_void 
get_winsize			    pub fn get_winsize(&mut self) -> IoResult<(int, int)> 
get_winsize			    pub fn get_winsize(&mut self) -> IoResult<(int, int)> 
getaddrinfo			    fn getaddrinfo(node: *const c_char, service: *const c_char,
getaddrinfo			    fn getaddrinfo(node: *const c_char, service: *const c_char,
getcwd			pub fn getcwd() -> IoResult<Path> 
getcwd			pub fn getcwd() -> io::Result<PathBuf> 
getcwd			pub fn getcwd() -> io::Result<PathBuf> 
getdtablesize			        unsafe fn getdtablesize() -> c_int 
getdtablesize			        unsafe fn getdtablesize() -> c_int 
getenv			pub fn getenv(n: &str) -> Option<String> 
getenv			pub fn getenv(k: &OsStr) -> Option<OsString> 
getenv			pub fn getenv(k: &OsStr) -> Option<OsString> 
getenv_as_bytes			pub fn getenv_as_bytes(n: &str) -> Option<Vec<u8>> 
getenv_nonempty			    fn getenv_nonempty(v: &str) -> Option<Path> 
getnameinfo			    fn getnameinfo(sa: *const libc::sockaddr, salen: libc::socklen_t,
getpwuid_r			    pub fn getpwuid_r(uid: libc::uid_t,
getrandom			    fn getrandom(_buf: &mut [u8]) -> libc::c_long { -1 }
getrandom			    fn getrandom(buf: &mut [u8]) -> libc::c_long 
getrandom_fill_bytes			    fn getrandom_fill_bytes(v: &mut [u8]) 
getrandom_next_u32			    fn getrandom_next_u32() -> u32 
getrandom_next_u64			    fn getrandom_next_u64() -> u64 
getrlimit			        fn getrlimit(resource: libc::c_int, rlp: *mut rlimit) -> libc::c_int;
getsockopt			pub fn getsockopt<T: Copy>(fd: sock_t, opt: libc::c_int,
getsockopt			fn getsockopt<T: Copy>(sock: &Socket, opt: c_int,
getsockopt			    pub fn getsockopt(sockfd: libc::c_int,
getsockopt			    pub fn getsockopt(sockfd: libc::SOCKET,
gettimeofday			    pub fn gettimeofday(timeval: *mut libc::timeval,
gettimeofday			    pub fn gettimeofday(tp: *mut libc::timeval,
gid			    fn gid(&self) -> Option<uint> 
gid			    pub fn gid<'a>(&'a mut self, id: uint) -> &'a mut Command 
gid			    fn gid(&self) -> Option<uint>;
gid			    fn gid(&mut self, id: gid_t) -> &mut process::Command 
gid			    fn gid(&mut self, id: gid_t) -> &mut process::Command;
granularity			    pub fn granularity() -> uint 
grow_by_insertion			fn grow_by_insertion(b: &mut Bencher) 
gt			    fn gt(&self, other: &OsStr) -> bool { self.bytes().gt(other.bytes()) }
gt			    fn gt(&self, other: &OsString) -> bool { &**self > &**other }
gt			    fn gt(&self, other: &Wtf8) -> bool { self.bytes.gt(&other.bytes) }
guard			pub mod guard 
guard			pub mod guard 
guard_lock			pub fn guard_lock<'a, T>(guard: &MutexGuard<'a, T>) -> &'a sys::Mutex 
guard_poison			pub fn guard_poison<'a, T>(guard: &MutexGuard<'a, T>) -> &'a poison::Flag 
handle			    pub fn handle<'a, T: Send>(&'a self, rx: &'a Receiver<T>) -> Handle<'a, T> 
handle			    pub fn handle(&self) -> libc::HANDLE 
handle			    pub fn handle(&self) -> &RawHandle { &self.handle }
handle			pub mod handle;
handle			    fn handle(&self) -> libc::HANDLE { let Event(handle) = *self; handle }
handle			    pub fn handle(&self) -> libc::HANDLE { self.inner.handle }
handle			    pub fn handle(&self) -> libc::HANDLE 
handle			    pub fn handle(&self) -> c::WSAEVENT { let Event(handle) = *self; handle }
hard_link			pub fn hard_link<P: AsPath + ?Sized, Q: AsPath + ?Sized>(src: &P, dst: &Q)
has_implicit_root			    fn has_implicit_root(&self) -> bool 
has_nonsemantic_trailing_slash			    fn has_nonsemantic_trailing_slash(&self) -> bool 
has_physical_root			fn has_physical_root(s: &[u8], prefix: Option<Prefix>) -> bool 
has_root			    fn has_root(&self) -> bool 
has_root			    pub fn has_root(&self) -> bool 
has_suffix			fn has_suffix(s: &[u8], prefix: Option<Prefix>) -> bool 
hash			    pub fn hash(&self) -> SafeHash 
hash			mod hash;
hash			    fn hash<H: Hasher>(&self, state: &mut H) 
hash			    fn hash<H: hash::Hasher>(&self, s: &mut H) 
hash			    fn hash<H: hash::Hasher>(&self, s: &mut H) 
hash			    fn hash<H: hash::Hasher>(&self, state: &mut H) 
hash			    fn hash<H: hash::Hasher>(&self, state: &mut H) 
hash			    fn hash<H: hash::Hasher>(&self, _: &mut H) 
hash			    fn hash<H: hash::Hasher>(&self, state: &mut H) 
hash			    fn hash<H: Hasher>(&self, state: &mut H) 
hash::Hash for EnvKey			impl hash::Hash for EnvKey 
hash::Hash for Ipv4Addr			impl hash::Hash for Ipv4Addr 
hash::Hash for Ipv6Addr			impl hash::Hash for Ipv6Addr 
hash::Hash for Path			impl hash::Hash for Path 
hash::Hash for Path			impl hash::Hash for Path 
hash::Hash for Repr			impl hash::Hash for Repr 
hash_map			pub mod hash_map 
hash_set			pub mod hash_set 
hash_state			pub mod hash_state 
hasher			    fn hasher(&self) -> SipHasher 
hasher			    fn hasher(&self) -> H { Default::default() }
hasher			    fn hasher(&self) -> Self::Hasher;
hashmap			    fn hashmap() 
hashmap_as_queue			fn hashmap_as_queue(b: &mut Bencher) 
helper			fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) 
helper			fn helper(input: libc::HANDLE, messages: Receiver<Req>, _: ()) 
helper_signal			pub mod helper_signal;
helper_signal			pub mod helper_signal;
helper_thread			pub mod helper_thread;
hexify			    fn hexify(b: u8) -> u8 
home_dir			pub fn home_dir() -> Option<PathBuf> 
home_dir			pub fn home_dir() -> Option<PathBuf> 
home_dir			pub fn home_dir() -> Option<PathBuf> 
homedir			    fn homedir() 
homedir			pub fn homedir() -> Option<Path> 
hours			    pub fn hours(hours: i64) -> Duration 
hton			fn hton<I: Int>(i: I) -> I { i.to_be() }
hton			fn hton<I: Int>(i: I) -> I { i.to_be() }
htons			pub fn htons(u: u16) -> u16 
hypot			    fn hypot(self, other: f32) -> f32 
hypot			        pub fn hypot(x: c_double, y: c_double) -> c_double;
hypot			    fn hypot(self, other: f64) -> f64 
hypot			    fn hypot(self, other: Self) -> Self;
hypotf			        pub fn hypotf(x: c_float, y: c_float) -> c_float;
id			    pub fn id(&self) -> libc::pid_t { self.handle.id() }
id			    pub fn id(&self) -> usize { self.id }
id			    pub fn id(&self) -> pid_t 
id			    pub fn id(&self) -> pid_t 
id			    pub fn id(&self) -> pid_t 
ilogb			        pub fn ilogb(n: c_double) -> c_int;
ilogbf			        pub fn ilogbf(n: c_float) -> c_int;
imp			mod imp 
imp			mod imp 
imp			    mod imp 
imp			    mod imp 
imp			mod imp 
imp			mod imp 
imp			mod imp 
imp			mod imp 
impls			mod impls;
in_ms_u64			fn in_ms_u64(d: Duration) -> u64 
inc			        fn inc() 
incoming			    pub fn incoming(&self) -> Incoming 
incoming			    fn incoming<'r>(&'r mut self) -> IncomingConnections<'r, Self> 
index			    fn index<'a>(&'a self, index: &Q) -> &'a V 
index			    pub fn index(&self) -> usize 
index			    fn index(&self, _index: &ops::RangeFull) -> &OsStr 
index			    fn index(&self, _range: &ops::RangeFull) -> &Wtf8 
index			    fn index(&self, range: &ops::Range<usize>) -> &Wtf8 
index			    fn index(&self, range: &ops::RangeFrom<usize>) -> &Wtf8 
index			    fn index(&self, range: &ops::RangeTo<usize>) -> &Wtf8 
index_mut			    fn index_mut<'a>(&'a mut self, index: &Q) -> &'a mut V 
infinity			    fn infinity() -> f32 { num::Float::infinity() }
infinity			    fn infinity() -> f64 { num::Float::infinity() }
infinity			    fn infinity() -> Self;
info			    fn info() -> &'static libc::mach_timebase_info 
inherit			    pub fn inherit() -> Stdio { Stdio(StdioImp::Inherit) }
inherit_blocker			    pub fn inherit_blocker(&mut self,
init			    pub unsafe fn init(_argc: int, _argv: *const *const u8) 
init			    pub unsafe fn init(argc: int, argv: *const *const u8) 
init			pub unsafe fn init(argc: int, argv: *const *const u8) { imp::init(argc, argv) }
init			unsafe fn init() 
init			pub fn init() {}
init			    pub unsafe fn init() 
init			    pub unsafe fn init() 
init			pub fn init() 
init			pub unsafe fn init() 
init			    pub unsafe fn init() 
init			    unsafe fn init(&self, slot: &UnsafeCell<Option<T>>) -> &T 
init_dtors			unsafe fn init_dtors() 
init_env_map			    fn init_env_map(&mut self) 
init_env_map			    fn init_env_map(&mut self)
init_frame			    pub fn init_frame(frame: &mut super::STACKFRAME64,
init_net			pub fn init_net() {}
init_net			pub fn init_net() 
init_state			    unsafe fn init_state() -> *mut backtrace_state 
initial_trail_surrogate			    fn initial_trail_surrogate(&self) -> Option<u16> 
inner			        extern "C" fn inner(
inner			    unsafe fn inner<'a>(&'a self) -> &'a Flavor<T> 
inner			mod inner 
inner			    fn inner(&mut self) -> Box<Inner> 
inner_mut			    unsafe fn inner_mut<'a>(&'a self) -> &'a mut Flavor<T> 
inner_unsafe			    fn inner_unsafe<'a>(&'a self) -> &'a UnsafeCell<Flavor<T>> 
inner_unsafe			    fn inner_unsafe<'a>(&'a self) -> &'a UnsafeCell<Flavor<T>>;
insert			    pub fn insert(&mut self, k: K, v: V) -> Option<V> 
insert			    pub fn insert(&mut self, mut value: V) -> V 
insert			    pub fn insert(self, value: V) -> &'a mut V 
insert			    pub fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()).is_none() }
insert			    fn insert(t: Box<Inner>, active: &mut Vec<Box<Inner>>) 
insert_hashed_nocheck			    fn insert_hashed_nocheck(&mut self, hash: SafeHash, k: K, v: V) -> &mut V 
insert_hashed_ordered			    fn insert_hashed_ordered(&mut self, hash: SafeHash, k: K, v: V) 
insert_or_replace_with			    fn insert_or_replace_with<'a, F>(&'a mut self,
inspect			    pub fn inspect(&self) -> u64 { self.hash }
int			    mod int 
int_macros			mod int_macros;
int_to_str_bytes_common			fn int_to_str_bytes_common<T, F>(num: T, radix: uint, sign: SignFormat, mut f: F) where
integer_decode			    fn integer_decode(self) -> (u64, i16, i8) { num::Float::integer_decode(self) }
integer_decode			    fn integer_decode(self) -> (u64, i16, i8) { num::Float::integer_decode(self) }
integer_decode			    fn integer_decode(self) -> (u64, i16, i8);
intersection			    pub fn intersection<'a>(&'a self, other: &'a HashSet<T, S>) -> Intersection<'a, T, S> 
into_ascii_lowercase			    fn into_ascii_lowercase(mut self) -> Vec<u8> 
into_ascii_lowercase			    fn into_ascii_lowercase(self) -> Self;
into_ascii_lowercase			    fn into_ascii_lowercase(self) -> String 
into_ascii_uppercase			    fn into_ascii_uppercase(mut self) -> Vec<u8> 
into_ascii_uppercase			    fn into_ascii_uppercase(self) -> Self;
into_ascii_uppercase			    fn into_ascii_uppercase(self) -> String 
into_bucket			    pub fn into_bucket(self) -> Bucket<K, V, M> 
into_bytes			    fn into_bytes(self) -> Vec<u8> { self }
into_bytes			    fn into_bytes(self) -> Vec<u8> { self.as_bytes().to_vec() }
into_bytes			    fn into_bytes(self) -> Vec<u8> { self.into_bytes() }
into_bytes			    fn into_bytes(self) -> Vec<u8> { self.to_vec() }
into_bytes			    fn into_bytes(self) -> Vec<u8>;
into_guard			    pub fn into_guard(self) -> T { self.guard }
into_inner			    fn into_inner(self) -> Buf 
into_inner			    pub fn into_inner(mut self) -> Result<W, IntoInnerError<BufWriter<W>>> 
into_inner			    pub fn into_inner(self) -> R { self.inner }
into_inner			    pub fn into_inner(self) -> Result<S, IntoInnerError<BufStream<S>>> 
into_inner			    pub fn into_inner(self) -> Result<W, IntoInnerError<LineWriter<W>>> 
into_inner			    pub fn into_inner(self) -> W { self.0 }
into_inner			    pub fn into_inner(self) -> T { self.inner }
into_inner			    fn into_inner(self) -> (*const libc::sockaddr, socklen_t) 
into_inner			    pub fn into_inner(mut self) -> W 
into_inner			    pub fn into_inner(self) -> R { self.inner }
into_inner			    pub fn into_inner(self) -> S 
into_inner			    pub fn into_inner(self) -> W { self.inner.into_inner() }
into_inner			    pub fn into_inner(self) -> Vec<u8> { self.buf }
into_inner			    pub fn into_inner(self) -> Path 
into_inner			    pub fn into_inner(self) -> (R, W) 
into_inner			    pub fn into_inner(self) -> R { self.inner }
into_inner			    pub fn into_inner(mut self) -> A 
into_inner			    pub fn into_inner(self) -> T { self.guard }
into_inner			    fn into_inner(self) -> Inner;
into_iter			    fn into_iter(mut self) -> IterMut<'a, K, V> 
into_iter			    fn into_iter(self) -> IntoIter<K, V> 
into_iter			    fn into_iter(self) -> Iter<'a, K, V> 
into_iter			    pub fn into_iter(self) -> IntoIter<K, V> 
into_iter			    fn into_iter(self) -> IntoIter<T> 
into_iter			    fn into_iter(self) -> Iter<'a, T> 
into_iter			    pub fn into_iter(self) -> IntoIter<T> 
into_iter			    pub fn into_iter(self) -> IntoIter<K, V> 
into_mut			    pub fn into_mut(self) -> &'a mut V 
into_mut_refs			    pub fn into_mut_refs(self) -> (&'t mut K, &'t mut V) 
into_option			    fn into_option(self) -> Option<FullBucket<K, V, M>> 
into_os_string			    pub fn into_os_string(self) -> OsString 
into_path			    pub fn into_path(mut self) -> PathBuf 
into_raw			    pub fn into_raw(self) -> c_int 
into_refs			    pub fn into_refs(self) -> (&'t K, &'t V) 
into_string			    pub fn into_string(self) -> Result<String, OsString> 
into_string			    pub fn into_string(self) -> Result<String, Wtf8Buf> 
into_string			    pub fn into_string(self) -> Result<String, Buf> 
into_string			    pub fn into_string(self) -> Result<String, Buf> 
into_string_lossy			    pub fn into_string_lossy(mut self) -> String 
into_table			    pub fn into_table(self) -> M 
into_vec			    pub fn into_vec(self) -> Vec<u8> { self.1 }
into_vec			    fn into_vec(self) -> Vec<u8>;
into_vec			    fn into_vec(self) -> Vec<u8> 
into_vec			    fn into_vec(self) -> Vec<u8> 
into_vec			    fn into_vec(self) -> Vec<u8> 
into_vec			    fn into_vec(self) -> Vec<u8>;
invalid_encoding			fn invalid_encoding() -> IoError 
invalid_path_raises			    fn invalid_path_raises() 
invalid_path_raises			    fn invalid_path_raises() 
invoke			    fn invoke(self: Box<F>, arg: A) -> R 
invoke			    fn invoke(self: Box<Self>, arg: A) -> R;
invoke			    pub fn invoke(self, arg: A) -> R 
io			pub mod io;
io::Seek for Cursor			impl io::Seek for Cursor<Vec<u8>> { seek!(); }
io::Seek for Cursor			impl<'a> io::Seek for Cursor<&'a [u8]> { seek!(); }
io::Seek for Cursor			impl<'a> io::Seek for Cursor<&'a mut [u8]> { seek!(); }
io_read_at_least			    fn io_read_at_least() 
ioctl			    pub fn ioctl(fd: libc::c_int, req: libc::c_ulong, ...) -> libc::c_int;
ioctlsocket			    pub fn ioctlsocket(s: libc::SOCKET, cmd: libc::c_long,
ip			    pub fn ip(&self) -> IpAddr 
ip			mod ip;
ip			pub mod ip;
ip_to_inaddr			pub fn ip_to_inaddr(ip: IpAddr) -> InAddr 
ipv4_properties			    fn ipv4_properties() 
ipv4_to_ipv6			    fn ipv4_to_ipv6() 
ipv6_addr_from_head_tail			        fn ipv6_addr_from_head_tail(head: &[u16], tail: &[u16]) -> Ipv6Addr 
ipv6_addr_from_head_tail			        fn ipv6_addr_from_head_tail(head: &[u16], tail: &[u16]) -> IpAddr 
ipv6_addr_to_string			    fn ipv6_addr_to_string() 
ipv6_addr_to_string			    fn ipv6_addr_to_string() 
ipv6_properties			    fn ipv6_properties() 
ipv6_to_ipv4			    fn ipv6_to_ipv4() 
is_absolute			    fn is_absolute(&self) -> bool;
is_absolute			    fn is_absolute(&self) -> bool 
is_absolute			    fn is_absolute(&self) -> bool 
is_absolute			    pub fn is_absolute(&self) -> bool 
is_ancestor_of			    fn is_ancestor_of(&self, other: &Self) -> bool;
is_ancestor_of			    fn is_ancestor_of(&self, other: &Path) -> bool 
is_ancestor_of			    fn is_ancestor_of(&self, other: &Path) -> bool 
is_ancestor_of_path_with_10_dirs			    fn is_ancestor_of_path_with_10_dirs(b: &mut Bencher) 
is_ascii			    fn is_ascii(&self) -> bool { *self & 128 == 0u8 }
is_ascii			    fn is_ascii(&self) -> bool 
is_ascii			    fn is_ascii(&self) -> bool;
is_ascii			    fn is_ascii(&self) -> bool 
is_code_point_boundary			pub fn is_code_point_boundary(slice: &Wtf8, index: uint) -> bool 
is_colon			    fn is_colon(b: &u8) -> bool { *b == b':' }
is_cwd_relative			pub fn is_cwd_relative(path: &Path) -> bool 
is_dir			    fn is_dir(&self) -> bool 
is_dir			    fn is_dir(&self) -> bool;
is_dir			    pub fn is_dir(&self) -> bool { self.0.is_dir() }
is_dir			    fn is_dir(&self) -> bool 
is_dir			    fn is_dir(&self) -> bool;
is_dir			    pub fn is_dir(&self) -> bool 
is_dir			    pub fn is_dir(&self) -> bool 
is_disjoint			    pub fn is_disjoint(&self, other: &HashSet<T, S>) -> bool 
is_drive			    fn is_drive(&self) -> bool 
is_empty			    pub fn is_empty(&self) -> bool { self.len() == 0 }
is_empty			    pub fn is_empty(&self) -> bool { self.map.len() == 0 }
is_eof			    fn is_eof(&self) -> bool 
is_eof			    fn is_eof(&self) -> bool 
is_file			    fn is_file(&self) -> bool 
is_file			    fn is_file(&self) -> bool;
is_file			    pub fn is_file(&self) -> bool { self.0.is_file() }
is_file			    fn is_file(&self) -> bool 
is_file			    fn is_file(&self) -> bool;
is_file			    pub fn is_file(&self) -> bool 
is_file			    pub fn is_file(&self) -> bool 
is_finite			    fn is_finite(self) -> bool { num::Float::is_finite(self) }
is_finite			    fn is_finite(self) -> bool { num::Float::is_finite(self) }
is_finite			    fn is_finite(self) -> bool;
is_getrandom_available			    fn is_getrandom_available() -> bool { false }
is_getrandom_available			    fn is_getrandom_available() -> bool 
is_global			    pub fn is_global(&self) -> bool 
is_infinite			    fn is_infinite(self) -> bool { num::Float::is_infinite(self) }
is_infinite			    fn is_infinite(self) -> bool { num::Float::is_infinite(self) }
is_infinite			    fn is_infinite(self) -> bool;
is_leader			    pub fn is_leader(&self) -> bool { self.0 }
is_link_local			    pub fn is_link_local(&self) -> bool 
is_loopback			    pub fn is_loopback(&self) -> bool 
is_multicast			    pub fn is_multicast(&self) -> bool 
is_nan			    fn is_nan(self) -> bool { num::Float::is_nan(self) }
is_nan			    fn is_nan(self) -> bool { num::Float::is_nan(self) }
is_nan			    fn is_nan(self) -> bool;
is_negative			    fn is_negative(self) -> bool { num::Float::is_negative(self) }
is_negative			    fn is_negative(self) -> bool { num::Float::is_negative(self) }
is_negative			    fn is_negative(self) -> bool;
is_normal			    fn is_normal(self) -> bool { num::Float::is_normal(self) }
is_normal			    fn is_normal(self) -> bool { num::Float::is_normal(self) }
is_normal			    fn is_normal(self) -> bool;
is_poisoned			    pub fn is_poisoned(&self) -> bool 
is_poisoned			    pub fn is_poisoned(&self) -> bool 
is_positive			    fn is_positive(self) -> bool { num::Float::is_positive(self) }
is_positive			    fn is_positive(self) -> bool { num::Float::is_positive(self) }
is_positive			    fn is_positive(self) -> bool;
is_private			    pub fn is_private(&self) -> bool 
is_relative			    fn is_relative(&self) -> bool 
is_relative			    fn is_relative(&self) -> bool 
is_relative			    pub fn is_relative(&self) -> bool 
is_sep			pub fn is_sep(c: char) -> bool 
is_sep			pub fn is_sep(c: char) -> bool 
is_sep_			        fn is_sep_(prefix: Option<PathPrefix>, u: u8) -> bool 
is_sep_byte			pub fn is_sep_byte(u: &u8) -> bool 
is_sep_byte			pub fn is_sep_byte(u: &u8) -> bool 
is_sep_byte			    fn is_sep_byte(&self, b: u8) -> bool 
is_sep_byte			    pub fn is_sep_byte(b: u8) -> bool 
is_sep_byte_verbatim			pub fn is_sep_byte_verbatim(u: &u8) -> bool 
is_sep_verbatim			pub fn is_sep_verbatim(c: char) -> bool 
is_separator			pub fn is_separator(c: char) -> bool 
is_set			    pub fn is_set(&'static self) -> bool 
is_str			    fn is_str(_: Option<& &'a T>) -> bool { BytesContainer::is_str(None::<&T>) }
is_str			    fn is_str(_: Option<&Self>) -> bool { false }
is_str			    fn is_str(_: Option<&String>) -> bool { true }
is_str			    fn is_str(_: Option<&str>) -> bool { true }
is_str			    fn is_str(_: Option<&Path>) -> bool { true }
is_subset			    pub fn is_subset(&self, other: &HashSet<T, S>) -> bool 
is_superset			    pub fn is_superset(&self, other: &HashSet<T, S>) -> bool 
is_tty			pub fn is_tty(fd: c_int) -> bool 
is_unicast_global			    pub fn is_unicast_global(&self) -> bool 
is_unicast_link_local			    pub fn is_unicast_link_local(&self) -> bool 
is_unicast_site_local			    pub fn is_unicast_site_local(&self) -> bool 
is_unique_local			    pub fn is_unique_local(&self) -> bool 
is_unspecified			    pub fn is_unspecified(&self) -> bool 
is_verbatim			pub fn is_verbatim(path: &Path) -> bool 
is_verbatim			    pub fn is_verbatim(&self) -> bool 
is_verbatim_sep			    pub fn is_verbatim_sep(b: u8) -> bool 
is_vol_abs			        fn is_vol_abs(path: &str, prefix: Option<PathPrefix>) -> bool 
is_vol_relative			pub fn is_vol_relative(path: &Path) -> bool 
is_zero			    pub fn is_zero(&self) -> bool 
isatty			    pub fn isatty(&self) -> bool 
isatty			    pub fn isatty(&self) -> bool { false }
issue_10663			    fn issue_10663() 
issue_15761			    fn issue_15761() 
iter			    pub fn iter(&self) -> Iter<K, V> 
iter			    pub fn iter(&self) -> Iter<T> 
iter			    pub fn iter(&self) -> Iter<K, V> 
iter			    pub fn iter(&self) -> Iter 
iter			    pub fn iter(&self) -> Iter<T> 
iter			    fn iter(&self) -> Packets { Packets { cur: self.head } }
iter::Extend for PathBuf			impl<'a, P: ?Sized + 'a> iter::Extend<&'a P> for PathBuf where P: AsPath 
iter::FromIterator for PathBuf			impl<'a, P: ?Sized + 'a> iter::FromIterator<&'a P> for PathBuf where P: AsPath 
iter_after			fn iter_after<A, I, J>(mut iter: I, mut prefix: J) -> Option<I> where
iter_mut			    pub fn iter_mut(&mut self) -> IterMut<K, V> 
iter_mut			    pub fn iter_mut(&mut self) -> IterMut<K, V> 
iter_reader_zero_length			    fn iter_reader_zero_length() 
j0			        pub fn j0(n: c_double) -> c_double;
j1			        pub fn j1(n: c_double) -> c_double;
jn			        pub fn jn(i: c_int, n: c_double) -> c_double;
join			        fn join(&self, path: &str) -> PathBuf 
join			        fn join(&self, path: &str) -> Path 
join			    fn join<T: BytesContainer>(&self, path: T) -> Self 
join			    pub fn join<P: ?Sized>(&self, path: &P) -> PathBuf where P: AsPath 
join			pub unsafe fn join(native: rust_thread) 
join			pub unsafe fn join(native: rust_thread) 
join			    fn join(&mut self) -> Result<T> 
join			    pub fn join(mut self) -> Result<()> 
join			    pub fn join(mut self) -> T 
join_abs_path_home_dir			    fn join_abs_path_home_dir(b: &mut Bencher) 
join_home_dir			    fn join_home_dir(b: &mut Bencher) 
join_many			    fn join_many<T: BytesContainer>(&self, paths: &[T]) -> Self 
join_many_abs_path_home_dir			    fn join_many_abs_path_home_dir(b: &mut Bencher) 
join_many_home_dir			    fn join_many_home_dir(b: &mut Bencher) 
join_multicast			    pub fn join_multicast(&self, multi: &IpAddr) -> io::Result<()> 
join_multicast			    pub fn join_multicast(&mut self, multi: IpAddr) -> IoResult<()> 
join_multicast			    pub fn join_multicast(&mut self, multi: IpAddr) -> IoResult<()> 
join_multicast			    pub fn join_multicast(&self, multi: &IpAddr) -> io::Result<()> 
join_paths			pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>
join_paths			pub fn join_paths<T: BytesContainer>(paths: &[T]) -> Result<Vec<u8>, &'static str> 
join_paths			pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>
join_paths			pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>
join_paths_unix			    fn join_paths_unix() 
join_paths_unix			    fn join_paths_unix() 
join_paths_windows			    fn join_paths_windows() 
join_paths_windows			    fn join_paths_windows() 
keep_going			pub fn keep_going<F>(data: &[u8], mut f: F) -> i64 where
kernel32			    pub mod kernel32 
key			    unsafe fn key(&self) -> imp::Key 
keys			    pub fn keys<'a>(&'a self) -> Keys<'a, K, V> 
kill			    pub fn kill(id: libc::pid_t, signal: int) -> IoResult<()> 
kill			    pub fn kill(&mut self) -> io::Result<()> 
kill			    pub unsafe fn kill(&self, signal: int) -> IoResult<()> 
kill			    pub unsafe fn kill(&self) -> io::Result<()> 
kill			    pub unsafe fn kill(&self, signal: int) -> IoResult<()> 
kill			    pub unsafe fn kill(&self) -> io::Result<()> 
killpid			    pub unsafe fn killpid(pid: pid_t, signal: int) -> IoResult<()> 
killpid			    pub unsafe fn killpid(pid: pid_t, signal: int) -> IoResult<()> 
kind			    pub fn kind(&self) -> ErrorKind 
kind			    pub fn kind(&self) -> MemoryMapKind { self.kind }
lang_start			fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int 
last_error			    pub fn last_error() -> IoError 
last_error			pub fn last_error() -> IoError 
last_error			pub fn last_error() -> IoError 
last_error			fn last_error() -> io::Error 
last_gai_error			pub fn last_gai_error(s: libc::c_int) -> IoError 
last_gai_error			pub fn last_gai_error(_errno: i32) -> IoError 
last_net_error			pub fn last_net_error() -> IoError 
last_net_error			pub fn last_net_error() -> IoError 
last_os_error			    pub fn last_os_error() -> Error 
last_os_error			    pub fn last_os_error() 
last_os_error			pub fn last_os_error() -> String 
last_two			        fn last_two<A, B, C>((_, b, c): (A, B, C)) -> (B, C) { (b, c) }
lazy_init			    unsafe fn lazy_init(&self) -> uint 
ldexp			    fn ldexp(x: f32, exp: int) -> f32 
ldexp			        pub fn ldexp(x: c_double, n: c_int) -> c_double;
ldexp			    fn ldexp(x: f64, exp: int) -> f64 
ldexp			    fn ldexp(x: Self, exp: isize) -> Self;
ldexpf			        pub fn ldexpf(x: c_float, n: c_int) -> c_float;
le			    fn le(&self, other: &OsStr) -> bool { self.bytes().le(other.bytes()) }
le			    fn le(&self, other: &OsString) -> bool { &**self <= &**other }
le			    fn le(&self, other: &Wtf8) -> bool { self.bytes.le(&other.bytes) }
leave_multicast			    pub fn leave_multicast(&self, multi: &IpAddr) -> io::Result<()> 
leave_multicast			    pub fn leave_multicast(&mut self, multi: IpAddr) -> IoResult<()> 
leave_multicast			    pub fn leave_multicast(&mut self, multi: IpAddr) -> IoResult<()> 
leave_multicast			    pub fn leave_multicast(&self, multi: &IpAddr) -> io::Result<()> 
len			    pub fn len(&self) -> usize { self.table.size() }
len			    fn len(&self) -> usize { self.iter.len() }
len			    pub fn len(&self) -> usize { self.map.len() }
len			    fn len(&self) -> usize { self.elems_left }
len			    fn len(&self) -> usize { self.table.size() }
len			    fn len(&self) -> usize { self.inner.len() }
len			    pub fn len(&self) -> u64 { self.0.size() }
len			    pub fn len(&self) -> uint { self.len }
len			    fn len(&self) -> usize 
len			    pub fn len(&self) -> uint 
len			    fn len(&self) -> usize { self.iter.len() }
len			    fn len(&self) -> usize { self.range.len() }
lgamma_r			        pub fn lgamma_r(n: c_double, sign: &mut c_int) -> c_double;
lgammaf_r			        pub fn lgammaf_r(n: c_float, sign: &mut c_int) -> c_float;
libunwind			mod libunwind;
limit			    pub fn limit(&self) -> u64 { self.limit }
limit			    pub fn limit(&self) -> uint { self.limit }
limit_reader_buffer			    fn limit_reader_buffer() 
limit_thread_creation_due_to_osx_and_valgrind			pub fn limit_thread_creation_due_to_osx_and_valgrind() -> bool 
lines			    fn lines() 
lines			    fn lines(self) -> Lines<Self> 
lines			    fn lines<'r>(&'r mut self) -> Lines<'r, Self>;
lines			    fn lines<'r>(&'r mut self) -> Lines<'r, T> 
link			pub fn link(src: &Path, dst: &Path) -> IoResult<()> 
link			pub fn link(src: &Path, dst: &Path) -> IoResult<()> 
link			pub fn link(src: &Path, dst: &Path) -> io::Result<()> 
link			pub fn link(src: &Path, dst: &Path) -> IoResult<()> 
link			pub fn link(src: &Path, dst: &Path) -> io::Result<()> 
links_work			    fn links_work() 
links_work			    fn links_work() 
listen			    fn listen(self) -> IoResult<A>;
listen			    fn listen(self) -> IoResult<UnixAcceptor> 
listen			    fn listen(self) -> IoResult<TcpAcceptor> 
listen			    fn listen(self) -> IoResult<A> 
listen			    pub fn listen(self) -> IoResult<UnixAcceptor> 
listen			    pub fn listen(self, backlog: int) -> IoResult<TcpAcceptor> 
listen			    pub fn listen(self) -> IoResult<UnixAcceptor> 
listen			    pub fn listen(self, backlog: int) -> IoResult<TcpAcceptor> 
listen_ip4_localhost			    fn listen_ip4_localhost() 
listen_localhost			    fn listen_localhost() 
ln			    fn ln(self) -> f32 { num::Float::ln(self) }
ln			    fn ln(self) -> f64 { num::Float::ln(self) }
ln			    fn ln(self) -> Self;
ln_1p			    fn ln_1p(self) -> f32 
ln_1p			    fn ln_1p(self) -> f64 
ln_1p			    fn ln_1p(self) -> Self;
load			                fn load() -> usize 
load_argc_and_argv			unsafe fn load_argc_and_argv(argc: int,
load_argc_and_argv			    unsafe fn load_argc_and_argv(argc: isize,
lock			    pub fn lock<'a>(&'a mut self) -> StdinReaderGuard<'a> 
lock			    pub fn lock(&'static self) -> LockResult<MutexGuard<()>> 
lock			    pub fn lock(&self) -> LockResult<MutexGuard<T>> 
lock			    pub unsafe fn lock(&self) { self.0.lock() }
lock			    pub unsafe fn lock(&self) 
lock			    pub unsafe fn lock(&self) 
lock_nonblocking			    fn lock_nonblocking(&self) {}
lock_nonblocking			    fn lock_nonblocking<'a>(&'a self) -> Guard<'a> 
lock_nonblocking			    fn lock_nonblocking(&self) {}
lock_nonblocking			    fn lock_nonblocking<'a>(&'a self) -> Guard<'a> 
log			    fn log(self, base: f32) -> f32 { num::Float::log(self, base) }
log			    fn log(self, base: f64) -> f64 { num::Float::log(self, base) }
log			    fn log(self, base: Self) -> Self;
log10			    fn log10(self) -> f32 { num::Float::log10(self) }
log10			    fn log10(self) -> f64 { num::Float::log10(self) }
log10			    fn log10(self) -> Self;
log1p			        pub fn log1p(n: c_double) -> c_double;
log1pf			        pub fn log1pf(n: c_float) -> c_float;
log2			    fn log2(self) -> f32 { num::Float::log2(self) }
log2			    fn log2(self) -> f64 { num::Float::log2(self) }
log2			    fn log2(self) -> Self;
log_enabled			pub fn log_enabled() -> bool 
logb			        pub fn logb(n: c_double) -> c_double;
logbf			        pub fn logbf(n: c_float) -> c_float;
lookup			fn lookup(hostname: Option<&str>, servname: Option<&str>, hint: Option<Hint>)
lookup			    fn lookup() -> Path 
lookup_host			pub fn lookup_host(host: &str) -> io::Result<LookupHost> 
lookup_host			pub fn lookup_host(host: &str) -> io::Result<LookupHost> 
lots_and_lots			    fn lots_and_lots() 
lstat			    fn lstat(path: &Path) -> io::Result<fs_imp::FileAttr> { fs_imp::lstat(path) }
lstat			    fn lstat(path: &Path) -> io::Result<fs_imp::FileAttr> { fs_imp::stat(path) }
lstat			    fn lstat(&self) -> IoResult<FileStat> { lstat(self) }
lstat			    fn lstat(&self) -> IoResult<FileStat>;
lstat			pub fn lstat(path: &Path) -> IoResult<FileStat> 
lstat			pub fn lstat(p: &Path) -> IoResult<FileStat> 
lstat			pub fn lstat(p: &Path) -> io::Result<FileAttr> 
lstat			pub fn lstat(_p: &Path) -> IoResult<FileStat> 
lt			    fn lt(&self, other: &OsStr) -> bool { self.bytes().lt(other.bytes()) }
lt			    fn lt(&self, other: &OsString) -> bool { &**self < &**other }
lt			    fn lt(&self, other: &Wtf8) -> bool { self.bytes.lt(&other.bytes) }
mach_absolute_time			        pub fn mach_absolute_time() -> u64;
mach_timebase_info			        pub fn mach_timebase_info(info: *mut libc::mach_timebase_info) -> libc::c_int;
macros			mod macros;
macros			mod macros;
main			    pub unsafe fn main() -> uint 
main			    pub unsafe fn main() -> uint 
make_absolute			pub fn make_absolute(p: &Path) -> IoResult<Path> 
make_ascii_lowercase			    fn make_ascii_lowercase(&mut self) { *self = self.to_ascii_lowercase(); }
make_ascii_lowercase			    fn make_ascii_lowercase(&mut self) 
make_ascii_lowercase			    fn make_ascii_lowercase(&mut self);
make_ascii_lowercase			    fn make_ascii_lowercase(&mut self) { self.bytes.make_ascii_lowercase() }
make_ascii_uppercase			    fn make_ascii_uppercase(&mut self) { *self = self.to_ascii_uppercase(); }
make_ascii_uppercase			    fn make_ascii_uppercase(&mut self) 
make_ascii_uppercase			    fn make_ascii_uppercase(&mut self);
make_ascii_uppercase			    fn make_ascii_uppercase(&mut self) { self.bytes.make_ascii_uppercase() }
make_command_line			fn make_command_line(prog: &CString, args: &[CString]) -> String 
make_command_line			fn make_command_line(prog: &OsStr, args: &[OsString]) -> Vec<u16> 
make_handler			    pub unsafe fn make_handler() -> Handler 
make_handler			    pub unsafe fn make_handler() -> super::Handler 
make_handler			pub unsafe fn make_handler() -> Handler 
make_hash			    fn make_hash<X: ?Sized>(&self, x: &X) -> SafeHash where X: Hash 
make_hash			pub fn make_hash<T: ?Sized, S>(hash_state: &S, t: &T) -> SafeHash
make_non_verbatim			pub fn make_non_verbatim(path: &Path) -> Option<Path> 
make_rand_name			    fn make_rand_name() -> OsString 
make_rand_name			    fn make_rand_name() -> String 
mantissa_digits			    fn mantissa_digits(unused_self: Option<f32>) -> uint 
mantissa_digits			    fn mantissa_digits(unused_self: Option<f64>) -> uint 
mantissa_digits			    fn mantissa_digits(unused_self: Option<Self>) -> usize;
map			pub mod map;
map			        fn map() -> RefCell<HashMap<i32, i32>> 
map_result			pub fn map_result<T, U, F>(result: LockResult<T>, f: F)
matches_exit_status			    pub fn matches_exit_status(&self, wanted: int) -> bool 
max			    fn max(self, other: f32) -> f32 
max			    fn max(self, other: f64) -> f64 
max			    fn max(self, other: Self) -> Self;
max_10_exp			    fn max_10_exp(unused_self: Option<f32>) -> int { num::Float::max_10_exp(unused_self) }
max_10_exp			    fn max_10_exp(unused_self: Option<f64>) -> int { num::Float::max_10_exp(unused_self) }
max_10_exp			    fn max_10_exp(unused_self: Option<Self>) -> isize;
max_exp			    fn max_exp(unused_self: Option<f32>) -> int { num::Float::max_exp(unused_self) }
max_exp			    fn max_exp(unused_self: Option<f64>) -> int { num::Float::max_exp(unused_self) }
max_exp			    fn max_exp(unused_self: Option<Self>) -> isize;
max_value			    fn max_value() -> f32 { num::Float::max_value() }
max_value			    fn max_value() -> f64 { num::Float::max_value() }
max_value			    fn max_value() -> Self;
max_value			    pub fn max_value() -> Duration { MAX }
mem			mod mem;
memory_map_file			    fn memory_map_file() 
memory_map_rw			    fn memory_map_rw() 
metadata			    fn metadata(&self) -> io::Result<Metadata> { metadata(self) }
metadata			    fn metadata(&self) -> io::Result<Metadata>;
metadata			    pub fn metadata(&self) -> io::Result<Metadata> 
metadata			pub fn metadata<P: AsPath + ?Sized>(path: &P) -> io::Result<Metadata> 
microseconds			    pub fn microseconds(microseconds: i64) -> Duration 
milliseconds			    pub fn milliseconds(milliseconds: i64) -> Duration 
min			    fn min(self, other: f32) -> f32 
min			    fn min(self, other: f64) -> f64 
min			    fn min(self, other: Self) -> Self;
min_10_exp			    fn min_10_exp(unused_self: Option<f32>) -> int { num::Float::min_10_exp(unused_self) }
min_10_exp			    fn min_10_exp(unused_self: Option<f64>) -> int { num::Float::min_10_exp(unused_self) }
min_10_exp			    fn min_10_exp(unused_self: Option<Self>) -> isize;
min_capacity			    fn min_capacity(&self, usable_size: usize) -> usize 
min_exp			    fn min_exp(unused_self: Option<f32>) -> int { num::Float::min_exp(unused_self) }
min_exp			    fn min_exp(unused_self: Option<f64>) -> int { num::Float::min_exp(unused_self) }
min_exp			    fn min_exp(unused_self: Option<Self>) -> isize;
min_pos_value			    fn min_pos_value(unused_self: Option<f32>) -> f32 { num::Float::min_pos_value(unused_self) }
min_pos_value			    fn min_pos_value(unused_self: Option<f64>) -> f64 { num::Float::min_pos_value(unused_self) }
min_pos_value			    fn min_pos_value(unused_self: Option<Self>) -> Self;
min_stack			pub fn min_stack() -> uint 
min_stack_size			fn min_stack_size(_: *const libc::pthread_attr_t) -> libc::size_t 
min_stack_size			fn min_stack_size(attr: *const libc::pthread_attr_t) -> libc::size_t 
min_value			    fn min_value() -> f32 { num::Float::min_value() }
min_value			    fn min_value() -> f64 { num::Float::min_value() }
min_value			    fn min_value() -> Self;
min_value			    pub fn min_value() -> Duration { MIN }
minutes			    pub fn minutes(minutes: i64) -> Duration 
mk_key			fn mk_key(s: &OsStr) -> OsString 
mkdir			pub fn mkdir(path: &Path, mode: FilePermission) -> IoResult<()> 
mkdir			pub fn mkdir(p: &Path, mode: uint) -> IoResult<()> 
mkdir			pub fn mkdir(p: &Path) -> io::Result<()> 
mkdir			pub fn mkdir(p: &Path, _mode: uint) -> IoResult<()> 
mkdir			pub fn mkdir(p: &Path) -> io::Result<()> 
mkdir_path_already_exists_error			    fn mkdir_path_already_exists_error() 
mkdir_path_already_exists_error			    fn mkdir_path_already_exists_error() 
mkdir_recursive			pub fn mkdir_recursive(path: &Path, mode: FilePermission) -> IoResult<()> 
mkdir_trailing_slash			    fn mkdir_trailing_slash() 
mkerr_libc			pub fn mkerr_libc<T: Int>(ret: T) -> IoResult<()> 
mkerr_winbool			fn mkerr_winbool(ret: libc::c_int) -> IoResult<()> 
mkstat			fn mkstat(stat: &libc::stat) -> FileStat 
mkstat			fn mkstat(stat: &libc::stat) -> FileStat 
mktime			    fn mktime(secs: u64, nsecs: u64) -> u64 { secs * 1000 + nsecs \/ 1000000 }
mktime			    fn mktime(&self, secs: u64, nsecs: u64) -> u64 
mod_floor_64			fn mod_floor_64(this: i64, other: i64) -> i64 
mode			    fn mode(&mut self, mode: i32) -> &mut OpenOptions 
mode			    fn mode(&mut self, mode: i32) -> &mut Self;
mode			    fn mode(&self) -> i32 { self.as_inner().mode() }
mode			    fn mode(&self) -> i32;
mode			    pub fn mode(&mut self, mode: i32) 
mode			    pub fn mode(&self) -> i32 { self.mode as i32 }
mode_string			fn mode_string(mode: FileMode) -> &'static str 
modf			        pub fn modf(n: c_double, iptr: &mut c_double) -> c_double;
modff			        pub fn modff(n: c_float, iptr: &mut c_float) -> c_float;
modified			    pub fn modified(&self) -> u64 { self.0.modified() }
modified			    pub fn modified(&self) -> u64 
modified			    pub fn modified(&self) -> u64 { self.to_ms(&self.data.ftLastWriteTime) }
mpsc			pub mod mpsc;
mpsc_queue			mod mpsc_queue;
ms_to_filetime			fn ms_to_filetime(ms: u64) -> libc::FILETIME 
ms_to_timeval			pub fn ms_to_timeval(ms: u64) -> libc::timeval 
ms_to_timeval			pub fn ms_to_timeval(ms: u64) -> libc::timeval 
mtime			    fn mtime(stat: &libc::stat) -> u64 
mul			    fn mul(self, rhs: i32) -> Duration 
mul_add			    fn mul_add(self, a: f32, b: f32) -> f32 { num::Float::mul_add(self, a, b) }
mul_add			    fn mul_add(self, a: f64, b: f64) -> f64 { num::Float::mul_add(self, a, b) }
mul_add			    fn mul_add(self, a: Self, b: Self) -> Self;
multicast_scope			    pub fn multicast_scope(&self) -> Option<Ipv6MulticastScope> 
multicast_time_to_live			    pub fn multicast_time_to_live(&mut self, ttl: int) -> IoResult<()> 
multicast_time_to_live			    pub fn multicast_time_to_live(&self, ttl: i32) -> io::Result<()> 
multiple_connect_interleaved_greedy_schedule			    fn multiple_connect_interleaved_greedy_schedule() 
multiple_connect_interleaved_greedy_schedule_ip4			    fn multiple_connect_interleaved_greedy_schedule_ip4() 
multiple_connect_interleaved_greedy_schedule_ip6			    fn multiple_connect_interleaved_greedy_schedule_ip6() 
multiple_connect_interleaved_lazy_schedule_ip4			    fn multiple_connect_interleaved_lazy_schedule_ip4() 
multiple_connect_interleaved_lazy_schedule_ip4			    fn multiple_connect_interleaved_lazy_schedule_ip4() 
multiple_connect_interleaved_lazy_schedule_ip6			    fn multiple_connect_interleaved_lazy_schedule_ip6() 
multiple_connect_serial_ip4			    fn multiple_connect_serial_ip4() 
multiple_connect_serial_ip4			    fn multiple_connect_serial_ip4() 
multiple_connect_serial_ip6			    fn multiple_connect_serial_ip6() 
mutex			mod mutex;
mutex			pub mod mutex;
mutex			pub mod mutex;
mutex			pub mod mutex;
naive_pow			        fn naive_pow<T: Int>(base: T, exp: usize) -> T 
name			    pub fn name(&self) -> Option<&str> 
name			    pub fn name(mut self, name: String) -> Builder 
name_bytes			    fn name_bytes(&self) -> &[u8] 
nan			    fn nan() -> f32 { num::Float::nan() }
nan			    fn nan() -> f64 { num::Float::nan() }
nan			    fn nan() -> Self;
nanos_mod_sec			    fn nanos_mod_sec(&self) -> i32 
nanoseconds			    pub fn nanoseconds(nanos: i64) -> Duration 
neg			    fn neg(self) -> Duration 
neg_infinity			    fn neg_infinity() -> f32 { num::Float::neg_infinity() }
neg_infinity			    fn neg_infinity() -> f64 { num::Float::neg_infinity() }
neg_infinity			    fn neg_infinity() -> Self;
neg_zero			    fn neg_zero() -> f32 { num::Float::neg_zero() }
neg_zero			    fn neg_zero() -> f64 { num::Float::neg_zero() }
neg_zero			    fn neg_zero() -> Self;
net			pub mod net;
net			pub mod net;
net			pub mod net;
net			pub mod net;
net			pub mod net;
net2			pub mod net2;
new			        fn new(k: usize) -> Dropable 
new			    fn new() -> DefaultResizePolicy 
new			    pub fn new() -> HashMap<K, V, RandomState> 
new			    pub fn new() -> RandomState 
new			    pub fn new() -> HashSet<T, RandomState> 
new			    pub fn new(capacity: usize) -> RawTable<K, V> 
new			    pub fn new(table: M, hash: SafeHash) -> Bucket<K, V, M> 
new			    pub fn new<T: IntoBytes>(t: T) -> Result<CString, NulError> 
new			    pub fn new() -> OsString 
new			    pub fn new() -> OpenOptions 
new			    pub fn new(prefix: &str) -> io::Result<TempDir> 
new			    pub fn new(inner: R) -> BufReader<R> 
new			    pub fn new(inner: S) -> BufStream<S> 
new			    pub fn new(inner: W) -> BufWriter<W> 
new			    pub fn new(inner: W) -> LineWriter<W> 
new			    pub fn new(inner: T) -> Cursor<T> 
new			    pub fn new(kind: ErrorKind,
new			    pub fn new(ip: IpAddr, port: u16) -> SocketAddr 
new			    pub fn new(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16,
new			    pub fn new(a: u8, b: u8, c: u8, d: u8) -> Ipv4Addr 
new			    fn new(s: &'a str) -> Parser<'a> 
new			    pub fn new(inner: R) -> BufferedReader<R> 
new			    pub fn new(inner: S) -> BufferedStream<S> 
new			    pub fn new(inner: W) -> BufferedWriter<W> 
new			    pub fn new(inner: W) -> LineBufferedWriter<W> 
new			    pub fn new(rx: Receiver<Vec<u8>>) -> ChanReader 
new			    pub fn new(tx: Sender<Vec<u8>>) -> ChanWriter 
new			    pub fn new(r: &'r mut R) -> Bytes<'r, R> 
new			    pub fn new() -> MemWriter 
new			    pub fn new(buf: &'a [u8]) -> BufReader<'a> 
new			    pub fn new(buf: &'a mut [u8]) -> BufWriter<'a> 
new			    pub fn new(buf: Vec<u8>) -> MemReader 
new			        fn new(r: T, behavior: Vec<BadReaderBehavior>) -> BadReader<T> 
new			    fn new(s: &'a str) -> Parser<'a> 
new			    fn new(s: TcpStreamImp) -> TcpStream 
new			    pub fn new<T: BytesContainer>(program: T) -> Command 
new			    pub fn new(prefix: &str) -> IoResult<TempDir> 
new			    pub fn new() -> IoResult<Timer> 
new			    pub fn new(iter: T) -> IterReader<T> 
new			    pub fn new(mut readers: I) -> ChainedReader<I, R> 
new			    pub fn new(r: R, limit: uint) -> LimitReader<R> 
new			    pub fn new(r: R, w: W) -> TeeReader<R, W> 
new			    pub fn new(writers: Vec<W>) -> MultiWriter<W> 
new			    fn new<T: BytesContainer>(path: T) -> Self 
new			    pub fn new<T: BytesContainer>(path: T) -> Path 
new			    pub fn new<T: BytesContainer>(path: T) -> Path 
new			    pub fn new(min_len: uint, options: &[MapOption]) -> Result<MemoryMap, MapError> 
new			    pub fn new<S: ?Sized + AsOsStr>(s: &S) -> &Path 
new			    pub fn new<S: ?Sized + AsOsStr>(s: &S) -> PathBuf 
new			    pub fn new<S: AsOsStr + ?Sized>(program: &S) -> Command 
new			    pub fn new() -> IoResult<StdRng> 
new			        pub fn new() -> IoResult<OsRng> 
new			    pub fn new(r: R) -> ReaderRng<R> 
new			    pub fn new(n: usize) -> Barrier 
new			    pub fn new() -> Condvar 
new			    fn new(inner: Arc<UnsafeCell<sync::Packet<T>>>) -> SyncSender<T> 
new			    fn new(inner: Flavor<T>) -> Receiver<T> 
new			    fn new(inner: Flavor<T>) -> Sender<T> 
new			    pub fn new() -> Queue<T> 
new			    unsafe fn new(v: Option<T>) -> *mut Node<T> 
new			    pub fn new() -> Packet<T> 
new			    pub fn new() -> Select 
new			    pub fn new() -> Packet<T> 
new			    fn new() -> *mut Node<T> 
new			    pub unsafe fn new(bound: usize) -> Queue<T> 
new			    pub fn new() -> Packet<T> 
new			    pub fn new(cap: usize) -> Packet<T> 
new			    fn new(lock: &'mutex StaticMutex, data: &'mutex UnsafeCell<T>)
new			    pub fn new(t: T) -> Mutex<T> 
new			    pub fn new(guard: T) -> PoisonError<T> 
new			    fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)
new			    pub fn new(t: T) -> RwLock<T> 
new			    pub fn new(count: int) -> Semaphore 
new			    fn new(jobs: &'a Arc<Mutex<Receiver<Thunk<'static>>>>) -> Sentinel<'a> 
new			    pub fn new(threads: usize) -> TaskPool 
new			    pub unsafe fn new() -> Condvar { Condvar(imp::Condvar::new()) }
new			    fn new(fd: sock_t) -> Inner 
new			    pub fn new(fd: sock_t) -> TcpStream 
new			    fn new(name: Option<String>) -> Self;
new			    pub fn new(dtor: Option<unsafe extern fn(*mut u8)>) -> Key 
new			    pub fn new() -> Wtf8Buf 
new			    pub unsafe fn new() -> Condvar 
new			    pub fn new(fd: c_int) -> FileDesc 
new			    pub fn new(fd: fd_t, close_on_drop: bool) -> FileDesc 
new			    pub fn new() -> OpenOptions 
new			pub fn new() -> (signal, signal) 
new			    pub unsafe fn new() -> Mutex 
new			    pub fn new(addr: &SocketAddr, ty: c_int) -> io::Result<Socket> 
new			    fn new(fd: fd_t) -> Inner 
new			    fn new(inner: Arc<Inner>) -> UnixStream 
new			    pub fn new(program: &OsStr) -> Command 
new			    pub unsafe fn new() -> RWLock 
new			    pub unsafe fn new() -> Handler 
new			    pub fn new() -> IoResult<Timer> 
new			    pub fn new(fd: c_int) -> IoResult<TTY> 
new			    pub unsafe fn new() -> Condvar { CONDVAR_INIT }
new			    pub fn new(fd: fd_t, close_on_drop: bool) -> FileDesc 
new			    fn new(root: &Arc<PathBuf>, wfd: &libc::WIN32_FIND_DATAW) -> Option<DirEntry> 
new			    pub fn new() -> OpenOptions { Default::default() }
new			    pub fn new(handle: HANDLE) -> Handle 
new			pub fn new() -> (HANDLE, HANDLE) 
new			    pub fn new(addr: &SocketAddr, ty: c_int) -> io::Result<Socket> 
new			    fn new(handle: libc::HANDLE) -> Inner 
new			    fn new(manual_reset: bool, initial_state: bool) -> IoResult<Event> 
new			    pub fn new(program: &OsStr) -> Command 
new			    pub unsafe fn new() -> Handler 
new			    pub fn new() -> IoResult<Event> 
new			    pub fn new() -> IoResult<Timer> 
new			    pub fn new(fd: c_int) -> IoResult<TTY> 
new			    fn new(name: Option<String>) -> Thread { Thread::new(name) }
new			    fn new(name: Option<String>) -> Thread 
new			    pub fn new() -> Builder 
new			    pub fn new<F>(func: F) -> Thunk<'a,(),R>
new_drop			fn new_drop(b : &mut Bencher) 
new_in			    pub fn new_in<P: AsPath + ?Sized>(tmpdir: &P, prefix: &str)
new_in			    pub fn new_in(tmpdir: &Path, prefix: &str) -> IoResult<TempDir> 
new_insert_drop			fn new_insert_drop(b : &mut Bencher) 
new_opt			    fn new_opt<T: BytesContainer>(path: T) -> Option<Self> 
new_opt			    pub fn new_opt<T: BytesContainer>(path: T) -> Option<Path> 
new_opt			    fn new_opt<T: BytesContainer>(path: T) -> Option<Path> 
new_opt			    pub fn new_opt<T: BytesContainer>(path: T) -> Option<Path> 
new_unchecked			    unsafe fn new_unchecked<T: BytesContainer>(path: T) -> Self;
new_unchecked			    unsafe fn new_unchecked<T: BytesContainer>(path: T) -> Path 
new_unchecked			    unsafe fn new_unchecked<T: BytesContainer>(path: T) -> Path 
new_uninitialized			    unsafe fn new_uninitialized(capacity: usize) -> RawTable<K, V> 
new_v4			    pub fn new_v4(a: u8, b: u8, c: u8, d: u8) -> IpAddr 
new_v6			    pub fn new_v6(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16,
next			    fn next(&mut self) -> Option<u8> { self.range.next().map(|i| self.data[i]) }
next			    fn next(&mut self) -> Option<&'a K> { self.iter.next() }
next			    fn next(&mut self) -> Option<&'a T> { self.iter.next() }
next			    fn next(&mut self) -> Option<&'a T> 
next			    fn next(&mut self) -> Option<K> { self.iter.next() }
next			    fn next(&mut self) -> Option<(&'a K, &'a V)> 
next			    fn next(&mut self) -> Option<(&'a K, &'a mut V)> 
next			    fn next(&mut self) -> Option<(K, V)> 
next			    fn next(&mut self) -> Option<(SafeHash, K, V)> 
next			    fn next(&mut self) -> Option<RawBucket<K, V>> 
next			    pub fn next(&mut self) 
next			    pub fn next(self) -> Bucket<K, V, M> 
next			    fn next(&mut self) -> Option<(OsString, OsString)> { self.inner.next() }
next			    fn next(&mut self) -> Option<(String, String)> 
next			    fn next(&mut self) -> Option<OsString> { self.inner.next() }
next			    fn next(&mut self) -> Option<PathBuf> { self.inner.next() }
next			    fn next(&mut self) -> Option<String> 
next			    fn next(&mut self) -> Option<io::Result<DirEntry>> 
next			    fn next(&mut self) -> Option<Result<String>> 
next			    fn next(&mut self) -> Option<Result<Vec<u8>>> 
next			    fn next(&mut self) -> Option<Result<u8>> 
next			    fn next(&mut self) -> Option<result::Result<char, CharsError>> 
next			    fn next(&mut self) -> Option<io::Result<SocketAddr>> { self.0.next() }
next			    fn next(&mut self) -> Option<io::Result<TcpStream>> 
next			    fn next(&mut self) -> Option<IoResult<u8>> 
next			    fn next(&mut self) -> Option<Path> 
next			    fn next(&mut self) -> Option<IoResult<String>> 
next			    fn next(&mut self) -> Option<IoResult<T>> 
next			    fn next(&mut self) -> Option<IoResult<char>> 
next			    fn next(&mut self) -> Option<&'a OsStr> 
next			    fn next(&mut self) -> Option<Component<'a>> 
next			    fn next(&mut self) -> Option<T> { self.rx.recv().ok() }
next			    fn next(&mut self) -> Option<*mut Handle<'static, ()>> 
next			    fn next(&mut self) -> Option<io::Result<SocketAddr>> 
next			    fn next(&mut self) -> Option<CodePoint> 
next			    fn next(&mut self) -> Option<u16> 
next			    fn next(&mut self) -> Option<io::Result<DirEntry>> 
next			    fn next(&mut self) -> Option<(OsString, OsString)> { self.iter.next() }
next			    fn next(&mut self) -> Option<OsString> { self.iter.next() }
next			    fn next(&mut self) -> Option<PathBuf> { self.iter.next() }
next			    fn next(&mut self) -> Option<io::Result<DirEntry>> 
next			    fn next(&mut self) -> Option<(OsString, OsString)> 
next			    fn next(&mut self) -> Option<OsString> 
next			    fn next(&mut self) -> Option<PathBuf> 
next_after			    fn next_after(self, other: f32) -> f32 
next_after			    fn next_after(self, other: f64) -> f64 
next_after			    fn next_after(self, other: Self) -> Self;
next_back			    fn next_back(&mut self) -> Option<u8> 
next_back			    fn next_back(&mut self) -> Option<&'a OsStr> 
next_back			    fn next_back(&mut self) -> Option<Component<'a>> 
next_surrogate			    fn next_surrogate(&self, mut pos: uint) -> Option<(uint, u16)> 
next_test_ip4			pub fn next_test_ip4() -> SocketAddr 
next_test_ip4			pub fn next_test_ip4() -> SocketAddr 
next_test_ip6			pub fn next_test_ip6() -> SocketAddr 
next_test_ip6			pub fn next_test_ip6() -> SocketAddr 
next_test_port			pub fn next_test_port() -> u16 
next_test_unix			pub fn next_test_unix() -> Path 
next_test_unix_socket			fn next_test_unix_socket() -> String 
next_u32			        fn next_u32(&mut self) -> u32 { self.i as u32 }
next_u32			    fn next_u32(&mut self) -> u32 
next_u32			        fn next_u32(&mut self) -> u32 
next_u32			    fn next_u32(&mut self) -> u32 
next_u64			        fn next_u64(&mut self) -> u64 { self.i }
next_u64			    fn next_u64(&mut self) -> u64 
next_u64			        fn next_u64(&mut self) -> u64 
next_u64			    fn next_u64(&mut self) -> u64 
nextafter			        pub fn nextafter(x: c_double, y: c_double) -> c_double;
nextafterf			        pub fn nextafterf(x: c_float, y: c_float) -> c_float;
no_runtime			    fn no_runtime() 
normal_fail			    fn normal_fail() 
normalize			    fn normalize<V: ?Sized + AsSlice<u8>>(v: &V) -> Vec<u8> 
normalize_			    fn normalize_(s: &str) -> (Option<PathPrefix>, String) 
normalize__			    fn normalize__(s: &str, prefix: Option<PathPrefix>) -> Option<String> 
normalize_helper			fn normalize_helper<'a>(v: &'a [u8], is_abs: bool) -> Option<Vec<&'a [u8]>> 
normalize_helper			fn normalize_helper<'a>(s: &'a str, prefix: Option<PathPrefix>) -> (bool, Option<Vec<&'a str>>) 
notify_all			    fn notify_all() 
notify_all			    pub fn notify_all(&'static self) { unsafe { self.inner.notify_all() } }
notify_all			    pub fn notify_all(&self) { unsafe { self.inner.inner.notify_all() } }
notify_all			    pub unsafe fn notify_all(&self) { self.0.notify_all() }
notify_all			    pub unsafe fn notify_all(&self) 
notify_all			    pub unsafe fn notify_all(&self) 
notify_one			    fn notify_one() 
notify_one			    pub fn notify_one(&'static self) { unsafe { self.inner.notify_one() } }
notify_one			    pub fn notify_one(&self) { unsafe { self.inner.inner.notify_one() } }
notify_one			    pub unsafe fn notify_one(&self) { self.0.notify_one() }
notify_one			    pub unsafe fn notify_one(&self) 
notify_one			    pub unsafe fn notify_one(&self) 
now			        pub fn now() -> SteadyTime 
now			pub fn now() -> u64 
now			    pub fn now() -> SteadyTime 
now			pub fn now() -> u64 
ns			        pub fn ns(&self) -> u64 
ns			    pub fn ns(&self) -> u64 
ntoh			fn ntoh<I: Int>(i: I) -> I { Int::from_be(i) }
ntoh			fn ntoh<I: Int>(i: I) -> I { Int::from_be(i) }
ntohs			pub fn ntohs(u: u16) -> u16 
nul_position			    pub fn nul_position(&self) -> usize { self.0 }
null			    pub fn null() -> Stdio { Stdio(StdioImp::Null) }
num			pub mod num;
num_cpus			pub fn num_cpus() -> uint 
num_days			    pub fn num_days(&self) -> i64 
num_hours			    pub fn num_hours(&self) -> i64 
num_microseconds			    pub fn num_microseconds(&self) -> Option<i64> 
num_milliseconds			    pub fn num_milliseconds(&self) -> i64 
num_minutes			    pub fn num_minutes(&self) -> i64 
num_nanoseconds			    pub fn num_nanoseconds(&self) -> Option<i64> 
num_seconds			    pub fn num_seconds(&self) -> i64 
num_weeks			    pub fn num_weeks(&self) -> i64 
objc_getClass			        fn objc_getClass(class_name: *const libc::c_uchar) -> NsId;
objc_getClass			        fn objc_getClass(class_name: *const libc::c_uchar) -> NsId;
objc_msgSend			        fn objc_msgSend(obj: NsId, sel: Sel, ...) -> NsId;
objc_msgSend			        fn objc_msgSend(obj: NsId, sel: Sel, ...) -> NsId;
octets			    pub fn octets(&self) -> [u8; 4] 
offset			    unsafe fn offset(self, count: isize) -> RawBucket<K, V> 
old_io			pub mod old_io;
old_io::Reader for S			        impl old_io::Reader for S 
old_io::Writer for S			        impl old_io::Writer for S 
old_path			pub mod old_path;
on_panic			pub fn on_panic(obj: &(Any+Send), file: &'static str, line: uint) 
once			mod once;
one			    fn one() -> f32 { num::Float::one() }
one			    fn one() -> f64 { num::Float::one() }
one			    fn one() -> Self;
oneshot			    fn oneshot() 
oneshot			    pub fn oneshot(&mut self, duration: Duration) -> Receiver<()> 
oneshot			mod oneshot;
oneshot			    pub fn oneshot(&mut self, msecs: u64, cb: Box<Callback + Send>) 
oneshot			    pub fn oneshot(&mut self, msecs: u64, cb: Box<Callback + Send>) 
oneshot_data_waiting			    fn oneshot_data_waiting() 
oneshot_fail			    fn oneshot_fail() 
oneshot_multi_task_recv_then_close			    fn oneshot_multi_task_recv_then_close() 
oneshot_multi_task_recv_then_send			    fn oneshot_multi_task_recv_then_send() 
oneshot_multi_thread_close_stress			    fn oneshot_multi_thread_close_stress() 
oneshot_multi_thread_recv_close_stress			    fn oneshot_multi_thread_recv_close_stress() 
oneshot_multi_thread_send_close_stress			    fn oneshot_multi_thread_send_close_stress() 
oneshot_multi_thread_send_recv_stress			    fn oneshot_multi_thread_send_recv_stress() 
oneshot_negative			    fn oneshot_negative() 
oneshot_single_thread_close_chan_first			    fn oneshot_single_thread_close_chan_first() 
oneshot_single_thread_close_port_first			    fn oneshot_single_thread_close_port_first() 
oneshot_single_thread_peek_close			    fn oneshot_single_thread_peek_close() 
oneshot_single_thread_peek_data			    fn oneshot_single_thread_peek_data() 
oneshot_single_thread_peek_open			    fn oneshot_single_thread_peek_open() 
oneshot_single_thread_recv_chan_close			    fn oneshot_single_thread_recv_chan_close() 
oneshot_single_thread_send_port_close			    fn oneshot_single_thread_send_port_close() 
oneshot_single_thread_send_then_recv			    fn oneshot_single_thread_send_then_recv() 
oneshot_single_thread_try_recv_closed			    fn oneshot_single_thread_try_recv_closed() 
oneshot_single_thread_try_recv_open			    fn oneshot_single_thread_try_recv_open() 
oneshot_single_thread_try_send_closed			    fn oneshot_single_thread_try_send_closed() 
oneshot_single_thread_try_send_closed2			    fn oneshot_single_thread_try_send_closed2() 
oneshot_single_thread_try_send_open			    fn oneshot_single_thread_try_send_open() 
oneshot_twice			    fn oneshot_twice() 
oneshot_zero			    fn oneshot_zero() 
open			    pub fn open(filename: Option<&Path>) -> Result<DynamicLibrary, String> 
open			    pub fn open(filename: Option<&[u8]>) -> Result<*mut u8, String> 
open			    pub fn open<P: AsPath + ?Sized>(&self, path: &P) -> io::Result<File> 
open			    pub fn open<P: AsPath + ?Sized>(path: &P) -> io::Result<File> 
open			    pub fn open(path: &Path) -> IoResult<File> 
open			    pub fn open(fd: libc::c_int) -> IoResult<PipeStream> 
open			pub fn open(path: &Path, fm: FileMode, fa: FileAccess) -> IoResult<FileDesc> 
open			    pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> 
open			pub fn open(path: &Path, fm: FileMode, fa: FileAccess) -> IoResult<FileDesc> 
open			    pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> 
open_external			    unsafe fn open_external(filename: &[u8]) -> *mut u8 
open_flavors			    fn open_flavors() 
open_flavors			    fn open_flavors() 
open_internal			    unsafe fn open_internal() -> *mut u8 
open_mode			    pub fn open_mode(path: &Path,
ops			impl ops::Index<ops::Range<usize>> for Wtf8 
ops			impl ops::Index<ops::RangeFrom<usize>> for Wtf8 
ops			impl ops::Index<ops::RangeTo<usize>> for Wtf8 
ops::Deref for OsString			impl ops::Deref for OsString 
ops::Deref for PathBuf			impl ops::Deref for PathBuf 
ops::Deref for Wtf8Buf			impl ops::Deref for Wtf8Buf 
ops::Index for OsString			impl ops::Index<ops::RangeFull> for OsString 
ops::Index for Wtf8			impl ops::Index<ops::RangeFull> for Wtf8 
optional_path			fn optional_path(path: &Path) -> Option<&Path> 
os			pub mod os;
os			pub mod os;
os			pub mod os;
os			mod os 
os			pub mod os;
os2path			fn os2path(os: OsString) -> PathBuf 
os2path			fn os2path(s: &[u16]) -> PathBuf 
os_datasync			        fn os_datasync(fd: c_int) -> c_int 
os_datasync			        unsafe fn os_datasync(fd: c_int) -> c_int { libc::fdatasync(fd) }
os_datasync			        unsafe fn os_datasync(fd: c_int) -> c_int { libc::fsync(fd) }
os_datasync			        unsafe fn os_datasync(fd: c_int) -> c_int 
os_str			mod os_str;
os_str			pub mod os_str;
os_str			pub mod os_str;
os_str_as_u8_slice			fn os_str_as_u8_slice(s: &OsStr) -> &[u8] 
os_str_len			        fn os_str_len(s: &OsStr) -> usize 
output			    pub fn output(&self) -> IoResult<ProcessOutput> 
output			    pub fn output(&mut self) -> io::Result<Output> 
output			fn output(w: &mut Writer, idx: int, addr: *mut libc::c_void,
page_size			pub fn page_size() -> usize 
page_size			pub fn page_size() -> uint 
page_size			pub fn page_size() -> usize 
page_size			pub fn page_size() -> usize 
pair			    pub fn pair() -> IoResult<PipePair> 
panicking			mod panicking;
panicking			pub fn panicking() -> bool 
panicking			    pub fn panicking() -> bool 
panicking			pub fn panicking() -> bool 
parent			    pub fn parent(&self) -> Option<&Path> 
park			    pub fn park() 
park			pub fn park() 
park_timeout			    pub fn park_timeout(dur: Duration) 
park_timeout			pub fn park_timeout(dur: Duration) 
parse			    fn parse(input: &[u8]) -> (OsString, OsString) 
parse_and_resolve_socket_addr			fn parse_and_resolve_socket_addr(s: &str) -> IoResult<Vec<SocketAddr>> 
parse_digit			        fn parse_digit(c: char, radix: u8) -> Option<u8> 
parse_digit			        fn parse_digit(c: char, radix: u8) -> Option<u8> 
parse_next_component			    fn parse_next_component(&self) -> (usize, Option<Component<'a>>) 
parse_next_component_back			    fn parse_next_component_back(&self) -> (usize, Option<Component<'a>>) 
parse_prefix			fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> 
parse_prefix			    pub fn parse_prefix(_: &OsStr) -> Option<Prefix> 
parse_prefix			    pub fn parse_prefix<'a>(path: &'a OsStr) -> Option<Prefix> 
parse_single_component			fn parse_single_component(comp: &[u8]) -> Option<Component> 
parse_two_comps			    fn parse_two_comps(mut path: &str, f: fn(char) -> bool) -> Option<(uint, uint)> 
parse_two_comps			        fn parse_two_comps(mut path: &[u8], f: fn(u8) -> bool) -> Option<(&[u8], &[u8])> 
parser			mod parser;
partial_cmp			    fn partial_cmp(&self, other: &CStr) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &OsStr) -> Option<cmp::Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &OsString) -> Option<cmp::Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &str) -> Option<cmp::Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &Ipv4Addr) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &Ipv6Addr) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &Path) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &Path) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &Components<'a>) -> Option<cmp::Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &Path) -> Option<cmp::Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &PathBuf) -> Option<cmp::Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &Wtf8) -> Option<cmp::Ordering> 
partial_read			    fn partial_read() 
partial_read			    fn partial_read() 
partial_read			    fn partial_read() 
passwd			pub struct passwd 
path			        fn path<'a>(&'a self) -> &'a Path2 
path			    pub fn path(&self) -> Option<&Path> 
path			    pub fn path(&self) -> PathBuf { self.0.path() }
path			    pub fn path(&self) -> &path::Path 
path			pub mod path;
path			        fn path<'a>(&'a self) -> &'a Path 
path			    pub fn path<'a>(&'a self) -> &'a Path 
path			    pub fn path<'a>(&'a self) -> &'a Path 
path			    pub fn path(&self) -> PathBuf 
path			    pub fn path(&self) -> PathBuf 
path2new			fn path2new(path: &Path) -> PathBuf 
path2old			fn path2old(path: &path::Path) -> Path 
path_exists			    fn path_exists() 
path_relative_from			    fn path_relative_from(&self, base: &Self) -> Option<Self>;
path_relative_from			    fn path_relative_from(&self, base: &Path) -> Option<Path> 
path_relative_from			    fn path_relative_from(&self, base: &Path) -> Option<Path> 
path_relative_from_backward			    fn path_relative_from_backward(b: &mut Bencher) 
path_relative_from_forward			    fn path_relative_from_forward(b: &mut Bencher) 
path_relative_from_same_level			    fn path_relative_from_same_level(b: &mut Bencher) 
peek			    pub fn peek(self) -> BucketState<K, V, M> 
peek			    pub fn peek(&self) -> Option<Component<'a>> 
peek			    fn peek() 
peek			    pub fn peek<'a>(&'a self) -> Option<&'a mut T> 
peer_addr			    pub fn peer_addr(&self) -> io::Result<SocketAddr> 
peer_addr			    pub fn peer_addr(&self) -> io::Result<SocketAddr> 
peer_name			    pub fn peer_name(&mut self) -> IoResult<SocketAddr> 
peer_name			    pub fn peer_name(addr: SocketAddr) 
peer_name			    pub fn peer_name(&mut self) -> IoResult<SocketAddr> 
period			    fn period() 
period			    pub fn period(&mut self, msecs: u64, cb: Box<Callback + Send>) 
period			    pub fn period(&mut self, msecs: u64, cb: Box<Callback + Send>) 
period_fail			    fn period_fail() 
periodic			    pub fn periodic(&mut self, duration: Duration) -> Receiver<()> 
periodic_negative			    fn periodic_negative() 
periodic_zero			    fn periodic_zero() 
perm			    pub fn perm(&self) -> FilePermissions 
perm			    pub fn perm(&self) -> FilePermissions 
permissions			    pub fn permissions(&self) -> Permissions 
pipe			pub mod pipe;
pipe			pub mod pipe;
pipe			pub unsafe fn pipe() -> IoResult<Pipe> 
pipe			pub mod pipe;
pipe			pub unsafe fn pipe() -> IoResult<(FileDesc, FileDesc)> 
pipe			pub mod pipe;
pipe			pub unsafe fn pipe() -> IoResult<(FileDesc, FileDesc)> 
pipe			unsafe fn pipe(name: *const u16, init: bool) -> libc::HANDLE 
pipe2			pub mod pipe2;
pipe2			pub mod pipe2;
platform			mod platform 
poison			mod poison;
pop			    fn pop(&mut self) -> bool;
pop			    fn pop(&mut self) -> bool 
pop			    fn pop(&mut self) -> bool 
pop			    pub fn pop(&mut self) -> bool 
pop			    pub fn pop(&self) -> PopResult<T> 
pop			    pub fn pop(&self) -> Option<T> 
pop_internal			fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>) -> (K, V) 
port			    pub fn port(&self) -> u16 
port_gone_concurrent			    fn port_gone_concurrent() 
port_gone_concurrent_shared			    fn port_gone_concurrent_shared() 
position			    pub fn position(&self) -> u64 { self.pos }
posix			pub mod posix;
postinit_lock			    pub fn postinit_lock(&self) -> MutexGuard<()> 
powf			    fn powf(self, n: f32) -> f32 { num::Float::powf(self, n) }
powf			    fn powf(self, n: f64) -> f64 { num::Float::powf(self, n) }
powf			    fn powf(self, n: Self) -> Self;
powi			    fn powi(self, n: i32) -> f32 { num::Float::powi(self, n) }
powi			    fn powi(self, n: i32) -> f64 { num::Float::powi(self, n) }
powi			    fn powi(self, n: i32) -> Self;
precise_time_ns			fn precise_time_ns() -> u64 
prefix			pub fn prefix(path: &Path) -> Option<PathPrefix> 
prefix			    pub fn prefix(&self) -> Option<&Path> 
prefix_and_root			    fn prefix_and_root(&self) -> usize 
prefix_is_verbatim			fn prefix_is_verbatim(p: Option<PathPrefix>) -> bool 
prefix_len			    fn prefix_len(&self) -> uint 
prefix_len			fn prefix_len(p: Option<PathPrefix>) -> uint 
prefix_len			    fn prefix_len(&self) -> usize 
prefix_remaining			    fn prefix_remaining(&self) -> usize 
prefix_verbatim			    fn prefix_verbatim(&self) -> bool 
preflight1			    fn preflight1() 
preflight2			    fn preflight2() 
preflight3			    fn preflight3() 
preflight4			    fn preflight4() 
preflight5			    fn preflight5() 
preflight6			    fn preflight6() 
preflight7			    fn preflight7() 
preflight8			    fn preflight8() 
preflight9			    fn preflight9() 
prelude			pub mod prelude;
prelude			pub mod prelude;
prelude			pub mod prelude 
prelude			pub mod prelude 
prepend_search_path			    pub fn prepend_search_path(path: &Path) 
print			pub fn print(s: &str) 
print			fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> 
print_args			pub fn print_args(fmt: fmt::Arguments) 
println			pub fn println(s: &str) 
println_args			pub fn println_args(fmt: fmt::Arguments) 
process			pub mod process;
process			pub mod process;
process			pub mod process;
process			pub mod process;
process2			pub mod process2;
process2			pub mod process2;
program			    fn program(&self) -> &CString 
program			    fn program(&self) -> &CString;
prune			    fn prune(root: &CString, dirs: Vec<Path>) -> Vec<Path> 
prune			    fn prune(root: &Path, dirs: Vec<Path>) -> Vec<Path> 
pthread_attr_destroy			    pub fn pthread_attr_destroy(attr: *mut libc::pthread_attr_t) -> libc::c_int;
pthread_attr_getguardsize			    pub fn pthread_attr_getguardsize(attr: *const libc::pthread_attr_t,
pthread_attr_getstack			    pub fn pthread_attr_getstack(attr: *const libc::pthread_attr_t,
pthread_attr_init			    fn pthread_attr_init(attr: *mut libc::pthread_attr_t) -> libc::c_int;
pthread_attr_setdetachstate			    fn pthread_attr_setdetachstate(attr: *mut libc::pthread_attr_t,
pthread_attr_setstacksize			    fn pthread_attr_setstacksize(attr: *mut libc::pthread_attr_t,
pthread_cond_broadcast			    pub fn pthread_cond_broadcast(cond: *mut pthread_cond_t) -> libc::c_int;
pthread_cond_destroy			    pub fn pthread_cond_destroy(cond: *mut pthread_cond_t) -> libc::c_int;
pthread_cond_signal			    pub fn pthread_cond_signal(cond: *mut pthread_cond_t) -> libc::c_int;
pthread_cond_t			    pub struct pthread_cond_t { value: libc::c_int }
pthread_cond_t			    pub struct pthread_cond_t 
pthread_cond_timedwait			    pub fn pthread_cond_timedwait(cond: *mut pthread_cond_t,
pthread_cond_wait			    pub fn pthread_cond_wait(cond: *mut pthread_cond_t,
pthread_create			    fn pthread_create(native: *mut libc::pthread_t,
pthread_detach			    fn pthread_detach(thread: libc::pthread_t) -> libc::c_int;
pthread_get_stackaddr_np			    pub fn pthread_get_stackaddr_np(thread: libc::pthread_t) -> *mut libc::c_void;
pthread_get_stacksize_np			    pub fn pthread_get_stacksize_np(thread: libc::pthread_t) -> libc::size_t;
pthread_getattr_np			    pub fn pthread_getattr_np(native: libc::pthread_t,
pthread_getspecific			    fn pthread_getspecific(key: pthread_key_t) -> *mut u8;
pthread_join			    fn pthread_join(native: libc::pthread_t,
pthread_key_create			    fn pthread_key_create(key: *mut pthread_key_t,
pthread_key_delete			    fn pthread_key_delete(key: pthread_key_t) -> c_int;
pthread_main_np			        pub fn pthread_main_np() -> libc::c_uint;
pthread_main_np			    pub fn pthread_main_np() -> libc::c_uint;
pthread_mutex_destroy			    pub fn pthread_mutex_destroy(lock: *mut pthread_mutex_t) -> libc::c_int;
pthread_mutex_lock			    pub fn pthread_mutex_lock(lock: *mut pthread_mutex_t) -> libc::c_int;
pthread_mutex_t			    pub struct pthread_mutex_t { value: libc::c_int }
pthread_mutex_t			    pub struct pthread_mutex_t 
pthread_mutex_trylock			    pub fn pthread_mutex_trylock(lock: *mut pthread_mutex_t) -> libc::c_int;
pthread_mutex_unlock			    pub fn pthread_mutex_unlock(lock: *mut pthread_mutex_t) -> libc::c_int;
pthread_rwlock_destroy			    pub fn pthread_rwlock_destroy(lock: *mut pthread_rwlock_t) -> libc::c_int;
pthread_rwlock_rdlock			    pub fn pthread_rwlock_rdlock(lock: *mut pthread_rwlock_t) -> libc::c_int;
pthread_rwlock_t			    pub struct pthread_rwlock_t 
pthread_rwlock_tryrdlock			    pub fn pthread_rwlock_tryrdlock(lock: *mut pthread_rwlock_t) -> libc::c_int;
pthread_rwlock_trywrlock			    pub fn pthread_rwlock_trywrlock(lock: *mut pthread_rwlock_t) -> libc::c_int;
pthread_rwlock_unlock			    pub fn pthread_rwlock_unlock(lock: *mut pthread_rwlock_t) -> libc::c_int;
pthread_rwlock_wrlock			    pub fn pthread_rwlock_wrlock(lock: *mut pthread_rwlock_t) -> libc::c_int;
pthread_self			    pub fn pthread_self() -> libc::pthread_t;
pthread_set_name_np			    fn pthread_set_name_np(tid: libc::pthread_t, name: *const libc::c_char);
pthread_setname_np			    fn pthread_setname_np(name: *const libc::c_char) -> libc::c_int;
pthread_setspecific			    fn pthread_setspecific(key: pthread_key_t, value: *mut u8) -> c_int;
pthread_stackseg_np			        pub fn pthread_stackseg_np(thread: libc::pthread_t,
pthread_stackseg_np			    pub fn pthread_stackseg_np(thread: libc::pthread_t,
ptr			        unsafe fn ptr(&'static self) -> Option<*mut T> 
push			    fn push(&mut self, len: uint, buf: &mut Vec<u8>) -> IoResult<uint> 
push			    fn push<T: BytesContainer>(&mut self, path: T) 
push			    pub fn push<P: ?Sized>(&mut self, path: &P) where P: AsPath 
push			pub fn push(f: Thunk<'static>) 
push			    pub fn push(&self, t: T) 
push			    pub fn push(&self, t: T) 
push			    pub fn push(&mut self, code_point: CodePoint) 
push_abs_path_home_dir			    fn push_abs_path_home_dir(b: &mut Bencher) 
push_at_least			    fn push_at_least() 
push_at_least			    fn push_at_least(&mut self, min: uint, len: uint, buf: &mut Vec<u8>) -> IoResult<uint> 
push_at_least			    fn push_at_least(&mut self, min: uint, len: uint, buf: &mut Vec<u8>) -> IoResult<uint> 
push_at_least_eof			    fn push_at_least_eof() 
push_at_least_error			    fn push_at_least_error() 
push_at_least_partial			    fn push_at_least_partial() 
push_char			    pub fn push_char(&mut self, c: char) 
push_code_point_unchecked			    fn push_code_point_unchecked(&mut self, code_point: CodePoint) 
push_home_dir			    fn push_home_dir(b: &mut Bencher) 
push_many			    fn push_many<T: BytesContainer>(&mut self, paths: &[T]) 
push_many_abs_path_home_dir			    fn push_many_abs_path_home_dir(b: &mut Bencher) 
push_many_home_dir			    fn push_many_home_dir(b: &mut Bencher) 
push_os_str			    pub fn push_os_str(&mut self, s: &OsStr) 
push_slice			    pub fn push_slice(&mut self, s: &Slice) 
push_slice			    pub fn push_slice(&mut self, s: &Slice) 
push_str			    pub fn push_str(&mut self, other: &str) 
push_unchecked			    unsafe fn push_unchecked<T: BytesContainer>(&mut self, path: T);
push_unchecked			    unsafe fn push_unchecked<T: BytesContainer>(&mut self, path: T) 
push_unchecked			    unsafe fn push_unchecked<T: BytesContainer>(&mut self, path: T) 
push_wtf8			    pub fn push_wtf8(&mut self, other: &Wtf8) 
put			    pub fn put(mut self, hash: SafeHash, key: K, value: V)
put			    pub fn put(_args: Vec<Vec<u8>>) 
put			    pub fn put(args: Vec<Vec<u8>>) 
put			pub fn put(args: Vec<Vec<u8>>) { imp::put(args) }
pwd_cmd			    pub fn pwd_cmd() -> Command 
pwd_cmd			    pub fn pwd_cmd() -> Command 
raise			        pub fn raise(signum: libc::c_int) -> libc::c_int;
raise_fd_limit			    pub unsafe fn raise_fd_limit() 
raise_fd_limit			    pub unsafe fn raise_fd_limit() {}
raise_fd_limit			pub fn raise_fd_limit() 
rand			pub mod rand;
rand_isaac			    fn rand_isaac(b: &mut Bencher) 
rand_isaac64			    fn rand_isaac64(b: &mut Bencher) 
rand_shuffle_100			    fn rand_shuffle_100(b: &mut Bencher) 
rand_std			    fn rand_std(b: &mut Bencher) 
rand_xorshift			    fn rand_xorshift(b: &mut Bencher) 
random			pub fn random<T: Rand>() -> T 
raw			pub fn raw(mutex: &Mutex) -> &imp::Mutex { &mutex.0 }
raw			    pub fn raw(&self) -> c_int { self.fd }
raw			pub unsafe fn raw(m: &Mutex) -> *mut ffi::pthread_mutex_t 
raw			    pub fn raw(&self) -> libc::c_int 
raw			    pub fn raw(&self) -> HANDLE { self.0 }
raw			pub unsafe fn raw(m: &Mutex) -> ffi::PSRWLOCK 
raw			    pub fn raw(&self) -> HANDLE 
raw_buckets			    fn raw_buckets(&self) -> RawBuckets<K, V> 
read			    pub fn read(&self) -> (&K, &V) 
read			    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub fn read(&mut self, read: bool) -> &mut OpenOptions 
read			            fn read(&mut self, _: &mut [u8]) -> io::Result<usize> { Ok(0) }
read			        fn read(&mut self, _: &mut [u8]) -> io::Result<usize> 
read			    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> 
read			        fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> 
read			    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { (**self).read(buf) }
read			    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> 
read			            fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> 
read			    fn read(&mut self, buf: &mut [u8]) -> Result<usize> 
read			    fn read(&mut self, buf: &mut [u8]) -> Result<usize>;
read			    fn read(&mut self, _buf: &mut [u8]) -> io::Result<usize> { Ok(0) }
read			    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> 
read			    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { self.0.read(buf) }
read			            fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<uint> 
read			        fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			        fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<uint> 
read			        fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			        fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { (*self).read(buf) }
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { self.inner.read(buf) }
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint>;
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			        fn read(stream: Option<old_io::PipeStream>) -> Receiver<IoResult<Vec<u8>>> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    fn read(&mut self, _buf: &mut [u8]) -> old_io::IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> 
read			        fn read<T: Read + Send + 'static>(stream: Option<T>) -> Receiver<io::Result<Vec<u8>>> 
read			    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub fn read(&'static self) -> LockResult<RwLockReadGuard<'static, ()>> 
read			    pub fn read(&self) -> LockResult<RwLockReadGuard<T>> 
read			    pub fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			pub fn read<T, L, R>(fd: sock_t, deadline: u64, mut lock: L, mut read: R) -> IoResult<uint> where
read			    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub unsafe fn read(&self) { self.0.read() }
read			    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub fn read(&self, buf: &mut [u8]) -> IoResult<uint> 
read			    pub fn read(&mut self, read: bool) 
read			    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub unsafe fn read(&self) 
read			    pub fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    pub fn read(&self, buf: &mut [u8]) -> IoResult<uint> 
read			    pub fn read(&mut self, read: bool) { self.read = read; }
read			    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> 
read			pub fn read(h: HANDLE, buf: &mut [u8]) -> io::Result<usize> 
read			    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub unsafe fn read(&self) 
read			    pub fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read_all			    pub fn read_all(input: &mut Reader) -> String 
read_at_least			    fn read_at_least(&mut self, min: uint, buf: &mut [u8]) -> IoResult<uint> 
read_at_least			    fn read_at_least(&mut self, min: uint, buf: &mut [u8]) -> IoResult<uint> 
read_atomically			    fn read_atomically<T, F>(&mut self, cb: F) -> Option<T> where
read_atomically			    fn read_atomically<T, F>(&mut self, cb: F) -> Option<T> where
read_be_f32			    fn read_be_f32(&mut self) -> IoResult<f32> 
read_be_f64			    fn read_be_f64(&mut self) -> IoResult<f64> 
read_be_i16			    fn read_be_i16(&mut self) -> IoResult<i16> 
read_be_i32			    fn read_be_i32(&mut self) -> IoResult<i32> 
read_be_i64			    fn read_be_i64(&mut self) -> IoResult<i64> 
read_be_int			    fn read_be_int(&mut self) -> IoResult<int> 
read_be_int_n			    fn read_be_int_n(&mut self, nbytes: uint) -> IoResult<i64> 
read_be_u16			    fn read_be_u16(&mut self) -> IoResult<u16> 
read_be_u32			    fn read_be_u32(&mut self) -> IoResult<u32> 
read_be_u64			    fn read_be_u64(&mut self) -> IoResult<u64> 
read_be_uint			    fn read_be_uint(&mut self) -> IoResult<uint> 
read_be_uint_n			    fn read_be_uint_n(&mut self, nbytes: uint) -> IoResult<u64> 
read_be_uint_n			    fn read_be_uint_n(&mut self, nbytes: uint) -> IoResult<u64> 
read_byte			    fn read_byte() 
read_byte			    fn read_byte(&mut self) -> IoResult<u8> 
read_byte_0_bytes			    fn read_byte_0_bytes() 
read_byte_eof			    fn read_byte_eof() 
read_byte_error			    fn read_byte_error() 
read_bytes			    fn read_bytes() 
read_bytes_eof			    fn read_bytes_eof() 
read_bytes_partial			    fn read_bytes_partial() 
read_char			    fn read_char(&mut self) -> Option<char> 
read_char			    fn read_char(&mut self) -> IoResult<char> 
read_char			    fn read_char(&mut self) -> Option<char> 
read_char			    pub fn read_char(&mut self) -> IoResult<char> 
read_char_buffered			    fn read_char_buffered() 
read_char_buffered			    fn read_char_buffered() 
read_closed			    fn read_closed(&self) -> bool 
read_digit			    fn read_digit(&mut self, radix: u8) -> Option<u8> 
read_digit			    fn read_digit(&mut self, radix: u8) -> Option<u8> 
read_dir			pub fn read_dir<P: AsPath + ?Sized>(path: &P) -> io::Result<ReadDir> 
read_eof			    fn read_eof() 
read_eof_ip4			    fn read_eof_ip4() 
read_eof_ip4			    fn read_eof_ip4() 
read_eof_ip6			    fn read_eof_ip6() 
read_eof_twice_ip4			    fn read_eof_twice_ip4() 
read_eof_twice_ip6			    fn read_eof_twice_ip6() 
read_exact			    fn read_exact(&mut self, len: uint) -> IoResult<Vec<u8>> 
read_given_char			    fn read_given_char(&mut self, c: char) -> Option<char> 
read_given_char			    fn read_given_char(&mut self, c: char) -> Option<char> 
read_groups			        fn read_groups(p: &mut Parser, groups: &mut [u16; 8], limit: usize)
read_groups			        fn read_groups(p: &mut Parser, groups: &mut [u16; 8], limit: uint) -> (uint, bool) 
read_i8			    fn read_i8(&mut self) -> IoResult<i8> 
read_ip_addr			    fn read_ip_addr(&mut self) -> Option<IpAddr> 
read_ip_addr			    fn read_ip_addr(&mut self) -> Option<IpAddr> 
read_ipv4_addr			    fn read_ipv4_addr(&mut self) -> Option<Ipv4Addr> 
read_ipv4_addr			    fn read_ipv4_addr(&mut self) -> Option<IpAddr> 
read_ipv4_addr_impl			    fn read_ipv4_addr_impl(&mut self) -> Option<Ipv4Addr> 
read_ipv4_addr_impl			    fn read_ipv4_addr_impl(&mut self) -> Option<IpAddr> 
read_ipv6_addr			    fn read_ipv6_addr(&mut self) -> Option<Ipv6Addr> 
read_ipv6_addr			    fn read_ipv6_addr(&mut self) -> Option<IpAddr> 
read_ipv6_addr_impl			    fn read_ipv6_addr_impl(&mut self) -> Option<Ipv6Addr> 
read_ipv6_addr_impl			    fn read_ipv6_addr_impl(&mut self) -> Option<IpAddr> 
read_le_f32			    fn read_le_f32(&mut self) -> IoResult<f32> 
read_le_f64			    fn read_le_f64(&mut self) -> IoResult<f64> 
read_le_i16			    fn read_le_i16(&mut self) -> IoResult<i16> 
read_le_i32			    fn read_le_i32(&mut self) -> IoResult<i32> 
read_le_i64			    fn read_le_i64(&mut self) -> IoResult<i64> 
read_le_int			    fn read_le_int(&mut self) -> IoResult<int> 
read_le_int_n			    fn read_le_int_n(&mut self, nbytes: uint) -> IoResult<i64> 
read_le_u16			    fn read_le_u16(&mut self) -> IoResult<u16> 
read_le_u32			    fn read_le_u32(&mut self) -> IoResult<u32> 
read_le_u64			    fn read_le_u64(&mut self) -> IoResult<u64> 
read_le_uint			    fn read_le_uint(&mut self) -> IoResult<uint> 
read_le_uint_n			    fn read_le_uint_n(&mut self, nbytes: uint) -> IoResult<u64> 
read_le_uint_n			    fn read_le_uint_n(&mut self, nbytes: uint) -> IoResult<u64> 
read_line			    fn read_line(&mut self, buf: &mut String) -> io::Result<()> { (**self).read_line(buf) }
read_line			    fn read_line(&mut self, buf: &mut String) -> Result<()> 
read_line			    fn read_line() 
read_line			    fn read_line(&mut self) -> IoResult<String> 
read_line			    pub fn read_line(&mut self) -> IoResult<String> 
read_link			pub fn read_link<P: AsPath + ?Sized>(path: &P) -> io::Result<PathBuf> 
read_mut			    pub fn read_mut(&mut self) -> (&mut K, &mut V) 
read_number			    fn read_number(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> 
read_number			    fn read_number(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> 
read_number_impl			    fn read_number_impl(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> 
read_number_impl			    fn read_number_impl(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> 
read_or			    fn read_or<T>(&mut self, parsers: &mut [Box<FnMut(&mut Parser) -> Option<T>>])
read_or			    fn read_or<T>(&mut self, parsers: &mut [Box<FnMut(&mut Parser) -> Option<T>>])
read_seq_3			    fn read_seq_3<A, B, C, PA, PB, PC>(&mut self,
read_seq_3			    fn read_seq_3<A, B, C, PA, PB, PC>(&mut self,
read_socket_addr			    fn read_socket_addr(&mut self) -> Option<SocketAddr> 
read_socket_addr			    fn read_socket_addr(&mut self) -> Option<SocketAddr> 
read_till_eof			    fn read_till_eof<T, F>(&mut self, cb: F) -> Option<T> where
read_till_eof			    fn read_till_eof<T, F>(&mut self, cb: F) -> Option<T> where
read_timeouts			    fn read_timeouts() 
read_timeouts			    fn read_timeouts() 
read_to_end			    fn read_to_end() 
read_to_end			    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<()> { (**self).read_to_end(buf) }
read_to_end			    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<()> 
read_to_end			    fn read_to_end() 
read_to_end			fn read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>) -> Result<()> 
read_to_end			    fn read_to_end() 
read_to_end			    fn read_to_end(&mut self) -> IoResult<Vec<u8>> 
read_to_end			    fn read_to_end(&mut self) -> IoResult<Vec<u8>> 
read_to_end_error			    fn read_to_end_error() 
read_to_string			    fn read_to_string(&mut self, buf: &mut String) -> io::Result<()> 
read_to_string			    fn read_to_string(&mut self, buf: &mut String) -> Result<()> 
read_to_string			    fn read_to_string() 
read_to_string			    fn read_to_string(&mut self) -> IoResult<String> 
read_u8			    fn read_u8(&mut self) -> IoResult<u8> 
read_unlock			    pub unsafe fn read_unlock(&self) { self.0.read_unlock() }
read_unlock			    pub unsafe fn read_unlock(&self) 
read_unlock			    pub unsafe fn read_unlock(&self) 
read_until			    fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> io::Result<()> 
read_until			    fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> Result<()> 
read_until			    fn read_until() 
read_until			fn read_until<R: BufRead + ?Sized>(r: &mut R, delim: u8, buf: &mut Vec<u8>)
read_until			    fn read_until(&mut self, byte: u8) -> IoResult<Vec<u8>> 
read_until			    pub fn read_until(&mut self, byte: u8) -> IoResult<Vec<u8>> 
readdir			pub fn readdir(path: &Path) -> IoResult<Vec<Path>> 
readdir			pub fn readdir(p: &Path) -> IoResult<Vec<Path>> 
readdir			pub fn readdir(p: &Path) -> io::Result<ReadDir> 
readdir			pub fn readdir(p: &Path) -> IoResult<Vec<Path>> 
readdir			pub fn readdir(p: &Path) -> io::Result<ReadDir> 
reader			pub mod reader;
readlink			pub fn readlink(path: &Path) -> IoResult<Path> 
readlink			pub fn readlink(p: &Path) -> IoResult<Path> 
readlink			pub fn readlink(p: &Path) -> io::Result<PathBuf> 
readlink			pub fn readlink(p: &Path) -> IoResult<Path> 
readlink			pub fn readlink(p: &Path) -> io::Result<PathBuf> 
readlink_not_symlink			    fn readlink_not_symlink() 
readlink_not_symlink			    fn readlink_not_symlink() 
readonly			    pub fn readonly(&self) -> bool { self.0.readonly() }
readonly			    pub fn readonly(&self) -> bool { self.mode & 0o222 == 0 }
readonly			    pub fn readonly(&self) -> bool 
readwrite_timeouts			    fn readwrite_timeouts() 
readwrite_timeouts			    fn readwrite_timeouts() 
real_args			fn real_args() -> Vec<String> 
real_args_as_bytes			fn real_args_as_bytes() -> Vec<Vec<u8>> 
receiver_goes_away_oneshot			    fn receiver_goes_away_oneshot() 
receiver_goes_away_period			    fn receiver_goes_away_period() 
recip			    fn recip(self) -> f32 { num::Float::recip(self) }
recip			    fn recip(self) -> f64 { num::Float::recip(self) }
recip			    fn recip(self) -> Self;
record_os_managed_stack_bounds			pub unsafe fn record_os_managed_stack_bounds(stack_lo: uint, _stack_hi: uint) 
record_rust_managed_stack_bounds			pub unsafe fn record_rust_managed_stack_bounds(stack_lo: uint, stack_hi: uint) 
record_sp_limit			            fn record_sp_limit(limit: *const c_void);
record_sp_limit			pub unsafe fn record_sp_limit(limit: uint) 
recursive_mkdir			    fn recursive_mkdir() 
recursive_mkdir			    fn recursive_mkdir() 
recursive_mkdir_failure			    fn recursive_mkdir_failure() 
recursive_mkdir_failure			    fn recursive_mkdir_failure() 
recursive_mkdir_slash			    fn recursive_mkdir_slash() 
recursive_mkdir_slash			    fn recursive_mkdir_slash() 
recursive_rmdir			    fn recursive_rmdir() 
recursive_rmdir			    fn recursive_rmdir() 
recv			            fn recv(rx: Receiver<Box<i32>>, i: i32) 
recv			    pub fn recv(&self) -> Result<T, RecvError> 
recv			    pub fn recv(&mut self) -> Result<T, Failure<T>> 
recv			    pub fn recv(&mut self) -> Result<T, RecvError> { self.rx.recv() }
recv			    pub fn recv(&mut self) -> Result<T, Failure> 
recv			    pub fn recv(&mut self) -> Result<T, Failure<T>> 
recv			    pub fn recv(&self) -> Result<T, ()> 
recv_a_lot			    fn recv_a_lot() 
recv_from			    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> 
recv_from			    pub fn recv_from(&mut self, buf: &mut [u8]) -> IoResult<(uint, SocketAddr)> 
recv_from			    pub fn recv_from(&mut self, buf: &mut [u8]) -> IoResult<(uint, SocketAddr)> 
recv_from			    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> 
recv_from_outside_runtime			    fn recv_from_outside_runtime() 
recv_from_timeout			    fn recv_from_timeout() 
refcell_vec			    fn refcell_vec() 
register			pub unsafe fn register(f: Callback) -> bool 
register_dtor			unsafe fn register_dtor(key: Key, dtor: Dtor) 
register_dtor			        unsafe fn register_dtor(&self) 
register_dtor			    unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) 
register_sigchld			        fn register_sigchld() -> (libc::c_int, c::sigaction) 
relative_from			    pub fn relative_from<'a, P: ?Sized>(&'a self, base: &'a P) -> Option<&Path> where
release			    pub fn release(&self) 
remove			    pub fn remove(self) -> V 
remove			    pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>
remove			    pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool
remove			    pub unsafe fn remove(&mut self) 
remove			    fn remove(&mut self) 
remove_dir			pub fn remove_dir<P: AsPath + ?Sized>(path: &P) -> io::Result<()> 
remove_dir_all			pub fn remove_dir_all<P: AsPath + ?Sized>(path: &P) -> io::Result<()> 
remove_file			pub fn remove_file<P: AsPath + ?Sized>(path: &P) -> io::Result<()> 
remove_var			pub fn remove_var<K: ?Sized>(k: &K) where K: AsOsStr 
rename			pub fn rename<P: AsPath + ?Sized, Q: AsPath + ?Sized>(from: &P, to: &Q)
rename			pub fn rename(from: &Path, to: &Path) -> IoResult<()> 
rename			pub fn rename(old: &Path, new: &Path) -> IoResult<()> 
rename			pub fn rename(old: &Path, new: &Path) -> io::Result<()> 
rename			pub fn rename(old: &Path, new: &Path) -> IoResult<()> 
rename			pub fn rename(old: &Path, new: &Path) -> io::Result<()> 
repeat			pub fn repeat(byte: u8) -> Repeat { Repeat { byte: byte } }
repeat_repeats			    fn repeat_repeats() 
replace			    pub fn replace(&mut self, h: SafeHash, k: K, v: V) -> (SafeHash, K, V) 
replace_path			        fn replace_path(me: &mut Path, path: &str, prefix: Option<PathPrefix>) 
report_overflow			pub unsafe fn report_overflow() 
repro			        fn repro() 
reseed			    fn reseed(&mut self, rng: &mut StdRng) 
reseed			    fn reseed(&mut self, seed: &'a [usize]) 
reseeding::Reseeder for ThreadRngReseeder			impl reseeding::Reseeder<StdRng> for ThreadRngReseeder 
reserve			    pub fn reserve(&mut self, additional: usize) 
reserve			    pub fn reserve(&mut self, additional: usize) 
reserve			    pub fn reserve(&mut self, additional: uint) 
reset_doesnt_switch_tasks			    fn reset_doesnt_switch_tasks() 
reset_doesnt_switch_tasks2			    fn reset_doesnt_switch_tasks2() 
resize			    fn resize(&mut self, new_capacity: usize) 
resolve_socket_addr			fn resolve_socket_addr(s: &str, p: u16) -> io::Result<vec::IntoIter<SocketAddr>> 
resolve_socket_addr			fn resolve_socket_addr(s: &str, p: u16) -> IoResult<Vec<SocketAddr>> 
result			mod result;
retry			pub fn retry<T, F> (mut f: F) -> T where
retry			pub fn retry<I, F>(f: F) -> I where F: FnOnce() -> I { f() } \/\/ PR rust-lang\/rust\/#17020
rev_move_buckets			    unsafe fn rev_move_buckets(&mut self) -> RevMoveBuckets<K, V> 
rlimit			    struct rlimit 
rmdir			pub fn rmdir(path: &Path) -> IoResult<()> 
rmdir			pub fn rmdir(p: &Path) -> IoResult<()> 
rmdir			pub fn rmdir(p: &Path) -> io::Result<()> 
rmdir			pub fn rmdir(p: &Path) -> IoResult<()> 
rmdir			pub fn rmdir(p: &Path) -> io::Result<()> 
rmdir_failed			    fn rmdir_failed(err: &IoError, path: &Path) -> String 
rmdir_recursive			pub fn rmdir_recursive(path: &Path) -> IoResult<()> 
robin_hood			fn robin_hood<'a, K: 'a, V: 'a>(mut bucket: FullBucketMut<'a, K, V>,
root_path			    fn root_path(&self) -> Option<Self>;
root_path			    fn root_path(&self) -> Option<Path> 
root_path			    fn root_path(&self) -> Option<Path> 
round			    fn round(self) -> f32 { num::Float::round(self) }
round			    fn round(self) -> f64 { num::Float::round(self) }
round			    fn round(self) -> Self;
round_up			fn round_up(from: uint, to: uint) -> uint 
round_up_to_next			fn round_up_to_next(unrounded: usize, target_alignment: usize) -> usize 
rsqrt		qrt(self) }
rsqrt		qrt(self) }
rsqrt			    fn rsqrt(self) -> Self;
rt			pub mod rt;
rtdeps			mod rtdeps;
run_dtors			unsafe fn run_dtors() 
run_output			    pub fn run_output(cmd: Command) -> String 
run_output			    pub fn run_output(mut cmd: Command) -> String 
running_on_valgrind			pub fn running_on_valgrind() -> bool 
rust_begin_unwind			pub extern fn rust_begin_unwind(msg: fmt::Arguments,
rust_current_exe			        fn rust_current_exe() -> *const c_char;
rust_dirent_t_size			        fn rust_dirent_t_size() -> libc::c_int;
rust_dirent_t_size			            fn rust_dirent_t_size() -> c_int;
rust_eh_personality			    extern "C" fn rust_eh_personality(
rust_eh_personality			    extern fn rust_eh_personality(
rust_eh_personality			    pub extern "C" fn rust_eh_personality(
rust_eh_personality_catch			    pub extern "C" fn rust_eh_personality_catch(
rust_exception_class			fn rust_exception_class() -> uw::_Unwind_Exception_Class 
rust_get_num_cpus			        fn rust_get_num_cpus() -> libc::uintptr_t;
rust_list_dir_val			        fn rust_list_dir_val(ptr: *mut dirent_t) -> *const libc::c_char;
rust_list_dir_val			            fn rust_list_dir_val(ptr: *mut libc::dirent_t) -> *const c_char;
rust_panic			fn rust_panic(cause: Box<Any + Send + 'static>) -> ! 
rust_running_on_valgrind			        fn rust_running_on_valgrind() -> uintptr_t;
rust_try			        fn rust_try(f: extern fn(*mut c_void),
rust_unset_sigprocmask			                pub fn rust_unset_sigprocmask();
rust_unset_sigprocmask			                pub fn rust_unset_sigprocmask();
rustrt			        mod rustrt 
rustrt			        mod rustrt 
rwlock			mod rwlock;
rwlock			pub mod rwlock;
rwlock			pub mod rwlock;
rwlock			pub mod rwlock;
sample			pub fn sample<T, I: Iterator<Item=T>, R: Rng>(rng: &mut R,
sched_yield			    fn sched_yield() -> libc::c_int;
scope_item_allowed			    fn scope_item_allowed() 
scoped			    pub fn scoped<'a, T, F>(f: F) -> JoinGuard<'a, T> where
scoped			    pub fn scoped<'a, T, F>(self, f: F) -> io::Result<JoinGuard<'a, T>> where
scoped			pub fn scoped<'a, T, F>(f: F) -> JoinGuard<'a, T> where
scoped			pub mod scoped;
search			    fn search<'a, Q: ?Sized>(&'a self, q: &Q) -> Option<FullBucketImm<'a, K, V>>
search_entry_hashed			fn search_entry_hashed<'a, K: Eq, V>(table: &'a mut RawTable<K,V>, hash: SafeHash, k: K)
search_hashed			fn search_hashed<K, V, M, F>(table: M,
search_mut			    fn search_mut<'a, Q: ?Sized>(&'a mut self, q: &Q) -> Option<FullBucketMut<'a, K, V>>
search_path			    pub fn search_path() -> Vec<Path> 
second			        fn second<A, B>((_, b): (A, B)) -> B { b }
seconds			    pub fn seconds(seconds: i64) -> Duration 
seek			    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> 
seek			        fn seek(&mut self, style: SeekFrom) -> io::Result<u64> 
seek			    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> { (**self).seek(pos) }
seek			    fn seek(&mut self, pos: SeekFrom) -> Result<u64>;
seek			    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> 
seek			    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> 
seek			    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()>;
seek			    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> 
seek			    pub fn seek(&self, pos: i64, whence: SeekStyle) -> IoResult<u64> 
seek			    pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> 
seek			    pub fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<u64> 
seek			    pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> 
seek_before_0			    fn seek_before_0() 
seek_before_0			    fn seek_before_0() 
seek_common			    fn seek_common(&self, pos: i64, style: SeekStyle) -> IoResult<u64> 
seek_past_end			    fn seek_past_end() 
seek_past_end			    fn seek_past_end() 
segments			    pub fn segments(&self) -> [u16; 8] 
sel_registerName			        fn sel_registerName(name: *const libc::c_uchar) -> Sel;
sel_registerName			        fn sel_registerName(name: *const libc::c_uchar) -> Sel;
select			mod select;
select			    pub fn select(nfds: libc::c_int,
select			mod select 
select			    pub fn select(nfds: libc::c_int,
select::Packet for Receiver			impl<T: Send> select::Packet for Receiver<T> 
self_exe_name			pub fn self_exe_name() -> Option<Path> 
self_exe_path			pub fn self_exe_path() -> Option<Path> 
self_referential			    fn self_referential() 
semaphore			mod semaphore;
send			            fn send(tx: Sender<Box<i32>>, i: i32) 
send			            fn send(tx: SyncSender<Box<i32>>, i: i32) 
send			    pub fn send(&self, t: T) -> Result<(), SendError<T>> 
send			    pub fn send(&mut self, t: T) -> Result<(), T> 
send			    pub fn send(&mut self, t: T) -> Result<(), T> 
send			    pub fn send(&mut self, t: T) -> Result<(), T> 
send			    pub fn send(&self, t: T) -> Result<(), T> 
send			    pub fn send(&'static self, msg: M) 
send1			    fn send1() 
send2			    fn send2() 
send3			    fn send3() 
send4			    fn send4() 
send_from_outside_runtime			    fn send_from_outside_runtime() 
send_to			    pub fn send_to<A: ToSocketAddrs + ?Sized>(&self, buf: &[u8], addr: &A)
send_to			    pub fn send_to<A: ToSocketAddr>(&mut self, buf: &[u8], addr: A) -> IoResult<()> 
send_to			    pub fn send_to(&mut self, buf: &[u8], dst: SocketAddr) -> IoResult<()> 
send_to			    pub fn send_to(&self, buf: &[u8], dst: &SocketAddr) -> io::Result<usize> 
send_to_timeout			    fn send_to_timeout() 
sender_goes_away_oneshot			    fn sender_goes_away_oneshot() 
sender_goes_away_period			    fn sender_goes_away_period() 
sent			    pub fn sent(&self) -> bool 
separator			    fn separator() -> u8 
sepidx_or_prefix_len			    fn sepidx_or_prefix_len(&self) -> Option<(uint,uint,uint)> 
set			pub mod set;
set			pub fn set(stack_bounds: (uint, uint), stack_guard: uint, thread: Thread) 
set			    pub fn set(&self, val: *mut u8) 
set			    pub unsafe fn set(&self, val: *mut u8) { imp::set(self.key(), val) }
set			pub unsafe fn set(key: Key, value: *mut u8) 
set			pub unsafe fn set(key: Key, value: *mut u8) 
set			        pub unsafe fn set(&self, ptr: *mut T) { *self.inner.get() = ptr; }
set			        pub unsafe fn set(&self, ptr: *mut T) { self.inner.set(ptr as *mut _) }
set			    pub fn set<R, F>(&'static self, t: &T, cb: F) -> R where
set_broadcast			    pub fn set_broadcast(&self, on: bool) -> io::Result<()> 
set_broadcast			    pub fn set_broadcast(&mut self, broadcast: bool) -> IoResult<()> 
set_broadcast			    pub fn set_broadcast(&mut self, on: bool) -> IoResult<()> 
set_broadcast			    pub fn set_broadcast(&self, on: bool) -> io::Result<()> 
set_cloexec			        unsafe fn set_cloexec(fd: c_int) 
set_cloexec			        unsafe fn set_cloexec(fd: c_int) 
set_current_dir			pub fn set_current_dir<P: AsPath + ?Sized>(p: &P) -> io::Result<()> 
set_current_dir_works			    fn set_current_dir_works() 
set_cwd_works			    fn set_cwd_works() 
set_exit_status			pub fn set_exit_status(code: i32) 
set_exit_status			pub fn set_exit_status(code: int) 
set_extension			    fn set_extension<T: BytesContainer>(&mut self, extension: T) 
set_extension			    pub fn set_extension<S: ?Sized + AsOsStr>(&mut self, extension: &S) -> bool 
set_file_name			    pub fn set_file_name<S: ?Sized>(&mut self, file_name: &S) where S: AsOsStr 
set_file_times			pub fn set_file_times<P: AsPath + ?Sized>(path: &P, accessed: u64,
set_filename			    fn set_filename<T: BytesContainer>(&mut self, filename: T) 
set_filename_unchecked			    unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T);
set_filename_unchecked			    unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T) 
set_filename_unchecked			    unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T) 
set_keepalive			    pub fn set_keepalive(&self, seconds: Option<u32>) -> io::Result<()> 
set_keepalive			    pub fn set_keepalive(&mut self, delay_in_seconds: Option<uint>) -> IoResult<()> 
set_keepalive			    pub fn set_keepalive(&mut self, seconds: Option<uint>) -> IoResult<()> 
set_keepalive			    pub fn set_keepalive(&self, seconds: Option<u32>) -> io::Result<()> 
set_len			    pub fn set_len(&self, size: u64) -> io::Result<()> 
set_membership			    pub fn set_membership(&mut self, addr: IpAddr, opt: libc::c_int) -> IoResult<()> 
set_membership			    fn set_membership(&self, addr: &IpAddr, opt: c_int) -> io::Result<()> 
set_mode			    fn set_mode(&mut self, mode: i32) 
set_mode			    fn set_mode(&mut self, mode: i32);
set_multicast_loop			    pub fn set_multicast_loop(&self, on: bool) -> io::Result<()> 
set_multicast_loop			    pub fn set_multicast_loop(&mut self, on: bool) -> IoResult<()> 
set_multicast_loop			    pub fn set_multicast_loop(&mut self, on: bool) -> IoResult<()> 
set_multicast_loop			    pub fn set_multicast_loop(&self, on: bool) -> io::Result<()> 
set_multicast_time_to_live			    pub fn set_multicast_time_to_live(&self, ttl: i32) -> io::Result<()> 
set_multicast_ttl			    pub fn set_multicast_ttl(&mut self, ttl: int) -> IoResult<()> 
set_name			pub unsafe fn set_name(name: &str) 
set_name			pub unsafe fn set_name(_name: &str) 
set_nodelay			    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> 
set_nodelay			    pub fn set_nodelay(&mut self, nodelay: bool) -> IoResult<()> 
set_nodelay			    pub fn set_nodelay(&mut self, nodelay: bool) -> IoResult<()> 
set_nodelay			    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> 
set_nonblocking			pub fn set_nonblocking(fd: sock_t, nb: bool) 
set_nonblocking			pub fn set_nonblocking(fd: sock_t, nb: bool) 
set_perm			pub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> 
set_perm			pub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> 
set_permissions			pub fn set_permissions<P: AsPath + ?Sized>(path: &P, perm: Permissions)
set_port			    fn set_port(&mut self, port: u16) 
set_position			    pub fn set_position(&mut self, pos: u64) { self.pos = pos; }
set_raw			    pub fn set_raw(&mut self, raw: bool) -> IoResult<()> 
set_raw			    pub fn set_raw(&mut self, _raw: bool) -> IoResult<()> 
set_raw			    pub fn set_raw(&mut self, raw: bool) -> IoResult<()> 
set_read_timeout			    pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) 
set_read_timeout			    pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) 
set_read_timeout			    pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) 
set_read_timeout			    pub fn set_read_timeout(&mut self, timeout: Option<u64>) 
set_read_timeout			    pub fn set_read_timeout(&mut self, timeout: Option<u64>) 
set_read_timeout			    pub fn set_read_timeout(&mut self, timeout: Option<u64>) 
set_readonly			    pub fn set_readonly(&mut self, readonly: bool) 
set_readonly			    pub fn set_readonly(&mut self, readonly: bool) 
set_readonly			    pub fn set_readonly(&mut self, readonly: bool) 
set_stderr			pub fn set_stderr(stderr: Box<Writer + Send>) -> Option<Box<Writer + Send>> 
set_stdout			pub fn set_stdout(stdout: Box<Writer + Send>) -> Option<Box<Writer + Send>> 
set_tcp_keepalive			    fn set_tcp_keepalive(&mut self, _seconds: uint) -> IoResult<()> 
set_tcp_keepalive			    fn set_tcp_keepalive(&mut self, seconds: uint) -> IoResult<()> 
set_tcp_keepalive			    fn set_tcp_keepalive(&self, _seconds: u32) -> io::Result<()> 
set_tcp_keepalive			    fn set_tcp_keepalive(&self, seconds: u32) -> io::Result<()> 
set_time_to_live			    pub fn set_time_to_live(&self, ttl: i32) -> io::Result<()> 
set_timeout			    pub fn set_timeout(&mut self, timeout_ms: Option<u64>) 
set_timeout			    pub fn set_timeout(&mut self, ms: Option<u64>) { self.inner.set_timeout(ms); }
set_timeout			    pub fn set_timeout(&mut self, timeout_ms: Option<u64>) 
set_timeout			    pub fn set_timeout(&mut self, timeout_ms: Option<u64>) 
set_timeout			    pub fn set_timeout(&mut self, timeout_ms: Option<u64>) 
set_timeout			    pub fn set_timeout(&mut self, timeout: Option<u64>) 
set_timeout			    pub fn set_timeout(&mut self, timeout: Option<u64>) 
set_timeout			    pub fn set_timeout(&mut self, timeout: Option<u64>) 
set_timeout			    pub fn set_timeout(&mut self, timeout: Option<u64>) 
set_timeout			    pub fn set_timeout(&mut self, timeout: Option<u64>) 
set_ttl			    pub fn set_ttl(&mut self, ttl: int) -> IoResult<()> 
set_var			pub fn set_var<K: ?Sized, V: ?Sized>(k: &K, v: &V)
set_write_timeout			    pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) 
set_write_timeout			    pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) 
set_write_timeout			    pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) 
set_write_timeout			    pub fn set_write_timeout(&mut self, timeout: Option<u64>) 
set_write_timeout			    pub fn set_write_timeout(&mut self, timeout: Option<u64>) 
set_write_timeout			    pub fn set_write_timeout(&mut self, timeout: Option<u64>) 
setenv			pub fn setenv<T: BytesContainer>(n: &str, v: T) 
setenv			pub fn setenv(k: &OsStr, v: &OsStr) 
setenv			pub fn setenv(k: &OsStr, v: &OsStr) 
setgroups			                            fn setgroups(ngroups: libc::c_int,
setgroups			                            fn setgroups(ngroups: libc::c_int,
setrlimit			        fn setrlimit(resource: libc::c_int, rlp: *const rlimit) -> libc::c_int;
setsockopt			pub fn setsockopt<T>(fd: sock_t, opt: libc::c_int, val: libc::c_int,
setsockopt			fn setsockopt<T>(sock: &Socket, opt: c_int, val: c_int,
setup_io			fn setup_io(io: StdioContainer) -> IoResult<(Option<PipeStream>, Option<PipeStream>)> 
setup_io			fn setup_io(io: &StdioImp, fd: libc::c_int, readable: bool)
share_mode			    fn share_mode(&mut self, access: i32) -> &mut OpenOptions 
share_mode			    fn share_mode(&mut self, val: i32) -> &mut Self;
share_mode			    pub fn share_mode(&mut self, val: i32) 
shared			mod shared;
shared_chan_stress			    fn shared_chan_stress() 
shared_data_waiting			    fn shared_data_waiting() 
shares_volume			        fn shares_volume(me: &Path, path: &str) -> bool 
shift			    pub fn shift(mut self) -> Option<GapThenFull<K, V, M>> 
short_write			pub fn short_write(n: uint, desc: &'static str) -> IoError 
shrink_to_fit			    pub fn shrink_to_fit(&mut self) 
shrink_to_fit			    pub fn shrink_to_fit(&mut self) 
shutdown			    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> 
shutdown			    fn shutdown(&'static self) 
shutdown			    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> 
shutdown_smoke			    fn shutdown_smoke() 
shutdown_smoke			    fn shutdown_smoke() 
sigaction			    pub fn sigaction(signum: libc::c_int,
sigaction			    pub struct sigaction 
sigaction			        pub fn sigaction(signum: libc::c_int,
sigaction			        pub struct sigaction 
sigaddset			    pub fn sigaddset(set: *mut sigset_t, signum: libc::c_int) -> libc::c_int;
sigaltstack			        pub fn sigaltstack(ss: *const sigaltstack,
sigaltstack			        pub struct sigaltstack 
sigchld_handler			        extern fn sigchld_handler(_signum: libc::c_int) 
sigdelset			    pub fn sigdelset(set: *mut sigset_t, signum: libc::c_int) -> libc::c_int;
sigemptyset			    pub fn sigemptyset(set: *mut sigset_t) -> libc::c_int;
siginfo			    pub struct siginfo 
siginfo			        pub struct siginfo 
signal			    pub fn signal(&mut self, signal: int) -> IoResult<()> 
signal			    pub fn signal(&self) -> bool 
signal			mod signal 
signal			    fn signal(&self) -> Option<i32> 
signal			    fn signal(&self) -> Option<i32>;
signal			pub fn signal(fd: libc::c_int) 
signal			        pub fn signal(signum: libc::c_int, handler: sighandler_t) -> sighandler_t;
signal			    mod signal 
signal			    fn signal(active: &mut Vec<Box<Inner>>,
signal			pub fn signal(handle: HANDLE) 
signal_exit			    pub fn signal_exit(&mut self) -> IoResult<()> 
signal_kill			    pub fn signal_kill(&mut self) -> IoResult<()> 
signal_reported_right			    fn signal_reported_right() 
signal_reported_right			    fn signal_reported_right() 
signum			    fn signum(self) -> f32 { num::Float::signum(self) }
signum			    fn signum(self) -> f64 { num::Float::signum(self) }
signum			    fn signum(self) -> Self;
sigset_t			    pub struct sigset_t 
sigset_t			        pub struct sigset_t 
simple			    fn simple() 
sin			    fn sin(self) -> f32 
sin			    fn sin(self) -> f64 
sin			    fn sin(self) -> Self;
sin_cos			    fn sin_cos(self) -> (f32, f32) 
sin_cos			    fn sin_cos(self) -> (f64, f64) 
sin_cos			    fn sin_cos(self) -> (Self, Self);
sinh			    fn sinh(self) -> f32 
sinh			        pub fn sinh(n: c_double) -> c_double;
sinh			    fn sinh(self) -> f64 
sinh			    fn sinh(self) -> Self;
sinhf			        pub fn sinhf(n: c_float) -> c_float;
sink			pub fn sink() -> Sink { Sink { _priv: () } }
sink_sinks			    fn sink_sinks() 
size			    pub fn size(&self) -> usize 
size			    fn size(&self) -> usize { self.size }
size			    pub fn size(&self) -> u64 { self.stat.st_size as u64 }
size			    pub fn size(&self) -> u64 
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) { self.range.size_hint() }
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) 
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) 
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) { self.range.size_hint() }
sleep			    fn sleep() 
sleep			    pub fn sleep(&mut self, duration: Duration) 
sleep			pub fn sleep(duration: Duration) 
sleep			    pub fn sleep(&mut self, ms: u64) 
sleep			    pub fn sleep(&mut self, msecs: u64) 
sleep_negative			    fn sleep_negative() 
sleep_zero			    fn sleep_zero() 
sleeper			    pub fn sleeper() -> Process 
slice_error_fail			pub fn slice_error_fail(s: &Wtf8, begin: uint, end: uint) -> ! 
slice_unchecked			pub unsafe fn slice_unchecked(s: &Wtf8, begin: uint, end: uint) -> &Wtf8 
slice_vec_capacity			unsafe fn slice_vec_capacity<'a, T>(v: &'a mut Vec<T>, start: uint, end: uint) -> &'a mut [T] 
smalltest			    pub fn smalltest<F,G>(server: F, client: G)
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke2			    fn smoke2() 
smoke_bound			    fn smoke_bound() 
smoke_chan_gone			    fn smoke_chan_gone() 
smoke_chan_gone_shared			    fn smoke_chan_gone_shared() 
smoke_dtor			    fn smoke_dtor() 
smoke_failure			    fn smoke_failure() 
smoke_failure			    fn smoke_failure() 
smoke_no_dtor			    fn smoke_no_dtor() 
smoke_once			    fn smoke_once() 
smoke_port_gone			    fn smoke_port_gone() 
smoke_shared			    fn smoke_shared() 
smoke_shared_port_gone			    fn smoke_shared_port_gone() 
smoke_shared_port_gone2			    fn smoke_shared_port_gone2() 
smoke_static			    fn smoke_static() 
smoke_test			        fn smoke_test() 
smoke_test_ip4			    fn smoke_test_ip4() 
smoke_test_ip6			    fn smoke_test_ip6() 
smoke_test_ip6			    fn smoke_test_ip6() 
smoke_threads			    fn smoke_threads() 
sockaddr_to_addr			pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,
sockaddr_to_addr			fn sockaddr_to_addr(storage: &libc::sockaddr_storage,
socket			pub fn socket(addr: SocketAddr, ty: libc::c_int) -> IoResult<sock_t> 
socket			    pub fn socket(&self) -> &Socket { &self.inner }
socket			    pub fn socket(&self) -> sock_t { self.inner.listener.socket() }
socket			    pub fn socket(&self) -> sock_t { self.sock }
socket_addr			    pub fn socket_addr(&self) -> io::Result<SocketAddr> 
socket_addr			    pub fn socket_addr(&self) -> io::Result<SocketAddr> 
socket_addr			    pub fn socket_addr(&self) -> io::Result<SocketAddr> 
socket_and_peer_name_ip4			    fn socket_and_peer_name_ip4() 
socket_and_peer_name_ip4			    fn socket_and_peer_name_ip4() 
socket_and_peer_name_ip6			    fn socket_and_peer_name_ip6() 
socket_name			    pub fn socket_name(&mut self) -> IoResult<SocketAddr> 
socket_name			    pub fn socket_name(addr: SocketAddr) 
socket_name			    pub fn socket_name(&mut self) -> IoResult<SocketAddr> 
socket_name			    pub fn socket_name(addr: SocketAddr) 
socket_name			    pub fn socket_name(&mut self) -> IoResult<SocketAddr> 
socket_name			    pub fn socket_name(&mut self) -> IoResult<ip::SocketAddr> 
socket_name			    pub fn socket_name(&mut self) -> IoResult<ip::SocketAddr> 
socket_name_ip4			    fn socket_name_ip4() 
socket_name_ip4			    fn socket_name_ip4() 
socket_name_ip6			    fn socket_name_ip6() 
socket_smoke_test_ip4			    fn socket_smoke_test_ip4() 
socket_smoke_test_ip4			    fn socket_smoke_test_ip4() 
socket_smoke_test_ip6			    fn socket_smoke_test_ip6() 
sockname			pub fn sockname(fd: sock_t,
sockname			fn sockname<F>(f: F) -> io::Result<SocketAddr>
soft_link			pub fn soft_link<P: AsPath + ?Sized, Q: AsPath + ?Sized>(src: &P, dst: &Q)
span			    pub fn span<F>(f: F) -> Duration where F: FnOnce() 
spawn			    pub fn spawn(&self) -> IoResult<Process> 
spawn			    pub fn spawn(&mut self) -> io::Result<Child> 
spawn			    pub fn spawn<F>(blk: F) -> Future<A>
spawn			    pub fn spawn<K, V, C, P>(cfg: &C, in_fd: Option<P>,
spawn			    pub fn spawn(cfg: &Command,
spawn			    pub fn spawn<K, V, C, P>(cfg: &C, in_fd: Option<P>,
spawn			    pub fn spawn(cfg: &Command,
spawn			    pub fn spawn<F>(f: F) -> Thread where F: FnOnce(), F: Send + 'static 
spawn			    pub fn spawn<F>(self, f: F) -> io::Result<JoinHandle> where
spawn			pub fn spawn<F>(f: F) -> JoinHandle where F: FnOnce(), F: Send + 'static 
spawn_in_pool			fn spawn_in_pool(jobs: Arc<Mutex<Receiver<Thunk<'static>>>>) 
spawn_inner			    fn spawn_inner(&self, default_io: StdioImp) -> io::Result<Child> 
spawn_inner			    fn spawn_inner<T: Send>(self, f: Thunk<(), T>) -> io::Result<JoinInner<T>> 
split			    fn split() 
split			    fn split(self, byte: u8) -> Split<Self> 
split_file_at_dot			fn split_file_at_dot(file: &OsStr) -> (Option<&OsStr>, Option<&OsStr>) 
split_paths			pub fn split_paths<T: AsOsStr + ?Sized>(unparsed: &T) -> SplitPaths 
split_paths			pub fn split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> 
split_paths			pub fn split_paths<'a>(unparsed: &'a OsStr) -> SplitPaths<'a> 
split_paths			pub fn split_paths(unparsed: &OsStr) -> SplitPaths 
split_paths_unix			    fn split_paths_unix() 
split_paths_unix			    fn split_paths_unix() 
split_paths_windows			    fn split_paths_windows() 
split_paths_windows			    fn split_paths_windows() 
spsc_queue			mod spsc_queue;
sqrt			    fn sqrt(self) -> f32 { num::Float::sqrt(self) }
sqrt			    fn sqrt(self) -> f64 { num::Float::sqrt(self) }
sqrt			    fn sqrt(self) -> Self;
square			        fn square(i: i32) -> i32 { i * i }
src			fn src<T, F>(fd: libc::c_int, _readable: bool, f: F) -> T where
stack			pub mod stack;
stack_exhausted			extern fn stack_exhausted() 
stack_guard			pub fn stack_guard() -> uint 
stack_overflow			pub mod stack_overflow;
stack_overflow			pub mod stack_overflow;
stack_size			    pub fn stack_size(mut self, size: uint) -> Builder 
stack_t			pub struct stack_t 
stampede_once			    fn stampede_once() 
standard_error			pub fn standard_error(kind: IoErrorKind) -> IoError 
start_selection			    fn start_selection(&self, mut token: SignalToken) -> StartResult 
start_selection			    pub fn start_selection(&mut self, token: SignalToken) -> SelectionResult<T> 
start_selection			    fn start_selection(&self, token: SignalToken) -> StartResult;
start_selection			    pub fn start_selection(&mut self, token: SignalToken) -> StartResult 
start_selection			    pub fn start_selection(&mut self, token: SignalToken) -> SelectionResult<T> 
start_selection			    pub fn start_selection(&self, token: SignalToken) -> StartResult 
start_thread			pub fn start_thread(main: *mut libc::c_void) -> thread::rust_thread_return 
starts_with			    pub fn starts_with<P: ?Sized>(&self, base: &P) -> bool where P: AsPath 
stat			    fn stat(&self) -> IoResult<FileStat> { stat(self) }
stat			    fn stat(&self) -> IoResult<FileStat>;
stat			    pub fn stat(&self) -> IoResult<FileStat> 
stat			pub fn stat(path: &Path) -> IoResult<FileStat> 
stat			pub fn stat(p: &Path) -> IoResult<FileStat> 
stat			pub fn stat(p: &Path) -> io::Result<FileAttr> 
stat			pub fn stat(p: &Path) -> IoResult<FileStat> 
stat			pub fn stat(p: &Path) -> io::Result<FileAttr> 
state			pub mod state;
state			    pub fn state(&'static self) -> State 
states			    fn states() 
static_smoke			    fn static_smoke() 
static_smoke			    fn static_smoke() 
statik			    fn statik() 
status			    pub fn status(&self) -> IoResult<ProcessExit> 
status			    pub fn status(&mut self) -> io::Result<ExitStatus> 
std			mod std 
stderr			    pub fn stderr<'a>(&'a mut self, cfg: StdioContainer) -> &'a mut Command 
stderr			pub fn stderr() -> LineBufferedWriter<StdWriter> 
stderr			    pub fn stderr(&mut self, cfg: Stdio) -> &mut Command 
stderr			    pub fn stderr(mut self, stderr: Box<Writer + Send + 'static>) -> Builder 
stderr_raw			pub fn stderr_raw() -> StdWriter 
stdin			    pub fn stdin<'a>(&'a mut self, cfg: StdioContainer) -> &'a mut Command 
stdin			pub fn stdin() -> StdinReader 
stdin			    pub fn stdin(&mut self, cfg: Stdio) -> &mut Command 
stdin_raw			pub fn stdin_raw() -> StdReader 
stdin_works			    fn stdin_works() 
stdin_works			    fn stdin_works() 
stdio			pub mod stdio;
stdout			    pub fn stdout<'a>(&'a mut self, cfg: StdioContainer) -> &'a mut Command 
stdout			pub fn stdout() -> LineBufferedWriter<StdWriter> 
stdout			    pub fn stdout(&mut self, cfg: Stdio) -> &mut Command 
stdout			    pub fn stdout(mut self, stdout: Box<Writer + Send + 'static>) -> Builder 
stdout_raw			pub fn stdout_raw() -> StdWriter 
stdout_works			    fn stdout_works() 
stdout_works			    fn stdout_works() 
store_func			    fn store_func(ptr: &AtomicUsize, module: &str, symbol: &str,
str_components			    pub fn str_components<'a>(&'a self) -> StrComponents<'a> 
str_components			    pub fn str_components<'a>(&'a self) -> StrComponents<'a> 
strconv			pub mod strconv;
stream			mod stream;
stream_data_waiting			    fn stream_data_waiting() 
stream_send_recv_stress			    fn stream_send_recv_stress() 
strerror_r			        fn strerror_r(errnum: c_int, buf: *mut c_char,
stress			    fn stress() 
stress			    fn stress() 
stress			    fn stress() 
stress_bound			        unsafe fn stress_bound(bound: usize) 
stress_factor			    pub fn stress_factor() -> usize 
stress_shared			    fn stress_shared() 
sub			    fn sub(self, rhs: &HashSet<T, S>) -> HashSet<T, S> 
sub			        fn sub(self, other: &SteadyTime) -> Duration 
sub			    fn sub(self, other: &SteadyTime) -> Duration 
sub			    fn sub(self, rhs: Duration) -> Duration 
success			    pub fn success(&self) -> bool 
success			    pub fn success(&self) -> bool 
success			    pub fn success(&self) -> bool 
success			    pub fn success(&self) -> bool 
symbol			    pub unsafe fn symbol(handle: *mut u8, symbol: *const libc::c_char) -> *mut u8 
symbol			    pub unsafe fn symbol(handle: *mut u8,
symbol			    pub unsafe fn symbol<T>(&self, symbol: &str) -> Result<*mut T, String> 
syminfo_cb			    extern fn syminfo_cb(data: *mut libc::c_void,
symlink			pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> 
symlink			pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> 
symlink			pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> 
symlink			pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> 
symlink			pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> 
symlink_noexist			    fn symlink_noexist() 
symlink_noexist			    fn symlink_noexist() 
symlinks_work			    fn symlinks_work() 
symlinks_work			    fn symlinks_work() 
symmetric_difference			    pub fn symmetric_difference<'a>(&'a self, other: &'a HashSet<T, S>)
sync			pub mod sync;
sync			mod sync;
sync			pub mod sync;
sync			pub mod sync;
sync1			    fn sync1() 
sync2			    fn sync2() 
sync3			    fn sync3() 
sync_all			    pub fn sync_all(&self) -> io::Result<()> 
sync_channel			pub fn sync_channel<T: Send>(bound: usize) -> (SyncSender<T>, Receiver<T>) 
sync_data			    pub fn sync_data(&self) -> io::Result<()> 
sync_doesnt_kill_anything			    fn sync_doesnt_kill_anything() 
sync_doesnt_kill_anything			    fn sync_doesnt_kill_anything() 
sync_tests			mod sync_tests 
sys::process::ProcessConfig for Command			impl sys::process::ProcessConfig<EnvKey, CString> for Command 
sys_common::AsInner for File			impl sys_common::AsInner<fs_imp::FileDesc> for File 
sys_common::AsInner for PipeStream			impl sys_common::AsInner<sys::fs::FileDesc> for PipeStream 
sys_common::AsInner for TcpAcceptor			impl sys_common::AsInner<TcpAcceptorImp> for TcpAcceptor 
sys_common::AsInner for TcpListener			impl sys_common::AsInner<TcpListenerImp> for TcpListener 
sys_common::AsInner for TcpStream			impl sys_common::AsInner<TcpStreamImp> for TcpStream 
sys_common::AsInner for UdpSocket			impl sys_common::AsInner<UdpSocketImp> for UdpSocket 
sys_common::AsInner for UnixAcceptor			impl sys_common::AsInner<UnixAcceptorImp> for UnixAcceptor 
sys_common::AsInner for UnixListener			impl sys_common::AsInner<UnixListenerImp> for UnixListener 
sys_common::AsInner for UnixStream			impl sys_common::AsInner<UnixStreamImp> for UnixStream 
syscall			            fn syscall(number: libc::c_long, ...) -> libc::c_long;
sysctl			        fn sysctl(name: *mut libc::c_int, namelen: libc::c_uint,
table			mod table;
table			    pub fn table(&self) -> &M 
take			    pub fn take(mut self) -> (EmptyBucket<K, V, M>, K, V) 
take			    fn take(self, limit: u64) -> Take<Self> 
take			    pub fn take() -> Option<Vec<Vec<u8>>> 
take			pub fn take() -> Option<Vec<Vec<u8>>> { imp::take() }
take_eof			    fn take_eof() 
take_some_bytes			    fn take_some_bytes() 
take_to_wake			    fn take_to_wake(&mut self) -> SignalToken 
take_to_wake			    fn take_to_wake(&mut self) -> SignalToken 
tan			    fn tan(self) -> f32 
tan			        pub fn tan(n: c_double) -> c_double;
tan			    fn tan(self) -> f64 
tan			    fn tan(self) -> Self;
tanf			        pub fn tanf(n: c_float) -> c_float;
tanh			    fn tanh(self) -> f32 
tanh			        pub fn tanh(n: c_double) -> c_double;
tanh			    fn tanh(self) -> f64 
tanh			    fn tanh(self) -> Self;
tanhf			        pub fn tanhf(n: c_float) -> c_float;
target_get_sp_limit			    unsafe fn target_get_sp_limit() -> uint 
target_record_sp_limit			    unsafe fn target_record_sp_limit(_: uint) 
target_record_sp_limit			    unsafe fn target_record_sp_limit(limit: uint) 
target_record_stack_bounds			    unsafe fn target_record_stack_bounds(_stack_lo: uint, _stack_hi: uint) {}
target_record_stack_bounds			    unsafe fn target_record_stack_bounds(stack_lo: uint, stack_hi: uint) 
task_pool			mod task_pool;
tcp			mod tcp;
tcp			pub mod tcp;
tcp			pub mod tcp;
tcp			pub mod tcp;
tcp_clone_smoke			    fn tcp_clone_smoke() 
tcp_clone_smoke			    fn tcp_clone_smoke() 
tcp_clone_two_read			    fn tcp_clone_two_read() 
tcp_clone_two_read			    fn tcp_clone_two_read() 
tcp_clone_two_write			    fn tcp_clone_two_write() 
tcp_clone_two_write			    fn tcp_clone_two_write() 
tee			    fn tee<W: Write>(self, out: W) -> Tee<Self, W> 
tee			    fn tee() 
tell			    fn tell(&self) -> IoResult<u64> 
tell			    fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }
tell			    fn tell(&self) -> IoResult<u64>;
tell			    fn tell(&self) -> IoResult<u64> 
tell			    pub fn tell(&self) -> IoResult<u64> 
tell			    pub fn tell(&self) -> IoResult<u64> 
temp_dir			pub fn temp_dir() -> PathBuf 
temp_dir			pub fn temp_dir() -> PathBuf 
temp_dir			pub fn temp_dir() -> PathBuf 
tempdir			mod tempdir;
tempfile			mod tempfile;
term			        unsafe fn term(signum: libc::c_int) -> ! 
test			mod test 
test			    fn test() 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			pub mod test;
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			    fn test() 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			    fn test() 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			    mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tgamma			        pub fn tgamma(n: c_double) -> c_double;
tgammaf			        pub fn tgammaf(n: c_float) -> c_float;
thread			pub mod thread;
thread			pub mod thread;
thread			pub mod thread;
thread			pub mod thread;
thread			    pub fn thread(&self) -> &Thread 
thread_info			pub mod thread_info;
thread_info::NewThread for Thread			impl thread_info::NewThread for Thread 
thread_local			pub mod thread_local;
thread_local			pub mod thread_local;
thread_local			pub mod thread_local;
thread_local			pub mod thread_local;
thread_rng			pub fn thread_rng() -> ThreadRng 
thread_start			pub extern fn thread_start(main: *mut libc::c_void) -> rust_thread_return 
thread_start			pub extern "system" fn thread_start(main: *mut libc::c_void) -> rust_thread_return 
thunk			pub mod thunk;
time			pub mod time;
time			pub mod time;
time			pub mod time;
time_to_live			    pub fn time_to_live(&mut self, ttl: int) -> IoResult<()> 
time_to_live			    pub fn time_to_live(&self, ttl: i32) -> io::Result<()> 
timeout			pub fn timeout(desc: &'static str) -> IoError 
timeout_concurrent_read			    fn timeout_concurrent_read() 
timeout_concurrent_read			    fn timeout_concurrent_read() 
timer			pub mod timer;
timer			pub mod timer;
timer			pub mod timer;
tmpdir			    pub fn tmpdir() -> TempDir 
tmpdir			    pub fn tmpdir() -> TempDir 
tmpdir			pub fn tmpdir() -> Path 
to_ascii_lowercase			    fn to_ascii_lowercase(&self) -> Self::Owned;
to_ascii_lowercase			    fn to_ascii_lowercase(&self) -> String 
to_ascii_lowercase			    fn to_ascii_lowercase(&self) -> Vec<u8> 
to_ascii_lowercase			    fn to_ascii_lowercase(&self) -> char 
to_ascii_lowercase			    fn to_ascii_lowercase(&self) -> u8 { ASCII_LOWERCASE_MAP[*self as usize] }
to_ascii_lowercase			    fn to_ascii_lowercase(&self) -> Wtf8Buf 
to_ascii_uppercase			    fn to_ascii_uppercase(&self) -> Self::Owned;
to_ascii_uppercase			    fn to_ascii_uppercase(&self) -> String 
to_ascii_uppercase			    fn to_ascii_uppercase(&self) -> Vec<u8> 
to_ascii_uppercase			    fn to_ascii_uppercase(&self) -> char 
to_ascii_uppercase			    fn to_ascii_uppercase(&self) -> u8 { ASCII_UPPERCASE_MAP[*self as usize] }
to_ascii_uppercase			    fn to_ascii_uppercase(&self) -> Wtf8Buf 
to_bytes			    pub fn to_bytes(&self) -> &[u8] 
to_bytes_with_nul			    pub fn to_bytes_with_nul(&self) -> &[u8] 
to_char			    pub fn to_char(&self) -> Option<char> 
to_char_lossy			    pub fn to_char_lossy(&self) -> char 
to_cstring			    fn to_cstring(&self) -> Result<CString, NulError> 
to_cstring			    fn to_cstring(&self) -> Result<CString, NulError>;
to_degrees			    fn to_degrees(self) -> f32 { num::Float::to_degrees(self) }
to_degrees			    fn to_degrees(self) -> f64 { num::Float::to_degrees(self) }
to_degrees			    fn to_degrees(self) -> Self;
to_i64			        fn to_i64(&self) -> Option<i64> { self.x.to_i64() }
to_ipv4			    pub fn to_ipv4(&self) -> Option<Ipv4Addr> 
to_ipv6_compatible			    pub fn to_ipv6_compatible(&self) -> Ipv6Addr 
to_ipv6_mapped			    pub fn to_ipv6_mapped(&self) -> Ipv6Addr 
to_ms			    fn to_ms(&self, ft: &libc::FILETIME) -> u64 
to_os_string			    pub fn to_os_string(&self) -> OsString 
to_owned			    fn to_owned(&self) -> OsString { self.to_os_string() }
to_owned			    fn to_owned(&self) -> PathBuf { self.to_path_buf() }
to_owned			    pub fn to_owned(&self) -> Buf 
to_owned			    pub fn to_owned(&self) -> Buf 
to_path_buf			    pub fn to_path_buf(&self) -> PathBuf 
to_radians			    fn to_radians(self) -> f32 { num::Float::to_radians(self) }
to_radians			    fn to_radians(self) -> f64 { num::Float::to_radians(self) }
to_radians			    fn to_radians(self) -> Self;
to_socket_addr			    fn to_socket_addr(&self) -> IoResult<SocketAddr> { Ok(*self) }
to_socket_addr			    fn to_socket_addr(&self) -> IoResult<SocketAddr> 
to_socket_addr_all			    fn to_socket_addr_all(&self) -> IoResult<Vec<SocketAddr>> 
to_socket_addr_ipaddr_u16			    fn to_socket_addr_ipaddr_u16() 
to_socket_addr_ipaddr_u16			    fn to_socket_addr_ipaddr_u16() 
to_socket_addr_socketaddr			    fn to_socket_addr_socketaddr() 
to_socket_addr_socketaddr			    fn to_socket_addr_socketaddr() 
to_socket_addr_str			    fn to_socket_addr_str() 
to_socket_addr_str			    fn to_socket_addr_str() 
to_socket_addr_str_u16			    fn to_socket_addr_str_u16() 
to_socket_addr_str_u16			    fn to_socket_addr_str_u16() 
to_socket_addrs			    fn to_socket_addrs(&self) -> io::Result<Self::Iter>;
to_socket_addrs			    fn to_socket_addrs(&self) -> io::Result<T::Iter> 
to_socket_addrs			    fn to_socket_addrs(&self) -> io::Result<option::IntoIter<SocketAddr>> 
to_socket_addrs			    fn to_socket_addrs(&self) -> io::Result<vec::IntoIter<SocketAddr>> 
to_str			    pub fn to_str(&self) -> Option<&str> 
to_str			    pub fn to_str(&self) -> Option<&str> 
to_str			    pub fn to_str(&self) -> Option<&str> 
to_str			    pub fn to_str(&self) -> Option<&str> 
to_str_base_36			        fn to_str_base_36(b: &mut Bencher) 
to_str_bin			        fn to_str_bin(b: &mut Bencher) 
to_str_dec			        fn to_str_dec(b: &mut Bencher) 
to_str_digits			pub fn to_str_digits(num: f32, dig: uint) -> String 
to_str_digits			pub fn to_str_digits(num: f64, dig: uint) -> String 
to_str_exact			pub fn to_str_exact(num: f32, dig: uint) -> String 
to_str_exact			pub fn to_str_exact(num: f64, dig: uint) -> String 
to_str_exp_digits			pub fn to_str_exp_digits(num: f32, dig: uint, upper: bool) -> String 
to_str_exp_digits			pub fn to_str_exp_digits(num: f64, dig: uint, upper: bool) -> String 
to_str_exp_exact			pub fn to_str_exp_exact(num: f32, dig: uint, upper: bool) -> String 
to_str_exp_exact			pub fn to_str_exp_exact(num: f64, dig: uint, upper: bool) -> String 
to_str_hex			pub fn to_str_hex(num: f32) -> String 
to_str_hex			pub fn to_str_hex(num: f64) -> String 
to_str_hex			        fn to_str_hex(b: &mut Bencher) 
to_str_oct			        fn to_str_oct(b: &mut Bencher) 
to_str_radix_special			pub fn to_str_radix_special(num: f32, rdx: u32) -> (String, bool) 
to_str_radix_special			pub fn to_str_radix_special(num: f64, rdx: u32) -> (String, bool) 
to_string			pub fn to_string(num: f32) -> String 
to_string			pub fn to_string(num: f64) -> String 
to_string			        fn to_string(x: int, base: u8) 
to_string			        fn to_string(x: uint, base: u8) 
to_string_lossy			    pub fn to_string_lossy(&self) -> CowString 
to_string_lossy			    pub fn to_string_lossy(&self) -> Cow<str> 
to_string_lossy			    pub fn to_string_lossy(&self) -> CowString 
to_string_lossy			    pub fn to_string_lossy(&self) -> CowString 
to_string_lossy			    pub fn to_string_lossy(&self) -> CowString 
to_u32			    pub fn to_u32(&self) -> u32 
to_u64			        fn to_u64(&self) -> Option<u64> { self.x.to_u64() }
to_utf16			pub fn to_utf16(s: &Path) -> IoResult<Vec<u16>> 
to_utf16			pub fn to_utf16(s: &Path) -> Vec<u16> 
to_utf16			fn to_utf16(s: Option<&str>) -> IoResult<Vec<u16>> 
to_utf16			fn to_utf16(c: &CString) -> IoResult<Vec<u16>> 
to_utf16_os			fn to_utf16_os(s: &OsStr) -> Vec<u16> 
tokens			pub fn tokens() -> (WaitToken, SignalToken) 
trace_fn			    extern fn trace_fn(ctx: *mut uw::_Unwind_Context,
translate_status			fn translate_status(status: c_int) -> ProcessExit 
translate_status			fn translate_status(status: c_int) -> ExitStatus 
trim_left			    fn trim_left(&mut self) 
trim_right			    fn trim_right(&mut self) 
trunc			    fn trunc(self) -> f32 { num::Float::trunc(self) }
trunc			    fn trunc(self) -> f64 { num::Float::trunc(self) }
trunc			    fn trunc(self) -> Self;
truncate			    pub fn truncate(&mut self, truncate: bool) -> &mut OpenOptions 
truncate			    pub fn truncate(&mut self, size: i64) -> IoResult<()> 
truncate			    pub fn truncate(&mut self, new_len: uint) 
truncate			    pub fn truncate(&self, offset: i64) -> IoResult<()> 
truncate			    pub fn truncate(&mut self, truncate: bool) 
truncate			    pub fn truncate(&self, size: u64) -> io::Result<()> 
truncate			    pub fn truncate(&mut self, offset: i64) -> IoResult<()> 
truncate			    pub fn truncate(&mut self, truncate: bool) { self.truncate = truncate; }
truncate			    pub fn truncate(&self, size: u64) -> io::Result<()> 
truncate_utf16_at_nul			pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] 
truncate_works			    fn truncate_works() 
truncate_works			    fn truncate_works() 
try			pub unsafe fn try<F: FnOnce()>(f: F) -> Result<(), Box<Any + Send>> 
try_clone			    pub fn try_clone(&self) -> io::Result<TcpListener> 
try_clone			    pub fn try_clone(&self) -> io::Result<TcpStream> 
try_clone			    pub fn try_clone(&self) -> io::Result<UdpSocket> 
try_connect			    fn try_connect(p: *const u16) -> Option<libc::HANDLE> 
try_fn			    extern fn try_fn<F: FnOnce()>(opt_closure: *mut c_void) 
try_lock			    fn try_lock() 
try_lock			    pub fn try_lock(&'static self) -> TryLockResult<MutexGuard<()>> 
try_lock			    pub fn try_lock(&self) -> TryLockResult<MutexGuard<T>> 
try_lock			    pub unsafe fn try_lock(&self) -> bool { self.0.try_lock() }
try_lock			    pub unsafe fn try_lock(&self) -> bool 
try_lock			    pub unsafe fn try_lock(&self) -> bool 
try_read			    pub fn try_read(&'static self)
try_read			    pub fn try_read(&self) -> TryLockResult<RwLockReadGuard<T>> 
try_read			    pub unsafe fn try_read(&self) -> bool { self.0.try_read() }
try_read			    pub unsafe fn try_read(&self) -> bool 
try_read			    pub unsafe fn try_read(&self) -> bool 
try_recv			    pub fn try_recv(&self) -> Result<T, TryRecvError> 
try_recv			    pub fn try_recv(&mut self) -> Result<T, Failure<T>> 
try_recv			    pub fn try_recv(&mut self) -> Result<T, Failure> 
try_recv			    pub fn try_recv(&mut self) -> Result<T, Failure<T>> 
try_recv			    pub fn try_recv(&self) -> Result<T, Failure> 
try_recv_states			    fn try_recv_states() 
try_send			    pub fn try_send(&self, t: T) -> Result<(), TrySendError<T>> 
try_send			    pub fn try_send(&self, t: T) -> Result<(), super::TrySendError<T>> 
try_send1			    fn try_send1() 
try_send2			    fn try_send2() 
try_send3			    fn try_send3() 
try_wait			    pub fn try_wait(&self) -> Option<ProcessExit> 
try_wait			    pub fn try_wait(&self) -> Option<ExitStatus> 
try_write			    pub fn try_write(&'static self)
try_write			    pub fn try_write(&self) -> TryLockResult<RwLockWriteGuard<T>> 
try_write			    pub unsafe fn try_write(&self) -> bool { self.0.try_write() }
try_write			    pub unsafe fn try_write(&self) -> bool 
try_write			    pub unsafe fn try_write(&self) -> bool 
tsa			    fn tsa<A: ToSocketAddrs>(a: A) -> io::Result<Vec<SocketAddr>> 
tty			pub mod tty;
tty			pub mod tty;
tuple			mod tuple;
two_mutexes			    fn two_mutexes() 
u64_from_be_bytes			pub fn u64_from_be_bytes(data: &[u8], start: uint, size: uint) -> u64 
u64_from_be_bytes_4_aligned			    fn u64_from_be_bytes_4_aligned(b: &mut Bencher) 
u64_from_be_bytes_4_unaligned			    fn u64_from_be_bytes_4_unaligned(b: &mut Bencher) 
u64_from_be_bytes_7_aligned			    fn u64_from_be_bytes_7_aligned(b: &mut Bencher) 
u64_from_be_bytes_7_unaligned			    fn u64_from_be_bytes_7_unaligned(b: &mut Bencher) 
u64_from_be_bytes_8_aligned			    fn u64_from_be_bytes_8_aligned(b: &mut Bencher) 
u64_from_be_bytes_8_unaligned			    fn u64_from_be_bytes_8_unaligned(b: &mut Bencher) 
u64_to_be_bytes			pub fn u64_to_be_bytes<T, F>(n: u64, size: uint, f: F) -> T where
u64_to_le_bytes			pub fn u64_to_le_bytes<T, F>(n: u64, size: uint, f: F) -> T where
u8_slice_as_os_str			unsafe fn u8_slice_as_os_str(s: &[u8]) -> &OsStr 
udp			mod udp;
udp			pub mod udp;
udp			pub mod udp;
udp			pub mod udp;
udp_clone_smoke			    fn udp_clone_smoke() 
udp_clone_smoke			    fn udp_clone_smoke() 
udp_clone_two_read			    fn udp_clone_two_read() 
udp_clone_two_read			    fn udp_clone_two_read() 
udp_clone_two_write			    fn udp_clone_two_write() 
udp_clone_two_write			    fn udp_clone_two_write() 
uid			    fn uid(&self) -> Option<uint> 
uid			    pub fn uid<'a>(&'a mut self, id: uint) -> &'a mut Command 
uid			    fn uid(&self) -> Option<uint>;
uid			    fn uid(&mut self, id: uid_t) -> &mut process::Command 
uid			    fn uid(&mut self, id: uid_t) -> &mut process::Command;
uid_fails_on_windows			    fn uid_fails_on_windows() 
uid_to_root_fails			    fn uid_to_root_fails() 
uid_to_root_fails			    fn uid_to_root_fails() 
uid_works			    fn uid_works() 
uid_works			    fn uid_works() 
uint			    mod uint 
uint_macros			mod uint_macros;
unblocks			    fn unblocks() 
unicode_path_exists			    fn unicode_path_exists() 
unicode_path_exists			    fn unicode_path_exists() 
unicode_path_is_dir			    fn unicode_path_is_dir() 
unicode_path_is_dir			    fn unicode_path_is_dir() 
unimpl			pub fn unimpl() -> IoError 
unimpl			pub fn unimpl() -> IoError 
union			    pub fn union<'a>(&'a self, other: &'a HashSet<T, S>) -> Union<'a, T, S> 
unit			mod unit;
unix_clone_smoke			    fn unix_clone_smoke() 
unix_clone_two_read			    fn unix_clone_two_read() 
unix_clone_two_write			    fn unix_clone_two_write() 
unix_socket			fn unix_socket(ty: libc::c_int) -> IoResult<fd_t> 
unlink			pub fn unlink(path: &Path) -> IoResult<()> 
unlink			pub fn unlink(p: &Path) -> IoResult<()> 
unlink			pub fn unlink(p: &Path) -> io::Result<()> 
unlink			pub fn unlink(p: &Path) -> IoResult<()> 
unlink			pub fn unlink(p: &Path) -> io::Result<()> 
unlink_readonly			    fn unlink_readonly() 
unlink_readonly			    fn unlink_readonly() 
unlock			    pub unsafe fn unlock(&self) { self.0.unlock() }
unlock			    pub unsafe fn unlock(&self) 
unlock			    pub unsafe fn unlock(&self) 
unpark			    pub fn unpark(&self) 
unregister_dtor			unsafe fn unregister_dtor(key: Key) -> bool 
unsetenv			pub fn unsetenv(n: &str) 
unsetenv			pub fn unsetenv(n: &OsStr) 
unsetenv			pub fn unsetenv(n: &OsStr) 
unwind			pub mod unwind;
unwrap			    pub fn unwrap(self) -> fd_t 
unwrap			    pub fn unwrap(self) -> fd_t 
update_desc			    fn update_desc(self, desc: &'static str) -> IoResult<T> 
update_desc			    fn update_desc(self, desc: &'static str) -> Self;
update_detail			    fn update_detail<D>(self, detail: D) -> IoResult<T> where
update_detail			    fn update_detail<D>(self, detail: D) -> Self where
update_err			        fn update_err<T>(result: IoResult<T>, file: &File) -> IoResult<T> 
update_err			    fn update_err<T>(err: IoResult<T>, path: &Path) -> IoResult<T> 
update_err			    fn update_err<T>(result: IoResult<T>, from: &Path, to: &Path) -> IoResult<T> 
update_err			    fn update_err<D>(self, desc: &'static str, detail: D) -> IoResult<T> where
update_err			    fn update_err<D>(self, desc: &'static str, detail: D) -> Self where
update_normalized			    fn update_normalized(&mut self, s: &str) 
update_sepidx			    fn update_sepidx(&mut self) 
upgrade			    pub fn upgrade(&mut self, up: Receiver<T>) -> UpgradeResult 
upgrade			    pub fn upgrade(&mut self, up: Receiver<T>) -> UpgradeResult 
usable_capacity			    fn usable_capacity(&self, cap: usize) -> usize 
util			mod util;
util			pub mod util;
util			pub mod util;
utime			    fn utime() 
utime			    fn utime() 
utime			pub fn utime(p: &Path, atime: u64, mtime: u64) -> IoResult<()> 
utime			pub fn utime(p: &Path, atime: u64, mtime: u64) -> IoResult<()> 
utime_noexist			    fn utime_noexist() 
utime_noexist			    fn utime_noexist() 
utimes			    pub fn utimes(filename: *const libc::c_char,
utimes			pub fn utimes(p: &Path, atime: u64, mtime: u64) -> io::Result<()> 
utimes			pub fn utimes(p: &Path, atime: u64, mtime: u64) -> io::Result<()> 
uw			mod uw 
v1			pub mod v1;
values			    pub fn values<'a>(&'a self) -> Values<'a, K, V> 
var			pub fn var<K: ?Sized>(key: &K) -> Result<String, VarError> where K: AsOsStr 
var_os			pub fn var_os<K: ?Sized>(key: &K) -> Option<OsString> where K: AsOsStr 
vars			pub fn vars() -> Vars 
vars_os			pub fn vars_os() -> VarsOs 
vec_seek_before_0			    fn vec_seek_before_0() 
vec_seek_past_end			    fn vec_seek_past_end() 
vectored_handler			extern "system" fn vectored_handler(ExceptionInfo: *mut EXCEPTION_POINTERS) -> LONG 
verify			    fn verify(&self, mutex: &sys_mutex::Mutex) 
w			        fn w(value: &[u8]) -> &Wtf8 { unsafe { transmute(value) } }
wait			    pub fn wait(&mut self) -> IoResult<ProcessExit> 
wait			    pub fn wait(&mut self) -> io::Result<ExitStatus> 
wait			    pub fn wait(&self) -> BarrierWaitResult 
wait			    pub fn wait<'a, T>(&'static self, guard: MutexGuard<'a, T>)
wait			    pub fn wait<'a, T>(&self, guard: MutexGuard<'a, T>)
wait			    pub fn wait(self) 
wait			    pub fn wait(&self) -> usize 
wait			fn wait<'a, 'b, T: Send>(lock: &'a Mutex<State<T>>,
wait			    pub unsafe fn wait(&self, mutex: &Mutex) { self.0.wait(mutex::raw(mutex)) }
wait			    pub unsafe fn wait(&self, mutex: &Mutex) 
wait			    pub fn wait(&self, deadline: u64) -> IoResult<ProcessExit> 
wait			    pub fn wait(&self) -> io::Result<ExitStatus> 
wait			    pub unsafe fn wait(&self, mutex: &Mutex) 
wait			    pub fn wait(&self, deadline: u64) -> IoResult<ProcessExit> 
wait			    pub fn wait(&self) -> io::Result<ExitStatus> 
wait2			    fn wait2(&self, do_preflight_checks: bool) -> usize 
wait_timeout			    fn wait_timeout() 
wait_timeout			    fn wait_timeout() 
wait_timeout			    pub fn wait_timeout<'a, T>(&'static self, guard: MutexGuard<'a, T>, dur: Duration)
wait_timeout			    pub fn wait_timeout<'a, T>(&self, guard: MutexGuard<'a, T>, dur: Duration)
wait_timeout			    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool 
wait_timeout			    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool 
wait_timeout			    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool 
wait_timeout2			    fn wait_timeout2() 
wait_timeout_with			    fn wait_timeout_with() 
wait_timeout_with			    pub fn wait_timeout_with<'a, T, F>(&'static self,
wait_timeout_with			    pub fn wait_timeout_with<'a, T, F>(&self,
wait_with_output			    pub fn wait_with_output(mut self) -> IoResult<ProcessOutput> 
wait_with_output			    pub fn wait_with_output(mut self) -> io::Result<Output> 
waitpid			    pub fn waitpid(pid: libc::pid_t, status: *mut libc::c_int,
waitpid_helper			        fn waitpid_helper(input: libc::c_int,
wakeup			fn wakeup<T>(token: SignalToken, guard: MutexGuard<State<T>>) 
wakeup_senders			    fn wakeup_senders(&self, waited: bool, mut guard: MutexGuard<State<T>>) 
walk_dir			pub fn walk_dir<P: AsPath + ?Sized>(path: &P) -> io::Result<WalkDir> 
walk_dir			pub fn walk_dir(path: &Path) -> IoResult<Directories> 
weak_rng			pub fn weak_rng() -> XorShiftRng 
weeks			    pub fn weeks(weeks: i64) -> Duration 
windows			pub mod windows;
winsize			    pub fn winsize(&mut self) -> IoResult<(int, int)> 
winsize			            struct winsize 
with			    fn with<R, F>(f: F) -> R where F: FnOnce(&mut ThreadInfo) -> R 
with			    pub fn with<F, R>(&'static self, f: F) -> R
with			    pub fn with<R, F>(&'static self, cb: F) -> R where
with_addresses			fn with_addresses<A, T, F>(addr: A, mut action: F) -> IoResult<T> where
with_arg			    pub fn with_arg<F>(func: F) -> Thunk<'a,A,R>
with_argv			fn with_argv<T,F>(prog: &CString, args: &[CString],
with_argv			fn with_argv<T,F>(prog: &CString, args: &[CString], cb: F) -> T
with_capacities			    pub fn with_capacities(reader_cap: usize, writer_cap: usize, inner: S)
with_capacities			    pub fn with_capacities(reader_cap: uint, writer_cap: uint, inner: S)
with_capacity			    pub fn with_capacity(capacity: usize) -> HashMap<K, V, RandomState> 
with_capacity			    pub fn with_capacity(capacity: usize) -> HashSet<T, RandomState> 
with_capacity			    pub fn with_capacity(cap: usize, inner: R) -> BufReader<R> 
with_capacity			    pub fn with_capacity(cap: usize, inner: W) -> BufWriter<W> 
with_capacity			    pub fn with_capacity(cap: uint, inner: R) -> BufferedReader<R> 
with_capacity			    pub fn with_capacity(cap: uint, inner: W) -> BufferedWriter<W> 
with_capacity			    pub fn with_capacity(n: uint) -> MemWriter 
with_capacity			    pub fn with_capacity(n: uint) -> Wtf8Buf 
with_capacity_and_hash_state			    pub fn with_capacity_and_hash_state(capacity: usize, hash_state: S)
with_capacity_and_hash_state			    pub fn with_capacity_and_hash_state(capacity: usize, hash_state: S)
with_dirp			fn with_dirp<T, F>(d: Option<&CString>, cb: F) -> T where
with_dirp			fn with_dirp<T, F>(d: Option<&OsString>, cb: F) -> T where
with_end_to_cap			fn with_end_to_cap<F>(v: &mut Vec<u8>, f: F) -> Result<usize>
with_envp			fn with_envp<K,V,T,F>(env: Option<&HashMap<K, V>>,
with_envp			fn with_envp<T, F>(env: Option<&HashMap<OsString, OsString>>, cb: F) -> T
with_envp			fn with_envp<K, V, T, F>(env: Option<&collections::HashMap<K, V>>, cb: F) -> T
with_envp			fn with_envp<F, T>(env: Option<&collections::HashMap<OsString, OsString>>, cb: F) -> T
with_extension			    fn with_extension<T: BytesContainer>(&self, extension: T) -> Self 
with_extension			    pub fn with_extension<S: ?Sized>(&self, extension: &S) -> PathBuf where S: AsOsStr 
with_file_name			    pub fn with_file_name<S: ?Sized>(&self, file_name: &S) -> PathBuf where S: AsOsStr 
with_filename			    fn with_filename<T: BytesContainer>(&self, filename: T) -> Self 
with_hash_state			    pub fn with_hash_state(hash_state: S) -> HashMap<K, V, S> 
with_hash_state			    pub fn with_hash_state(hash_state: S) -> HashSet<T, S> 
with_task_stdout			fn with_task_stdout<F>(f: F) where F: FnOnce(&mut Writer) -> IoResult<()> 
wouldblock			pub fn wouldblock() -> bool 
wouldblock			pub fn wouldblock() -> bool 
write			    fn write(&mut self, buf: &[u8]) -> io::Result<usize> 
write			    pub fn write(&mut self, write: bool) -> &mut OpenOptions 
write			            fn write(&mut self, b: &[u8]) -> io::Result<usize> { Ok(b.len()) }
write			            fn write(&mut self, buf: &[u8]) -> io::Result<usize> { Ok(buf.len()) }
write			    fn write(&mut self, buf: &[u8]) -> io::Result<usize> 
write			    fn write(&mut self, buf: &[u8]) -> io::Result<usize> 
write			    fn write(&mut self, data: &[u8]) -> io::Result<usize> 
write			    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { (**self).write(buf) }
write			    fn write(&mut self, buf: &[u8]) -> io::Result<usize> 
write			    fn write(&mut self, data: &[u8]) -> io::Result<usize> 
write			    fn write(&mut self, buf: &[u8]) -> Result<usize>;
write			    fn write(&mut self, data: &[u8]) -> Result<usize> 
write			    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { Ok(buf.len()) }
write			    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { self.0.write(buf) }
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.write_all(buf) }
write			    fn write(&mut self, buf: &[u8]) -> io::Result<usize> 
write			    pub fn write(&'static self) -> LockResult<RwLockWriteGuard<'static, ()>> 
write			    pub fn write(&self) -> LockResult<RwLockWriteGuard<T>> 
write			    pub fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			pub fn write<T, L, W>(fd: sock_t,
write			    pub fn write(&self, buf: &[u8]) -> io::Result<usize> 
write			    pub unsafe fn write(&self) { self.0.write() }
write			pub fn write(w: &mut Writer) -> IoResult<()> 
write			    pub fn write(&self, buf: &[u8]) -> io::Result<usize> 
write			    pub fn write(&self, buf: &[u8]) -> IoResult<()> 
write			    pub fn write(&mut self, write: bool) 
write			    pub fn write(&self, buf: &[u8]) -> io::Result<usize> 
write			    pub fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			    pub fn write(&self, buf: &[u8]) -> io::Result<usize> 
write			    pub unsafe fn write(&self) 
write			    pub fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			pub fn write(w: &mut Writer) -> IoResult<()> 
write			    pub fn write(&self, buf: &[u8]) -> IoResult<()> 
write			    pub fn write(&mut self, write: bool) { self.write = write; }
write			    pub fn write(&self, buf: &[u8]) -> io::Result<usize> 
write			    pub fn write(&self, buf: &[u8]) -> io::Result<usize> 
write			pub fn write(h: HANDLE, buf: &[u8]) -> io::Result<usize> 
write			    pub fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			    pub fn write(&self, buf: &[u8]) -> io::Result<usize> 
write			    pub unsafe fn write(&self) 
write			    pub fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write_all			    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> { (**self).write_all(buf) }
write_all			    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> 
write_all			    fn write_all(&mut self, data: &[u8]) -> io::Result<()> 
write_all			    fn write_all(&mut self, mut buf: &[u8]) -> Result<()> 
write_all			            fn write_all(&mut self, _: &[u8]) -> old_io::IoResult<()> { Ok(()) }
write_all			            fn write_all(&mut self, _buf: &[u8]) -> IoResult<()> { Ok(()) }
write_all			        fn write_all(&mut self, _: &[u8]) -> old_io::IoResult<()> { Ok(()) }
write_all			    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> 
write_all			    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> 
write_all			    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> 
write_all			    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> 
write_all			    fn write_all(&mut self, src: &[u8]) -> IoResult<()> 
write_all			    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> { (**self).write_all(buf) }
write_all			    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> { self.inner.write_all(buf) }
write_all			    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> 
write_all			    fn write_all(&mut self, buf: &[u8]) -> IoResult<()>;
write_all			    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> 
write_all			    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> 
write_all			    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> 
write_all			    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> 
write_all			    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> 
write_all			            fn write_all(&mut self, _buf: &[u8]) -> old_io::IoResult<()> 
write_all			    fn write_all(&mut self, _buf: &[u8]) -> old_io::IoResult<()> { Ok(()) }
write_all			    fn write_all(&mut self, buf: &[u8]) -> old_io::IoResult<()> 
write_all			    fn write_all(&mut self, bytes: &[u8]) -> IoResult<()> 
write_be_f32			    fn write_be_f32(&mut self, f: f32) -> IoResult<()> 
write_be_f64			    fn write_be_f64(&mut self, f: f64) -> IoResult<()> 
write_be_i16			    fn write_be_i16(&mut self, n: i16) -> IoResult<()> 
write_be_i32			    fn write_be_i32(&mut self, n: i32) -> IoResult<()> 
write_be_i64			    fn write_be_i64(&mut self, n: i64) -> IoResult<()> 
write_be_int			    fn write_be_int(&mut self, n: int) -> IoResult<()> 
write_be_u16			    fn write_be_u16(&mut self, n: u16) -> IoResult<()> 
write_be_u32			    fn write_be_u32(&mut self, n: u32) -> IoResult<()> 
write_be_u64			    fn write_be_u64(&mut self, n: u64) -> IoResult<()> 
write_be_uint			    fn write_be_uint(&mut self, n: uint) -> IoResult<()> 
write_begone			    fn write_begone() 
write_bytes			    pub fn write_bytes(&mut self, data: &[u8]) 
write_char			    fn write_char(&mut self, c: char) -> IoResult<()> 
write_close			    fn write_close() 
write_close_ip4			    fn write_close_ip4() 
write_close_ip6			    fn write_close_ip6() 
write_closed			    fn write_closed(&self) -> bool 
write_fmt			    fn write_fmt(&mut self, fmt: fmt::Arguments) -> io::Result<()> { (**self).write_fmt(fmt) }
write_fmt			    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<()> 
write_fmt			    fn write_fmt(&mut self, fmt: fmt::Arguments) -> IoResult<()> 
write_i8			    fn write_i8(&mut self, n: i8) -> IoResult<()> 
write_int			    fn write_int(&mut self, n: int) -> IoResult<()> 
write_le_f32			    fn write_le_f32(&mut self, f: f32) -> IoResult<()> 
write_le_f64			    fn write_le_f64(&mut self, f: f64) -> IoResult<()> 
write_le_i16			    fn write_le_i16(&mut self, n: i16) -> IoResult<()> 
write_le_i32			    fn write_le_i32(&mut self, n: i32) -> IoResult<()> 
write_le_i64			    fn write_le_i64(&mut self, n: i64) -> IoResult<()> 
write_le_int			    fn write_le_int(&mut self, n: int) -> IoResult<()> 
write_le_u16			    fn write_le_u16(&mut self, n: u16) -> IoResult<()> 
write_le_u32			    fn write_le_u32(&mut self, n: u32) -> IoResult<()> 
write_le_u64			    fn write_le_u64(&mut self, n: u64) -> IoResult<()> 
write_le_uint			    fn write_le_uint(&mut self, n: uint) -> IoResult<()> 
write_line			    fn write_line(&mut self, s: &str) -> IoResult<()> 
write_str			            fn write_str(&mut self, s: &str) -> fmt::Result 
write_str			            fn write_str(&mut self, s: &str) -> fmt::Result 
write_str			    fn write_str(&mut self, s: &str) -> IoResult<()> 
write_str			        fn write_str(&mut self, bytes: &str) -> fmt::Result 
write_str			    fn write_str(&mut self, data: &str) -> fmt::Result 
write_timeouts			    fn write_timeouts() 
write_timeouts			    fn write_timeouts() 
write_u8			    fn write_u8(&mut self, n: u8) -> IoResult<()> 
write_uint			    fn write_uint(&mut self, n: uint) -> IoResult<()> 
write_unlock			    pub unsafe fn write_unlock(&self) { self.0.write_unlock() }
write_unlock			    pub unsafe fn write_unlock(&self) { self.read_unlock() }
write_unlock			    pub unsafe fn write_unlock(&self) 
wtf8			pub mod wtf8;
wtf8_as_str			    fn wtf8_as_str() 
wtf8_ascii_byte_at			    fn wtf8_ascii_byte_at() 
wtf8_code_point_at			    fn wtf8_code_point_at() 
wtf8_code_point_range_at			    fn wtf8_code_point_range_at() 
wtf8_code_points			    fn wtf8_code_points() 
wtf8_encode_wide			    fn wtf8_encode_wide() 
wtf8_from_str			    fn wtf8_from_str() 
wtf8_len			    fn wtf8_len() 
wtf8_show			    fn wtf8_show() 
wtf8_slice			    fn wtf8_slice() 
wtf8_slice_from			    fn wtf8_slice_from() 
wtf8_slice_from_not_code_point_boundary			    fn wtf8_slice_from_not_code_point_boundary() 
wtf8_slice_not_code_point_boundary			    fn wtf8_slice_not_code_point_boundary() 
wtf8_slice_to			    fn wtf8_slice_to() 
wtf8_slice_to_not_code_point_boundary			    fn wtf8_slice_to_not_code_point_boundary() 
wtf8_to_string_lossy			    fn wtf8_to_string_lossy() 
wtf8buf_as_slice			    fn wtf8buf_as_slice() 
wtf8buf_extend			    fn wtf8buf_extend() 
wtf8buf_from_iterator			    fn wtf8buf_from_iterator() 
wtf8buf_from_str			    fn wtf8buf_from_str() 
wtf8buf_from_string			    fn wtf8buf_from_string() 
wtf8buf_from_wide			    fn wtf8buf_from_wide() 
wtf8buf_into_string			    fn wtf8buf_into_string() 
wtf8buf_into_string_lossy			    fn wtf8buf_into_string_lossy() 
wtf8buf_new			    fn wtf8buf_new() 
wtf8buf_push			    fn wtf8buf_push() 
wtf8buf_push_char			    fn wtf8buf_push_char() 
wtf8buf_push_str			    fn wtf8buf_push_str() 
wtf8buf_push_wtf8			    fn wtf8buf_push_wtf8() 
wtf8buf_show			    fn wtf8buf_show() 
wtf8buf_truncate			    fn wtf8buf_truncate() 
wtf8buf_truncate_fail_code_point_boundary			    fn wtf8buf_truncate_fail_code_point_boundary() 
wtf8buf_truncate_fail_longer			    fn wtf8buf_truncate_fail_longer() 
y0			        pub fn y0(n: c_double) -> c_double;
y1			        pub fn y1(n: c_double) -> c_double;
yield_now			pub unsafe fn yield_now() { assert_eq!(sched_yield(), 0); }
yield_now			pub unsafe fn yield_now() 
yield_now			    pub fn yield_now() 
yield_now			pub fn yield_now() 
yn			        pub fn yn(i: c_int, n: c_double) -> c_double;
zero			    fn zero() -> f32 { num::Float::zero() }
zero			    fn zero() -> f64 { num::Float::zero() }
zero			    fn zero() -> Self;
zero			    pub fn zero() -> Duration 
zeroed_process_information			fn zeroed_process_information() -> libc::types::os::arch::extra::PROCESS_INFORMATION 
zeroed_process_information			fn zeroed_process_information() -> libc::types::os::arch::extra::PROCESS_INFORMATION 
zeroed_startupinfo			fn zeroed_startupinfo() -> libc::types::os::arch::extra::STARTUPINFO 
zeroed_startupinfo			fn zeroed_startupinfo() -> libc::types::os::arch::extra::STARTUPINFO 
