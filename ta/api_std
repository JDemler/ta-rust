ADDRESS64			struct ADDRESS64 
ADDRESS_MODE			enum ADDRESS_MODE 
Acceptor			pub trait Acceptor<T> 
Acceptor for TcpAcceptor			impl Acceptor<TcpStream> for TcpAcceptor 
Acceptor for UnixAcceptor			impl Acceptor<UnixStream> for UnixAcceptor 
AcceptorInner			struct AcceptorInner 
AcceptorInner			struct AcceptorInner 
AcceptorInner			struct AcceptorInner 
AcceptorState			struct AcceptorState 
AcquireSRWLockExclusive			    pub fn AcquireSRWLockExclusive(SRWLock: LPSRWLOCK);
AcquireSRWLockShared			    pub fn AcquireSRWLockShared(SRWLock: LPSRWLOCK);
Adaptor			        struct Adaptor<'a, T: ?Sized +'a> 
Add for Duration			impl Add for Duration 
AddVectoredExceptionHandler			    fn AddVectoredExceptionHandler(FirstHandler: ULONG,
AsInner			pub trait AsInner<Inner> 
AsRawFd			pub trait AsRawFd 
AsRawFd for io			impl AsRawFd for io::fs::File 
AsRawFd for io			impl AsRawFd for io::net::pipe::UnixAcceptor 
AsRawFd for io			impl AsRawFd for io::net::pipe::UnixListener 
AsRawFd for io			impl AsRawFd for io::net::pipe::UnixStream 
AsRawFd for io			impl AsRawFd for io::net::tcp::TcpAcceptor 
AsRawFd for io			impl AsRawFd for io::net::tcp::TcpListener 
AsRawFd for io			impl AsRawFd for io::net::tcp::TcpStream 
AsRawFd for io			impl AsRawFd for io::net::udp::UdpSocket 
AsRawFd for io			impl AsRawFd for io::pipe::PipeStream 
AsRawHandle			pub trait AsRawHandle 
AsRawHandle for io			impl AsRawHandle for io::fs::File 
AsRawHandle for io			impl AsRawHandle for io::net::pipe::UnixAcceptor 
AsRawHandle for io			impl AsRawHandle for io::net::pipe::UnixListener 
AsRawHandle for io			impl AsRawHandle for io::net::pipe::UnixStream 
AsRawHandle for io			impl AsRawHandle for io::pipe::PipeStream 
AsRawSocket			pub trait AsRawSocket 
AsRawSocket for io			impl AsRawSocket for io::net::tcp::TcpAcceptor 
AsRawSocket for io			impl AsRawSocket for io::net::tcp::TcpListener 
AsRawSocket for io			impl AsRawSocket for io::net::tcp::TcpStream 
AsRawSocket for io			impl AsRawSocket for io::net::udp::UdpSocket 
AsciiExt			impl AsciiExt<Vec<u8>> for [u8] 
AsciiExt			pub trait AsciiExt<T = Self> 
AsciiExt for char			impl AsciiExt for char 
AsciiExt for str			impl AsciiExt<String> for str 
AsciiExt for u8			impl AsciiExt for u8 
BadReader			    impl<T: Reader> BadReader<T> 
BadReader			    struct BadReader<T> 
BadReaderBehavior			    enum BadReaderBehavior 
Barrier			impl Barrier 
Barrier			pub struct Barrier 
BarrierState			struct BarrierState 
BarrierWaitResult			impl BarrierWaitResult 
BarrierWaitResult			pub struct BarrierWaitResult(bool);
Blocker			enum Blocker 
Bucket			impl<K, V, M> Bucket<K, V, M> 
Bucket			pub struct Bucket<K, V, M> 
BucketState			impl<K, V, M> BucketState<K, V, M> 
BucketState			pub enum BucketState<K, V, M> 
BufReader			impl<'a> BufReader<'a> 
BufReader			pub struct BufReader<'a> 
BufWriter			impl<'a> BufWriter<'a> 
BufWriter			pub struct BufWriter<'a> 
BufWriter			    struct BufWriter<'a> 
Buffer			impl<'a> Buffer for &'a [u8] 
Buffer			pub trait Buffer: Reader 
Buffer			impl<T> Buffer<T> 
Buffer			struct Buffer<T> 
Buffer for BufReader			impl<'a> Buffer for BufReader<'a> 
Buffer for BufferedReader			impl<R: Reader> Buffer for BufferedReader<R> 
Buffer for BufferedStream			impl<S: Stream> Buffer for BufferedStream<S> 
Buffer for ChanReader			impl Buffer for ChanReader 
Buffer for LimitReader			impl<R: Buffer> Buffer for LimitReader<R> 
Buffer for MemReader			impl Buffer for MemReader 
Buffer for NullReader			impl Buffer for NullReader 
Buffer for RefReader			impl<'a, R: Buffer> Buffer for RefReader<'a, R> 
Buffer for ZeroReader			impl Buffer for ZeroReader 
BufferPrelude			pub trait BufferPrelude 
BufferPrelude for T			impl<T: Buffer> BufferPrelude for T 
BufferedReader			impl<R: Reader> BufferedReader<R> 
BufferedReader			pub struct BufferedReader<R> 
BufferedStream			impl<S: Stream> BufferedStream<S> 
BufferedStream			pub struct BufferedStream<S> 
BufferedWriter			impl<W: Writer> BufferedWriter<W> 
BufferedWriter			pub struct BufferedWriter<W> 
Builder			impl Builder 
Builder			pub struct Builder 
ByRefReader			pub trait ByRefReader 
ByRefReader for T			impl<T: Reader> ByRefReader for T 
ByRefWriter			pub trait ByRefWriter 
ByRefWriter for T			impl<T: Writer> ByRefWriter for T 
Bytes			impl<'r, R: Reader> Bytes<'r, R> 
Bytes			pub struct Bytes<'r, T:'r> 
BytesContainer			impl BytesContainer for [u8] 
BytesContainer			impl<'a, T: ?Sized + BytesContainer> BytesContainer for &'a T 
BytesContainer			pub trait BytesContainer 
BytesContainer for CString			impl BytesContainer for CString 
BytesContainer for EnvKey			impl BytesContainer for EnvKey 
BytesContainer for Path			impl BytesContainer for Path 
BytesContainer for Path			impl BytesContainer for Path 
BytesContainer for String			impl BytesContainer for String 
BytesContainer for Vec			impl BytesContainer for Vec<u8> 
BytesContainer for str			impl BytesContainer for str 
BytesReader			pub trait BytesReader 
BytesReader for T			impl<T: Reader> BytesReader for T 
CONDITION_VARIABLE			pub struct CONDITION_VARIABLE { pub ptr: LPVOID }
CONSOLE_SCREEN_BUFFER_INFO			pub struct CONSOLE_SCREEN_BUFFER_INFO 
CONTEXT			    pub struct CONTEXT;
CONTEXT			    pub struct CONTEXT 
COORD			pub struct COORD 
CString			impl CString 
CString			pub struct CString 
Callback			pub trait Callback 
Callback			pub trait Callback 
Callback for TimerCallback			impl Callback for TimerCallback 
CancelIo			    pub fn CancelIo(hFile: libc::HANDLE) -> libc::BOOL;
CancelIoEx			    pub fn CancelIoEx(hFile: libc::HANDLE,
ChainedReader			pub struct ChainedReader<I, R> 
ChanReader			impl ChanReader 
ChanReader			pub struct ChanReader 
ChanWriter			impl ChanWriter 
ChanWriter			pub struct ChanWriter 
Chars			pub struct Chars<'r, T:'r> 
Cleanup			struct Cleanup 
Clone for ChanWriter			impl Clone for ChanWriter 
Clone for Dropable			    impl Clone for Dropable 
Clone for Iter			impl<'a, K, V> Clone for Iter<'a, K, V> 
Clone for Iter			impl<'a, K, V> Clone for Iter<'a, K, V> 
Clone for Keys			impl<'a, K, V> Clone for Keys<'a, K, V> 
Clone for PipeStream			impl Clone for PipeStream 
Clone for RawBuckets			impl<'a, K, V> Clone for RawBuckets<'a, K, V> 
Clone for RawTable			impl<K: Clone, V: Clone> Clone for RawTable<K, V> 
Clone for Sender			impl<T: Send> Clone for Sender<T> 
Clone for SyncSender			impl<T: Send> Clone for SyncSender<T> 
Clone for TcpAcceptor			impl Clone for TcpAcceptor 
Clone for TcpAcceptor			impl Clone for TcpAcceptor 
Clone for TcpAcceptor			impl Clone for TcpAcceptor 
Clone for TcpStream			impl Clone for TcpStream 
Clone for TcpStream			impl Clone for TcpStream 
Clone for UdpSocket			impl Clone for UdpSocket 
Clone for UdpSocket			impl Clone for UdpSocket 
Clone for UnixAcceptor			impl Clone for UnixAcceptor 
Clone for UnixAcceptor			impl Clone for UnixAcceptor 
Clone for UnixAcceptor			impl Clone for UnixAcceptor 
Clone for UnixStream			impl Clone for UnixStream 
Clone for UnixStream			impl Clone for UnixStream 
Clone for UnixStream			impl Clone for UnixStream 
Clone for Values			impl<'a, K, V> Clone for Values<'a, K, V> 
Command			impl Command 
Command			pub struct Command 
CommandLineToArgvW			    fn CommandLineToArgvW(lpCmdLine: LPCWSTR,
Condvar			impl Condvar 
Condvar			pub struct Condvar { inner: Box<StaticCondvar> }
Condvar			impl Condvar 
Condvar			pub struct Condvar(imp::Condvar);
Condvar			impl Condvar 
Condvar			pub struct Condvar { inner: UnsafeCell<ffi::pthread_cond_t> }
Condvar			impl Condvar 
Condvar			pub struct Condvar { inner: UnsafeCell<ffi::CONDITION_VARIABLE> }
ConstRng			    struct ConstRng { i: u64 }
Context			    struct Context<'a> 
Copy for Bucket			impl<K,V,M:Copy> Copy for Bucket<K,V,M> {}
Copy for MapOption			impl Copy for MapOption {}
Copy for MemoryMapKind			impl Copy for MemoryMapKind {}
Copy for RawBucket			impl<K,V> Copy for RawBucket<K,V> {}
CreateEventA			    fn CreateEventA(lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
CreateThread			    fn CreateThread(lpThreadAttributes: LPSECURITY_ATTRIBUTES,
CreateWaitableTimerA			        pub fn CreateWaitableTimerA(lpTimerAttributes: LPSECURITY_ATTRIBUTES,
CryptAcquireContextA			        fn CryptAcquireContextA(phProv: *mut HCRYPTPROV,
CryptGenRandom			        fn CryptGenRandom(hProv: HCRYPTPROV,
CryptReleaseContext			        fn CryptReleaseContext(hProv: HCRYPTPROV, dwFlags: DWORD) -> BOOL;
DISPATCHER_CONTEXT			    pub struct DISPATCHER_CONTEXT;
Default for FilePermission			impl Default for FilePermission 
Default for RandomSipHasher			impl Default for RandomSipHasher 
DefaultResizePolicy			impl DefaultResizePolicy 
DefaultResizePolicy			struct DefaultResizePolicy;
DeleteCriticalSection			    pub fn DeleteCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);
Deref for CString			impl Deref for CString 
Deref for MutexGuard			impl<'mutex, T> Deref for MutexGuard<'mutex, T> 
Deref for RwLockReadGuard			impl<'rwlock, T> Deref for RwLockReadGuard<'rwlock, T> 
Deref for RwLockWriteGuard			impl<'rwlock, T> Deref for RwLockWriteGuard<'rwlock, T> 
Deref for StdinReaderGuard			impl<'a> Deref for StdinReaderGuard<'a> 
DerefMut for MutexGuard			impl<'mutex, T> DerefMut for MutexGuard<'mutex, T> 
DerefMut for RwLockWriteGuard			impl<'rwlock, T> DerefMut for RwLockWriteGuard<'rwlock, T> 
DerefMut for StdinReaderGuard			impl<'a> DerefMut for StdinReaderGuard<'a> 
Difference			pub struct Difference<'a, T: 'a, H: 'a> 
Directories			pub struct Directories 
Display			impl<'a, P: GenericPath> Display<'a, P> 
Display			pub struct Display<'a, P:'a> 
Div for Duration			impl Div<i32> for Duration 
Dl_info			    struct Dl_info 
Drain			pub struct Drain<'a, K: 'a, V: 'a> 
Drain			pub struct Drain<'a, K: 'a> 
Drain			pub struct Drain<'a, K: 'a, V: 'a> 
Drop for BufferedWriter			impl<W: Writer> Drop for BufferedWriter<W> 
Drop for Cleanup			impl Drop for Cleanup 
Drop for Condvar			impl Drop for Condvar 
Drop for Drain			impl<'a, K: 'a, V: 'a> Drop for Drain<'a, K, V> 
Drop for Dropable			    impl Drop for Dropable 
Drop for DynamicLibrary			impl Drop for DynamicLibrary 
Drop for Event			impl Drop for Event 
Drop for Event			impl Drop for Event 
Drop for FileDesc			impl Drop for FileDesc 
Drop for FileDesc			impl Drop for FileDesc 
Drop for Foo			        impl Drop for Foo 
Drop for Foo			    impl Drop for Foo 
Drop for Guard			impl<'a> Drop for Guard<'a> 
Drop for Handle			impl<'rx, T: Send> Drop for Handle<'rx, T> 
Drop for Handler			impl Drop for Handler 
Drop for Handler			impl Drop for Handler 
Drop for Inner			impl Drop for Inner 
Drop for Inner			impl Drop for Inner 
Drop for Inner			impl Drop for Inner 
Drop for JoinGuard			impl<'a, T: Send + 'a> Drop for JoinGuard<'a, T> 
Drop for Key			impl Drop for Key 
Drop for MemoryMap			impl Drop for MemoryMap 
Drop for Mutex			impl<T: Send> Drop for Mutex<T> 
Drop for MutexGuard			impl<'a, T> Drop for MutexGuard<'a, T> 
Drop for OsRng			    impl Drop for OsRng 
Drop for Packet			impl<T: Send> Drop for Packet<T> 
Drop for Packet			impl<T: Send> Drop for Packet<T> 
Drop for Packet			impl<T: Send> Drop for Packet<T> 
Drop for Packet			impl<T: Send> Drop for Packet<T> 
Drop for Process			impl Drop for Process 
Drop for Process			impl Drop for Process 
Drop for Queue			impl<T: Send> Drop for Queue<T> 
Drop for Queue			impl<T: Send> Drop for Queue<T> 
Drop for RawTable			impl<K, V> Drop for RawTable<K, V> 
Drop for Receiver			impl<T: Send> Drop for Receiver<T> 
Drop for Reset			        impl<'a, T> Drop for Reset<'a, T> 
Drop for RwLock			impl<T> Drop for RwLock<T> 
Drop for RwLockReadGuard			impl<'a, T> Drop for RwLockReadGuard<'a, T> 
Drop for RwLockWriteGuard			impl<'a, T> Drop for RwLockWriteGuard<'a, T> 
Drop for S1			        impl Drop for S1 
Drop for S2			        impl Drop for S2 
Drop for Select			impl Drop for Select 
Drop for SemaphoreGuard			impl<'a> Drop for SemaphoreGuard<'a> 
Drop for Sender			impl<T: Send> Drop for Sender<T> 
Drop for Sentinel			impl<'a> Drop for Sentinel<'a> 
Drop for SyncSender			impl<T: Send> Drop for SyncSender<T> 
Drop for TTY			impl Drop for TTY 
Drop for TcpListener			impl Drop for TcpListener 
Drop for TempDir			    impl Drop for TempDir 
Drop for TempDir			impl Drop for TempDir 
Drop for Timer			impl Drop for Timer 
Drop for Timer			impl Drop for Timer 
Drop for UnixListener			impl Drop for UnixListener 
Drop for UnixListener			impl Drop for UnixListener 
Drop for Unwinder			            impl Drop for Unwinder 
Drop for Unwinder			            impl Drop for Unwinder 
Dropable			    impl Dropable 
Dropable			    struct Dropable 
Dummy			struct Dummy(UnsafeCell<()>);
Dummy			struct Dummy(UnsafeCell<()>);
Duration			impl Duration 
Duration			pub struct Duration 
DynamicLibrary			impl DynamicLibrary 
DynamicLibrary			pub struct DynamicLibrary 
EXCEPTION_DISPOSITION			    pub enum EXCEPTION_DISPOSITION 
EXCEPTION_POINTERS			pub struct EXCEPTION_POINTERS 
EXCEPTION_RECORD			    pub struct EXCEPTION_RECORD;
EXCEPTION_RECORD			pub struct EXCEPTION_RECORD 
EmptyBucket			impl<K, V, M> EmptyBucket<K, V, M> 
EmptyBucket			pub struct EmptyBucket<K, V, M> 
EnterCriticalSection			    pub fn EnterCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);
Entry			impl<'a, K, V> Entry<'a, K, V> 
Entry			pub enum Entry<'a, K: 'a, V: 'a> 
EnvKey			struct EnvKey(CString);
EofReader			    struct EofReader;
Eq for Path			impl Eq for Path {}
Eq for Path			impl Eq for Path {}
Error			pub trait Error: Send 
Error for FromUtf16Error			impl Error for FromUtf16Error 
Error for FromUtf8Error			impl Error for FromUtf8Error 
Error for IoError			impl Error for IoError 
Error for MapError			impl Error for MapError 
Error for Utf8Error			impl Error for Utf8Error 
ErroringLaterReader			    struct ErroringLaterReader 
ErroringReader			    struct ErroringReader;
Event			impl Event 
Event			struct Event(libc::HANDLE);
Event			impl Event 
Event			pub struct Event(c::WSAEVENT);
Exception			struct Exception 
ExponentFormat			pub enum ExponentFormat 
FLOATING_SAVE_AREA			    pub struct FLOATING_SAVE_AREA 
FailFlushWriter			        struct FailFlushWriter;
Failure			pub enum Failure<T> 
Failure			pub enum Failure 
Failure			pub enum Failure<T> 
Failure			pub enum Failure 
File			impl File 
File			pub struct File 
FileAccess			pub enum FileAccess 
FileDesc			impl FileDesc 
FileDesc			pub struct FileDesc 
FileDesc			impl FileDesc 
FileDesc			pub struct FileDesc 
FileMode			pub enum FileMode 
FileStat			pub struct FileStat 
FileType			pub enum FileType 
Flag			pub enum Flag 
Flag			impl Flag 
Flag			pub struct Flag { failed: UnsafeCell<bool> }
Flavor			enum Flavor<T> 
Float			pub trait Float
Float for f32			impl Float for f32 
Float for f64			impl Float for f64 
Foo			        struct Foo;
Foo			    struct Foo(Sender<()>);
FormatMessageW			        fn FormatMessageW(flags: DWORD,
FreeLibrary			        fn FreeLibrary(handle: *mut libc::c_void);
FromError			pub trait FromError<E> 
FromError			impl<T> FromError<PoisonError<T>> for TryLockError<T> 
FromError for Box			impl FromError<IoError> for Box<Error> 
FromError for Box			impl FromError<MapError> for Box<Error> 
FromError for E			impl<E> FromError<E> for E 
FromPrimitive for Value			    impl FromPrimitive for Value 
FromStr for IpAddr			impl FromStr for IpAddr 
FromStr for Path			impl FromStr for Path 
FromStr for Path			impl FromStr for Path 
FromStr for SocketAddr			impl FromStr for SocketAddr 
FullBucket			impl<K, V, M> FullBucket<K, V, M> 
FullBucket			pub struct FullBucket<K, V, M> 
Future			impl<A:Clone> Future<A> 
Future			impl<A:Send> Future<A> 
Future			impl<A> Future<A> 
Future			pub struct Future<A> 
FutureState			enum FutureState<A> 
GapThenFull			struct GapThenFull<K, V, M> 
GenericPath			pub trait GenericPath: Clone + GenericPathUnsafe 
GenericPath for Path			impl GenericPath for Path 
GenericPath for Path			impl GenericPath for Path 
GenericPathUnsafe			pub trait GenericPathUnsafe 
GenericPathUnsafe for Path			impl GenericPathUnsafe for Path 
GenericPathUnsafe for Path			impl GenericPathUnsafe for Path 
GetCommandLineW			    fn GetCommandLineW() -> LPCWSTR;
GetConsoleMode			    pub fn GetConsoleMode(hConsoleHandle: libc::HANDLE,
GetConsoleScreenBufferInfo			    pub fn GetConsoleScreenBufferInfo(
GetCurrentProcess			    fn GetCurrentProcess() -> libc::HANDLE;
GetCurrentThread			    fn GetCurrentThread() -> libc::HANDLE;
GetLastError			        fn GetLastError() -> DWORD;
GetModuleHandleExW			        fn GetModuleHandleExW(dwFlags: libc::DWORD, name: *const u16,
GetModuleHandleW			        fn GetModuleHandleW(lpModuleName: LPCWSTR) -> HMODULE;
GetProcAddress			        fn GetProcAddress(handle: *mut libc::c_void,
GetProcAddress			        fn GetProcAddress(hModule: HMODULE, lpProcName: LPCSTR) -> LPVOID;
Guard			pub struct Guard 
Guard			pub struct Guard<'a> 
Handle			impl<'rx, T: Send> Handle<'rx, T> 
Handle			pub struct Handle<'rx, T:'rx> 
Handler			impl Handler 
Handler			pub struct Handler 
Handler			impl Handler 
Handler			pub struct Handler 
Hash for EnvKey			impl Hash for EnvKey 
HashMap			impl<K: Hash + Eq, V> HashMap<K, V, RandomSipHasher> 
HashMap			pub struct HashMap<K, V, H = RandomSipHasher> 
HashSet			impl<T: Hash + Eq> HashSet<T, RandomSipHasher> 
HashSet			pub struct HashSet<T, H = RandomSipHasher> 
Hasher for RandomSipHasher			impl Hasher<sip::SipState> for RandomSipHasher 
Helper			impl<M: Send> Helper<M> 
Helper			pub struct Helper<M> 
Hint			pub struct Hint 
InAddr			pub enum InAddr 
IncomingConnections			pub struct IncomingConnections<'a, A: ?Sized +'a> 
Info			pub struct Info 
InitialZeroByteReader			    struct InitialZeroByteReader 
InitializeCriticalSectionAndSpinCount			    pub fn InitializeCriticalSectionAndSpinCount(
Inner			struct Inner 
Inner			impl Inner 
Inner			struct Inner 
Inner			impl Inner 
Inner			struct Inner 
Inner			pub struct Inner 
Inner			impl Inner 
Inner			struct Inner 
Inner			struct Inner 
InternalBufferedWriter			impl<W> InternalBufferedWriter<W> 
InternalBufferedWriter			struct InternalBufferedWriter<W>(BufferedWriter<W>);
Intersection			pub struct Intersection<'a, T: 'a, H: 'a> 
IntoIter			pub struct IntoIter<K, V> 
IntoIter			pub struct IntoIter<K> 
IntoIter			pub struct IntoIter<K, V> 
Invoke			pub trait Invoke<A=(),R=()> 
Invoke for F			impl<A,R,F> Invoke<A,R> for F
IoError			impl IoError 
IoError			pub struct IoError 
IoErrorKind			pub enum IoErrorKind 
IpAddr			pub enum IpAddr 
Iter			pub struct Iter<'a, K: 'a, V: 'a> 
Iter			pub struct Iter<'a, K: 'a> 
Iter			pub struct Iter<'a, K: 'a, V: 'a> 
Iter			pub struct Iter<'a, T:'a> 
IterMut			pub struct IterMut<'a, K: 'a, V: 'a> 
IterMut			pub struct IterMut<'a, K: 'a, V: 'a> 
IterReader			pub struct IterReader<T> 
Iterator for Bytes			impl<'r, R: Reader> Iterator for Bytes<'r, R> 
Iterator for Chars			impl<'r, T: Buffer> Iterator for Chars<'r, T> 
Iterator for Difference			impl<'a, T, S, H> Iterator for Difference<'a, T, H>
Iterator for Directories			impl Iterator for Directories 
Iterator for Drain			impl<'a, K: 'a, V: 'a> Iterator for Drain<'a, K, V> 
Iterator for Drain			impl<'a, K: 'a> Iterator for Drain<'a, K> 
Iterator for Drain			impl<'a, K: 'a, V: 'a> Iterator for Drain<'a, K, V> 
Iterator for Intersection			impl<'a, T, S, H> Iterator for Intersection<'a, T, H>
Iterator for IntoIter			impl<K, V> Iterator for IntoIter<K, V> 
Iterator for IntoIter			impl<K> Iterator for IntoIter<K> 
Iterator for IntoIter			impl<K, V> Iterator for IntoIter<K, V> 
Iterator for Iter			impl<'a, K, V> Iterator for Iter<'a, K, V> 
Iterator for Iter			impl<'a, K> Iterator for Iter<'a, K> 
Iterator for Iter			impl<'a, K, V> Iterator for Iter<'a, K, V> 
Iterator for Iter			impl<'a, T: Send> Iterator for Iter<'a, T> 
Iterator for IterMut			impl<'a, K, V> Iterator for IterMut<'a, K, V> 
Iterator for IterMut			impl<'a, K, V> Iterator for IterMut<'a, K, V> 
Iterator for Keys			impl<'a, K, V> Iterator for Keys<'a, K, V> 
Iterator for Lines			impl<'r, T: Buffer> Iterator for Lines<'r, T> 
Iterator for Packets			impl Iterator for Packets 
Iterator for RawBuckets			impl<'a, K, V> Iterator for RawBuckets<'a, K, V> 
Iterator for RevMoveBuckets			impl<'a, K, V> Iterator for RevMoveBuckets<'a, K, V> 
Iterator for SymmetricDifference			impl<'a, T, S, H> Iterator for SymmetricDifference<'a, T, H>
Iterator for Union			impl<'a, T, S, H> Iterator for Union<'a, T, H>
Iterator for Values			impl<'a, K, V> Iterator for Values<'a, K, V> 
JoinGuard			impl<'a, T: Send + 'a> JoinGuard<'a, T> 
JoinGuard			impl<T: Send> JoinGuard<'static, T> 
JoinGuard			pub struct JoinGuard<'a, T: 'a> 
Juju			        struct Juju;
KDHELP64			struct KDHELP64 
Key			impl Key 
Key			pub struct Key 
Key			    impl<T> Key<T> 
Key			    pub struct Key<T> 
Key			impl<T: 'static> Key<T> 
Key			pub struct Key<T> 
Key			impl<T> Key<T> 
Key			pub struct Key<T> { #[doc(hidden)] pub inner: __impl::KeyInner<T> }
KeyInner			    impl<T> KeyInner<T> 
KeyInner			    pub struct KeyInner<T> { pub inner: UnsafeCell<*mut T> }
KeyInner			    pub struct KeyInner<T> 
Keys			pub struct Keys<'a, K: 'a, V: 'a> 
LeaveCriticalSection			    pub fn LeaveCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);
LimitReader			impl<R: Reader> LimitReader<R> 
LimitReader			pub struct LimitReader<R> 
LineBufferedWriter			impl<W: Writer> LineBufferedWriter<W> 
LineBufferedWriter			pub struct LineBufferedWriter<W> 
Lines			pub struct Lines<'r, T:'r> 
Listener			pub trait Listener<T, A: Acceptor<T>> 
Listener for TcpListener			impl Listener<TcpStream, TcpAcceptor> for TcpListener 
Listener for UnixListener			impl Listener<UnixStream, UnixAcceptor> for UnixListener 
LoadLibraryW			        fn LoadLibraryW(name: *const libc::c_void) -> *mut libc::c_void;
LocalFree			    fn LocalFree(ptr: *mut c_void);
M128A			    pub struct M128A 
MapError			pub enum MapError 
MapOption			pub enum MapOption 
MemReader			impl MemReader 
MemReader			pub struct MemReader 
MemWriter			impl MemWriter 
MemWriter			pub struct MemWriter 
MemoryMap			impl MemoryMap 
MemoryMap			pub struct MemoryMap 
MemoryMapKind			pub enum MemoryMapKind 
Message			enum Message<T> 
Mul for Duration			impl Mul<i32> for Duration 
MultiWriter			impl MultiWriter 
MultiWriter			pub struct MultiWriter 
Mutex			impl<T: Send> Mutex<T> 
Mutex			pub struct Mutex<T> 
Mutex			impl Mutex 
Mutex			pub struct Mutex(imp::Mutex);
Mutex			impl Mutex 
Mutex			pub struct Mutex { inner: UnsafeCell<ffi::pthread_mutex_t> }
Mutex			impl Mutex 
Mutex			pub struct Mutex { inner: AtomicUint }
MutexGuard			impl<'mutex, T> MutexGuard<'mutex, T> 
MutexGuard			pub struct MutexGuard<'a, T: 'a> 
MyUpgrade			enum MyUpgrade<T> 
Neg for Duration			impl Neg for Duration 
NewThread			pub trait NewThread 
Node			impl<T> Node<T> 
Node			struct Node<T> 
Node			impl<T: Send> Node<T> 
Node			struct Node<T> 
Node			struct Node 
NullReader			pub struct NullReader;
NullStream			    pub struct NullStream;
NullWriter			pub struct NullWriter;
OccupiedEntry			impl<'a, K, V> OccupiedEntry<'a, K, V> 
OccupiedEntry			pub struct OccupiedEntry<'a, K: 'a, V: 'a> 
Once			impl Once 
Once			pub struct Once 
Ord for Path			impl Ord for Path 
Ord for Path			impl Ord for Path 
OsRng			    impl OsRng 
OsRng			    pub struct OsRng 
OsRngInner			    enum OsRngInner 
OwnedAsciiExt			pub trait OwnedAsciiExt 
OwnedAsciiExt for String			impl OwnedAsciiExt for String 
OwnedAsciiExt for Vec			impl OwnedAsciiExt for Vec<u8> 
Packet			impl<T: Send> Packet<T> 
Packet			pub struct Packet<T> 
Packet			pub trait Packet 
Packet			impl<T: Send> Packet<T> 
Packet			pub struct Packet<T> 
Packet			impl<T: Send> Packet<T> 
Packet			pub struct Packet<T> 
Packet			impl<T: Send> Packet<T> 
Packet			pub struct Packet<T> 
Packet			    struct Packet<T>(Arc<(Mutex<T>, Condvar)>);
Packet			struct Packet<T>(Arc<UnsafeCell<Option<Result<T>>>>);
Packets			struct Packets { cur: *mut Handle<'static, ()> }
Parser			impl<'a> Parser<'a> 
Parser			struct Parser<'a> 
PartialEq for EnvKey			impl PartialEq for EnvKey 
PartialEq for Path			impl PartialEq for Path 
PartialEq for Path			impl PartialEq for Path 
PartialOrd for Path			impl PartialOrd for Path 
PartialOrd for Path			impl PartialOrd for Path 
PartialReader			    struct PartialReader 
Path			impl Path 
Path			pub struct Path 
Path			impl Path 
Path			pub struct Path 
PathExtensions			pub trait PathExtensions 
PathExtensions for path			impl PathExtensions for path::Path 
PathPrefix			pub enum PathPrefix 
Pipe			pub struct Pipe 
PipePair			pub struct PipePair 
PipeStream			impl PipeStream 
PipeStream			pub struct PipeStream 
PoisonError			impl<T> PoisonError<T> 
PoisonError			pub struct PoisonError<T> 
PopResult			pub enum PopResult<T> 
Process			impl Process 
Process			pub struct Process 
Process			impl Process 
Process			pub struct Process 
Process			impl Process 
Process			pub struct Process 
ProcessConfig			pub trait ProcessConfig<K: BytesContainer, V: BytesContainer> 
ProcessExit			impl ProcessExit 
ProcessExit			pub enum ProcessExit 
ProcessOutput			pub struct ProcessOutput 
Protocol			pub enum Protocol 
Queue			impl<T: Send> Queue<T> 
Queue			pub struct Queue<T> 
Queue			impl<T: Send> Queue<T> 
Queue			pub struct Queue<T> 
Queue			impl Queue 
Queue			struct Queue 
RWLock			impl RWLock 
RWLock			pub struct RWLock(imp::RWLock);
RWLock			impl RWLock 
RWLock			pub struct RWLock { inner: UnsafeCell<ffi::pthread_rwlock_t> }
RWLock			impl RWLock 
RWLock			pub struct RWLock { inner: UnsafeCell<ffi::SRWLOCK> }
RaceBox			struct RaceBox(BufferedReader<StdReader>);
RaceBox			struct RaceBox(helper_signal::signal);
RacyCell			impl<T> RacyCell<T> 
RacyCell			struct RacyCell<T>(pub UnsafeCell<T>);
RandomSipHasher			impl RandomSipHasher 
RandomSipHasher			pub struct RandomSipHasher 
RawBucket			impl<K, V> RawBucket<K, V> 
RawBucket			struct RawBucket<K, V> 
RawBuckets			struct RawBuckets<'a, K, V> 
RawTable			impl<K, V> RawTable<K, V> 
RawTable			pub struct RawTable<K, V> 
ReadConsoleW			    pub fn ReadConsoleW(hConsoleInput: libc::HANDLE,
Reader			impl<'a> Reader for &'a [u8] 
Reader			impl<'a> Reader for &'a mut (Reader+'a) 
Reader			pub trait Reader 
Reader for BadReader			    impl<T: Reader> Reader for BadReader<T> 
Reader for Box			impl<'a> Reader for Box<Reader+'a> 
Reader for BufReader			impl<'a> Reader for BufReader<'a> 
Reader for BufferedReader			impl<R: Reader> Reader for BufferedReader<R> 
Reader for BufferedStream			impl<S: Stream> Reader for BufferedStream<S> 
Reader for ChanReader			impl Reader for ChanReader 
Reader for EofReader			    impl Reader for EofReader 
Reader for ErroringLaterReader			    impl Reader for ErroringLaterReader 
Reader for ErroringReader			    impl Reader for ErroringReader 
Reader for File			impl Reader for File 
Reader for InitialZeroByteReader			    impl Reader for InitialZeroByteReader 
Reader for InternalBufferedWriter			impl<W: Reader> Reader for InternalBufferedWriter<W> 
Reader for IoResult			impl<R: Reader> Reader for IoResult<R> 
Reader for LimitReader			impl<R: Reader> Reader for LimitReader<R> 
Reader for MemReader			impl Reader for MemReader 
Reader for NullReader			impl Reader for NullReader 
Reader for NullStream			    impl Reader for NullStream 
Reader for PartialReader			    impl Reader for PartialReader 
Reader for PipeStream			impl Reader for PipeStream 
Reader for RefReader			impl<'a, R: Reader> Reader for RefReader<'a, R> 
Reader for ShortReader			    impl Reader for ShortReader 
Reader for StdReader			impl Reader for StdReader 
Reader for StdinReader			impl Reader for StdinReader 
Reader for TcpStream			impl Reader for TcpStream 
Reader for TeeReader			impl<R: Reader, W: Writer> Reader for TeeReader<R, W> 
Reader for ThreeChunkReader			    impl Reader for ThreeChunkReader 
Reader for UnixStream			impl Reader for UnixStream 
Reader for ZeroReader			impl Reader for ZeroReader 
ReaderRng			impl<R: Reader> ReaderRng<R> 
ReaderRng			pub struct ReaderRng<R> 
Receiver			impl<T: Send> Receiver<T> 
Receiver			pub struct Receiver<T> 
RecvError			pub struct RecvError;
RefReader			pub struct RefReader<'a, R:'a> 
RefWriter			pub struct RefWriter<'a, W:'a> 
ReleaseSRWLockExclusive			    pub fn ReleaseSRWLockExclusive(SRWLock: LPSRWLOCK);
ReleaseSRWLockShared			    pub fn ReleaseSRWLockShared(SRWLock: LPSRWLOCK);
Req			enum Req 
Req			pub enum Req 
Req			pub enum Req 
Reset			        struct Reset<'a, T: 'a> 
RevMoveBuckets			struct RevMoveBuckets<'a, K, V> 
Rng for ConstRng			    impl Rng for ConstRng 
Rng for OsRng			    impl Rng for OsRng 
Rng for ReaderRng			impl<R: Reader> Rng for ReaderRng<R> 
Rng for StdRng			impl Rng for StdRng 
Rng for ThreadRng			impl Rng for ThreadRng 
RtlCaptureContext			    fn RtlCaptureContext(ctx: *mut arch::CONTEXT);
Rtld			    pub enum Rtld 
RwLock			impl<T: Send + Sync> RwLock<T> 
RwLock			pub struct RwLock<T> 
RwLockReadGuard			impl<'rwlock, T> RwLockReadGuard<'rwlock, T> 
RwLockReadGuard			pub struct RwLockReadGuard<'a, T: 'a> 
RwLockWriteGuard			impl<'rwlock, T> RwLockWriteGuard<'rwlock, T> 
RwLockWriteGuard			pub struct RwLockWriteGuard<'a, T: 'a> 
S			        struct S;
S1			        struct S1(Sender<()>);
S1			        struct S1;
S2			        struct S2;
SMALL_RECT			pub struct SMALL_RECT 
SRWLOCK			pub struct SRWLOCK { pub ptr: LPVOID }
STACKFRAME64			struct STACKFRAME64 
SYMBOL_INFO			struct SYMBOL_INFO 
SafeHash			impl SafeHash 
SafeHash			pub struct SafeHash 
SearchResult			enum SearchResult<K, V, M> 
SearchResult			impl<K, V, M> SearchResult<K, V, M> 
SecRandom			    struct SecRandom;
SecRandomCopyBytes			        fn SecRandomCopyBytes(rnd: *const SecRandom,
SeedableRng for StdRng			impl<'a> SeedableRng<&'a [uint]> for StdRng 
Seek			pub trait Seek 
Seek for BufReader			impl<'a> Seek for BufReader<'a> 
Seek for BufWriter			impl<'a> Seek for BufWriter<'a> 
Seek for File			impl Seek for File 
Seek for IoResult			impl<S: Seek> Seek for IoResult<S> 
Seek for MemReader			impl Seek for MemReader 
SeekStyle			pub enum SeekStyle 
Select			impl Select 
Select			pub struct Select 
SelectionResult			pub enum SelectionResult<T> 
SelectionResult			pub enum SelectionResult<T> 
Semaphore			impl Semaphore 
Semaphore			pub struct Semaphore 
SemaphoreGuard			pub struct SemaphoreGuard<'a> 
SendError			pub struct SendError<T>(pub T);
Sender			impl<T: Send> Sender<T> 
Sender			pub struct Sender<T> 
Sentinel			impl<'a> Sentinel<'a> 
Sentinel			struct Sentinel<'a> 
SetConsoleMode			    pub fn SetConsoleMode(hConsoleHandle: libc::HANDLE,
SetEvent			    pub fn SetEvent(hEvent: libc::HANDLE) -> libc::BOOL;
SetEvent			    fn SetEvent(hEvent: HANDLE) -> BOOL;
SetLastError			        fn SetLastError(error: libc::size_t);
SetLastError			            fn SetLastError(dwErrCode: DWORD);
SetThreadStackGuarantee			    fn SetThreadStackGuarantee(StackSizeInBytes: *mut ULONG) -> BOOL;
SetWaitableTimer			        pub fn SetWaitableTimer(hTimer: HANDLE,
ShortReader			    pub struct ShortReader 
SignFormat			pub enum SignFormat 
SignalToken			impl SignalToken 
SignalToken			pub struct SignalToken 
SignificantDigits			pub enum SignificantDigits 
SleepConditionVariableCS			    pub fn SleepConditionVariableCS(ConditionVariable: LPCONDITION_VARIABLE,
SocketAddr			pub struct SocketAddr 
SocketStatus			pub enum SocketStatus 
SocketType			pub enum SocketType 
StartResult			pub enum StartResult 
State			struct State<T> 
State			pub enum State 
StaticCondvar			impl StaticCondvar 
StaticCondvar			pub struct StaticCondvar 
StaticKey			impl StaticKey 
StaticKey			pub struct StaticKey 
StaticKeyInner			pub struct StaticKeyInner 
StaticMutex			impl StaticMutex 
StaticMutex			pub struct StaticMutex 
StaticRwLock			impl StaticRwLock 
StaticRwLock			pub struct StaticRwLock 
StdReader			impl StdReader 
StdReader			pub struct StdReader 
StdRng			impl StdRng 
StdRng			pub struct StdRng 
StdSource			enum StdSource 
StdWriter			impl StdWriter 
StdWriter			pub struct StdWriter 
StdinReader			impl StdinReader 
StdinReader			pub struct StdinReader 
StdinReaderGuard			pub struct StdinReaderGuard<'a> 
Stdio			impl Stdio 
Stdio			pub struct Stdio(libc::c_int);
StdioContainer			pub enum StdioContainer 
Stream			pub trait Stream: Reader + Writer { }
Stream for T			impl<T: Reader + Writer> Stream for T {}
Sub for Duration			impl Sub for Duration 
SwitchToThread			    fn SwitchToThread() -> BOOL;
SymmetricDifference			pub struct SymmetricDifference<'a, T: 'a, H: 'a> 
SyncSender			impl<T: Send> SyncSender<T> 
SyncSender			pub struct SyncSender<T> 
TTY			impl TTY 
TTY			pub struct TTY 
TTY			impl TTY 
TTY			pub struct TTY 
TaskPool			impl TaskPool 
TaskPool			pub struct TaskPool 
TcpAcceptor			impl TcpAcceptor 
TcpAcceptor			pub struct TcpAcceptor 
TcpAcceptor			impl TcpAcceptor 
TcpAcceptor			pub struct TcpAcceptor 
TcpAcceptor			impl TcpAcceptor 
TcpAcceptor			pub struct TcpAcceptor 
TcpListener			impl TcpListener 
TcpListener			pub struct TcpListener 
TcpListener			impl TcpListener 
TcpListener			pub struct TcpListener 
TcpListener			impl TcpListener 
TcpListener			pub struct TcpListener { sock: sock_t }
TcpStream			impl TcpStream 
TcpStream			pub struct TcpStream 
TcpStream			impl TcpStream 
TcpStream			pub struct TcpStream 
TeeReader			impl<R: Reader, W: Writer> TeeReader<R, W> 
TeeReader			pub struct TeeReader<R, W> 
TempDir			    impl TempDir 
TempDir			    pub struct TempDir(Path);
TempDir			impl TempDir 
TempDir			pub struct TempDir 
TestWriter			        struct TestWriter;
Thread			impl Thread 
Thread			pub struct Thread 
ThreadInfo			impl ThreadInfo 
ThreadInfo			struct ThreadInfo 
ThreadRng			pub struct ThreadRng 
ThreadRngReseeder			struct ThreadRngReseeder;
ThreeChunkReader			    struct ThreeChunkReader 
Thunk			impl<A,R> Thunk<A,R> 
Thunk			impl<R> Thunk<(),R> 
Thunk			pub struct Thunk<A=(),R=()> 
Timer			impl Timer 
Timer			pub struct Timer 
Timer			impl Timer 
Timer			pub struct Timer 
Timer			impl Timer 
Timer			pub struct Timer 
TimerCallback			struct TimerCallback { tx: Sender<()> }
TlsAlloc			    fn TlsAlloc() -> DWORD;
TlsFree			    fn TlsFree(dwTlsIndex: DWORD) -> BOOL;
TlsGetValue			    fn TlsGetValue(dwTlsIndex: DWORD) -> LPVOID;
TlsSetValue			    fn TlsSetValue(dwTlsIndex: DWORD, lpTlsvalue: LPVOID) -> BOOL;
ToPrimitive for Value			    impl ToPrimitive for Value 
ToSocketAddr			impl ToSocketAddr for (IpAddr, u16) 
ToSocketAddr			impl<'a> ToSocketAddr for &'a str 
ToSocketAddr			impl<'a> ToSocketAddr for (&'a str, u16) 
ToSocketAddr			pub trait ToSocketAddr 
ToSocketAddr for SocketAddr			impl ToSocketAddr for SocketAddr 
TryAcquireSRWLockExclusive			    pub fn TryAcquireSRWLockExclusive(SRWLock: LPSRWLOCK) -> BOOLEAN;
TryAcquireSRWLockShared			    pub fn TryAcquireSRWLockShared(SRWLock: LPSRWLOCK) -> BOOLEAN;
TryEnterCriticalSection			    pub fn TryEnterCriticalSection(lpCriticalSection: LPCRITICAL_SECTION) -> BOOL;
TryLockError			pub enum TryLockError<T> 
TryRecvError			pub enum TryRecvError 
TrySendError			pub enum TrySendError<T> 
UdpSocket			impl UdpSocket 
UdpSocket			pub struct UdpSocket 
UdpSocket			impl UdpSocket 
UdpSocket			pub struct UdpSocket 
Union			pub struct Union<'a, T: 'a, H: 'a> 
UnixAcceptor			impl UnixAcceptor 
UnixAcceptor			pub struct UnixAcceptor 
UnixAcceptor			impl UnixAcceptor 
UnixAcceptor			pub struct UnixAcceptor 
UnixAcceptor			impl UnixAcceptor 
UnixAcceptor			pub struct UnixAcceptor 
UnixListener			impl UnixListener 
UnixListener			pub struct UnixListener 
UnixListener			impl UnixListener 
UnixListener			pub struct UnixListener 
UnixListener			impl UnixListener 
UnixListener			pub struct UnixListener 
UnixStream			impl UnixStream 
UnixStream			pub struct UnixStream 
UnixStream			impl UnixStream 
UnixStream			pub struct UnixStream 
UnixStream			impl UnixStream 
UnixStream			pub struct UnixStream 
UnsafeFlavor			trait UnsafeFlavor<T> 
UnsafeFlavor for Receiver			impl<T> UnsafeFlavor<T> for Receiver<T> 
UnsafeFlavor for Sender			impl<T> UnsafeFlavor<T> for Sender<T> 
UnstableFileStat			pub struct UnstableFileStat 
Unwinder			            struct Unwinder 
Unwinder			            struct Unwinder 
UpdateIoError			trait UpdateIoError<T> 
UpdateIoError for IoResult			impl<T> UpdateIoError<T> for IoResult<T> 
UpgradeResult			pub enum UpgradeResult 
UpgradeResult			pub enum UpgradeResult 
VacantEntry			impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> 
VacantEntry			pub struct VacantEntry<'a, K: 'a, V: 'a> 
VacantEntryState			enum VacantEntryState<K, V, M> 
Value			    struct Value { x: int }
Value			    struct Value<T: 'static> 
Values			pub struct Values<'a, K: 'a, V: 'a> 
WEXITSTATUS			        pub fn WEXITSTATUS(status: i32) -> i32 { (status >> 8) & 0xff }
WEXITSTATUS			        pub fn WEXITSTATUS(status: i32) -> i32 { status >> 8 }
WIFEXITED			        pub fn WIFEXITED(status: i32) -> bool { (status & 0x7f) == 0 }
WIFEXITED			        pub fn WIFEXITED(status: i32) -> bool { (status & 0xff) == 0 }
WSACloseEvent			    pub fn WSACloseEvent(hEvent: WSAEVENT) -> libc::BOOL;
WSACreateEvent			    pub fn WSACreateEvent() -> WSAEVENT;
WSADATA			pub struct WSADATA 
WSAEnumNetworkEvents			    pub fn WSAEnumNetworkEvents(s: libc::SOCKET,
WSAEventSelect			    pub fn WSAEventSelect(s: libc::SOCKET,
WSAGetLastError			    pub fn WSAGetLastError() -> libc::c_int;
WSANETWORKEVENTS			pub struct WSANETWORKEVENTS 
WSASetEvent			    pub fn WSASetEvent(hEvent: WSAEVENT) -> libc::BOOL;
WSAStartup			    pub fn WSAStartup(wVersionRequested: libc::WORD,
WSAWaitForMultipleEvents			    pub fn WSAWaitForMultipleEvents(cEvents: libc::DWORD,
WTERMSIG			        pub fn WTERMSIG(status: i32) -> i32 { status & 0o177 }
WTERMSIG			        pub fn WTERMSIG(status: i32) -> i32 { status & 0x7f }
WaitForMultipleObjects			    pub fn WaitForMultipleObjects(nCount: libc::DWORD,
WaitForMultipleObjects			        pub fn WaitForMultipleObjects(nCount: DWORD,
WaitForSingleObject			    fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;
WaitForSingleObject			        pub fn WaitForSingleObject(hHandle: HANDLE,
WaitToken			impl WaitToken 
WaitToken			pub struct WaitToken 
WakeAllConditionVariable			    pub fn WakeAllConditionVariable(ConditionVariable: LPCONDITION_VARIABLE);
WakeConditionVariable			    pub fn WakeConditionVariable(ConditionVariable: LPCONDITION_VARIABLE);
WriteConsoleW			    pub fn WriteConsoleW(hConsoleOutput: libc::HANDLE,
Writer			impl<'a> Writer for &'a mut (Writer+'a) 
Writer			pub trait Writer 
Writer for Box			impl<'a> Writer for Box<Writer+'a> 
Writer for BufWriter			impl<'a> Writer for BufWriter<'a> 
Writer for BufferedStream			impl<S: Stream> Writer for BufferedStream<S> 
Writer for BufferedWriter			impl<W: Writer> Writer for BufferedWriter<W> 
Writer for ChanWriter			impl Writer for ChanWriter 
Writer for FailFlushWriter			        impl Writer for FailFlushWriter 
Writer for File			impl Writer for File 
Writer for IoResult			impl<W: Writer> Writer for IoResult<W> 
Writer for LineBufferedWriter			impl<W: Writer> Writer for LineBufferedWriter<W> 
Writer for MemWriter			impl Writer for MemWriter 
Writer for MultiWriter			impl Writer for MultiWriter 
Writer for NullStream			    impl Writer for NullStream 
Writer for NullWriter			impl Writer for NullWriter 
Writer for PipeStream			impl Writer for PipeStream 
Writer for RefWriter			impl<'a, W: Writer> Writer for RefWriter<'a, W> 
Writer for StdWriter			impl Writer for StdWriter 
Writer for Stdio			impl Writer for Stdio 
Writer for TcpStream			impl Writer for TcpStream 
Writer for TestWriter			        impl Writer for TestWriter 
Writer for UnixStream			impl Writer for UnixStream 
Writer for Vec			impl Writer for Vec<u8> 
ZeroReader			pub struct ZeroReader;
_GCC_specific_handler			        fn _GCC_specific_handler(
_NSGetArgc			    pub fn _NSGetArgc() -> *mut c_int;
_NSGetArgv			    pub fn _NSGetArgv() -> *mut *mut *mut c_char;
_Unwind_Action			pub enum _Unwind_Action 
_Unwind_Backtrace			        pub fn _Unwind_Backtrace(trace: _Unwind_Trace_Fn,
_Unwind_Context			pub enum _Unwind_Context {}
_Unwind_Context			    pub enum _Unwind_Context {}
_Unwind_DeleteException			    pub fn _Unwind_DeleteException(exception: *mut _Unwind_Exception);
_Unwind_Exception			pub struct _Unwind_Exception 
_Unwind_FindEnclosingFunction			        pub fn _Unwind_FindEnclosingFunction(pc: *mut libc::c_void)
_Unwind_FindEnclosingFunction			    pub unsafe fn _Unwind_FindEnclosingFunction(pc: *mut libc::c_void)
_Unwind_GetIP			        pub fn _Unwind_GetIP(ctx: *mut _Unwind_Context) -> libc::uintptr_t;
_Unwind_GetIP			    pub unsafe fn _Unwind_GetIP(ctx: *mut _Unwind_Context) -> libc::uintptr_t 
_Unwind_RaiseException			    pub fn _Unwind_RaiseException(exception: *mut _Unwind_Exception)
_Unwind_RaiseException			pub unsafe fn _Unwind_RaiseException(exc: *mut _Unwind_Exception)
_Unwind_Reason_Code			pub enum _Unwind_Reason_Code 
_Unwind_Reason_Code			    pub enum _Unwind_Reason_Code 
_Unwind_SjLj_RaiseException			    fn _Unwind_SjLj_RaiseException(e: *mut _Unwind_Exception)
_Unwind_State			pub enum _Unwind_State 
_Unwind_VRS_DataRepresentation			        enum _Unwind_VRS_DataRepresentation 
_Unwind_VRS_Get			            fn _Unwind_VRS_Get(ctx: *mut _Unwind_Context,
_Unwind_VRS_RegClass			        enum _Unwind_VRS_RegClass 
_Unwind_VRS_Result			        enum _Unwind_VRS_Result 
__dfly_error			            fn __dfly_error() -> *const c_int;
__errno_location			            fn __errno_location() -> *const c_int;
__error			            fn __error() -> *const c_int;
__gcc_personality_seh0			        fn __gcc_personality_seh0(
__gcc_personality_sj0			        fn __gcc_personality_sj0(version: c_int,
__gcc_personality_v0			        fn __gcc_personality_v0(state: uw::_Unwind_State,
__gcc_personality_v0			        fn __gcc_personality_v0(version: c_int,
__getit			            fn __getit() -> &'static __KeyInner<__UnsafeCell<__Option<
__impl			pub mod __impl 
__impl			pub mod __impl 
__init			            fn __init() -> 
__xpg_strerror_r			            fn __xpg_strerror_r(errnum: c_int,
_ensure_buffer_is_object_safe			    fn _ensure_buffer_is_object_safe<T: Buffer>(x: &T) -> &Buffer 
_homedir			    fn _homedir() -> Option<Path> 
_setenv			    fn _setenv(n: &str, v: &[u8]) 
_tlv_atexit			            fn _tlv_atexit(dtor: unsafe extern fn(*mut u8),
_unsetenv			    fn _unsetenv(n: &str) 
abort			pub fn abort(args: fmt::Arguments) -> ! 
abort_selection			    fn abort_selection(&self) -> bool 
abort_selection			    pub fn abort_selection(&mut self) -> Result<bool, Receiver<T>> 
abort_selection			    fn abort_selection(&self) -> bool;
abort_selection			    pub fn abort_selection(&mut self, _was_upgrade: bool) -> bool 
abort_selection			    pub fn abort_selection(&mut self,
abort_selection			    pub fn abort_selection(&self) -> bool 
abs			    fn abs(self) -> f32 { num::Float::abs(self) }
abs			    fn abs(self) -> f64 { num::Float::abs(self) }
abs			    fn abs(self) -> Self;
abs_sub			    fn abs_sub(self, other: f32) -> f32 
abs_sub			    fn abs_sub(self, other: f64) -> f64 
abs_sub			    fn abs_sub(self, other: Self) -> Self;
accept			    fn accept(&mut self) -> IoResult<T>;
accept			    fn accept(&mut self) -> IoResult<UnixStream> 
accept			    fn accept(&mut self) -> IoResult<TcpStream> 
accept			    fn accept(&mut self) -> IoResult<T> 
accept			    pub fn accept(&mut self) -> IoResult<UnixStream> 
accept			    pub fn accept(&mut self) -> IoResult<TcpStream> 
accept			    pub fn accept(&mut self) -> IoResult<UnixStream> 
accept			    pub fn accept(&mut self) -> IoResult<TcpStream> 
accept_lots			    fn accept_lots() 
accept_timeout			    fn accept_timeout() 
accept_timeout			    fn accept_timeout() 
access			    pub fn access(&self) -> SemaphoreGuard 
access_string			fn access_string(access: FileAccess) -> &'static str 
acos			    fn acos(self) -> f32 
acos			        pub fn acos(n: c_double) -> c_double;
acos			    fn acos(self) -> f64 
acos			    fn acos(self) -> Self;
acosf			        pub fn acosf(n: c_float) -> c_float;
acosh			    fn acosh(self) -> f32 
acosh			    fn acosh(self) -> f64 
acosh			    fn acosh(self) -> Self;
acquire			    pub fn acquire(&self) 
acquire_send_slot			    fn acquire_send_slot(&self) -> MutexGuard<State<T>> 
add			    pub unsafe fn add(&mut self) 
add			    fn add(self, rhs: Duration) -> Duration 
addr_to_sockaddr			pub fn addr_to_sockaddr(addr: SocketAddr,
addr_to_sockaddr_un			fn addr_to_sockaddr_un(addr: &CString,
addrinfo			pub mod addrinfo;
addrinfo			pub mod addrinfo 
addrinfo			pub mod addrinfo 
all			            pub fn all() -> 
alloc			    unsafe fn alloc(&self) -> *mut Node<T> 
append_arg			    fn append_arg(cmd: &mut String, arg: &str) 
append_char_at			    fn append_char_at(cmd: &mut String, arg: &[char], i: uint) 
append_path			        fn append_path(me: &mut Path, path: &str) 
arch			mod arch 
arch_consts			mod arch_consts 
arg			    pub fn arg<'a, T: BytesContainer>(&'a mut self, arg: T) -> &'a mut Command 
args			    fn args(&self) -> &[CString] 
args			    pub fn args<'a, T: BytesContainer>(&'a mut self, args: &[T]) -> &'a mut Command 
args			pub fn args() -> Vec<String> 
args			pub mod args;
args			    fn args(&self) -> &[CString];
args_as_bytes			pub fn args_as_bytes() -> Vec<Vec<u8>> 
as_bytes			    pub fn as_bytes(&self) -> &[u8] 
as_bytes_with_nul			    pub fn as_bytes_with_nul(&self) -> &[u8] 
as_cow			    pub fn as_cow(&self) -> CowString<'a> 
as_inner			    fn as_inner(&self) -> &fs_imp::FileDesc 
as_inner			    fn as_inner(&self) -> &UnixAcceptorImp 
as_inner			    fn as_inner(&self) -> &UnixListenerImp 
as_inner			    fn as_inner(&self) -> &UnixStreamImp 
as_inner			    fn as_inner(&self) -> &TcpAcceptorImp 
as_inner			    fn as_inner(&self) -> &TcpListenerImp 
as_inner			    fn as_inner(&self) -> &TcpStreamImp 
as_inner			    fn as_inner(&self) -> &UdpSocketImp 
as_inner			    fn as_inner(&self) -> &sys::fs::FileDesc 
as_inner			    fn as_inner(&self) -> &Inner;
as_raw_fd			    fn as_raw_fd(&self) -> Fd 
as_raw_fd			    fn as_raw_fd(&self) -> Fd;
as_raw_handle			    fn as_raw_handle(&self) -> Handle 
as_raw_handle			    fn as_raw_handle(&self) -> Handle;
as_raw_socket			    fn as_raw_socket(&self) -> Socket 
as_raw_socket			    fn as_raw_socket(&self) -> Socket;
as_slice_with_nul			    pub fn as_slice_with_nul(&self) -> &[libc::c_char] { self.inner.as_slice() }
as_str			    fn as_str<'a>(&'a self) -> Option<&'a str> 
as_str			    fn as_str<'a>(&'a self) -> Option<&'a str> 
as_vec			    fn as_vec<'a>(&'a self) -> &'a [u8];
as_vec			    fn as_vec<'a>(&'a self) -> &'a [u8] 
as_vec			    fn as_vec<'a>(&'a self) -> &'a [u8] 
ascii			pub mod ascii;
asin			    fn asin(self) -> f32 
asin			        pub fn asin(n: c_double) -> c_double;
asin			    fn asin(self) -> f64 
asin			    fn asin(self) -> Self;
asinf			        pub fn asinf(n: c_float) -> c_float;
asinh			    fn asinh(self) -> f32 
asinh			    fn asinh(self) -> f64 
asinh			    fn asinh(self) -> Self;
assert_send			    fn assert_send<T: Send>() {}
assert_sync			    fn assert_sync<T: Sync>() {}
at_exit			pub fn at_exit<F:FnOnce()+Send>(f: F) 
at_exit_imp			mod at_exit_imp;
at_index			    pub fn at_index(table: M, ib_index: uint) -> Bucket<K, V, M> 
atan			    fn atan(self) -> f32 
atan			        pub fn atan(n: c_double) -> c_double;
atan			    fn atan(self) -> f64 
atan			    fn atan(self) -> Self;
atan2			    fn atan2(self, other: f32) -> f32 
atan2			        pub fn atan2(a: c_double, b: c_double) -> c_double;
atan2			    fn atan2(self, other: f64) -> f64 
atan2			    fn atan2(self, other: Self) -> Self;
atan2f			        pub fn atan2f(a: c_float, b: c_float) -> c_float;
atanf			        pub fn atanf(n: c_float) -> c_float;
atanh			    fn atanh(self) -> f32 
atanh			    fn atanh(self) -> f64 
atanh			    fn atanh(self) -> Self;
aux_homedir			    fn aux_homedir(home_name: &str) -> Option<Path> 
avoid_copying_the_body			    fn avoid_copying_the_body<F>(spawnfn: F) where F: FnOnce(Thunk) 
await			    fn await(_fd: sock_t, set: &mut c::fd_set, timeout: u64) -> libc::c_int 
await			    fn await(fd: sock_t, set: &mut c::fd_set, timeout: u64) -> libc::c_int 
await			pub fn await(fds: &[sock_t], deadline: Option<u64>,
await			pub fn await(handle: libc::HANDLE, deadline: u64,
backslash_run_ends_in_quote			    fn backslash_run_ends_in_quote(s: &[char], mut i: uint) -> bool 
backtrace			pub mod backtrace;
backtrace			pub mod backtrace;
backtrace			        fn backtrace(buf: *mut *mut libc::c_void,
backtrace			pub mod backtrace;
backtrace			pub mod backtrace;
backtrace_create_state			        fn backtrace_create_state(filename: *const libc::c_char,
backtrace_state			    enum backtrace_state {}
backtrace_syminfo			        fn backtrace_syminfo(state: *mut backtrace_state,
barrier			mod barrier;
base_port			fn base_port() -> u16 
begin_unwind			pub fn begin_unwind<M: Any + Send>(msg: M, file_line: &(&'static str, uint)) -> ! 
begin_unwind_fmt			pub fn begin_unwind_fmt(msg: fmt::Arguments, file_line: &(&'static str, uint)) -> ! 
begin_unwind_inner			fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) -> ! 
bench			mod bench;
bench			mod bench 
bench			mod bench 
bench			mod bench 
bench			mod bench 
bench			mod bench 
bench_buf_reader			    fn bench_buf_reader(b: &mut Bencher) 
bench_buf_writer			    fn bench_buf_writer(b: &mut Bencher) 
bench_buffered_reader			    fn bench_buffered_reader(b: &mut Bencher) 
bench_buffered_stream			    fn bench_buffered_stream(b: &mut Bencher) 
bench_buffered_writer			    fn bench_buffered_writer(b: &mut Bencher) 
bench_mem_reader			    fn bench_mem_reader(b: &mut Bencher) 
bench_mem_writer_001_0000			    fn bench_mem_writer_001_0000(b: &mut Bencher) 
bench_mem_writer_001_0010			    fn bench_mem_writer_001_0010(b: &mut Bencher) 
bench_mem_writer_001_0100			    fn bench_mem_writer_001_0100(b: &mut Bencher) 
bench_mem_writer_001_1000			    fn bench_mem_writer_001_1000(b: &mut Bencher) 
bench_mem_writer_100_0000			    fn bench_mem_writer_100_0000(b: &mut Bencher) 
bench_mem_writer_100_0010			    fn bench_mem_writer_100_0010(b: &mut Bencher) 
bench_mem_writer_100_0100			    fn bench_mem_writer_100_0100(b: &mut Bencher) 
bench_mem_writer_100_1000			    fn bench_mem_writer_100_1000(b: &mut Bencher) 
bench_pow_function			    fn bench_pow_function(b: &mut Bencher) 
binary_file			    fn binary_file() 
bind			    pub fn bind<P: BytesContainer>(path: P) -> IoResult<UnixListener> 
bind			    pub fn bind<A: ToSocketAddr>(addr: A) -> IoResult<TcpListener> 
bind			    pub fn bind<A: ToSocketAddr>(addr: A) -> IoResult<UdpSocket> 
bind			    pub fn bind(addr: SocketAddr) -> IoResult<UdpSocket> 
bind			    pub fn bind(addr: &CString) -> IoResult<UnixListener> 
bind			fn bind(addr: &CString, ty: libc::c_int) -> IoResult<Inner> 
bind			    pub fn bind(addr: ip::SocketAddr) -> IoResult<TcpListener> 
bind			    pub fn bind(addr: &CString) -> IoResult<UnixListener> 
bind			    pub fn bind(addr: ip::SocketAddr) -> IoResult<TcpListener> 
bind_error			    fn bind_error() 
bind_error			    fn bind_error() 
bind_error			    fn bind_error() 
bitand			            fn bitand(self, other: 
bitand			    fn bitand(self, rhs: &HashSet<T, H>) -> HashSet<T, H> 
bitflags			pub mod bitflags;
bitor			            fn bitor(self, other: 
bitor			    fn bitor(self, rhs: &HashSet<T, H>) -> HashSet<T, H> 
bits			            pub fn bits(&self) -> 
bitxor			            fn bitxor(self, other: 
bitxor			    fn bitxor(self, rhs: &HashSet<T, H>) -> HashSet<T, H> 
blocking			mod blocking;
bool			mod bool;
boot			    pub fn boot<T, F>(&'static self, f: F, helper: fn(helper_signal::signal, Receiver<M>, T)) where
borrow			    pub fn borrow(&self) -> LockResult<Guard> 
both_ready			    fn both_ready() 
buffered			mod buffered;
build_with_zero1			    fn build_with_zero1() { CString::from_slice(b"\\0"); }
build_with_zero2			    fn build_with_zero2() { CString::from_vec(vec![0]); }
build_with_zero3			    fn build_with_zero3() 
builtin			pub mod builtin 
bump			    fn bump(&mut self, amt: int) -> int 
bump			    fn bump(&mut self, amt: int) -> int 
by_ref			    fn by_ref<'a>(&'a mut self) -> RefReader<'a, Self>;
by_ref			    fn by_ref<'a>(&'a mut self) -> RefReader<'a, T> 
by_ref			    fn by_ref<'a>(&'a mut self) -> RefWriter<'a, Self>;
by_ref			    fn by_ref<'a>(&'a mut self) -> RefWriter<'a, T> 
bytes			    fn bytes<'r>(&'r mut self) -> extensions::Bytes<'r, Self>;
bytes			    fn bytes<'r>(&'r mut self) -> extensions::Bytes<'r, T> 
bytes_0_bytes			    fn bytes_0_bytes() 
bytes_eof			    fn bytes_eof() 
bytes_error			    fn bytes_error() 
c			pub mod c;
c			pub mod c;
c_str			mod c_str;
c_str_to_bytes			pub unsafe fn c_str_to_bytes<'a>(raw: &'a *const libc::c_char) -> &'a [u8] 
c_str_to_bytes_with_nul			pub unsafe fn c_str_to_bytes_with_nul<'a>(raw: &'a *const libc::c_char) -> &'a [u8] 
c_to_rust			    fn c_to_rust() 
calculate_allocation			fn calculate_allocation(hash_size: uint, hash_align: uint,
calculate_offsets			fn calculate_offsets(hashes_size: uint,
call			    fn call(&mut self) 
call			    fn call(&mut self);
call			    fn call(&mut self);
call_once			    pub fn call_once<F>(&'static self, f: F) where F: FnOnce() 
can_alias_safehash_as_u64			fn can_alias_safehash_as_u64() 
can_recv			    fn can_recv(&self) -> bool 
can_recv			    pub fn can_recv(&mut self) -> Result<bool, Receiver<T>> 
can_recv			    fn can_recv(&self) -> bool;
can_recv			    pub fn can_recv(&mut self) -> bool 
can_recv			    pub fn can_recv(&mut self) -> Result<bool, Receiver<T>> 
can_recv			    pub fn can_recv(&self) -> bool 
cancel			    fn cancel(mut self) 
cancel_io			    fn cancel_io(&self) -> IoResult<()> 
cap			    fn cap(&self) -> uint { self.buf.len() }
capacity			    pub fn capacity(&self) -> uint 
capacity			    pub fn capacity(&self) -> uint 
capacity			    pub fn capacity(&self) -> uint 
capture_stderr			    fn capture_stderr() 
capture_stdout			    fn capture_stdout() 
cast_from_uint			    pub unsafe fn cast_from_uint(signal_ptr: uint) -> SignalToken 
cast_to_uint			    pub unsafe fn cast_to_uint(self) -> uint 
cause			    fn cause(&self) -> Option<&Error> { None }
cbrt			    fn cbrt(self) -> f32 
cbrt			        pub fn cbrt(n: c_double) -> c_double;
cbrt			    fn cbrt(self) -> f64 
cbrt			    fn cbrt(self) -> Self;
cbrtf			        pub fn cbrtf(n: c_float) -> c_float;
ceil			    fn ceil(self) -> f32 { num::Float::ceil(self) }
ceil			    fn ceil(self) -> f64 { num::Float::ceil(self) }
ceil			    fn ceil(self) -> Self;
cell_allowed			    fn cell_allowed() 
chan_gone_concurrent			    fn chan_gone_concurrent() 
change_dir			pub fn change_dir(p: &Path) -> IoResult<()> 
change_file_times			pub fn change_file_times(path: &Path, atime: u64, mtime: u64) -> IoResult<()> 
channel			pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) 
chars			    fn chars<'r>(&'r mut self) -> Chars<'r, Self>;
chars			    fn chars<'r>(&'r mut self) -> Chars<'r, T> 
chdir			pub fn chdir(p: &Path) -> IoResult<()> 
chdir			pub fn chdir(p: &Path) -> IoResult<()> 
check			        fn check(m: &HashMap<int, ()>) 
check_for_errors_in			    pub fn check_for_errors_in<T, F>(f: F) -> Result<T, String> where
check_parse			        fn check_parse(unparsed: &str, parsed: &[&str]) -> bool 
check_word_size			        fn check_word_size() 
checked_add			    pub fn checked_add(&self, rhs: &Duration) -> Option<Duration> 
checked_sub			    pub fn checked_sub(&self, rhs: &Duration) -> Option<Duration> 
child_no			        fn child_no(x: uint) -> Thunk 
chmod			pub fn chmod(path: &Path, mode: io::FilePermission) -> IoResult<()> 
chmod			pub fn chmod(p: &Path, mode: uint) -> IoResult<()> 
chmod			pub fn chmod(p: &Path, mode: uint) -> IoResult<()> 
chmod_works			    fn chmod_works() 
chown			pub fn chown(path: &Path, uid: int, gid: int) -> IoResult<()> 
chown			pub fn chown(p: &Path, uid: int, gid: int) -> IoResult<()> 
chown			pub fn chown(_p: &Path, _uid: int, _gid: int) -> IoResult<()> 
circular			    fn circular() 
classify			    fn classify(self) -> FpCategory { num::Float::classify(self) }
classify			    fn classify(self) -> FpCategory { num::Float::classify(self) }
classify			    fn classify(self) -> FpCategory;
cleanup			    pub fn cleanup() 
cleanup			    pub unsafe fn cleanup() 
cleanup			pub unsafe fn cleanup() { imp::cleanup() }
cleanup			pub fn cleanup() 
cleanup			pub unsafe fn cleanup() 
cleanup			    pub unsafe fn cleanup() 
cleanup			pub unsafe fn cleanup() 
cleanup_dir			    fn cleanup_dir(&mut self) -> IoResult<()> 
clear			    pub fn clear(&mut self) 
clear			    pub fn clear(&mut self) { self.map.clear() }
clock_gettime			        pub fn clock_gettime(clk_id: c_int, tp: *mut timespec) -> c_int;
clone			        fn clone(&self) -> Dropable 
clone			    fn clone(&self) -> Iter<'a, K, V> 
clone			    fn clone(&self) -> Keys<'a, K, V> 
clone			    fn clone(&self) -> Values<'a, K, V> 
clone			    fn clone(&self) -> Iter<'a, K, V> 
clone			    fn clone(&self) -> RawBuckets<'a, K, V> 
clone			    fn clone(&self) -> RawTable<K, V> 
clone			    fn clone(&self) -> ChanWriter 
clone			    fn clone(&self) -> UnixAcceptor 
clone			    fn clone(&self) -> UnixStream 
clone			    fn clone(&self) -> TcpAcceptor 
clone			    fn clone(&self) -> TcpStream 
clone			    fn clone(&self) -> UdpSocket 
clone			    fn clone(&self) -> PipeStream 
clone			    pub fn clone() -> Option<Vec<Vec<u8>>> 
clone			pub fn clone() -> Option<Vec<Vec<u8>>> { imp::clone() }
clone			    fn clone(&self) -> Sender<T> 
clone			    fn clone(&self) -> SyncSender<T> 
clone			    fn clone(&self) -> TcpStream 
clone			    fn clone(&self) -> UdpSocket 
clone			    fn clone(&self) -> UnixAcceptor 
clone			    fn clone(&self) -> UnixStream 
clone			    fn clone(&self) -> TcpAcceptor 
clone			    fn clone(&self) -> UnixAcceptor 
clone			    fn clone(&self) -> UnixStream 
clone			    fn clone(&self) -> TcpAcceptor 
clone_accept_concurrent			    fn clone_accept_concurrent() 
clone_accept_concurrent			    fn clone_accept_concurrent() 
clone_accept_smoke			    fn clone_accept_smoke() 
clone_accept_smoke			    fn clone_accept_smoke() 
clone_chan			    pub fn clone_chan(&mut self) 
clone_chan			    pub fn clone_chan(&self) 
clone_while_reading			    fn clone_while_reading() 
cloning			    fn cloning() 
cloning2			    fn cloning2() 
cloning3			    fn cloning3() 
close			    pub unsafe fn close(handle: *mut u8) 
close			    pub fn close(mut self) -> IoResult<()> 
close			pub fn close(fd: libc::c_int) 
close			pub fn close(handle: HANDLE) 
close_accept			    pub fn close_accept(&mut self) -> IoResult<()> 
close_accept			    pub fn close_accept(&mut self) -> IoResult<()> 
close_accept			    pub fn close_accept(&mut self) -> IoResult<()> 
close_accept			    pub fn close_accept(&mut self) -> IoResult<()> 
close_accept			    pub fn close_accept(&mut self) -> IoResult<()> 
close_accept			    pub fn close_accept(&mut self) -> IoResult<()> 
close_accept_concurrent			    fn close_accept_concurrent() 
close_accept_concurrent			    fn close_accept_concurrent() 
close_accept_smoke			    fn close_accept_smoke() 
close_accept_smoke			    fn close_accept_smoke() 
close_read			    pub fn close_read(&mut self) -> IoResult<()> 
close_read			    pub fn close_read(&mut self) -> IoResult<()> 
close_read			    pub fn close_read(&mut self) -> IoResult<()> 
close_read			    pub fn close_read(&mut self) -> IoResult<()> 
close_read			    pub fn close_read(&mut self) -> IoResult<()> 
close_read_wakes_up			    fn close_read_wakes_up() 
close_read_wakes_up			    fn close_read_wakes_up() 
close_readwrite_smoke			    fn close_readwrite_smoke() 
close_readwrite_smoke			    fn close_readwrite_smoke() 
close_sock			pub unsafe fn close_sock(sock: sock_t) { let _ = libc::close(sock); }
close_sock			pub unsafe fn close_sock(sock: sock_t) { let _ = libc::closesocket(sock); }
close_write			    pub fn close_write(&mut self) -> IoResult<()> 
close_write			    pub fn close_write(&mut self) -> IoResult<()> 
close_write			    pub fn close_write(&mut self) -> IoResult<()> 
close_write			    pub fn close_write(&mut self) -> IoResult<()> 
close_write			    pub fn close_write(&mut self) -> IoResult<()> 
closed			    fn closed() 
closing_channel_during_drop_doesnt_kill_everything			    fn closing_channel_during_drop_doesnt_kill_everything() 
cmath			mod cmath 
cmath			mod cmath 
cmp			    fn cmp(&self, other: &Path) -> Ordering 
cmp			    fn cmp(&self, other: &Path) -> Ordering 
collections			pub mod collections;
combine			fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i64) -> IoResult<u64> 
combine			                    fn combine(arr: &[u8]) -> i32 
comm_adapters			mod comm_adapters;
comp_requires_verbatim			        fn comp_requires_verbatim(s: &str) -> bool 
compat			pub mod compat 
components			    pub fn components<'a>(&'a self) -> Components<'a> 
components			    pub fn components<'a>(&'a self) -> Components<'a> 
condvar			mod condvar;
condvar			pub mod condvar;
condvar			pub mod condvar;
condvar			pub mod condvar;
connect			    pub fn connect<P: BytesContainer>(path: P) -> IoResult<UnixStream> 
connect			        fn connect(i: int, addr: SocketAddr) 
connect			    pub fn connect<A: ToSocketAddr>(addr: A) -> IoResult<TcpStream> 
connect			    pub fn connect(addr: SocketAddr, timeout: Option<u64>) -> IoResult<TcpStream> 
connect			    pub fn connect(addr: &CString,
connect			fn connect(addr: &CString, ty: libc::c_int,
connect			    pub fn connect(addr: &CString, timeout: Option<u64>) -> IoResult<UnixStream> 
connect_error			    fn connect_error() 
connect_error			    fn connect_error() 
connect_ip4_loopback			    fn connect_ip4_loopback() 
connect_ip6_loopback			    fn connect_ip6_loopback() 
connect_localhost			    fn connect_localhost() 
connect_timeout			    pub fn connect_timeout<P>(path: P, timeout: Duration)
connect_timeout			    pub fn connect_timeout<A: ToSocketAddr>(addr: A,
connect_timeout			pub fn connect_timeout(fd: sock_t,
connect_timeout_error			    fn connect_timeout_error() 
connect_timeout_negative			    fn connect_timeout_negative() 
connect_timeout_success			    fn connect_timeout_success() 
connect_timeout_zero			    fn connect_timeout_zero() 
consts			pub mod consts 
consume			    fn consume(&mut self, amt: uint) { self.inner.consume(amt) }
consume			    fn consume(&mut self, amt: uint) 
consume			    fn consume(&mut self, amt: uint) 
consume			    fn consume(&mut self, amt: uint) { self.pos += amt; }
consume			    fn consume(&mut self, amt: uint) 
consume			    fn consume(&mut self, amt: uint) { self.inner.consume(amt) }
consume			    fn consume(&mut self, amt: uint);
consume			    fn consume(&mut self, _amt: uint) {}
consume			    fn consume(&mut self, amt: uint) 
container_as_bytes			    fn container_as_bytes<'a>(&'a self) -> &'a [u8] 
container_as_bytes			    fn container_as_bytes(&self) -> &[u8] 
container_as_bytes			    fn container_as_bytes<'a>(&'a self) -> &'a [u8] 
container_as_bytes			    fn container_as_bytes<'a>(&'a self) -> &'a [u8];
container_as_bytes			    fn container_as_bytes<'a>(&'a self) -> &'a [u8] 
container_as_bytes			    fn container_as_bytes<'a>(&'a self) -> &'a [u8] 
container_as_str			    fn container_as_str(&self) -> Option<&str> 
container_as_str			    fn container_as_str<'a>(&'a self) -> Option<&'a str> 
container_as_str			    fn container_as_str<'a>(&'a self) -> Option<&'a str> 
contains			            pub fn contains(&self, other: 
contains			    pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool
contains_key			    pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool
contains_nul			fn contains_nul<T: BytesContainer>(v: &T) -> bool 
convert			        fn convert<'a>(x: Option<&'a str>) -> &'a [u8] 
copy			pub fn copy(from: &Path, to: &Path) -> IoResult<()> 
copy			pub fn copy<R: Reader, W: Writer>(r: &mut R, w: &mut W) -> io::IoResult<()> 
copy_file_does_not_exist			    fn copy_file_does_not_exist() 
copy_file_dst_dir			    fn copy_file_dst_dir() 
copy_file_dst_exists			    fn copy_file_dst_exists() 
copy_file_ok			    fn copy_file_ok() 
copy_file_preserves_perm_bits			    fn copy_file_preserves_perm_bits() 
copy_file_src_dir			    fn copy_file_src_dir() 
cos			    fn cos(self) -> f32 
cos			    fn cos(self) -> f64 
cos			    fn cos(self) -> Self;
cosh			    fn cosh(self) -> f32 
cosh			        pub fn cosh(n: c_double) -> c_double;
cosh			    fn cosh(self) -> f64 
cosh			    fn cosh(self) -> Self;
coshf			        pub fn coshf(n: c_float) -> c_float;
create			    pub fn create(path: &Path) -> IoResult<File> 
create			pub unsafe fn create(stack: uint, p: Thunk) -> rust_thread 
create			pub unsafe fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key 
create			pub unsafe fn create(stack: uint, p: Thunk) -> rust_thread 
create			pub unsafe fn create(dtor: Option<Dtor>) -> Key 
create_path			    pub fn create_path(path: &[Path]) -> Vec<u8> 
cstr			fn cstr(path: &Path) -> CString 
current			    pub unsafe fn current() -> uint 
current			    pub unsafe fn current() -> uint 
current			    pub fn current() -> Thread 
current_thread			pub fn current_thread() -> Thread 
cwd			    fn cwd(&self) -> Option<&CString> 
cwd			    pub fn cwd<'a>(&'a mut self, dir: &Path) -> &'a mut Command 
cwd			    fn cwd(&self) -> Option<&CString>;
darwin_fd_limit			mod darwin_fd_limit 
data			    pub fn data(&self) -> *mut u8 { self.data }
datasync			    pub fn datasync(&mut self) -> IoResult<()> 
datasync			    pub fn datasync(&self) -> IoResult<()> 
datasync			    pub fn datasync(&mut self) -> IoResult<()> { return self.fsync(); }
days			    pub fn days(days: i64) -> Duration 
decode_error			pub fn decode_error(errno: i32) -> IoError 
decode_error			pub fn decode_error(errno: i32) -> IoError 
decode_error_detailed			pub fn decode_error_detailed(errno: i32) -> IoError 
decode_error_detailed			pub fn decode_error_detailed(errno: i32) -> IoError 
decrement			    fn decrement(&mut self, token: SignalToken) -> StartResult 
decrement			    fn decrement(&mut self, token: SignalToken) -> Result<(), SignalToken> 
default			    fn default() -> HashMap<K, V, H> 
default			    fn default() -> HashSet<T, H> 
default			    fn default() -> RandomSipHasher 
default			    fn default() -> FilePermission { FilePermission::empty() }
default_sched_threads			pub fn default_sched_threads() -> uint 
demangle			    fn demangle() 
demangle			pub fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> 
demangle_dollars			    fn demangle_dollars() 
demangle_many_dollars			    fn demangle_many_dollars() 
demangle_windows			    fn demangle_windows() 
dequeue			    fn dequeue(&mut self) -> Option<SignalToken> 
dequeue			    fn dequeue(&mut self) -> T 
deref			    fn deref(&self) -> &[libc::c_char] 
deref			    fn deref(&self) -> &BufferedReader<StdReader> 
deref			    fn deref<'a>(&'a self) -> &'a T 
deref			    fn deref(&self) -> &T { unsafe { &*self.__data.get() } }
deref_mut			    fn deref_mut(&mut self) -> &mut BufferedReader<StdReader> 
deref_mut			    fn deref_mut<'a>(&'a mut self) -> &'a mut T 
deref_mut			    fn deref_mut(&mut self) -> &mut T 
description			    fn description(&self) -> &str { "invalid utf-16" }
description			    fn description(&self) -> &str { "invalid utf-8" }
description			    fn description(&self) -> &str 
description			    fn description(&self) -> &str;
description			    fn description(&self) -> &str 
description			    fn description(&self) -> &str { "memory map error" }
destroy			    pub unsafe fn destroy(&'static self) 
destroy			    pub unsafe fn destroy(&'static self) 
destroy			    pub unsafe fn destroy(&'static self) 
destroy			    pub unsafe fn destroy(&self) { self.0.destroy() }
destroy			    pub unsafe fn destroy(&self) { self.0.destroy() }
destroy			    pub unsafe fn destroy(&self) { self.0.destroy() }
destroy			    pub unsafe fn destroy(&self) 
destroy			    pub unsafe fn destroy(&self) 
destroy			    pub unsafe fn destroy(&self) 
destroy			    pub unsafe fn destroy(&self) 
destroy			pub unsafe fn destroy(key: Key) 
destroy			    pub unsafe fn destroy(&self) 
destroy			    pub unsafe fn destroy(&self) 
destroy			    pub unsafe fn destroy(&self) 
destroy			pub unsafe fn destroy(key: Key) 
destroy_upgraded_shared_port_when_sender_still_active			    fn destroy_upgraded_shared_port_when_sender_still_active() 
destroyed			    pub fn destroyed(&'static self) -> bool { self.state() == State::Destroyed }
detach			    fn detach(&self) -> bool 
detach			    fn detach(&self) -> bool;
detach			pub unsafe fn detach(native: rust_thread) 
detach			pub unsafe fn detach(native: rust_thread) 
detach			    pub fn detach(mut self) 
detach_works			    fn detach_works() 
detached			    pub fn detached<'a>(&'a mut self) -> &'a mut Command 
detail			    fn detail(&self) -> Option<String> { None }
detail			    fn detail(&self) -> Option<String> { Some(self.to_string()) }
detail			    fn detail(&self) -> Option<String> 
detail			    fn detail(&self) -> Option<String> { Some(format!("{:?}", self)) }
difference			    pub fn difference<'a>(&'a self, other: &'a HashSet<T, H>) -> Difference<'a, T, H> 
digits			    fn digits(unused_self: Option<f32>) -> uint { num::Float::digits(unused_self) }
digits			    fn digits(unused_self: Option<f64>) -> uint { num::Float::digits(unused_self) }
digits			    fn digits(unused_self: Option<Self>) -> uint;
dir_path			    fn dir_path(&self) -> Self 
dir_path			    fn dir_path(&self) -> Path 
dirname			    fn dirname<'a>(&'a self) -> &'a [u8];
dirname			    fn dirname<'a>(&'a self) -> &'a [u8] 
dirname			    fn dirname<'a>(&'a self) -> &'a [u8] 
dirname_str			    fn dirname_str<'a>(&'a self) -> Option<&'a str> 
dirname_str			    fn dirname_str<'a>(&'a self) -> Option<&'a str> 
display			    fn display<'a>(&'a self) -> Display<'a, Self> 
distance			    pub fn distance(&self) -> uint 
div			    fn div(self, rhs: i32) -> Duration 
div_floor_64			fn div_floor_64(this: i64, other: i64) -> i64 
div_mod_floor_64			fn div_mod_floor_64(this: i64, other: i64) -> (i64, i64) 
div_rem_64			fn div_rem_64(this: i64, other: i64) -> (i64, i64) 
dl			pub mod dl 
dladdr			        fn dladdr(addr: *const libc::c_void,
dlclose			        fn dlclose(handle: *mut libc::c_void) -> libc::c_int;
dlerror			        fn dlerror() -> *mut libc::c_char;
dll_filename			pub fn dll_filename(base: &str) -> String 
dlopen			        fn dlopen(filename: *const libc::c_char,
dlsym			        fn dlsym(handle: *mut libc::c_void,
dns_smoke_test			    fn dns_smoke_test() 
do_bench_mem_writer			    fn do_bench_mem_writer(b: &mut Bencher, times: uint, len: uint) 
do_send			    fn do_send(&mut self, t: Message<T>) -> UpgradeResult 
do_unlink			    fn do_unlink(p_utf16: &Vec<u16>) -> IoResult<()> 
done			    pub fn done(&self, guard: &Guard) 
dont_close_fd_on_command_spawn			    fn dont_close_fd_on_command_spawn() 
dont_panic_in_drop_on_panicked_flush			    fn dont_panic_in_drop_on_panicked_flush() 
double_bind			    fn double_bind() 
drain			    pub fn drain(&mut self) -> Drain<K, V> 
drain			    pub fn drain(&mut self) -> Drain<T> 
drain			    pub fn drain(&mut self) -> Drain<K, V> 
drain			        fn drain(fd: libc::c_int) -> bool 
drop			        fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			        fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			        fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			                fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			                fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) { unsafe { close_sock(self.fd); } }
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) { unsafe { let _ = libc::close(self.fd); } }
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) { (self.SymCleanup)(self.handle); }
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) {}
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			            fn drop(&mut self) 
drop			        fn drop(&mut self) 
drop			            fn drop(&mut self) 
drop_chan			    pub fn drop_chan(&mut self) 
drop_chan			    pub fn drop_chan(&mut self) 
drop_chan			    pub fn drop_chan(&mut self) 
drop_chan			    pub fn drop_chan(&self) 
drop_full			    fn drop_full() 
drop_full			    fn drop_full() 
drop_full_shared			    fn drop_full_shared() 
drop_handler			    pub unsafe fn drop_handler(_handler: &mut super::Handler) 
drop_handler			    pub unsafe fn drop_handler(handler: &mut Handler) 
drop_port			    pub fn drop_port(&mut self) 
drop_port			    pub fn drop_port(&mut self) 
drop_port			    pub fn drop_port(&mut self) 
drop_port			    pub fn drop_port(&self) 
drop_removes_acceptor_path			    fn drop_removes_acceptor_path() 
drop_removes_listener_path			    fn drop_removes_listener_path() 
dtors_in_dtors_in_dtors			    fn dtors_in_dtors_in_dtors() 
dumb_print			pub fn dumb_print(args: fmt::Arguments) 
duration			pub mod duration;
dynamic_lib			pub mod dynamic_lib;
dynamic_tests			mod dynamic_tests 
eabi			pub mod eabi 
empty			            pub fn empty() -> 
ends_with_path			    fn ends_with_path(&self, child: &Self) -> bool;
ends_with_path			    fn ends_with_path(&self, child: &Path) -> bool 
ends_with_path			    fn ends_with_path(&self, child: &Path) -> bool 
ends_with_path_home_dir			    fn ends_with_path_home_dir(b: &mut Bencher) 
ends_with_path_missmatch_jome_home			    fn ends_with_path_missmatch_jome_home(b: &mut Bencher) 
enqueue			    fn enqueue(&mut self, node: &mut Node) -> WaitToken 
enqueue			    fn enqueue(&mut self, t: T) 
entry			    pub fn entry<'a>(&'a mut self, key: K) -> Entry<'a, K, V>
env			    fn env(&self) -> Option<&EnvMap> 
env			    pub fn env<'a, T, U>(&'a mut self, key: T, val: U)
env			pub fn env() -> Vec<(String,String)> 
env			    fn env(&self) -> Option<&collections::HashMap<K, V>>;
env_as_bytes			pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> 
env_cmd			    pub fn env_cmd() -> Command 
env_convert			        fn env_convert(input: Vec<Vec<u8>>) -> Vec<(Vec<u8>, Vec<u8>)> 
env_map_keys_ci			    fn env_map_keys_ci() 
env_remove			    pub fn env_remove<'a, T>(&'a mut self, key: T) -> &'a mut Command
env_set_all			    pub fn env_set_all<'a, T, U>(&'a mut self, env: &[(T,U)])
envvar			    pub fn envvar() -> &'static str 
eof			    pub fn eof(&self) -> bool 
eof			    pub fn eof(&self) -> bool { self.pos >= self.buf.len() }
eof			pub fn eof() -> IoError 
epipe			fn epipe() -> IoError 
epsilon			    fn epsilon() -> f32 { num::Float::epsilon() }
epsilon			    fn epsilon() -> f64 { num::Float::epsilon() }
epsilon			    fn epsilon() -> Self;
eq			    fn eq(&self, other: &HashMap<K, V, H>) -> bool 
eq			    fn eq(&self, other: &HashSet<T, H>) -> bool 
eq			    fn eq(&self, other: &EnvKey) -> bool 
eq			    fn eq(&self, other: &Path) -> bool 
eq			    fn eq(&self, other: &Path) -> bool 
eq_ignore_ascii_case			    fn eq_ignore_ascii_case(&self, other: &Self) -> bool;
eq_ignore_ascii_case			    fn eq_ignore_ascii_case(&self, other: &[u8]) -> bool 
eq_ignore_ascii_case			    fn eq_ignore_ascii_case(&self, other: &char) -> bool 
eq_ignore_ascii_case			    fn eq_ignore_ascii_case(&self, other: &str) -> bool 
eq_ignore_ascii_case			    fn eq_ignore_ascii_case(&self, other: &u8) -> bool 
equiv_prefix			    fn equiv_prefix(&self, other: &Path) -> bool 
erf			        pub fn erf(n: c_double) -> c_double;
erfc			        pub fn erfc(n: c_double) -> c_double;
erfcf			        pub fn erfcf(n: c_float) -> c_float;
erff			        pub fn erff(n: c_float) -> c_float;
errno			pub fn errno() -> uint 
errno			pub fn errno() -> int 
errno			pub fn errno() -> uint 
errno_location			    fn errno_location() -> *const c_int 
error			pub mod error;
error_cb			    extern fn error_cb(_data: *mut libc::c_void, _msg: *const libc::c_char,
error_string			pub fn error_string(errnum: uint) -> String 
error_string			pub fn error_string(errno: i32) -> String 
error_string			pub fn error_string(errnum: i32) -> String 
escape_default			pub fn escape_default<F>(c: u8, mut f: F) where
exception_cleanup			    extern fn exception_cleanup(_unwind_code: uw::_Unwind_Reason_Code,
execute			    pub fn execute<F>(&self, job: F)
exists			    fn exists(&self) -> bool 
exists			    fn exists(&self) -> bool;
exit_reported_right			    fn exit_reported_right() 
exp			    fn exp(self) -> f32 { num::Float::exp(self) }
exp			    fn exp(self) -> f64 { num::Float::exp(self) }
exp			    fn exp(self) -> Self;
exp2			    fn exp2(self) -> f32 { num::Float::exp(self) }
exp2			    fn exp2(self) -> f64 { num::Float::exp(self) }
exp2			    fn exp2(self) -> Self;
exp_m1			    fn exp_m1(self) -> f32 
exp_m1			    fn exp_m1(self) -> f64 
exp_m1			    fn exp_m1(self) -> Self;
expect_full			    pub fn expect_full(self) -> FullBucket<K, V, M> 
expm1			        pub fn expm1(n: c_double) -> c_double;
expm1f			        pub fn expm1f(n: c_float) -> c_float;
ext			pub mod ext;
ext			pub mod ext;
extend			    fn extend<T: Iterator<Item=(K, V)>>(&mut self, mut iter: T) 
extend			    fn extend<I: Iterator<Item=T>>(&mut self, mut iter: I) 
extend_sign			fn extend_sign(val: u64, nbytes: uint) -> i64 
extension			    fn extension<'a>(&'a self) -> Option<&'a [u8]> 
extension_str			    fn extension_str<'a>(&'a self) -> Option<&'a str> 
extension_str			    fn extension_str<'a>(&'a self) -> Option<&'a str> 
extensions			pub mod extensions;
f			        fn f(i: int, tx: Sender<()>) 
f64			    mod f64 
fail			                fn fail(output: &mut FileDesc) -> ! 
failure			mod failure;
fallback			                extern "system" fn fallback(
fast_rebind			    fn fast_rebind() 
fd			    pub fn fd(&self) -> sock_t { self.inner.fd }
fd			    pub fn fd(&self) -> fd_t { self.fd }
fd			    pub fn fd(&self) -> fd_t { self.inner.fd }
fd			    pub fn fd(&self) -> fd_t { self.inner.listener.fd() }
fd			    pub fn fd(&self) -> sock_t { self.inner.fd() }
fd			    pub fn fd(&self) -> sock_t { self.inner.listener.fd() }
fd			    pub fn fd(&self) -> fd_t { self.fd }
fd_set			    pub fn fd_set(set: &mut fd_set, fd: i32) 
fd_set			    pub struct fd_set 
fd_set			pub fn fd_set(set: &mut fd_set, s: libc::SOCKET) 
fd_set			pub struct fd_set 
fdim			        pub fn fdim(a: c_double, b: c_double) -> c_double;
fdimf			        pub fn fdimf(a: c_float, b: c_float) -> c_float;
ffi			pub mod ffi;
file_test_directoryinfo_check_exists_before_and_after_mkdir			    fn file_test_directoryinfo_check_exists_before_and_after_mkdir() 
file_test_directoryinfo_readdir			    fn file_test_directoryinfo_readdir() 
file_test_fileinfo_check_exists_before_and_after_file_creation			    fn file_test_fileinfo_check_exists_before_and_after_file_creation() 
file_test_fileinfo_false_when_checking_is_file_on_a_directory			    fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() 
file_test_io_non_positional_read			    fn file_test_io_non_positional_read() 
file_test_io_seek_and_tell_smoke_test			    fn file_test_io_seek_and_tell_smoke_test() 
file_test_io_seek_and_write			    fn file_test_io_seek_and_write() 
file_test_io_seek_shakedown			    fn file_test_io_seek_shakedown() 
file_test_io_smoke_test			    fn file_test_io_smoke_test() 
file_test_iounlinking_invalid_path_should_raise_condition			    fn file_test_iounlinking_invalid_path_should_raise_condition() 
file_test_stat_is_correct_on_is_dir			    fn file_test_stat_is_correct_on_is_dir() 
file_test_stat_is_correct_on_is_file			    fn file_test_stat_is_correct_on_is_file() 
file_test_walk_dir			    fn file_test_walk_dir() 
filename			    fn filename<'a>(&'a self) -> Option<&'a [u8]>;
filename			    fn filename<'a>(&'a self) -> Option<&'a [u8]> 
filename			    fn filename<'a>(&'a self) -> Option<&'a [u8]> 
filename_display			    fn filename_display<'a>(&'a self) -> Display<'a, Self> 
filename_str			    fn filename_str<'a>(&'a self) -> Option<&'a str> 
filename_str			    fn filename_str<'a>(&'a self) -> Option<&'a str> 
filestem			    fn filestem<'a>(&'a self) -> Option<&'a [u8]> 
filestem_str			    fn filestem_str<'a>(&'a self) -> Option<&'a str> 
filestem_str			    fn filestem_str<'a>(&'a self) -> Option<&'a str> 
fill_buf			    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> { self.inner.fill_buf() }
fill_buf			    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> 
fill_buf			    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> 
fill_buf			    fn fill_buf(&mut self) -> IoResult<&[u8]> 
fill_buf			    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> 
fill_buf			    fn fill_buf(&mut self) -> IoResult<&[u8]> { self.inner.fill_buf() }
fill_buf			    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]>;
fill_buf			    fn fill_buf<'a>(&'a mut self) -> io::IoResult<&'a [u8]> 
fill_bytes			    fn fill_bytes(&mut self, bytes: &mut [u8]) 
fill_bytes			        fn fill_bytes(&mut self, v: &mut [u8]) 
fill_bytes			    fn fill_bytes(&mut self, v: &mut [u8]) 
fill_utf16_buf_and_decode			pub fn fill_utf16_buf_and_decode<F>(mut f: F) -> Option<String> where
find_existing			fn find_existing(b: &mut Bencher) 
find_nonexisting			fn find_nonexisting(b: &mut Bencher) 
first			        fn first<A, B>((a, _): (A, B)) -> A { a }
first			        fn first<A, B>((a, _): (A, B)) -> A { a }
first			    pub fn first(table: M) -> Bucket<K, V, M> 
first_bucket_raw			    fn first_bucket_raw(&self) -> RawBucket<K, V> 
flags			    fn flags(_stat: &libc::stat) -> u64 { 0 }
flags			    fn flags(stat: &libc::stat) -> u64 { stat.st_flags as u64 }
float_macros			mod float_macros;
float_to_str_bytes_common			pub fn float_to_str_bytes_common<T: Float>(
float_to_str_common			pub fn float_to_str_common<T: Float>(
float_to_string			        fn float_to_string(b: &mut Bencher) 
floor			    fn floor(self) -> f32 { num::Float::floor(self) }
floor			    fn floor(self) -> f64 { num::Float::floor(self) }
floor			    fn floor(self) -> Self;
flush			            fn flush(&mut self) -> IoResult<()> { Err(io::standard_error(EndOfFile)) }
flush			    fn flush(&mut self) -> IoResult<()> { self.inner.flush() }
flush			    fn flush(&mut self) -> IoResult<()> 
flush			    fn flush(&mut self) -> IoResult<()> { (**self).flush() }
flush			    fn flush(&mut self) -> IoResult<()> { Ok(()) }
flush			    fn flush(&mut self) -> IoResult<()> { self.inner.flush() }
flush			    fn flush(&mut self) -> IoResult<()> 
flush			    fn flush(&mut self) -> IoResult<()> 
flush			pub fn flush() 
flush			            fn flush(&mut self) -> io::IoResult<()> 
flush			    fn flush(&mut self) -> io::IoResult<()> 
flush_buf			    fn flush_buf(&mut self) -> IoResult<()> 
fmax			        pub fn fmax(a: c_double, b: c_double) -> c_double;
fmaxf			        pub fn fmaxf(a: c_float, b: c_float) -> c_float;
fmin			        pub fn fmin(a: c_double, b: c_double) -> c_double;
fminf			        pub fn fminf(a: c_float, b: c_float) -> c_float;
fmod			        pub fn fmod(a: c_double, b: c_double) -> c_double;
fmodf			        pub fn fmodf(a: c_float, b: c_float) -> c_float;
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			pub mod fmt;
fmt			    fn fmt(&self, out: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt::Show for CString			impl fmt::Show for CString 
fmt::Show for Command			impl fmt::Show for Command 
fmt::Show for Display			impl<'a, P: GenericPath> fmt::Show for Display<'a, P> 
fmt::Show for FilePermission			impl fmt::Show for FilePermission 
fmt::Show for MapError			impl fmt::Show for MapError 
fmt::Show for Path			impl fmt::Show for Path 
fmt::Show for Path			impl fmt::Show for Path 
fmt::Show for PoisonError			impl<T> fmt::Show for PoisonError<T> 
fmt::Show for ProcessExit			impl fmt::Show for ProcessExit 
fmt::Show for RecvError			impl fmt::Show for RecvError 
fmt::Show for SendError			impl<T> fmt::Show for SendError<T> 
fmt::Show for TryLockError			impl<T> fmt::Show for TryLockError<T> 
fmt::Show for TryRecvError			impl fmt::Show for TryRecvError 
fmt::Show for TrySendError			impl<T> fmt::Show for TrySendError<T> 
fmt::String for Command			impl fmt::String for Command 
fmt::String for Display			impl<'a, P: GenericPath> fmt::String for Display<'a, P> 
fmt::String for Duration			impl fmt::String for Duration 
fmt::String for FilePermission			impl fmt::String for FilePermission 
fmt::String for IoError			impl fmt::String for IoError 
fmt::String for IpAddr			impl fmt::String for IpAddr 
fmt::String for ProcessExit			impl fmt::String for ProcessExit 
fmt::String for SocketAddr			impl fmt::String for SocketAddr 
fmt::Writer for Adaptor			        impl<'a, T: ?Sized + Writer> fmt::Writer for Adaptor<'a, T> 
fmt::Writer for BufWriter			    impl<'a> fmt::Writer for BufWriter<'a> 
fmt::Writer for Stdio			impl fmt::Writer for Stdio 
foo			        fn foo() -> Foo 
forget			    fn forget() 
forget			    pub fn forget(mut self) 
format			pub fn format(args: Arguments) -> string::String 
fract			    fn fract(self) -> f32 { num::Float::fract(self) }
fract			    fn fract(self) -> f64 { num::Float::fract(self) }
fract			    fn fract(self) -> Self;
free_handle			fn free_handle(handle: *mut ()) 
free_lock			unsafe fn free_lock(h: ffi::LPCRITICAL_SECTION) 
freeaddrinfo			    fn freeaddrinfo(res: *mut libc::addrinfo);
frexp			    fn frexp(self) -> (f32, int) 
frexp			        pub fn frexp(n: c_double, value: &mut c_int) -> c_double;
frexp			    fn frexp(self) -> (f64, int) 
frexp			    fn frexp(self) -> (Self, int);
frexpf			        pub fn frexpf(n: c_float, value: &mut c_int) -> c_float;
frob			    fn frob() 
from_bits			            pub fn from_bits(bits: 
from_bits_truncate			            pub fn from_bits_truncate(bits: 
from_errno			    pub fn from_errno(errno: uint, detail: bool) -> IoError 
from_error			    fn from_error(err: E) -> E 
from_error			    fn from_error(err: E) -> Self;
from_error			    fn from_error(err: IoError) -> Box<Error> 
from_error			    fn from_error(err: MapError) -> Box<Error> 
from_error			    fn from_error(err: PoisonError<T>) -> TryLockError<T> 
from_filedesc			    pub fn from_filedesc(fd: FileDesc) -> PipeStream 
from_fn			    pub fn from_fn<F>(f: F) -> Future<A>
from_i64			        fn from_i64(n: i64) -> Option<Value> { Some(Value { x: n as int }) }
from_iter			    fn from_iter<T: Iterator<Item=(K, V)>>(iter: T) -> HashMap<K, V, H> 
from_iter			    fn from_iter<I: Iterator<Item=T>>(iter: I) -> HashSet<T, H> 
from_receiver			    pub fn from_receiver(rx: Receiver<A>) -> Future<A> 
from_seed			    fn from_seed(seed: &'a [uint]) -> StdRng 
from_slice			    pub fn from_slice(v: &[u8]) -> CString 
from_str			    fn from_str(s: &str) -> Option<IpAddr> 
from_str			    fn from_str(s: &str) -> Option<SocketAddr> 
from_str			    fn from_str<T: ::str::FromStr>(t: &str) -> Option<T> 
from_str			    fn from_str(s: &str) -> Option<Path> 
from_str			    fn from_str(s: &str) -> Option<Path> 
from_u64			        fn from_u64(n: u64) -> Option<Value> { Some(Value { x: n as int }) }
from_utf8			        fn from_utf8(s: &[u8]) -> Option<&str> 
from_value			    pub fn from_value(val: A) -> Future<A> 
from_vec			    pub fn from_vec(v: Vec<u8>) -> CString 
from_vec			    pub fn from_vec(buf: Vec<u8>) -> MemWriter 
from_vec_unchecked			    pub unsafe fn from_vec_unchecked(mut v: Vec<u8>) -> CString 
fs			pub mod fs;
fs			pub mod fs;
fs			pub mod fs;
fstat			    pub fn fstat(&self) -> IoResult<FileStat> 
fstat			    pub fn fstat(&self) -> IoResult<io::FileStat> 
fsync			    pub fn fsync(&mut self) -> IoResult<()> 
fsync			    pub fn fsync(&self) -> IoResult<()> 
fsync			    pub fn fsync(&mut self) -> IoResult<()> 
full			    pub fn full(&self) -> &FullBucket<K, V, M> 
future			mod future;
gai_strerror			    fn gai_strerror(errcode: libc::c_int) -> *const libc::c_char;
gap_peek			    pub fn gap_peek(self) -> Option<GapThenFull<K, V, M>> 
gen			    fn gen(_stat: &libc::stat) -> u64 { 0 }
gen			    fn gen(stat: &libc::stat) -> u64 { stat.st_gen as u64 }
get			    pub fn get(&self) -> &V 
get			    pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, K, V>> 
get			    pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>
get			    pub fn get(&mut self) -> A 
get			    unsafe fn get(&self) -> *mut T 
get			    pub fn get(&self) -> bool 
get			    pub fn get(&self) -> *mut u8 
get			    pub unsafe fn get(&self) -> *mut u8 { imp::get(self.key()) }
get			pub unsafe fn get(key: Key) -> *mut u8 
get			    unsafe fn get(&self) -> ffi::LPCRITICAL_SECTION 
get			pub unsafe fn get(key: Key) -> *mut u8 
get			        pub unsafe fn get(&'static self) -> Option<&'static T> 
get			        pub unsafe fn get(&self) -> *mut T { *self.inner.get() }
get			        pub unsafe fn get(&self) -> *mut T { self.inner.get() as *mut _ }
get_address_name			pub fn get_address_name(addr: IpAddr) -> IoResult<String> 
get_address_name			pub fn get_address_name(addr: IpAddr) -> Result<String, IoError> 
get_env_map			    fn get_env_map<'a>(&'a mut self) -> &'a mut EnvMap 
get_env_pairs			pub unsafe fn get_env_pairs() -> Vec<Vec<u8>> 
get_env_pairs			pub unsafe fn get_env_pairs() -> Vec<Vec<u8>> 
get_exit_status			pub fn get_exit_status() -> int 
get_fd			        fn get_fd(file: &File) -> libc::HANDLE 
get_fd			        fn get_fd(file: &File) -> libc::c_int 
get_global_ptr			    fn get_global_ptr() -> *mut Option<Box<Vec<Vec<u8>>>> 
get_host_addresses			pub fn get_host_addresses(host: &str) -> IoResult<Vec<IpAddr>> 
get_host_addresses			pub fn get_host_addresses(host: Option<&str>, servname: Option<&str>,
get_mut			    pub fn get_mut(&mut self) -> &mut V 
get_mut			    pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>
get_mut			    fn get_mut<'a>(&'a mut self) -> &'a mut BufferedWriter<W> 
get_mut			    pub fn get_mut(&mut self) -> &mut R { &mut self.inner }
get_mut			    pub fn get_mut(&mut self) -> &mut S 
get_mut			    pub fn get_mut(&mut self) -> &mut W { self.inner.as_mut().unwrap() }
get_ref			    pub fn get_ref(&self) -> &S 
get_ref			    pub fn get_ref(&self) -> &W { self.inner.as_ref().unwrap() }
get_ref			    pub fn get_ref<'a>(&'a self) -> &'a W { self.inner.get_ref() }
get_ref			    pub fn get_ref<'a>(&self) -> &R { &self.inner }
get_ref			    pub fn get_ref<'a>(&'a self) -> &'a [u8] { self.buf.as_slice() }
get_ref			    pub fn get_ref<'a>(&'a mut self) -> &'a A 
get_remove_insert			fn get_remove_insert(b: &mut Bencher) 
get_sp_limit			            fn get_sp_limit() -> *const c_void;
get_sp_limit			pub unsafe fn get_sp_limit() -> uint 
get_stack_start			    unsafe fn get_stack_start() -> *mut libc::c_void 
get_task_guard_page			unsafe fn get_task_guard_page() -> uint 
get_winsize			    pub fn get_winsize(&mut self) -> IoResult<(int, int)> 
get_winsize			    pub fn get_winsize(&mut self) -> IoResult<(int, int)> 
getaddrinfo			    fn getaddrinfo(node: *const c_char, service: *const c_char,
getcwd			pub fn getcwd() -> IoResult<Path> 
getcwd			pub fn getcwd() -> IoResult<Path> 
getcwd			pub fn getcwd() -> IoResult<Path> 
getenv			pub fn getenv(n: &str) -> Option<String> 
getenv_as_bytes			pub fn getenv_as_bytes(n: &str) -> Option<Vec<u8>> 
getenv_nonempty			    fn getenv_nonempty(v: &str) -> Option<Path> 
getnameinfo			    fn getnameinfo(sa: *const libc::sockaddr, salen: libc::socklen_t,
getrandom			    fn getrandom(_buf: &mut [u8]) -> libc::c_long { -1 }
getrandom			    fn getrandom(buf: &mut [u8]) -> libc::c_long 
getrandom_fill_bytes			    fn getrandom_fill_bytes(v: &mut [u8]) 
getrandom_next_u32			    fn getrandom_next_u32() -> u32 
getrandom_next_u64			    fn getrandom_next_u64() -> u64 
getrlimit			        fn getrlimit(resource: libc::c_int, rlp: *mut rlimit) -> libc::c_int;
getsockopt			pub fn getsockopt<T: Copy>(fd: sock_t, opt: libc::c_int,
getsockopt			    pub fn getsockopt(sockfd: libc::c_int,
getsockopt			    pub fn getsockopt(sockfd: libc::SOCKET,
gettimeofday			    pub fn gettimeofday(timeval: *mut libc::timeval,
gettimeofday			    pub fn gettimeofday(tp: *mut libc::timeval,
gid			    fn gid(&self) -> Option<uint> 
gid			    pub fn gid<'a>(&'a mut self, id: uint) -> &'a mut Command 
gid			    fn gid(&self) -> Option<uint>;
granularity			    pub fn granularity() -> uint 
grow_by_insertion			fn grow_by_insertion(b: &mut Bencher) 
guard			pub mod guard 
guard			pub mod guard 
guard_lock			pub fn guard_lock<'a, T>(guard: &MutexGuard<'a, T>) -> &'a sys::Mutex 
guard_poison			pub fn guard_poison<'a, T>(guard: &MutexGuard<'a, T>) -> &'a poison::Flag 
handle			    pub fn handle<'a, T: Send>(&'a self, rx: &'a Receiver<T>) -> Handle<'a, T> 
handle			    pub fn handle(&self) -> libc::HANDLE 
handle			    fn handle(&self) -> libc::HANDLE { let Event(handle) = *self; handle }
handle			    pub fn handle(&self) -> libc::HANDLE { self.inner.handle }
handle			    pub fn handle(&self) -> libc::HANDLE 
handle			    pub fn handle(&self) -> c::WSAEVENT { let Event(handle) = *self; handle }
has_nonsemantic_trailing_slash			    fn has_nonsemantic_trailing_slash(&self) -> bool 
hash			    pub fn hash(&self) -> SafeHash 
hash			mod hash;
hash			    fn hash<T: ?Sized + Hash<sip::SipState>>(&self, value: &T) -> u64 
hash			    fn hash(&self, state: &mut SipState) 
hash			pub mod hash;
hash			    fn hash(&self, state: &mut S) 
hash			    fn hash(&self, _: &mut S) 
hash			    fn hash(&self, state: &mut S) 
hash::Hash for Path			impl<S: hash::Writer> hash::Hash<S> for Path 
hash::Hash for Path			impl<S: hash::Writer> hash::Hash<S> for Path 
hash_map			pub mod hash_map 
hash_set			pub mod hash_set 
hashmap			    fn hashmap() 
hashmap_as_queue			fn hashmap_as_queue(b: &mut Bencher) 
helper			fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) 
helper			fn helper(input: libc::HANDLE, messages: Receiver<Req>, _: ()) 
helper_signal			pub mod helper_signal;
helper_signal			pub mod helper_signal;
helper_thread			pub mod helper_thread;
homedir			    fn homedir() 
homedir			pub fn homedir() -> Option<Path> 
hours			    pub fn hours(hours: i64) -> Duration 
htons			pub fn htons(u: u16) -> u16 
hypot			    fn hypot(self, other: f32) -> f32 
hypot			        pub fn hypot(x: c_double, y: c_double) -> c_double;
hypot			    fn hypot(self, other: f64) -> f64 
hypot			    fn hypot(self, other: Self) -> Self;
hypotf			        pub fn hypotf(x: c_float, y: c_float) -> c_float;
id			    pub fn id(&self) -> libc::pid_t { self.handle.id() }
id			    pub fn id(&self) -> uint { self.id }
id			    pub fn id(&self) -> pid_t 
id			    pub fn id(&self) -> pid_t 
ilogb			        pub fn ilogb(n: c_double) -> c_int;
ilogbf			        pub fn ilogbf(n: c_float) -> c_int;
imp			mod imp 
imp			mod imp 
imp			    mod imp 
imp			mod imp 
imp			mod imp 
imp			mod imp 
imp			mod imp 
imp			mod imp 
in_ms_u64			fn in_ms_u64(d: Duration) -> u64 
inc			        fn inc() 
incoming			    fn incoming<'r>(&'r mut self) -> IncomingConnections<'r, Self> 
index			    fn index<'a>(&'a self, index: &Q) -> &'a V 
index			    pub fn index(&self) -> uint 
index_mut			    fn index_mut<'a>(&'a mut self, index: &Q) -> &'a mut V 
infinity			    fn infinity() -> f32 { num::Float::infinity() }
infinity			    fn infinity() -> f64 { num::Float::infinity() }
infinity			    fn infinity() -> Self;
inherit_blocker			    pub fn inherit_blocker(&mut self,
init			    pub unsafe fn init(_argc: int, _argv: *const *const u8) 
init			    pub unsafe fn init(argc: int, argv: *const *const u8) 
init			pub unsafe fn init(argc: int, argv: *const *const u8) { imp::init(argc, argv) }
init			unsafe fn init() 
init			    pub unsafe fn init() 
init			    pub unsafe fn init() 
init			pub unsafe fn init() 
init			    pub unsafe fn init() 
init			    unsafe fn init(&self, slot: &UnsafeCell<Option<T>>) -> &T 
init_dtors			unsafe fn init_dtors() 
init_frame			    pub fn init_frame(frame: &mut super::STACKFRAME64,
init_lock			unsafe fn init_lock() -> ffi::LPCRITICAL_SECTION 
init_net			pub fn init_net() {}
init_net			pub fn init_net() 
init_state			    unsafe fn init_state() -> *mut backtrace_state 
inner			        extern "C" fn inner(
inner			    unsafe fn inner<'a>(&'a self) -> &'a Flavor<T> 
inner			    fn inner(&mut self) -> Box<Inner> 
inner_mut			    unsafe fn inner_mut<'a>(&'a self) -> &'a mut Flavor<T> 
inner_unsafe			    fn inner_unsafe<'a>(&'a self) -> &'a UnsafeCell<Flavor<T>> 
inner_unsafe			    fn inner_unsafe<'a>(&'a self) -> &'a UnsafeCell<Flavor<T>>;
insert			            pub fn insert(&mut self, other: 
insert			    pub fn insert(&mut self, k: K, v: V) -> Option<V> 
insert			    pub fn insert(&mut self, mut value: V) -> V 
insert			    pub fn insert(self, value: V) -> &'a mut V 
insert			    pub fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()).is_none() }
insert			    fn insert(t: Box<Inner>, active: &mut Vec<Box<Inner>>) 
insert_hashed_nocheck			    fn insert_hashed_nocheck(&mut self, hash: SafeHash, k: K, v: V) -> &mut V 
insert_hashed_ordered			    fn insert_hashed_ordered(&mut self, hash: SafeHash, k: K, v: V) 
insert_or_replace_with			    fn insert_or_replace_with<'a, F>(&'a mut self,
inspect			    pub fn inspect(&self) -> u64 { self.hash }
int			    mod int 
int_macros			mod int_macros;
int_to_str_bytes_common			fn int_to_str_bytes_common<T, F>(num: T, radix: uint, sign: SignFormat, mut f: F) where
integer_decode			    fn integer_decode(self) -> (u64, i16, i8) { num::Float::integer_decode(self) }
integer_decode			    fn integer_decode(self) -> (u64, i16, i8) { num::Float::integer_decode(self) }
integer_decode			    fn integer_decode(self) -> (u64, i16, i8);
intersection			    pub fn intersection<'a>(&'a self, other: &'a HashSet<T, H>) -> Intersection<'a, T, H> 
intersects			            pub fn intersects(&self, other: 
into_ascii_lowercase			    fn into_ascii_lowercase(mut self) -> Vec<u8> 
into_ascii_lowercase			    fn into_ascii_lowercase(self) -> Self;
into_ascii_lowercase			    fn into_ascii_lowercase(self) -> String 
into_ascii_uppercase			    fn into_ascii_uppercase(mut self) -> Vec<u8> 
into_ascii_uppercase			    fn into_ascii_uppercase(self) -> Self;
into_ascii_uppercase			    fn into_ascii_uppercase(self) -> String 
into_bucket			    pub fn into_bucket(self) -> Bucket<K, V, M> 
into_guard			    pub fn into_guard(self) -> T { self.guard }
into_inner			    pub fn into_inner(mut self) -> W 
into_inner			    pub fn into_inner(self) -> R { self.inner }
into_inner			    pub fn into_inner(self) -> S 
into_inner			    pub fn into_inner(self) -> W { self.inner.into_inner() }
into_inner			    pub fn into_inner(self) -> Vec<u8> { self.buf }
into_inner			    pub fn into_inner(self) -> Path 
into_inner			    pub fn into_inner(self) -> (R, W) 
into_inner			    pub fn into_inner(self) -> R { self.inner }
into_inner			    pub fn into_inner(mut self) -> A 
into_iter			    pub fn into_iter(self) -> IntoIter<K, V> 
into_iter			    pub fn into_iter(self) -> IntoIter<T> 
into_iter			    pub fn into_iter(self) -> IntoIter<K, V> 
into_mut			    pub fn into_mut(self) -> &'a mut V 
into_mut_refs			    pub fn into_mut_refs(self) -> (&'t mut K, &'t mut V) 
into_option			    fn into_option(self) -> Option<FullBucket<K, V, M>> 
into_refs			    pub fn into_refs(self) -> (&'t K, &'t V) 
into_table			    pub fn into_table(self) -> M 
into_vec			    fn into_vec(self) -> Vec<u8>;
into_vec			    fn into_vec(self) -> Vec<u8> 
into_vec			    fn into_vec(self) -> Vec<u8> 
invalid_encoding			fn invalid_encoding() -> IoError 
invalid_path_raises			    fn invalid_path_raises() 
invoke			    fn invoke(self: Box<F>, arg: A) -> R 
invoke			    fn invoke(self: Box<Self>, arg: A) -> R;
invoke			    pub fn invoke(self, arg: A) -> R 
io			pub mod io;
io::Reader for S			        impl io::Reader for S 
io::Writer for S			        impl io::Writer for S 
io_read_at_least			    fn io_read_at_least() 
ioctl			    pub fn ioctl(fd: libc::c_int, req: libc::c_ulong, ...) -> libc::c_int;
ioctlsocket			    pub fn ioctlsocket(s: libc::SOCKET, cmd: libc::c_long,
ip			pub mod ip;
ip_to_inaddr			pub fn ip_to_inaddr(ip: IpAddr) -> InAddr 
ipv6_addr_from_head_tail			        fn ipv6_addr_from_head_tail(head: &[u16], tail: &[u16]) -> IpAddr 
ipv6_addr_to_string			    fn ipv6_addr_to_string() 
is_absolute			    fn is_absolute(&self) -> bool;
is_absolute			    fn is_absolute(&self) -> bool 
is_absolute			    fn is_absolute(&self) -> bool 
is_all			            pub fn is_all(&self) -> bool 
is_ancestor_of			    fn is_ancestor_of(&self, other: &Self) -> bool;
is_ancestor_of			    fn is_ancestor_of(&self, other: &Path) -> bool 
is_ancestor_of			    fn is_ancestor_of(&self, other: &Path) -> bool 
is_ancestor_of_path_with_10_dirs			    fn is_ancestor_of_path_with_10_dirs(b: &mut Bencher) 
is_ascii			    fn is_ascii(&self) -> bool 
is_ascii			    fn is_ascii(&self) -> bool;
is_cwd_relative			pub fn is_cwd_relative(path: &Path) -> bool 
is_dir			    fn is_dir(&self) -> bool 
is_dir			    fn is_dir(&self) -> bool;
is_disjoint			    pub fn is_disjoint(&self, other: &HashSet<T, H>) -> bool 
is_empty			            pub fn is_empty(&self) -> bool 
is_empty			    pub fn is_empty(&self) -> bool { self.len() == 0 }
is_empty			    pub fn is_empty(&self) -> bool { self.map.len() == 0 }
is_eof			    fn is_eof(&self) -> bool 
is_file			    fn is_file(&self) -> bool 
is_file			    fn is_file(&self) -> bool;
is_finite			    fn is_finite(self) -> bool { num::Float::is_finite(self) }
is_finite			    fn is_finite(self) -> bool { num::Float::is_finite(self) }
is_finite			    fn is_finite(self) -> bool;
is_getrandom_available			    fn is_getrandom_available() -> bool { false }
is_getrandom_available			    fn is_getrandom_available() -> bool 
is_infinite			    fn is_infinite(self) -> bool { num::Float::is_infinite(self) }
is_infinite			    fn is_infinite(self) -> bool { num::Float::is_infinite(self) }
is_infinite			    fn is_infinite(self) -> bool;
is_leader			    pub fn is_leader(&self) -> bool { self.0 }
is_nan			    fn is_nan(self) -> bool { num::Float::is_nan(self) }
is_nan			    fn is_nan(self) -> bool { num::Float::is_nan(self) }
is_nan			    fn is_nan(self) -> bool;
is_negative			    fn is_negative(self) -> bool { num::Float::is_negative(self) }
is_negative			    fn is_negative(self) -> bool { num::Float::is_negative(self) }
is_negative			    fn is_negative(self) -> bool;
is_normal			    fn is_normal(self) -> bool { num::Float::is_normal(self) }
is_normal			    fn is_normal(self) -> bool { num::Float::is_normal(self) }
is_normal			    fn is_normal(self) -> bool;
is_positive			    fn is_positive(self) -> bool { num::Float::is_positive(self) }
is_positive			    fn is_positive(self) -> bool { num::Float::is_positive(self) }
is_positive			    fn is_positive(self) -> bool;
is_relative			    fn is_relative(&self) -> bool 
is_relative			    fn is_relative(&self) -> bool 
is_sep			pub fn is_sep(c: char) -> bool 
is_sep			pub fn is_sep(c: char) -> bool 
is_sep_			        fn is_sep_(prefix: Option<PathPrefix>, u: u8) -> bool 
is_sep_byte			pub fn is_sep_byte(u: &u8) -> bool 
is_sep_byte			pub fn is_sep_byte(u: &u8) -> bool 
is_sep_byte_verbatim			pub fn is_sep_byte_verbatim(u: &u8) -> bool 
is_sep_verbatim			pub fn is_sep_verbatim(c: char) -> bool 
is_set			    pub fn is_set(&'static self) -> bool 
is_str			    fn is_str(_: Option<& &'a T>) -> bool { BytesContainer::is_str(None::<&T>) }
is_str			    fn is_str(_: Option<&Self>) -> bool { false }
is_str			    fn is_str(_: Option<&String>) -> bool { true }
is_str			    fn is_str(_: Option<&str>) -> bool { true }
is_str			    fn is_str(_: Option<&Path>) -> bool { true }
is_subset			    pub fn is_subset(&self, other: &HashSet<T, H>) -> bool 
is_superset			    pub fn is_superset(&self, other: &HashSet<T, H>) -> bool 
is_tty			pub fn is_tty(fd: c_int) -> bool 
is_verbatim			pub fn is_verbatim(path: &Path) -> bool 
is_vol_abs			        fn is_vol_abs(path: &str, prefix: Option<PathPrefix>) -> bool 
is_vol_relative			pub fn is_vol_relative(path: &Path) -> bool 
is_zero			    pub fn is_zero(&self) -> bool 
isatty			    pub fn isatty(&self) -> bool 
isatty			    pub fn isatty(&self) -> bool { false }
isatty			    pub fn isatty(&self) -> bool { true }
issue_10663			    fn issue_10663() 
issue_15761			    fn issue_15761() 
iter			    pub fn iter(&self) -> Iter<K, V> 
iter			    pub fn iter(&self) -> Iter<T> 
iter			    pub fn iter(&self) -> Iter<K, V> 
iter			    pub fn iter(&self) -> Iter<T> 
iter			    fn iter(&self) -> Packets { Packets { cur: self.head } }
iter_mut			    pub fn iter_mut(&mut self) -> IterMut<K, V> 
iter_mut			    pub fn iter_mut(&mut self) -> IterMut<K, V> 
iter_reader_zero_length			    fn iter_reader_zero_length() 
j0			        pub fn j0(n: c_double) -> c_double;
j1			        pub fn j1(n: c_double) -> c_double;
jn			        pub fn jn(i: c_int, n: c_double) -> c_double;
join			        fn join(&self, path: &str) -> Path 
join			    fn join<T: BytesContainer>(&self, path: T) -> Self 
join			pub unsafe fn join(native: rust_thread) 
join			pub unsafe fn join(native: rust_thread) 
join			    pub fn join(mut self) -> Result<T> 
join_abs_path_home_dir			    fn join_abs_path_home_dir(b: &mut Bencher) 
join_home_dir			    fn join_home_dir(b: &mut Bencher) 
join_many			    fn join_many<T: BytesContainer>(&self, paths: &[T]) -> Self 
join_many_abs_path_home_dir			    fn join_many_abs_path_home_dir(b: &mut Bencher) 
join_many_home_dir			    fn join_many_home_dir(b: &mut Bencher) 
join_multicast			    pub fn join_multicast(&mut self, multi: IpAddr) -> IoResult<()> 
join_multicast			    pub fn join_multicast(&mut self, multi: IpAddr) -> IoResult<()> 
join_paths			pub fn join_paths<T: BytesContainer>(paths: &[T]) -> Result<Vec<u8>, &'static str> 
join_paths			pub fn join_paths<T: BytesContainer>(paths: &[T]) -> Result<Vec<u8>, &'static str> 
join_paths			pub fn join_paths<T: BytesContainer>(paths: &[T]) -> Result<Vec<u8>, &'static str> 
join_paths_unix			    fn join_paths_unix() 
join_paths_windows			    fn join_paths_windows() 
keep_going			pub fn keep_going<F>(data: &[u8], mut f: F) -> i64 where
kernel32			    pub mod kernel32 
key			    unsafe fn key(&self) -> imp::Key 
keys			    pub fn keys<'a>(&'a self) -> Keys<'a, K, V> 
kill			    pub fn kill(id: libc::pid_t, signal: int) -> IoResult<()> 
kill			    pub unsafe fn kill(&self, signal: int) -> IoResult<()> 
kill			    pub unsafe fn kill(&self, signal: int) -> IoResult<()> 
killpid			    pub unsafe fn killpid(pid: pid_t, signal: int) -> IoResult<()> 
killpid			    pub unsafe fn killpid(pid: pid_t, signal: int) -> IoResult<()> 
kind			    pub fn kind(&self) -> MemoryMapKind { self.kind }
lang_start			fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int 
last_error			    pub fn last_error() -> IoError 
last_error			pub fn last_error() -> IoError 
last_error			pub fn last_error() -> IoError 
last_gai_error			pub fn last_gai_error(s: libc::c_int) -> IoError 
last_gai_error			pub fn last_gai_error(_errno: i32) -> IoError 
last_net_error			pub fn last_net_error() -> IoError 
last_net_error			pub fn last_net_error() -> IoError 
last_os_error			    pub fn last_os_error() 
last_os_error			pub fn last_os_error() -> String 
last_two			        fn last_two<A, B, C>((_, b, c): (A, B, C)) -> (B, C) { (b, c) }
lazy_init			    unsafe fn lazy_init(&self) -> uint 
ldexp			    fn ldexp(x: f32, exp: int) -> f32 
ldexp			        pub fn ldexp(x: c_double, n: c_int) -> c_double;
ldexp			    fn ldexp(x: f64, exp: int) -> f64 
ldexp			    fn ldexp(x: Self, exp: int) -> Self;
ldexpf			        pub fn ldexpf(x: c_float, n: c_int) -> c_float;
leave_multicast			    pub fn leave_multicast(&mut self, multi: IpAddr) -> IoResult<()> 
leave_multicast			    pub fn leave_multicast(&mut self, multi: IpAddr) -> IoResult<()> 
len			    pub fn len(&self) -> uint { self.table.size() }
len			    pub fn len(&self) -> uint { self.map.len() }
len			    pub fn len(&self) -> uint { self.len }
lgamma_r			        pub fn lgamma_r(n: c_double, sign: &mut c_int) -> c_double;
lgammaf_r			        pub fn lgammaf_r(n: c_float, sign: &mut c_int) -> c_float;
libunwind			mod libunwind;
limit			    pub fn limit(&self) -> uint { self.limit }
limit_reader_buffer			    fn limit_reader_buffer() 
limit_thread_creation_due_to_osx_and_valgrind			pub fn limit_thread_creation_due_to_osx_and_valgrind() -> bool 
lines			    fn lines<'r>(&'r mut self) -> Lines<'r, Self>;
lines			    fn lines<'r>(&'r mut self) -> Lines<'r, T> 
link			pub fn link(src: &Path, dst: &Path) -> IoResult<()> 
link			pub fn link(src: &Path, dst: &Path) -> IoResult<()> 
link			pub fn link(src: &Path, dst: &Path) -> IoResult<()> 
links_work			    fn links_work() 
listen			    fn listen(self) -> IoResult<A>;
listen			    fn listen(self) -> IoResult<UnixAcceptor> 
listen			    fn listen(self) -> IoResult<TcpAcceptor> 
listen			    fn listen(self) -> IoResult<A> 
listen			    pub fn listen(self) -> IoResult<UnixAcceptor> 
listen			    pub fn listen(self, backlog: int) -> IoResult<TcpAcceptor> 
listen			    pub fn listen(self) -> IoResult<UnixAcceptor> 
listen			    pub fn listen(self, backlog: int) -> IoResult<TcpAcceptor> 
listen_ip4_localhost			    fn listen_ip4_localhost() 
ln			    fn ln(self) -> f32 { num::Float::ln(self) }
ln			    fn ln(self) -> f64 { num::Float::ln(self) }
ln			    fn ln(self) -> Self;
ln_1p			    fn ln_1p(self) -> f32 
ln_1p			    fn ln_1p(self) -> f64 
ln_1p			    fn ln_1p(self) -> Self;
load_argc_and_argv			unsafe fn load_argc_and_argv(argc: int,
load_argc_and_argv			    unsafe fn load_argc_and_argv(argc: int, argv: *const *const u8) -> Vec<Vec<u8>> 
load_self			pub fn load_self() -> Option<Vec<u8>> 
load_self			pub fn load_self() -> Option<Vec<u8>> 
lock			    pub fn lock<'a>(&'a mut self) -> StdinReaderGuard<'a> 
lock			    pub fn lock(&'static self) -> LockResult<MutexGuard<()>> 
lock			    pub fn lock(&self) -> LockResult<MutexGuard<T>> 
lock			    pub unsafe fn lock(&self) { self.0.lock() }
lock			    pub unsafe fn lock(&self) 
lock			    pub unsafe fn lock(&self) 
lock_nonblocking			    fn lock_nonblocking(&self) {}
lock_nonblocking			    fn lock_nonblocking<'a>(&'a self) -> Guard<'a> 
lock_nonblocking			    fn lock_nonblocking(&self) {}
lock_nonblocking			    fn lock_nonblocking<'a>(&'a self) -> Guard<'a> 
log			    fn log(self, base: f32) -> f32 { num::Float::log(self, base) }
log			    fn log(self, base: f64) -> f64 { num::Float::log(self, base) }
log			    fn log(self, base: Self) -> Self;
log10			    fn log10(self) -> f32 { num::Float::log10(self) }
log10			    fn log10(self) -> f64 { num::Float::log10(self) }
log10			    fn log10(self) -> Self;
log1p			        pub fn log1p(n: c_double) -> c_double;
log1pf			        pub fn log1pf(n: c_float) -> c_float;
log2			    fn log2(self) -> f32 { num::Float::log2(self) }
log2			    fn log2(self) -> f64 { num::Float::log2(self) }
log2			    fn log2(self) -> Self;
log_enabled			pub fn log_enabled() -> bool 
logb			        pub fn logb(n: c_double) -> c_double;
logbf			        pub fn logbf(n: c_float) -> c_float;
lookup			fn lookup(hostname: Option<&str>, servname: Option<&str>, hint: Option<Hint>)
lookup			    fn lookup() -> Path 
lots_and_lots			    fn lots_and_lots() 
lstat			    fn lstat(&self) -> IoResult<FileStat> { lstat(self) }
lstat			    fn lstat(&self) -> IoResult<FileStat>;
lstat			pub fn lstat(path: &Path) -> IoResult<FileStat> 
lstat			pub fn lstat(p: &Path) -> IoResult<FileStat> 
lstat			pub fn lstat(_p: &Path) -> IoResult<FileStat> 
mach_absolute_time			        pub fn mach_absolute_time() -> u64;
mach_timebase_info			        pub fn mach_timebase_info(info: *mut mach_timebase_info) -> c_int;
macros			pub mod macros;
macros			mod macros;
main			    pub unsafe fn main() -> uint 
main			    pub unsafe fn main() -> uint 
make_absolute			pub fn make_absolute(p: &Path) -> IoResult<Path> 
make_command_line			fn make_command_line(prog: &CString, args: &[CString]) -> String 
make_handler			    pub unsafe fn make_handler() -> Handler 
make_handler			    pub unsafe fn make_handler() -> super::Handler 
make_handler			pub unsafe fn make_handler() -> Handler 
make_hash			    fn make_hash<X: ?Sized + Hash<S>>(&self, x: &X) -> SafeHash 
make_hash			pub fn make_hash<T: ?Sized + Hash<S>, S, H: Hasher<S>>(hasher: &H, t: &T) -> SafeHash 
make_non_verbatim			pub fn make_non_verbatim(path: &Path) -> Option<Path> 
make_rand_name			    fn make_rand_name() -> String 
mantissa_digits			    fn mantissa_digits(unused_self: Option<f32>) -> uint 
mantissa_digits			    fn mantissa_digits(unused_self: Option<f64>) -> uint 
mantissa_digits			    fn mantissa_digits(unused_self: Option<Self>) -> uint;
map			pub mod map;
map			        fn map() -> RefCell<HashMap<int, int>> 
map_result			pub fn map_result<T, U, F>(result: LockResult<T>, f: F)
matches_exit_status			    pub fn matches_exit_status(&self, wanted: int) -> bool 
max			    fn max(self, other: f32) -> f32 
max			    fn max(self, other: f64) -> f64 
max			    fn max(self, other: Self) -> Self;
max_10_exp			    fn max_10_exp(unused_self: Option<f32>) -> int { num::Float::max_10_exp(unused_self) }
max_10_exp			    fn max_10_exp(unused_self: Option<f64>) -> int { num::Float::max_10_exp(unused_self) }
max_10_exp			    fn max_10_exp(unused_self: Option<Self>) -> int;
max_exp			    fn max_exp(unused_self: Option<f32>) -> int { num::Float::max_exp(unused_self) }
max_exp			    fn max_exp(unused_self: Option<f64>) -> int { num::Float::max_exp(unused_self) }
max_exp			    fn max_exp(unused_self: Option<Self>) -> int;
max_value			    fn max_value() -> f32 { num::Float::max_value() }
max_value			    fn max_value() -> f64 { num::Float::max_value() }
max_value			    fn max_value() -> Self;
max_value			    pub fn max_value() -> Duration { MAX }
mem			mod mem;
memory_map_file			    fn memory_map_file() 
memory_map_rw			    fn memory_map_rw() 
microseconds			    pub fn microseconds(microseconds: i64) -> Duration 
milliseconds			    pub fn milliseconds(milliseconds: i64) -> Duration 
min			    fn min(self, other: f32) -> f32 
min			    fn min(self, other: f64) -> f64 
min			    fn min(self, other: Self) -> Self;
min_10_exp			    fn min_10_exp(unused_self: Option<f32>) -> int { num::Float::min_10_exp(unused_self) }
min_10_exp			    fn min_10_exp(unused_self: Option<f64>) -> int { num::Float::min_10_exp(unused_self) }
min_10_exp			    fn min_10_exp(unused_self: Option<Self>) -> int;
min_capacity			    fn min_capacity(&self, usable_size: uint) -> uint 
min_exp			    fn min_exp(unused_self: Option<f32>) -> int { num::Float::min_exp(unused_self) }
min_exp			    fn min_exp(unused_self: Option<f64>) -> int { num::Float::min_exp(unused_self) }
min_exp			    fn min_exp(unused_self: Option<Self>) -> int;
min_pos_value			    fn min_pos_value(unused_self: Option<f32>) -> f32 { num::Float::min_pos_value(unused_self) }
min_pos_value			    fn min_pos_value(unused_self: Option<f64>) -> f64 { num::Float::min_pos_value(unused_self) }
min_pos_value			    fn min_pos_value(unused_self: Option<Self>) -> Self;
min_stack			pub fn min_stack() -> uint 
min_stack_size			fn min_stack_size(_: *const libc::pthread_attr_t) -> libc::size_t 
min_stack_size			fn min_stack_size(attr: *const libc::pthread_attr_t) -> libc::size_t 
min_value			    fn min_value() -> f32 { num::Float::min_value() }
min_value			    fn min_value() -> f64 { num::Float::min_value() }
min_value			    fn min_value() -> Self;
min_value			    pub fn min_value() -> Duration { MIN }
minutes			    pub fn minutes(minutes: i64) -> Duration 
mkdir			pub fn mkdir(path: &Path, mode: FilePermission) -> IoResult<()> 
mkdir			pub fn mkdir(p: &Path, mode: uint) -> IoResult<()> 
mkdir			pub fn mkdir(p: &Path, _mode: uint) -> IoResult<()> 
mkdir_path_already_exists_error			    fn mkdir_path_already_exists_error() 
mkdir_recursive			pub fn mkdir_recursive(path: &Path, mode: FilePermission) -> IoResult<()> 
mkerr_libc			pub fn mkerr_libc<T: Int>(ret: T) -> IoResult<()> 
mkerr_winbool			fn mkerr_winbool(ret: libc::c_int) -> IoResult<()> 
mkstat			fn mkstat(stat: &libc::stat) -> FileStat 
mkstat			fn mkstat(stat: &libc::stat) -> FileStat 
mktime			    fn mktime(secs: u64, nsecs: u64) -> u64 { secs * 1000 + nsecs \/ 1000000 }
mod_floor_64			fn mod_floor_64(this: i64, other: i64) -> i64 
mode_string			fn mode_string(mode: FileMode) -> &'static str 
modf			        pub fn modf(n: c_double, iptr: &mut c_double) -> c_double;
modff			        pub fn modff(n: c_float, iptr: &mut c_float) -> c_float;
mpsc			pub mod mpsc;
mpsc_queue			mod mpsc_queue;
ms_to_timeval			pub fn ms_to_timeval(ms: u64) -> libc::timeval 
ms_to_timeval			pub fn ms_to_timeval(ms: u64) -> libc::timeval 
mul			    fn mul(self, rhs: i32) -> Duration 
mul_add			    fn mul_add(self, a: f32, b: f32) -> f32 { num::Float::mul_add(self, a, b) }
mul_add			    fn mul_add(self, a: f64, b: f64) -> f64 { num::Float::mul_add(self, a, b) }
mul_add			    fn mul_add(self, a: Self, b: Self) -> Self;
multicast_time_to_live			    pub fn multicast_time_to_live(&mut self, ttl: int) -> IoResult<()> 
multiple_connect_interleaved_greedy_schedule_ip4			    fn multiple_connect_interleaved_greedy_schedule_ip4() 
multiple_connect_interleaved_greedy_schedule_ip6			    fn multiple_connect_interleaved_greedy_schedule_ip6() 
multiple_connect_interleaved_lazy_schedule_ip4			    fn multiple_connect_interleaved_lazy_schedule_ip4() 
multiple_connect_interleaved_lazy_schedule_ip6			    fn multiple_connect_interleaved_lazy_schedule_ip6() 
multiple_connect_serial_ip4			    fn multiple_connect_serial_ip4() 
multiple_connect_serial_ip6			    fn multiple_connect_serial_ip6() 
mutex			mod mutex;
mutex			pub mod mutex;
mutex			pub mod mutex;
mutex			pub mod mutex;
naive_pow			        fn naive_pow<T: Int>(base: T, exp: uint) -> T 
name			    pub fn name(&self) -> Option<&str> 
name			    pub fn name(mut self, name: String) -> Builder 
nan			    fn nan() -> f32 { num::Float::nan() }
nan			    fn nan() -> f64 { num::Float::nan() }
nan			    fn nan() -> Self;
nanos_mod_sec			    fn nanos_mod_sec(&self) -> i32 
nanoseconds			    pub fn nanoseconds(nanos: i64) -> Duration 
neg			    fn neg(self) -> Duration 
neg_infinity			    fn neg_infinity() -> f32 { num::Float::neg_infinity() }
neg_infinity			    fn neg_infinity() -> f64 { num::Float::neg_infinity() }
neg_infinity			    fn neg_infinity() -> Self;
neg_zero			    fn neg_zero() -> f32 { num::Float::neg_zero() }
neg_zero			    fn neg_zero() -> f64 { num::Float::neg_zero() }
neg_zero			    fn neg_zero() -> Self;
net			pub mod net;
net			pub mod net;
new			        fn new(k: uint) -> Dropable 
new			    fn new() -> DefaultResizePolicy 
new			    pub fn new() -> HashMap<K, V, RandomSipHasher> 
new			    pub fn new() -> HashSet<T, RandomSipHasher> 
new			    pub fn new(capacity: uint) -> RawTable<K, V> 
new			    pub fn new(table: M, hash: SafeHash) -> Bucket<K, V, M> 
new			    pub fn new() -> RandomSipHasher 
new			    pub fn new(inner: R) -> BufferedReader<R> 
new			    pub fn new(inner: S) -> BufferedStream<S> 
new			    pub fn new(inner: W) -> BufferedWriter<W> 
new			    pub fn new(inner: W) -> LineBufferedWriter<W> 
new			    pub fn new(rx: Receiver<Vec<u8>>) -> ChanReader 
new			    pub fn new(tx: Sender<Vec<u8>>) -> ChanWriter 
new			    pub fn new(r: &'r mut R) -> Bytes<'r, R> 
new			    pub fn new() -> MemWriter 
new			    pub fn new(buf: &'a [u8]) -> BufReader<'a> 
new			    pub fn new(buf: &'a mut [u8]) -> BufWriter<'a> 
new			    pub fn new(buf: Vec<u8>) -> MemReader 
new			        fn new(r: T, behavior: Vec<BadReaderBehavior>) -> BadReader<T> 
new			    fn new(s: &'a str) -> Parser<'a> 
new			    fn new(s: TcpStreamImp) -> TcpStream 
new			    pub fn new<T: BytesContainer>(program: T) -> Command 
new			    pub fn new(prefix: &str) -> IoResult<TempDir> 
new			    pub fn new() -> IoResult<Timer> 
new			    pub fn new(iter: T) -> IterReader<T> 
new			    pub fn new(mut readers: I) -> ChainedReader<I, R> 
new			    pub fn new(r: R, limit: uint) -> LimitReader<R> 
new			    pub fn new(r: R, w: W) -> TeeReader<R, W> 
new			    pub fn new(writers: Vec<Box<Writer+'static>>) -> MultiWriter 
new			    pub fn new(min_len: uint, options: &[MapOption]) -> Result<MemoryMap, MapError> 
new			    fn new<T: BytesContainer>(path: T) -> Self 
new			    pub fn new<T: BytesContainer>(path: T) -> Path 
new			    pub fn new<T: BytesContainer>(path: T) -> Path 
new			    pub fn new() -> IoResult<StdRng> 
new			        pub fn new() -> IoResult<OsRng> 
new			    pub fn new(r: R) -> ReaderRng<R> 
new			    pub fn new(n: uint) -> Barrier 
new			    pub fn new() -> Condvar 
new			    fn new(inner: Arc<RacyCell<sync::Packet<T>>>) -> SyncSender<T> 
new			    fn new(inner: Flavor<T>) -> Receiver<T> 
new			    fn new(inner: Flavor<T>) -> Sender<T> 
new			    fn new(value: T) -> RacyCell<T> 
new			    pub fn new() -> Queue<T> 
new			    unsafe fn new(v: Option<T>) -> *mut Node<T> 
new			    pub fn new() -> Packet<T> 
new			    pub fn new() -> Select 
new			    pub fn new() -> Packet<T> 
new			    fn new() -> *mut Node<T> 
new			    pub unsafe fn new(bound: uint) -> Queue<T> 
new			    pub fn new() -> Packet<T> 
new			    pub fn new(cap: uint) -> Packet<T> 
new			    fn new(lock: &'mutex StaticMutex, data: &'mutex UnsafeCell<T>)
new			    pub fn new(t: T) -> Mutex<T> 
new			    fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)
new			    pub fn new(t: T) -> RwLock<T> 
new			    pub fn new(count: int) -> Semaphore 
new			    fn new(jobs: &Arc<Mutex<Receiver<Thunk>>>) -> Sentinel 
new			    pub fn new(threads: uint) -> TaskPool 
new			    pub unsafe fn new() -> Condvar { Condvar(imp::Condvar::new()) }
new			    pub unsafe fn new() -> Mutex { Mutex(imp::Mutex::new()) }
new			    fn new(fd: sock_t) -> Inner 
new			    pub fn new(fd: sock_t) -> TcpStream 
new			    pub unsafe fn new() -> RWLock { RWLock(imp::RWLock::new()) }
new			    fn new(name: Option<String>) -> Self;
new			    pub fn new(dtor: Option<unsafe extern fn(*mut u8)>) -> Key 
new			    pub unsafe fn new() -> Condvar 
new			    pub fn new(fd: fd_t, close_on_drop: bool) -> FileDesc 
new			pub fn new() -> (signal, signal) 
new			    pub unsafe fn new() -> Mutex 
new			    fn new(fd: fd_t) -> Inner 
new			    fn new(inner: Arc<Inner>) -> UnixStream 
new			    pub unsafe fn new() -> RWLock 
new			    pub unsafe fn new() -> Handler 
new			    pub fn new() -> IoResult<Timer> 
new			    pub fn new(fd: c_int) -> IoResult<TTY> 
new			    pub unsafe fn new() -> Condvar { CONDVAR_INIT }
new			    pub fn new(fd: fd_t, close_on_drop: bool) -> FileDesc 
new			pub fn new() -> (HANDLE, HANDLE) 
new			    pub unsafe fn new() -> Mutex 
new			    fn new(handle: libc::HANDLE) -> Inner 
new			    fn new(manual_reset: bool, initial_state: bool) -> IoResult<Event> 
new			    pub unsafe fn new() -> RWLock { RWLOCK_INIT }
new			    pub unsafe fn new() -> Handler 
new			    pub fn new() -> IoResult<Event> 
new			    pub fn new() -> IoResult<Timer> 
new			    pub fn new(fd: c_int) -> IoResult<TTY> 
new			    fn new(name: Option<String>) -> Thread { Thread::new(name) }
new			    fn new(name: Option<String>) -> Thread 
new			    pub fn new() -> Builder 
new			    pub fn new<F>(func: F) -> Thunk<(),R>
new_drop			fn new_drop(b : &mut Bencher) 
new_in			    pub fn new_in(tmpdir: &Path, prefix: &str) -> IoResult<TempDir> 
new_insert_drop			fn new_insert_drop(b : &mut Bencher) 
new_opt			    fn new_opt<T: BytesContainer>(path: T) -> Option<Self> 
new_opt			    pub fn new_opt<T: BytesContainer>(path: T) -> Option<Path> 
new_opt			    fn new_opt<T: BytesContainer>(path: T) -> Option<Path> 
new_opt			    pub fn new_opt<T: BytesContainer>(path: T) -> Option<Path> 
new_poison_error			pub fn new_poison_error<T>(guard: T) -> PoisonError<T> 
new_unchecked			    unsafe fn new_unchecked<T: BytesContainer>(path: T) -> Self;
new_unchecked			    unsafe fn new_unchecked<T: BytesContainer>(path: T) -> Path 
new_unchecked			    unsafe fn new_unchecked<T: BytesContainer>(path: T) -> Path 
new_uninitialized			    unsafe fn new_uninitialized(capacity: uint) -> RawTable<K, V> 
next			    fn next(&mut self) -> Option<(K, V)> 
next			    fn next(&mut self) -> Option<&'a K> { self.iter.next() }
next			    fn next(&mut self) -> Option<&'a T> { self.iter.next() }
next			    fn next(&mut self) -> Option<&'a T> 
next			    fn next(&mut self) -> Option<K> { self.iter.next() }
next			    fn next(&mut self) -> Option<(&'a K, &'a V)> 
next			    fn next(&mut self) -> Option<(&'a K, &'a mut V)> 
next			    fn next(&mut self) -> Option<(K, V)> 
next			    fn next(&mut self) -> Option<(SafeHash, K, V)> 
next			    fn next(&mut self) -> Option<RawBucket<K, V>> 
next			    pub fn next(&mut self) 
next			    pub fn next(self) -> Bucket<K, V, M> 
next			    fn next(&mut self) -> Option<IoResult<u8>> 
next			    fn next(&mut self) -> Option<Path> 
next			    fn next(&mut self) -> Option<IoResult<String>> 
next			    fn next(&mut self) -> Option<IoResult<T>> 
next			    fn next(&mut self) -> Option<IoResult<char>> 
next			    fn next(&mut self) -> Option<T> { self.rx.recv().ok() }
next			    fn next(&mut self) -> Option<*mut Handle<'static, ()>> 
next_after			    fn next_after(self, other: f32) -> f32 
next_after			    fn next_after(self, other: f64) -> f64 
next_after			    fn next_after(self, other: Self) -> Self;
next_test_ip4			pub fn next_test_ip4() -> SocketAddr 
next_test_ip6			pub fn next_test_ip6() -> SocketAddr 
next_test_port			pub fn next_test_port() -> u16 
next_test_unix			pub fn next_test_unix() -> Path 
next_u32			        fn next_u32(&mut self) -> u32 { self.i as u32 }
next_u32			    fn next_u32(&mut self) -> u32 
next_u32			        fn next_u32(&mut self) -> u32 
next_u32			    fn next_u32(&mut self) -> u32 
next_u64			        fn next_u64(&mut self) -> u64 { self.i }
next_u64			    fn next_u64(&mut self) -> u64 
next_u64			        fn next_u64(&mut self) -> u64 
next_u64			    fn next_u64(&mut self) -> u64 
nextafter			        pub fn nextafter(x: c_double, y: c_double) -> c_double;
nextafterf			        pub fn nextafterf(x: c_float, y: c_float) -> c_float;
no_runtime			    fn no_runtime() 
normal_fail			    fn normal_fail() 
normalize			    fn normalize<V: ?Sized + AsSlice<u8>>(v: &V) -> Vec<u8> 
normalize_			    fn normalize_(s: &str) -> (Option<PathPrefix>, String) 
normalize__			    fn normalize__(s: &str, prefix: Option<PathPrefix>) -> Option<String> 
normalize_helper			fn normalize_helper<'a>(v: &'a [u8], is_abs: bool) -> Option<Vec<&'a [u8]>> 
normalize_helper			fn normalize_helper<'a>(s: &'a str, prefix: Option<PathPrefix>) -> (bool, Option<Vec<&'a str>>) 
not			            fn not(self) -> 
notify_all			    fn notify_all() 
notify_all			    pub fn notify_all(&'static self) { unsafe { self.inner.notify_all() } }
notify_all			    pub fn notify_all(&self) { unsafe { self.inner.inner.notify_all() } }
notify_all			    pub unsafe fn notify_all(&self) { self.0.notify_all() }
notify_all			    pub unsafe fn notify_all(&self) 
notify_all			    pub unsafe fn notify_all(&self) 
notify_one			    fn notify_one() 
notify_one			    pub fn notify_one(&'static self) { unsafe { self.inner.notify_one() } }
notify_one			    pub fn notify_one(&self) { unsafe { self.inner.inner.notify_one() } }
notify_one			    pub unsafe fn notify_one(&self) { self.0.notify_one() }
notify_one			    pub unsafe fn notify_one(&self) 
notify_one			    pub unsafe fn notify_one(&self) 
now			pub fn now() -> u64 
now			pub fn now() -> u64 
ntohs			pub fn ntohs(u: u16) -> u16 
num			pub mod num;
num_cpus			pub fn num_cpus() -> uint 
num_days			    pub fn num_days(&self) -> i64 
num_hours			    pub fn num_hours(&self) -> i64 
num_microseconds			    pub fn num_microseconds(&self) -> Option<i64> 
num_milliseconds			    pub fn num_milliseconds(&self) -> i64 
num_minutes			    pub fn num_minutes(&self) -> i64 
num_nanoseconds			    pub fn num_nanoseconds(&self) -> Option<i64> 
num_seconds			    pub fn num_seconds(&self) -> i64 
num_weeks			    pub fn num_weeks(&self) -> i64 
objc_getClass			        fn objc_getClass(class_name: *const libc::c_uchar) -> NsId;
objc_msgSend			        fn objc_msgSend(obj: NsId, sel: Sel, ...) -> NsId;
offset			    unsafe fn offset(self, count: int) -> RawBucket<K, V> 
on_fail			pub fn on_fail(obj: &(Any+Send), file: &'static str, line: uint) 
once			mod once;
one			    fn one() -> f32 { num::Float::one() }
one			    fn one() -> f64 { num::Float::one() }
one			    fn one() -> Self;
oneshot			    fn oneshot() 
oneshot			    pub fn oneshot(&mut self, duration: Duration) -> Receiver<()> 
oneshot			mod oneshot;
oneshot			    pub fn oneshot(&mut self, msecs: u64, cb: Box<Callback + Send>) 
oneshot			    pub fn oneshot(&mut self, msecs: u64, cb: Box<Callback + Send>) 
oneshot_data_waiting			    fn oneshot_data_waiting() 
oneshot_fail			    fn oneshot_fail() 
oneshot_multi_task_recv_then_close			    fn oneshot_multi_task_recv_then_close() 
oneshot_multi_task_recv_then_send			    fn oneshot_multi_task_recv_then_send() 
oneshot_multi_thread_close_stress			    fn oneshot_multi_thread_close_stress() 
oneshot_multi_thread_recv_close_stress			    fn oneshot_multi_thread_recv_close_stress() 
oneshot_multi_thread_send_close_stress			    fn oneshot_multi_thread_send_close_stress() 
oneshot_multi_thread_send_recv_stress			    fn oneshot_multi_thread_send_recv_stress() 
oneshot_negative			    fn oneshot_negative() 
oneshot_single_thread_close_chan_first			    fn oneshot_single_thread_close_chan_first() 
oneshot_single_thread_close_port_first			    fn oneshot_single_thread_close_port_first() 
oneshot_single_thread_peek_close			    fn oneshot_single_thread_peek_close() 
oneshot_single_thread_peek_data			    fn oneshot_single_thread_peek_data() 
oneshot_single_thread_peek_open			    fn oneshot_single_thread_peek_open() 
oneshot_single_thread_recv_chan_close			    fn oneshot_single_thread_recv_chan_close() 
oneshot_single_thread_send_port_close			    fn oneshot_single_thread_send_port_close() 
oneshot_single_thread_send_then_recv			    fn oneshot_single_thread_send_then_recv() 
oneshot_single_thread_try_recv_closed			    fn oneshot_single_thread_try_recv_closed() 
oneshot_single_thread_try_recv_open			    fn oneshot_single_thread_try_recv_open() 
oneshot_single_thread_try_send_closed			    fn oneshot_single_thread_try_send_closed() 
oneshot_single_thread_try_send_closed2			    fn oneshot_single_thread_try_send_closed2() 
oneshot_single_thread_try_send_open			    fn oneshot_single_thread_try_send_open() 
oneshot_twice			    fn oneshot_twice() 
oneshot_zero			    fn oneshot_zero() 
open			    pub fn open(filename: Option<&Path>) -> Result<DynamicLibrary, String> 
open			    pub fn open(path: &Path) -> IoResult<File> 
open			    pub fn open(fd: libc::c_int) -> IoResult<PipeStream> 
open			pub fn open(path: &Path, fm: FileMode, fa: FileAccess) -> IoResult<FileDesc> 
open			pub fn open(path: &Path, fm: FileMode, fa: FileAccess) -> IoResult<FileDesc> 
open_external			    pub unsafe fn open_external(filename: &[u8]) -> *mut u8 
open_flavors			    fn open_flavors() 
open_internal			    pub unsafe fn open_internal() -> *mut u8 
open_mode			    pub fn open_mode(path: &Path,
os			pub mod os;
os			pub mod os;
os			pub mod os;
os			mod os 
os			pub mod os;
os_datasync			        fn os_datasync(fd: c_int) -> c_int 
os_precise_time_ns			    fn os_precise_time_ns() -> u64 
output			    pub fn output(&self) -> IoResult<ProcessOutput> 
output			fn output(w: &mut Writer, idx: int, addr: *mut libc::c_void,
page_size			pub fn page_size() -> uint 
page_size			pub fn page_size() -> uint 
page_size			pub fn page_size() -> uint 
pair			    pub fn pair() -> IoResult<PipePair> 
panicking			pub fn panicking() -> bool 
panicking			    pub fn panicking() -> bool 
park			    pub fn park() 
parse_and_resolve_socket_addr			fn parse_and_resolve_socket_addr(s: &str) -> IoResult<Vec<SocketAddr>> 
parse_digit			        fn parse_digit(c: char, radix: u8) -> Option<u8> 
parse_prefix			fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> 
parse_two_comps			    fn parse_two_comps(mut path: &str, f: fn(char) -> bool) -> Option<(uint, uint)> 
partial_cmp			    fn partial_cmp(&self, other: &Path) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &Path) -> Option<Ordering> 
partial_read			    fn partial_read() 
partial_read			    fn partial_read() 
path			        fn path<'a>(&'a self) -> &'a Path 
path			    pub fn path<'a>(&'a self) -> &'a Path 
path			    pub fn path<'a>(&'a self) -> &'a Path 
path			pub mod path;
path_exists			    fn path_exists() 
path_relative_from			    fn path_relative_from(&self, base: &Self) -> Option<Self>;
path_relative_from			    fn path_relative_from(&self, base: &Path) -> Option<Path> 
path_relative_from			    fn path_relative_from(&self, base: &Path) -> Option<Path> 
path_relative_from_backward			    fn path_relative_from_backward(b: &mut Bencher) 
path_relative_from_forward			    fn path_relative_from_forward(b: &mut Bencher) 
path_relative_from_same_level			    fn path_relative_from_same_level(b: &mut Bencher) 
peek			    pub fn peek(self) -> BucketState<K, V, M> 
peek			    fn peek() 
peek			    pub fn peek<'a>(&'a self) -> Option<&'a mut T> 
peer_name			    pub fn peer_name(&mut self) -> IoResult<SocketAddr> 
peer_name			    pub fn peer_name(addr: SocketAddr) 
peer_name			    pub fn peer_name(&mut self) -> IoResult<SocketAddr> 
period			    fn period() 
period			    pub fn period(&mut self, msecs: u64, cb: Box<Callback + Send>) 
period			    pub fn period(&mut self, msecs: u64, cb: Box<Callback + Send>) 
period_fail			    fn period_fail() 
periodic			    pub fn periodic(&mut self, duration: Duration) -> Receiver<()> 
periodic_negative			    fn periodic_negative() 
periodic_zero			    fn periodic_zero() 
pipe			pub mod pipe;
pipe			pub mod pipe;
pipe			pub unsafe fn pipe() -> IoResult<Pipe> 
pipe			pub mod pipe;
pipe			pub unsafe fn pipe() -> IoResult<(FileDesc, FileDesc)> 
pipe			pub mod pipe;
pipe			pub unsafe fn pipe() -> IoResult<(FileDesc, FileDesc)> 
pipe			unsafe fn pipe(name: *const u16, init: bool) -> libc::HANDLE 
poison			mod poison;
pop			    fn pop(&mut self) -> bool;
pop			    fn pop(&mut self) -> bool 
pop			    fn pop(&mut self) -> bool 
pop			    pub fn pop(&self) -> PopResult<T> 
pop			    pub fn pop(&self) -> Option<T> 
pop_internal			fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>) -> (K, V) 
port_gone_concurrent			    fn port_gone_concurrent() 
port_gone_concurrent_shared			    fn port_gone_concurrent_shared() 
posix			pub mod posix;
postinit_lock			    pub fn postinit_lock(&self) -> MutexGuard<()> 
powf			    fn powf(self, n: f32) -> f32 { num::Float::powf(self, n) }
powf			    fn powf(self, n: f64) -> f64 { num::Float::powf(self, n) }
powf			    fn powf(self, n: Self) -> Self;
powi			    fn powi(self, n: i32) -> f32 { num::Float::powi(self, n) }
powi			    fn powi(self, n: i32) -> f64 { num::Float::powi(self, n) }
powi			    fn powi(self, n: i32) -> Self;
precise_time_ns			fn precise_time_ns() -> u64 
prefix			pub fn prefix(path: &Path) -> Option<PathPrefix> 
prefix_is_verbatim			fn prefix_is_verbatim(p: Option<PathPrefix>) -> bool 
prefix_len			    fn prefix_len(&self) -> uint 
prefix_len			fn prefix_len(p: Option<PathPrefix>) -> uint 
preflight1			    fn preflight1() 
preflight2			    fn preflight2() 
preflight3			    fn preflight3() 
preflight4			    fn preflight4() 
preflight5			    fn preflight5() 
preflight6			    fn preflight6() 
preflight7			    fn preflight7() 
preflight8			    fn preflight8() 
preflight9			    fn preflight9() 
prelude			pub mod prelude;
prelude			pub mod prelude 
prelude			pub mod prelude 
prepend_search_path			    pub fn prepend_search_path(path: &Path) 
print			pub fn print(s: &str) 
print			fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> 
print_args			pub fn print_args(fmt: fmt::Arguments) 
println			pub fn println(s: &str) 
println_args			pub fn println_args(fmt: fmt::Arguments) 
process			pub mod process;
process			pub mod process;
process			pub mod process;
program			    fn program(&self) -> &CString 
program			    fn program(&self) -> &CString;
prune			    fn prune(root: &CString, dirs: Vec<Path>) -> Vec<Path> 
prune			    fn prune(root: &Path, dirs: Vec<Path>) -> Vec<Path> 
pthread_attr_destroy			    pub fn pthread_attr_destroy(attr: *mut libc::pthread_attr_t) -> libc::c_int;
pthread_attr_getguardsize			    pub fn pthread_attr_getguardsize(attr: *const libc::pthread_attr_t,
pthread_attr_getstack			    pub fn pthread_attr_getstack(attr: *const libc::pthread_attr_t,
pthread_attr_init			    fn pthread_attr_init(attr: *mut libc::pthread_attr_t) -> libc::c_int;
pthread_attr_setdetachstate			    fn pthread_attr_setdetachstate(attr: *mut libc::pthread_attr_t,
pthread_attr_setstacksize			    fn pthread_attr_setstacksize(attr: *mut libc::pthread_attr_t,
pthread_cond_broadcast			    pub fn pthread_cond_broadcast(cond: *mut pthread_cond_t) -> libc::c_int;
pthread_cond_destroy			    pub fn pthread_cond_destroy(cond: *mut pthread_cond_t) -> libc::c_int;
pthread_cond_signal			    pub fn pthread_cond_signal(cond: *mut pthread_cond_t) -> libc::c_int;
pthread_cond_t			    pub struct pthread_cond_t { value: libc::c_int }
pthread_cond_t			    pub struct pthread_cond_t 
pthread_cond_timedwait			    pub fn pthread_cond_timedwait(cond: *mut pthread_cond_t,
pthread_cond_wait			    pub fn pthread_cond_wait(cond: *mut pthread_cond_t,
pthread_create			    fn pthread_create(native: *mut libc::pthread_t,
pthread_detach			    fn pthread_detach(thread: libc::pthread_t) -> libc::c_int;
pthread_get_stackaddr_np			    pub fn pthread_get_stackaddr_np(thread: libc::pthread_t) -> *mut libc::c_void;
pthread_get_stacksize_np			    pub fn pthread_get_stacksize_np(thread: libc::pthread_t) -> libc::size_t;
pthread_getattr_np			    pub fn pthread_getattr_np(native: libc::pthread_t,
pthread_getspecific			    fn pthread_getspecific(key: pthread_key_t) -> *mut u8;
pthread_join			    fn pthread_join(native: libc::pthread_t,
pthread_key_create			    fn pthread_key_create(key: *mut pthread_key_t,
pthread_key_delete			    fn pthread_key_delete(key: pthread_key_t) -> c_int;
pthread_mutex_destroy			    pub fn pthread_mutex_destroy(lock: *mut pthread_mutex_t) -> libc::c_int;
pthread_mutex_lock			    pub fn pthread_mutex_lock(lock: *mut pthread_mutex_t) -> libc::c_int;
pthread_mutex_t			    pub struct pthread_mutex_t { value: libc::c_int }
pthread_mutex_t			    pub struct pthread_mutex_t 
pthread_mutex_trylock			    pub fn pthread_mutex_trylock(lock: *mut pthread_mutex_t) -> libc::c_int;
pthread_mutex_unlock			    pub fn pthread_mutex_unlock(lock: *mut pthread_mutex_t) -> libc::c_int;
pthread_rwlock_destroy			    pub fn pthread_rwlock_destroy(lock: *mut pthread_rwlock_t) -> libc::c_int;
pthread_rwlock_rdlock			    pub fn pthread_rwlock_rdlock(lock: *mut pthread_rwlock_t) -> libc::c_int;
pthread_rwlock_t			    pub struct pthread_rwlock_t 
pthread_rwlock_tryrdlock			    pub fn pthread_rwlock_tryrdlock(lock: *mut pthread_rwlock_t) -> libc::c_int;
pthread_rwlock_trywrlock			    pub fn pthread_rwlock_trywrlock(lock: *mut pthread_rwlock_t) -> libc::c_int;
pthread_rwlock_unlock			    pub fn pthread_rwlock_unlock(lock: *mut pthread_rwlock_t) -> libc::c_int;
pthread_rwlock_wrlock			    pub fn pthread_rwlock_wrlock(lock: *mut pthread_rwlock_t) -> libc::c_int;
pthread_self			    pub fn pthread_self() -> libc::pthread_t;
pthread_setspecific			    fn pthread_setspecific(key: pthread_key_t, value: *mut u8) -> c_int;
ptr			        unsafe fn ptr(&'static self) -> Option<*mut T> 
push			    fn push(&mut self, len: uint, buf: &mut Vec<u8>) -> IoResult<uint> 
push			    fn push<T: BytesContainer>(&mut self, path: T) 
push			pub fn push(f: Thunk) 
push			    pub fn push(&self, t: T) 
push			    pub fn push(&self, t: T) 
push_abs_path_home_dir			    fn push_abs_path_home_dir(b: &mut Bencher) 
push_at_least			    fn push_at_least() 
push_at_least			    fn push_at_least(&mut self, min: uint, len: uint, buf: &mut Vec<u8>) -> IoResult<uint> 
push_at_least			    fn push_at_least(&mut self, min: uint, len: uint, buf: &mut Vec<u8>) -> IoResult<uint> 
push_at_least_eof			    fn push_at_least_eof() 
push_at_least_error			    fn push_at_least_error() 
push_at_least_partial			    fn push_at_least_partial() 
push_home_dir			    fn push_home_dir(b: &mut Bencher) 
push_many			    fn push_many<T: BytesContainer>(&mut self, paths: &[T]) 
push_many_abs_path_home_dir			    fn push_many_abs_path_home_dir(b: &mut Bencher) 
push_many_home_dir			    fn push_many_home_dir(b: &mut Bencher) 
push_unchecked			    unsafe fn push_unchecked<T: BytesContainer>(&mut self, path: T);
push_unchecked			    unsafe fn push_unchecked<T: BytesContainer>(&mut self, path: T) 
push_unchecked			    unsafe fn push_unchecked<T: BytesContainer>(&mut self, path: T) 
put			    pub fn put(mut self, hash: SafeHash, key: K, value: V)
put			    pub fn put(_args: Vec<Vec<u8>>) 
put			    pub fn put(args: Vec<Vec<u8>>) 
put			pub fn put(args: Vec<Vec<u8>>) { imp::put(args) }
pwd_cmd			    pub fn pwd_cmd() -> Command 
raise			        pub fn raise(signum: libc::c_int) -> libc::c_int;
raise_fd_limit			    pub unsafe fn raise_fd_limit() 
raise_fd_limit			    pub unsafe fn raise_fd_limit() {}
raise_fd_limit			pub fn raise_fd_limit() 
rand			pub mod rand;
rand_isaac			    fn rand_isaac(b: &mut Bencher) 
rand_isaac64			    fn rand_isaac64(b: &mut Bencher) 
rand_shuffle_100			    fn rand_shuffle_100(b: &mut Bencher) 
rand_std			    fn rand_std(b: &mut Bencher) 
rand_xorshift			    fn rand_xorshift(b: &mut Bencher) 
random			pub fn random<T: Rand>() -> T 
raw			pub fn raw(mutex: &Mutex) -> &imp::Mutex { &mutex.0 }
raw			pub unsafe fn raw(m: &Mutex) -> *mut ffi::pthread_mutex_t 
raw			pub unsafe fn raw(m: &Mutex) -> ffi::LPCRITICAL_SECTION 
raw_buckets			    fn raw_buckets(&self) -> RawBuckets<K, V> 
read			    pub fn read(&self) -> (&K, &V) 
read			            fn read(&mut self, _: &mut [u8]) -> io::IoResult<uint> 
read			        fn read(&mut self, _: &mut [u8]) -> io::IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			        fn read(&mut self, _: &mut [u8]) -> io::IoResult<uint> 
read			        fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			        fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { (*self).read(buf) }
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { self.inner.read(buf) }
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint>;
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			        fn read(stream: Option<io::PipeStream>) -> Receiver<IoResult<Vec<u8>>> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    fn read(&mut self, _buf: &mut [u8]) -> io::IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> 
read			    pub fn read(&'static self) -> LockResult<RwLockReadGuard<'static, ()>> 
read			    pub fn read(&self) -> LockResult<RwLockReadGuard<T>> 
read			    pub fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			pub fn read<T, L, R>(fd: sock_t, deadline: u64, mut lock: L, mut read: R) -> IoResult<uint> where
read			    pub unsafe fn read(&self) { self.0.read() }
read			    pub fn read(&self, buf: &mut [u8]) -> IoResult<uint> 
read			    pub fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    pub unsafe fn read(&self) 
read			    pub fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    pub fn read(&self, buf: &mut [u8]) -> IoResult<uint> 
read			    pub fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    pub unsafe fn read(&self) 
read			    pub fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read_all			    pub fn read_all(input: &mut Reader) -> String 
read_at_least			    fn read_at_least(&mut self, min: uint, buf: &mut [u8]) -> IoResult<uint> 
read_at_least			    fn read_at_least(&mut self, min: uint, buf: &mut [u8]) -> IoResult<uint> 
read_atomically			    fn read_atomically<T, F>(&mut self, cb: F) -> Option<T> where
read_be_f32			    fn read_be_f32(&mut self) -> IoResult<f32> 
read_be_f64			    fn read_be_f64(&mut self) -> IoResult<f64> 
read_be_i16			    fn read_be_i16(&mut self) -> IoResult<i16> 
read_be_i32			    fn read_be_i32(&mut self) -> IoResult<i32> 
read_be_i64			    fn read_be_i64(&mut self) -> IoResult<i64> 
read_be_int			    fn read_be_int(&mut self) -> IoResult<int> 
read_be_int_n			    fn read_be_int_n(&mut self, nbytes: uint) -> IoResult<i64> 
read_be_u16			    fn read_be_u16(&mut self) -> IoResult<u16> 
read_be_u32			    fn read_be_u32(&mut self) -> IoResult<u32> 
read_be_u64			    fn read_be_u64(&mut self) -> IoResult<u64> 
read_be_uint			    fn read_be_uint(&mut self) -> IoResult<uint> 
read_be_uint_n			    fn read_be_uint_n(&mut self, nbytes: uint) -> IoResult<u64> 
read_be_uint_n			    fn read_be_uint_n(&mut self, nbytes: uint) -> IoResult<u64> 
read_byte			    fn read_byte() 
read_byte			    fn read_byte(&mut self) -> IoResult<u8> 
read_byte_0_bytes			    fn read_byte_0_bytes() 
read_byte_eof			    fn read_byte_eof() 
read_byte_error			    fn read_byte_error() 
read_bytes			    fn read_bytes() 
read_bytes_eof			    fn read_bytes_eof() 
read_bytes_partial			    fn read_bytes_partial() 
read_char			    fn read_char(&mut self) -> IoResult<char> 
read_char			    fn read_char(&mut self) -> Option<char> 
read_char			    pub fn read_char(&mut self) -> IoResult<char> 
read_char_buffered			    fn read_char_buffered() 
read_closed			    fn read_closed(&self) -> bool 
read_digit			    fn read_digit(&mut self, radix: u8) -> Option<u8> 
read_eof			    fn read_eof() 
read_eof_ip4			    fn read_eof_ip4() 
read_eof_ip6			    fn read_eof_ip6() 
read_eof_twice_ip4			    fn read_eof_twice_ip4() 
read_eof_twice_ip6			    fn read_eof_twice_ip6() 
read_exact			    fn read_exact(&mut self, len: uint) -> IoResult<Vec<u8>> 
read_given_char			    fn read_given_char(&mut self, c: char) -> Option<char> 
read_groups			        fn read_groups(p: &mut Parser, groups: &mut [u16; 8], limit: uint) -> (uint, bool) 
read_i8			    fn read_i8(&mut self) -> IoResult<i8> 
read_ip_addr			    fn read_ip_addr(&mut self) -> Option<IpAddr> 
read_ipv4_addr			    fn read_ipv4_addr(&mut self) -> Option<IpAddr> 
read_ipv4_addr_impl			    fn read_ipv4_addr_impl(&mut self) -> Option<IpAddr> 
read_ipv6_addr			    fn read_ipv6_addr(&mut self) -> Option<IpAddr> 
read_ipv6_addr_impl			    fn read_ipv6_addr_impl(&mut self) -> Option<IpAddr> 
read_le_f32			    fn read_le_f32(&mut self) -> IoResult<f32> 
read_le_f64			    fn read_le_f64(&mut self) -> IoResult<f64> 
read_le_i16			    fn read_le_i16(&mut self) -> IoResult<i16> 
read_le_i32			    fn read_le_i32(&mut self) -> IoResult<i32> 
read_le_i64			    fn read_le_i64(&mut self) -> IoResult<i64> 
read_le_int			    fn read_le_int(&mut self) -> IoResult<int> 
read_le_int_n			    fn read_le_int_n(&mut self, nbytes: uint) -> IoResult<i64> 
read_le_u16			    fn read_le_u16(&mut self) -> IoResult<u16> 
read_le_u32			    fn read_le_u32(&mut self) -> IoResult<u32> 
read_le_u64			    fn read_le_u64(&mut self) -> IoResult<u64> 
read_le_uint			    fn read_le_uint(&mut self) -> IoResult<uint> 
read_le_uint_n			    fn read_le_uint_n(&mut self, nbytes: uint) -> IoResult<u64> 
read_le_uint_n			    fn read_le_uint_n(&mut self, nbytes: uint) -> IoResult<u64> 
read_line			    fn read_line(&mut self) -> IoResult<String> 
read_line			    pub fn read_line(&mut self) -> IoResult<String> 
read_mut			    pub fn read_mut(&mut self) -> (&mut K, &mut V) 
read_number			    fn read_number(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> 
read_number_impl			    fn read_number_impl(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> 
read_or			    fn read_or<T>(&mut self, parsers: &mut [Box<FnMut(&mut Parser) -> Option<T>>])
read_seq_3			    fn read_seq_3<A, B, C, PA, PB, PC>(&mut self,
read_socket_addr			    fn read_socket_addr(&mut self) -> Option<SocketAddr> 
read_till_eof			    fn read_till_eof<T, F>(&mut self, cb: F) -> Option<T> where
read_timeouts			    fn read_timeouts() 
read_timeouts			    fn read_timeouts() 
read_to_end			    fn read_to_end() 
read_to_end			    fn read_to_end(&mut self) -> IoResult<Vec<u8>> 
read_to_end			    fn read_to_end(&mut self) -> IoResult<Vec<u8>> 
read_to_end_error			    fn read_to_end_error() 
read_to_string			    fn read_to_string(&mut self) -> IoResult<String> 
read_u8			    fn read_u8(&mut self) -> IoResult<u8> 
read_unlock			    pub unsafe fn read_unlock(&self) { self.0.read_unlock() }
read_unlock			    pub unsafe fn read_unlock(&self) 
read_unlock			    pub unsafe fn read_unlock(&self) 
read_until			    fn read_until(&mut self, byte: u8) -> IoResult<Vec<u8>> 
read_until			    pub fn read_until(&mut self, byte: u8) -> IoResult<Vec<u8>> 
readdir			pub fn readdir(path: &Path) -> IoResult<Vec<Path>> 
readdir			pub fn readdir(p: &Path) -> IoResult<Vec<Path>> 
readdir			pub fn readdir(p: &Path) -> IoResult<Vec<Path>> 
reader			pub mod reader;
readlink			pub fn readlink(path: &Path) -> IoResult<Path> 
readlink			pub fn readlink(p: &Path) -> IoResult<Path> 
readlink			pub fn readlink(p: &Path) -> IoResult<Path> 
readlink_not_symlink			    fn readlink_not_symlink() 
readwrite_timeouts			    fn readwrite_timeouts() 
readwrite_timeouts			    fn readwrite_timeouts() 
real_args			fn real_args() -> Vec<String> 
real_args_as_bytes			fn real_args_as_bytes() -> Vec<Vec<u8>> 
receiver_goes_away_oneshot			    fn receiver_goes_away_oneshot() 
receiver_goes_away_period			    fn receiver_goes_away_period() 
recip			    fn recip(self) -> f32 { num::Float::recip(self) }
recip			    fn recip(self) -> f64 { num::Float::recip(self) }
recip			    fn recip(self) -> Self;
record_os_managed_stack_bounds			pub unsafe fn record_os_managed_stack_bounds(stack_lo: uint, _stack_hi: uint) 
record_rust_managed_stack_bounds			pub unsafe fn record_rust_managed_stack_bounds(stack_lo: uint, stack_hi: uint) 
record_sp_limit			            fn record_sp_limit(limit: *const c_void);
record_sp_limit			pub unsafe fn record_sp_limit(limit: uint) 
recursive_mkdir			    fn recursive_mkdir() 
recursive_mkdir_failure			    fn recursive_mkdir_failure() 
recursive_mkdir_slash			    fn recursive_mkdir_slash() 
recursive_rmdir			    fn recursive_rmdir() 
recv			            fn recv(rx: Receiver<Box<int>>, i: int) 
recv			    pub fn recv(&self) -> Result<T, RecvError> 
recv			    pub fn recv(&mut self) -> Result<T, Failure<T>> 
recv			    pub fn recv(&mut self) -> Result<T, RecvError> { self.rx.recv() }
recv			    pub fn recv(&mut self) -> Result<T, Failure> 
recv			    pub fn recv(&mut self) -> Result<T, Failure<T>> 
recv			    pub fn recv(&self) -> Result<T, ()> 
recv_a_lot			    fn recv_a_lot() 
recv_from			    pub fn recv_from(&mut self, buf: &mut [u8]) -> IoResult<(uint, SocketAddr)> 
recv_from			    pub fn recv_from(&mut self, buf: &mut [u8]) -> IoResult<(uint, SocketAddr)> 
recv_from_outside_runtime			    fn recv_from_outside_runtime() 
recv_from_timeout			    fn recv_from_timeout() 
refcell_vec			    fn refcell_vec() 
register			pub unsafe fn register(f: Callback) -> bool 
register_dtor			unsafe fn register_dtor(key: Key, dtor: Dtor) 
register_dtor			        unsafe fn register_dtor(&self) 
register_dtor			    unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) 
register_sigchld			        fn register_sigchld() -> (libc::c_int, c::sigaction) 
release			    pub fn release(&self) 
remove			            pub fn remove(&mut self, other: 
remove			    pub fn remove(self) -> V 
remove			    pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>
remove			    pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool
remove			    pub unsafe fn remove(&mut self) 
remove			    fn remove(&mut self) 
rename			pub fn rename(from: &Path, to: &Path) -> IoResult<()> 
rename			pub fn rename(old: &Path, new: &Path) -> IoResult<()> 
rename			pub fn rename(old: &Path, new: &Path) -> IoResult<()> 
replace			    pub fn replace(&mut self, h: SafeHash, k: K, v: V) -> (SafeHash, K, V) 
replace_path			        fn replace_path(me: &mut Path, path: &str, prefix: Option<PathPrefix>) 
report_overflow			pub unsafe fn report_overflow() 
repro			        fn repro() 
reseed			    fn reseed(&mut self, rng: &mut StdRng) 
reseed			    fn reseed(&mut self, seed: &'a [uint]) 
reseeding::Reseeder for ThreadRngReseeder			impl reseeding::Reseeder<StdRng> for ThreadRngReseeder 
reserve			    pub fn reserve(&mut self, additional: uint) 
reserve			    pub fn reserve(&mut self, additional: uint) 
reset_doesnt_switch_tasks			    fn reset_doesnt_switch_tasks() 
reset_doesnt_switch_tasks2			    fn reset_doesnt_switch_tasks2() 
resize			    fn resize(&mut self, new_capacity: uint) 
resolve_socket_addr			fn resolve_socket_addr(s: &str, p: u16) -> IoResult<Vec<SocketAddr>> 
result			mod result;
retry			pub fn retry<T, F> (mut f: F) -> T where
retry			pub fn retry<I, F>(f: F) -> I where F: FnOnce() -> I { f() } \/\/ PR rust-lang\/rust\/#17020
rev_move_buckets			    unsafe fn rev_move_buckets(&mut self) -> RevMoveBuckets<K, V> 
rlimit			    struct rlimit 
rmdir			pub fn rmdir(path: &Path) -> IoResult<()> 
rmdir			pub fn rmdir(p: &Path) -> IoResult<()> 
rmdir			pub fn rmdir(p: &Path) -> IoResult<()> 
rmdir_failed			    fn rmdir_failed(err: &IoError, path: &Path) -> String 
rmdir_recursive			pub fn rmdir_recursive(path: &Path) -> IoResult<()> 
robin_hood			fn robin_hood<'a, K: 'a, V: 'a>(mut bucket: FullBucketMut<'a, K, V>,
root_path			    fn root_path(&self) -> Option<Self>;
root_path			    fn root_path(&self) -> Option<Path> 
root_path			    fn root_path(&self) -> Option<Path> 
round			    fn round(self) -> f32 { num::Float::round(self) }
round			    fn round(self) -> f64 { num::Float::round(self) }
round			    fn round(self) -> Self;
round_up			fn round_up(from: uint, to: uint) -> uint 
round_up_to_next			fn round_up_to_next(unrounded: uint, target_alignment: uint) -> uint 
rsqrt		qrt(self) }
rsqrt		qrt(self) }
rsqrt			    fn rsqrt(self) -> Self;
rt			pub mod rt;
rtdeps			mod rtdeps;
run_dtors			unsafe fn run_dtors() 
run_output			    pub fn run_output(cmd: Command) -> String 
running_on_valgrind			pub fn running_on_valgrind() -> bool 
rust_begin_unwind			pub extern fn rust_begin_unwind(msg: fmt::Arguments,
rust_dirent_t_size			        fn rust_dirent_t_size() -> libc::c_int;
rust_eh_personality			    extern "C" fn rust_eh_personality(
rust_eh_personality			    extern fn rust_eh_personality(
rust_eh_personality			    pub extern "C" fn rust_eh_personality(
rust_eh_personality_catch			    pub extern "C" fn rust_eh_personality_catch(
rust_env_pairs			        fn rust_env_pairs() -> *const *const c_char;
rust_exception_class			fn rust_exception_class() -> uw::_Unwind_Exception_Class 
rust_get_num_cpus			        fn rust_get_num_cpus() -> libc::uintptr_t;
rust_list_dir_val			        fn rust_list_dir_val(ptr: *mut dirent_t) -> *const libc::c_char;
rust_panic			fn rust_panic(cause: Box<Any + Send>) -> ! 
rust_running_on_valgrind			        fn rust_running_on_valgrind() -> uintptr_t;
rust_try			        fn rust_try(f: extern fn(*mut c_void),
rust_unset_sigprocmask			                pub fn rust_unset_sigprocmask();
rustrt			        mod rustrt 
rwlock			mod rwlock;
rwlock			pub mod rwlock;
rwlock			pub mod rwlock;
rwlock			pub mod rwlock;
sample			pub fn sample<T, I: Iterator<Item=T>, R: Rng>(rng: &mut R,
sched_yield			    fn sched_yield() -> libc::c_int;
scope_item_allowed			    fn scope_item_allowed() 
scoped			    pub fn scoped<'a, T, F>(f: F) -> JoinGuard<'a, T> where
scoped			    pub fn scoped<'a, T, F>(self, f: F) -> JoinGuard<'a, T> where
scoped			pub mod scoped;
search			    fn search<'a, Q: ?Sized>(&'a self, q: &Q) -> Option<FullBucketImm<'a, K, V>>
search_entry_hashed			fn search_entry_hashed<'a, K: Eq, V>(table: &'a mut RawTable<K,V>, hash: SafeHash, k: K)
search_hashed			fn search_hashed<K, V, M, F>(table: M,
search_mut			    fn search_mut<'a, Q: ?Sized>(&'a mut self, q: &Q) -> Option<FullBucketMut<'a, K, V>>
search_path			    pub fn search_path() -> Vec<Path> 
second			        fn second<A, B>((_, b): (A, B)) -> B { b }
seconds			    pub fn seconds(seconds: i64) -> Duration 
seek			    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> 
seek			    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> 
seek			    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()>;
seek			    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> 
seek			    pub fn seek(&self, pos: i64, whence: SeekStyle) -> IoResult<u64> 
seek			    pub fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<u64> 
seek_before_0			    fn seek_before_0() 
seek_common			    fn seek_common(&self, pos: i64, style: SeekStyle) -> IoResult<u64> 
seek_past_end			    fn seek_past_end() 
sel_registerName			        fn sel_registerName(name: *const libc::c_uchar) -> Sel;
select			mod select;
select			    pub fn select(nfds: libc::c_int,
select			mod select 
select			    pub fn select(nfds: libc::c_int,
select::Packet for Receiver			impl<T: Send> select::Packet for Receiver<T> 
self_exe_name			pub fn self_exe_name() -> Option<Path> 
self_exe_path			pub fn self_exe_path() -> Option<Path> 
self_referential			    fn self_referential() 
semaphore			mod semaphore;
send			            fn send(tx: Sender<Box<int>>, i: int) 
send			            fn send(tx: SyncSender<Box<int>>, i: int) 
send			    pub fn send(&self, t: T) -> Result<(), SendError<T>> 
send			    pub fn send(&mut self, t: T) -> Result<(), T> 
send			    pub fn send(&mut self, t: T) -> Result<(), T> 
send			    pub fn send(&mut self, t: T) -> Result<(), T> 
send			    pub fn send(&self, t: T) -> Result<(), T> 
send			    pub fn send(&'static self, msg: M) 
send1			    fn send1() 
send2			    fn send2() 
send3			    fn send3() 
send4			    fn send4() 
send_from_outside_runtime			    fn send_from_outside_runtime() 
send_to			    pub fn send_to<A: ToSocketAddr>(&mut self, buf: &[u8], addr: A) -> IoResult<()> 
send_to			    pub fn send_to(&mut self, buf: &[u8], dst: SocketAddr) -> IoResult<()> 
send_to_timeout			    fn send_to_timeout() 
sender_goes_away_oneshot			    fn sender_goes_away_oneshot() 
sender_goes_away_period			    fn sender_goes_away_period() 
sent			    pub fn sent(&self) -> bool 
separator			    fn separator() -> u8 
sepidx_or_prefix_len			    fn sepidx_or_prefix_len(&self) -> Option<(uint,uint,uint)> 
set			pub mod set;
set			pub fn set(stack_bounds: (uint, uint), stack_guard: uint, thread: Thread) 
set			    pub fn set(&self, val: *mut u8) 
set			    pub unsafe fn set(&self, val: *mut u8) { imp::set(self.key(), val) }
set			pub unsafe fn set(key: Key, value: *mut u8) 
set			pub unsafe fn set(key: Key, value: *mut u8) 
set			        pub unsafe fn set(&self, ptr: *mut T) { *self.inner.get() = ptr; }
set			        pub unsafe fn set(&self, ptr: *mut T) { self.inner.set(ptr as *mut _) }
set			    pub fn set<R, F>(&'static self, t: &T, cb: F) -> R where
set_broadcast			    pub fn set_broadcast(&mut self, broadcast: bool) -> IoResult<()> 
set_broadcast			    pub fn set_broadcast(&mut self, on: bool) -> IoResult<()> 
set_cloexec			        unsafe fn set_cloexec(fd: c_int) 
set_cwd_works			    fn set_cwd_works() 
set_environ			        unsafe fn set_environ(envp: *const c_void) 
set_exit_status			pub fn set_exit_status(code: int) 
set_extension			    fn set_extension<T: BytesContainer>(&mut self, extension: T) 
set_filename			    fn set_filename<T: BytesContainer>(&mut self, filename: T) 
set_filename_unchecked			    unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T);
set_filename_unchecked			    unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T) 
set_filename_unchecked			    unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T) 
set_keepalive			    pub fn set_keepalive(&mut self, delay_in_seconds: Option<uint>) -> IoResult<()> 
set_keepalive			    pub fn set_keepalive(&mut self, seconds: Option<uint>) -> IoResult<()> 
set_membership			    pub fn set_membership(&mut self, addr: IpAddr, opt: libc::c_int) -> IoResult<()> 
set_multicast_loop			    pub fn set_multicast_loop(&mut self, on: bool) -> IoResult<()> 
set_multicast_loop			    pub fn set_multicast_loop(&mut self, on: bool) -> IoResult<()> 
set_multicast_ttl			    pub fn set_multicast_ttl(&mut self, ttl: int) -> IoResult<()> 
set_nodelay			    pub fn set_nodelay(&mut self, nodelay: bool) -> IoResult<()> 
set_nodelay			    pub fn set_nodelay(&mut self, nodelay: bool) -> IoResult<()> 
set_nonblocking			pub fn set_nonblocking(fd: sock_t, nb: bool) -> IoResult<()> 
set_nonblocking			pub fn set_nonblocking(fd: sock_t, nb: bool) -> IoResult<()> 
set_raw			    pub fn set_raw(&mut self, raw: bool) -> IoResult<()> 
set_raw			    pub fn set_raw(&mut self, _raw: bool) -> IoResult<()> 
set_raw			    pub fn set_raw(&mut self, raw: bool) -> IoResult<()> 
set_read_timeout			    pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) 
set_read_timeout			    pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) 
set_read_timeout			    pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) 
set_read_timeout			    pub fn set_read_timeout(&mut self, timeout: Option<u64>) 
set_read_timeout			    pub fn set_read_timeout(&mut self, timeout: Option<u64>) 
set_read_timeout			    pub fn set_read_timeout(&mut self, timeout: Option<u64>) 
set_stderr			pub fn set_stderr(stderr: Box<Writer + Send>) -> Option<Box<Writer + Send>> 
set_stdout			pub fn set_stdout(stdout: Box<Writer + Send>) -> Option<Box<Writer + Send>> 
set_tcp_keepalive			    fn set_tcp_keepalive(&mut self, _seconds: uint) -> IoResult<()> 
set_tcp_keepalive			    fn set_tcp_keepalive(&mut self, seconds: uint) -> IoResult<()> 
set_timeout			    pub fn set_timeout(&mut self, timeout_ms: Option<u64>) 
set_timeout			    pub fn set_timeout(&mut self, ms: Option<u64>) { self.inner.set_timeout(ms); }
set_timeout			    pub fn set_timeout(&mut self, timeout_ms: Option<u64>) 
set_timeout			    pub fn set_timeout(&mut self, timeout_ms: Option<u64>) 
set_timeout			    pub fn set_timeout(&mut self, timeout_ms: Option<u64>) 
set_timeout			    pub fn set_timeout(&mut self, timeout: Option<u64>) 
set_timeout			    pub fn set_timeout(&mut self, timeout: Option<u64>) 
set_timeout			    pub fn set_timeout(&mut self, timeout: Option<u64>) 
set_timeout			    pub fn set_timeout(&mut self, timeout: Option<u64>) 
set_timeout			    pub fn set_timeout(&mut self, timeout: Option<u64>) 
set_ttl			    pub fn set_ttl(&mut self, ttl: int) -> IoResult<()> 
set_write_timeout			    pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) 
set_write_timeout			    pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) 
set_write_timeout			    pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) 
set_write_timeout			    pub fn set_write_timeout(&mut self, timeout: Option<u64>) 
set_write_timeout			    pub fn set_write_timeout(&mut self, timeout: Option<u64>) 
set_write_timeout			    pub fn set_write_timeout(&mut self, timeout: Option<u64>) 
setenv			pub fn setenv<T: BytesContainer>(n: &str, v: T) 
setgroups			                            fn setgroups(ngroups: libc::c_int,
setrlimit			        fn setrlimit(resource: libc::c_int, rlp: *const rlimit) -> libc::c_int;
setsockopt			pub fn setsockopt<T>(fd: sock_t, opt: libc::c_int, val: libc::c_int,
setup_io			fn setup_io(io: StdioContainer) -> IoResult<(Option<PipeStream>, Option<PipeStream>)> 
shared			mod shared;
shared_chan_stress			    fn shared_chan_stress() 
shared_data_waiting			    fn shared_data_waiting() 
shares_volume			        fn shares_volume(me: &Path, path: &str) -> bool 
shift			    pub fn shift(mut self) -> Option<GapThenFull<K, V, M>> 
short_write			pub fn short_write(n: uint, desc: &'static str) -> IoError 
shrink_to_fit			    pub fn shrink_to_fit(&mut self) 
shrink_to_fit			    pub fn shrink_to_fit(&mut self) 
shutdown			    fn shutdown(&'static self) 
shutdown_smoke			    fn shutdown_smoke() 
sigaction			    pub fn sigaction(signum: libc::c_int,
sigaction			    pub struct sigaction 
sigaction			        pub fn sigaction(signum: libc::c_int,
sigaction			        pub struct sigaction 
sigaddset			    pub fn sigaddset(set: *mut sigset_t, signum: libc::c_int) -> libc::c_int;
sigaltstack			        pub fn sigaltstack(ss: *const sigaltstack,
sigaltstack			        pub struct sigaltstack 
sigchld_handler			        extern fn sigchld_handler(_signum: libc::c_int) 
sigdelset			    pub fn sigdelset(set: *mut sigset_t, signum: libc::c_int) -> libc::c_int;
sigemptyset			    pub fn sigemptyset(set: *mut sigset_t) -> libc::c_int;
siginfo			    pub struct siginfo 
siginfo			        pub struct siginfo 
signal			    pub fn signal(&mut self, signal: int) -> IoResult<()> 
signal			    pub fn signal(&self) -> bool 
signal			mod signal 
signal			pub fn signal(fd: libc::c_int) 
signal			        pub fn signal(signum: libc::c_int, handler: sighandler_t) -> sighandler_t;
signal			    mod signal 
signal			    fn signal(active: &mut Vec<Box<Inner>>,
signal			pub fn signal(handle: HANDLE) 
signal_exit			    pub fn signal_exit(&mut self) -> IoResult<()> 
signal_kill			    pub fn signal_kill(&mut self) -> IoResult<()> 
signal_reported_right			    fn signal_reported_right() 
signum			    fn signum(self) -> f32 { num::Float::signum(self) }
signum			    fn signum(self) -> f64 { num::Float::signum(self) }
signum			    fn signum(self) -> Self;
sigset_t			    pub struct sigset_t 
sigset_t			        pub struct sigset_t 
simple			    fn simple() 
sin			    fn sin(self) -> f32 
sin			    fn sin(self) -> f64 
sin			    fn sin(self) -> Self;
sin_cos			    fn sin_cos(self) -> (f32, f32) 
sin_cos			    fn sin_cos(self) -> (f64, f64) 
sin_cos			    fn sin_cos(self) -> (Self, Self);
sinh			    fn sinh(self) -> f32 
sinh			        pub fn sinh(n: c_double) -> c_double;
sinh			    fn sinh(self) -> f64 
sinh			    fn sinh(self) -> Self;
sinhf			        pub fn sinhf(n: c_float) -> c_float;
size			    pub fn size(&self) -> uint 
size			    fn size(&self) -> uint { self.size }
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
size_hint			    fn size_hint(&self) -> (uint, Option<uint>) 
sleep			    fn sleep() 
sleep			    pub fn sleep(&mut self, duration: Duration) 
sleep			pub fn sleep(duration: Duration) 
sleep			    pub fn sleep(&mut self, ms: u64) 
sleep			    pub fn sleep(&mut self, msecs: u64) 
sleep_negative			    fn sleep_negative() 
sleep_zero			    fn sleep_zero() 
sleeper			    pub fn sleeper() -> Process 
slice_vec_capacity			unsafe fn slice_vec_capacity<'a, T>(v: &'a mut Vec<T>, start: uint, end: uint) -> &'a mut [T] 
smalltest			    pub fn smalltest<F,G>(server: F, client: G)
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke2			    fn smoke2() 
smoke_bound			    fn smoke_bound() 
smoke_chan_gone			    fn smoke_chan_gone() 
smoke_chan_gone_shared			    fn smoke_chan_gone_shared() 
smoke_dtor			    fn smoke_dtor() 
smoke_failure			    fn smoke_failure() 
smoke_no_dtor			    fn smoke_no_dtor() 
smoke_once			    fn smoke_once() 
smoke_port_gone			    fn smoke_port_gone() 
smoke_shared			    fn smoke_shared() 
smoke_shared_port_gone			    fn smoke_shared_port_gone() 
smoke_shared_port_gone2			    fn smoke_shared_port_gone2() 
smoke_static			    fn smoke_static() 
smoke_test			        fn smoke_test() 
smoke_test_ip4			    fn smoke_test_ip4() 
smoke_test_ip6			    fn smoke_test_ip6() 
smoke_threads			    fn smoke_threads() 
sockaddr_to_addr			pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,
socket			pub fn socket(addr: SocketAddr, ty: libc::c_int) -> IoResult<sock_t> 
socket			    pub fn socket(&self) -> sock_t { self.inner.listener.socket() }
socket			    pub fn socket(&self) -> sock_t { self.sock }
socket_and_peer_name_ip4			    fn socket_and_peer_name_ip4() 
socket_and_peer_name_ip6			    fn socket_and_peer_name_ip6() 
socket_name			    pub fn socket_name(&mut self) -> IoResult<SocketAddr> 
socket_name			    pub fn socket_name(addr: SocketAddr) 
socket_name			    pub fn socket_name(&mut self) -> IoResult<SocketAddr> 
socket_name			    pub fn socket_name(addr: SocketAddr) 
socket_name			    pub fn socket_name(&mut self) -> IoResult<SocketAddr> 
socket_name			    pub fn socket_name(&mut self) -> IoResult<ip::SocketAddr> 
socket_name			    pub fn socket_name(&mut self) -> IoResult<ip::SocketAddr> 
socket_name_ip4			    fn socket_name_ip4() 
socket_name_ip6			    fn socket_name_ip6() 
socket_smoke_test_ip4			    fn socket_smoke_test_ip4() 
socket_smoke_test_ip6			    fn socket_smoke_test_ip6() 
sockname			pub fn sockname(fd: sock_t,
span			    pub fn span<F>(f: F) -> Duration where F: FnOnce() 
spawn			    pub fn spawn(&self) -> IoResult<Process> 
spawn			    pub fn spawn<F>(blk: F) -> Future<A>
spawn			    pub fn spawn<K, V, C, P>(cfg: &C, in_fd: Option<P>,
spawn			    pub fn spawn<K, V, C, P>(cfg: &C, in_fd: Option<P>,
spawn			    pub fn spawn<F>(f: F) -> Thread where F: FnOnce(), F: Send + 'static 
spawn			    pub fn spawn<F>(self, f: F) -> Thread where F: FnOnce(), F: Send + 'static 
spawn_in_pool			fn spawn_in_pool(jobs: Arc<Mutex<Receiver<Thunk>>>) 
spawn_inner			    fn spawn_inner<T: Send>(self, f: Thunk<(), T>, finish: Thunk<Result<T>, ()>)
split_paths			pub fn split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> 
split_paths			pub fn split_paths(unparsed: &[u8]) -> Vec<Path> 
split_paths			pub fn split_paths(unparsed: &[u8]) -> Vec<Path> 
split_paths_unix			    fn split_paths_unix() 
split_paths_windows			    fn split_paths_windows() 
spsc_queue			mod spsc_queue;
sqrt			    fn sqrt(self) -> f32 { num::Float::sqrt(self) }
sqrt			    fn sqrt(self) -> f64 { num::Float::sqrt(self) }
sqrt			    fn sqrt(self) -> Self;
square			        fn square(i: int) -> int { i * i }
src			fn src<T, F>(fd: libc::c_int, _readable: bool, f: F) -> T where
stack			pub mod stack;
stack_exhausted			extern fn stack_exhausted() 
stack_guard			pub fn stack_guard() -> uint 
stack_overflow			pub mod stack_overflow;
stack_overflow			pub mod stack_overflow;
stack_size			    pub fn stack_size(mut self, size: uint) -> Builder 
stampede_once			    fn stampede_once() 
standard_error			pub fn standard_error(kind: IoErrorKind) -> IoError 
start_selection			    fn start_selection(&self, mut token: SignalToken) -> StartResult 
start_selection			    pub fn start_selection(&mut self, token: SignalToken) -> SelectionResult<T> 
start_selection			    fn start_selection(&self, token: SignalToken) -> StartResult;
start_selection			    pub fn start_selection(&mut self, token: SignalToken) -> StartResult 
start_selection			    pub fn start_selection(&mut self, token: SignalToken) -> SelectionResult<T> 
start_selection			    pub fn start_selection(&self, token: SignalToken) -> StartResult 
start_thread			pub fn start_thread(main: *mut libc::c_void) -> thread::rust_thread_return 
stat			    fn stat(&self) -> IoResult<FileStat> { stat(self) }
stat			    fn stat(&self) -> IoResult<FileStat>;
stat			    pub fn stat(&self) -> IoResult<FileStat> 
stat			pub fn stat(path: &Path) -> IoResult<FileStat> 
stat			pub fn stat(p: &Path) -> IoResult<FileStat> 
stat			pub fn stat(p: &Path) -> IoResult<FileStat> 
state			    pub fn state(&'static self) -> State 
states			    fn states() 
static_smoke			    fn static_smoke() 
static_smoke			    fn static_smoke() 
statik			    fn statik() 
status			    pub fn status(&self) -> IoResult<ProcessExit> 
std			mod std 
stderr			    pub fn stderr<'a>(&'a mut self, cfg: StdioContainer) -> &'a mut Command 
stderr			pub fn stderr() -> LineBufferedWriter<StdWriter> 
stderr			    pub fn stderr(mut self, stderr: Box<Writer + Send>) -> Builder 
stderr_raw			pub fn stderr_raw() -> StdWriter 
stdin			    pub fn stdin<'a>(&'a mut self, cfg: StdioContainer) -> &'a mut Command 
stdin			pub fn stdin() -> StdinReader 
stdin_raw			pub fn stdin_raw() -> StdReader 
stdin_works			    fn stdin_works() 
stdio			pub mod stdio;
stdout			    pub fn stdout<'a>(&'a mut self, cfg: StdioContainer) -> &'a mut Command 
stdout			pub fn stdout() -> LineBufferedWriter<StdWriter> 
stdout			    pub fn stdout(mut self, stdout: Box<Writer + Send>) -> Builder 
stdout_raw			pub fn stdout_raw() -> StdWriter 
stdout_works			    fn stdout_works() 
store_func			    unsafe fn store_func(ptr: *mut uint, module: &str, symbol: &str, fallback: uint) 
str_components			    pub fn str_components<'a>(&'a self) -> StrComponents<'a> 
str_components			    pub fn str_components<'a>(&'a self) -> StrComponents<'a> 
strconv			pub mod strconv;
stream			mod stream;
stream_data_waiting			    fn stream_data_waiting() 
stream_send_recv_stress			    fn stream_send_recv_stress() 
strerror_r			            fn strerror_r(errnum: c_int, buf: *mut c_char,
strerror_r			    fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: libc::size_t)
strerror_r			    fn strerror_r(errnum: c_int, buf: *mut c_char,
stress			    fn stress() 
stress			    fn stress() 
stress			    fn stress() 
stress_bound			        unsafe fn stress_bound(bound: uint) 
stress_factor			    pub fn stress_factor() -> uint 
stress_shared			    fn stress_shared() 
sub			            fn sub(self, other: 
sub			    fn sub(self, rhs: &HashSet<T, H>) -> HashSet<T, H> 
sub			    fn sub(self, rhs: Duration) -> Duration 
success			    pub fn success(&self) -> bool 
symbol			    pub unsafe fn symbol(handle: *mut u8, symbol: *const libc::c_char) -> *mut u8 
symbol			    pub unsafe fn symbol(handle: *mut u8,
symbol			    pub unsafe fn symbol<T>(&self, symbol: &str) -> Result<*mut T, String> 
syminfo_cb			    extern fn syminfo_cb(data: *mut libc::c_void,
symlink			pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> 
symlink			pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> 
symlink			pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> 
symlink_noexist			    fn symlink_noexist() 
symlinks_work			    fn symlinks_work() 
symmetric_difference			    pub fn symmetric_difference<'a>(&'a self, other: &'a HashSet<T, H>)
sync			pub mod sync;
sync			mod sync;
sync			pub mod sync;
sync			pub mod sync;
sync1			    fn sync1() 
sync2			    fn sync2() 
sync3			    fn sync3() 
sync_channel			pub fn sync_channel<T: Send>(bound: uint) -> (SyncSender<T>, Receiver<T>) 
sync_doesnt_kill_anything			    fn sync_doesnt_kill_anything() 
sync_tests			mod sync_tests 
sys::process::ProcessConfig for Command			impl sys::process::ProcessConfig<EnvKey, CString> for Command 
sys_common::AsInner for File			impl sys_common::AsInner<fs_imp::FileDesc> for File 
sys_common::AsInner for PipeStream			impl sys_common::AsInner<sys::fs::FileDesc> for PipeStream 
sys_common::AsInner for TcpAcceptor			impl sys_common::AsInner<TcpAcceptorImp> for TcpAcceptor 
sys_common::AsInner for TcpListener			impl sys_common::AsInner<TcpListenerImp> for TcpListener 
sys_common::AsInner for TcpStream			impl sys_common::AsInner<TcpStreamImp> for TcpStream 
sys_common::AsInner for UdpSocket			impl sys_common::AsInner<UdpSocketImp> for UdpSocket 
sys_common::AsInner for UnixAcceptor			impl sys_common::AsInner<UnixAcceptorImp> for UnixAcceptor 
sys_common::AsInner for UnixListener			impl sys_common::AsInner<UnixListenerImp> for UnixListener 
sys_common::AsInner for UnixStream			impl sys_common::AsInner<UnixStreamImp> for UnixStream 
syscall			            fn syscall(number: libc::c_long, ...) -> libc::c_long;
sysctl			        fn sysctl(name: *mut libc::c_int, namelen: libc::c_uint,
table			mod table;
table			    pub fn table(&self) -> &M 
take			    pub fn take(mut self) -> (EmptyBucket<K, V, M>, K, V) 
take			    pub fn take() -> Option<Vec<Vec<u8>>> 
take			pub fn take() -> Option<Vec<Vec<u8>>> { imp::take() }
take_to_wake			    fn take_to_wake(&mut self) -> SignalToken 
take_to_wake			    fn take_to_wake(&mut self) -> SignalToken 
tan			    fn tan(self) -> f32 
tan			        pub fn tan(n: c_double) -> c_double;
tan			    fn tan(self) -> f64 
tan			    fn tan(self) -> Self;
tanf			        pub fn tanf(n: c_float) -> c_float;
tanh			    fn tanh(self) -> f32 
tanh			        pub fn tanh(n: c_double) -> c_double;
tanh			    fn tanh(self) -> f64 
tanh			    fn tanh(self) -> Self;
tanhf			        pub fn tanhf(n: c_float) -> c_float;
target_get_sp_limit			    unsafe fn target_get_sp_limit() -> uint 
target_record_sp_limit			    unsafe fn target_record_sp_limit(_: uint) 
target_record_sp_limit			    unsafe fn target_record_sp_limit(limit: uint) 
target_record_stack_bounds			    unsafe fn target_record_stack_bounds(_stack_lo: uint, _stack_hi: uint) {}
target_record_stack_bounds			    unsafe fn target_record_stack_bounds(stack_lo: uint, stack_hi: uint) 
task_pool			mod task_pool;
tcp			pub mod tcp;
tcp			pub mod tcp;
tcp			pub mod tcp;
tcp_clone_smoke			    fn tcp_clone_smoke() 
tcp_clone_two_read			    fn tcp_clone_two_read() 
tcp_clone_two_write			    fn tcp_clone_two_write() 
tell			    fn tell(&self) -> IoResult<u64> 
tell			    fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }
tell			    fn tell(&self) -> IoResult<u64>;
tell			    fn tell(&self) -> IoResult<u64> 
tell			    pub fn tell(&self) -> IoResult<u64> 
tell			    pub fn tell(&self) -> IoResult<u64> 
tempfile			mod tempfile;
term			        unsafe fn term(signum: libc::c_int) -> ! 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			pub mod test;
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			    fn test() 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			    fn test() 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			    mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tgamma			        pub fn tgamma(n: c_double) -> c_double;
tgammaf			        pub fn tgammaf(n: c_float) -> c_float;
thread			pub mod thread;
thread			pub mod thread;
thread			pub mod thread;
thread			pub mod thread;
thread			    pub fn thread(&self) -> &Thread 
thread_info			pub mod thread_info;
thread_info::NewThread for Thread			impl thread_info::NewThread for Thread 
thread_local			pub mod thread_local;
thread_local			pub mod thread_local;
thread_local			pub mod thread_local;
thread_local			pub mod thread_local;
thread_rng			pub fn thread_rng() -> ThreadRng 
thread_start			pub extern fn thread_start(main: *mut libc::c_void) -> rust_thread_return 
thread_start			pub extern "system" fn thread_start(main: *mut libc::c_void) -> rust_thread_return 
thunk			pub mod thunk;
thunk			                extern "system" fn thunk(
time			pub mod time;
time_to_live			    pub fn time_to_live(&mut self, ttl: int) -> IoResult<()> 
timeout			pub fn timeout(desc: &'static str) -> IoError 
timeout_concurrent_read			    fn timeout_concurrent_read() 
timeout_concurrent_read			    fn timeout_concurrent_read() 
timer			pub mod timer;
timer			pub mod timer;
timer			pub mod timer;
tmpdir			    pub fn tmpdir() -> TempDir 
tmpdir			pub fn tmpdir() -> Path 
to_ascii_lowercase			    fn to_ascii_lowercase(&self) -> String 
to_ascii_lowercase			    fn to_ascii_lowercase(&self) -> T;
to_ascii_lowercase			    fn to_ascii_lowercase(&self) -> Vec<u8> 
to_ascii_lowercase			    fn to_ascii_lowercase(&self) -> char 
to_ascii_lowercase			    fn to_ascii_lowercase(&self) -> u8 
to_ascii_uppercase			    fn to_ascii_uppercase(&self) -> String 
to_ascii_uppercase			    fn to_ascii_uppercase(&self) -> T;
to_ascii_uppercase			    fn to_ascii_uppercase(&self) -> Vec<u8> 
to_ascii_uppercase			    fn to_ascii_uppercase(&self) -> char 
to_ascii_uppercase			    fn to_ascii_uppercase(&self) -> u8 
to_degrees			    fn to_degrees(self) -> f32 { num::Float::to_degrees(self) }
to_degrees			    fn to_degrees(self) -> f64 { num::Float::to_degrees(self) }
to_degrees			    fn to_degrees(self) -> Self;
to_i64			        fn to_i64(&self) -> Option<i64> { self.x.to_i64() }
to_radians			    fn to_radians(self) -> f32 { num::Float::to_radians(self) }
to_radians			    fn to_radians(self) -> f64 { num::Float::to_radians(self) }
to_radians			    fn to_radians(self) -> Self;
to_socket_addr			    fn to_socket_addr(&self) -> IoResult<SocketAddr> { Ok(*self) }
to_socket_addr			    fn to_socket_addr(&self) -> IoResult<SocketAddr> 
to_socket_addr_all			    fn to_socket_addr_all(&self) -> IoResult<Vec<SocketAddr>> 
to_socket_addr_ipaddr_u16			    fn to_socket_addr_ipaddr_u16() 
to_socket_addr_socketaddr			    fn to_socket_addr_socketaddr() 
to_socket_addr_str			    fn to_socket_addr_str() 
to_socket_addr_str_u16			    fn to_socket_addr_str_u16() 
to_str_base_36			        fn to_str_base_36(b: &mut Bencher) 
to_str_bin			        fn to_str_bin(b: &mut Bencher) 
to_str_dec			        fn to_str_dec(b: &mut Bencher) 
to_str_digits			pub fn to_str_digits(num: f32, dig: uint) -> String 
to_str_digits			pub fn to_str_digits(num: f64, dig: uint) -> String 
to_str_exact			pub fn to_str_exact(num: f32, dig: uint) -> String 
to_str_exact			pub fn to_str_exact(num: f64, dig: uint) -> String 
to_str_exp_digits			pub fn to_str_exp_digits(num: f32, dig: uint, upper: bool) -> String 
to_str_exp_digits			pub fn to_str_exp_digits(num: f64, dig: uint, upper: bool) -> String 
to_str_exp_exact			pub fn to_str_exp_exact(num: f32, dig: uint, upper: bool) -> String 
to_str_exp_exact			pub fn to_str_exp_exact(num: f64, dig: uint, upper: bool) -> String 
to_str_hex			pub fn to_str_hex(num: f32) -> String 
to_str_hex			pub fn to_str_hex(num: f64) -> String 
to_str_hex			        fn to_str_hex(b: &mut Bencher) 
to_str_oct			        fn to_str_oct(b: &mut Bencher) 
to_str_radix_special			pub fn to_str_radix_special(num: f32, rdx: uint) -> (String, bool) 
to_str_radix_special			pub fn to_str_radix_special(num: f64, rdx: uint) -> (String, bool) 
to_string			pub fn to_string(num: f32) -> String 
to_string			pub fn to_string(num: f64) -> String 
to_string			        fn to_string(x: int, base: u8) 
to_string			        fn to_string(x: uint, base: u8) 
to_u64			        fn to_u64(&self) -> Option<u64> { self.x.to_u64() }
to_utf16			pub fn to_utf16(s: &Path) -> IoResult<Vec<u16>> 
to_utf16			pub fn to_utf16(s: Option<&str>) -> IoResult<Vec<u16>> 
to_utf16			fn to_utf16(c: &CString) -> IoResult<Vec<u16>> 
toggle			            pub fn toggle(&mut self, other: 
tokens			pub fn tokens() -> (WaitToken, SignalToken) 
trace_fn			    extern fn trace_fn(ctx: *mut uw::_Unwind_Context,
translate_status			fn translate_status(status: c_int) -> ProcessExit 
trunc			    fn trunc(self) -> f32 { num::Float::trunc(self) }
trunc			    fn trunc(self) -> f64 { num::Float::trunc(self) }
trunc			    fn trunc(self) -> Self;
truncate			    pub fn truncate(&mut self, size: i64) -> IoResult<()> 
truncate			    pub fn truncate(&self, offset: i64) -> IoResult<()> 
truncate			    pub fn truncate(&mut self, offset: i64) -> IoResult<()> 
truncate_utf16_at_nul			pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] 
truncate_works			    fn truncate_works() 
try			pub unsafe fn try<F: FnOnce()>(f: F) -> Result<(), Box<Any + Send>> 
try_connect			    fn try_connect(p: *const u16) -> Option<libc::HANDLE> 
try_fn			    extern fn try_fn<F: FnOnce()>(opt_closure: *mut c_void) 
try_lock			    fn try_lock() 
try_lock			    pub fn try_lock(&'static self) -> TryLockResult<MutexGuard<()>> 
try_lock			    pub fn try_lock(&self) -> TryLockResult<MutexGuard<T>> 
try_lock			    pub unsafe fn try_lock(&self) -> bool { self.0.try_lock() }
try_lock			    pub unsafe fn try_lock(&self) -> bool 
try_lock			    pub unsafe fn try_lock(&self) -> bool 
try_read			    pub fn try_read(&'static self)
try_read			    pub fn try_read(&self) -> TryLockResult<RwLockReadGuard<T>> 
try_read			    pub unsafe fn try_read(&self) -> bool { self.0.try_read() }
try_read			    pub unsafe fn try_read(&self) -> bool 
try_read			    pub unsafe fn try_read(&self) -> bool 
try_recv			    pub fn try_recv(&self) -> Result<T, TryRecvError> 
try_recv			    pub fn try_recv(&mut self) -> Result<T, Failure<T>> 
try_recv			    pub fn try_recv(&mut self) -> Result<T, Failure> 
try_recv			    pub fn try_recv(&mut self) -> Result<T, Failure<T>> 
try_recv			    pub fn try_recv(&self) -> Result<T, Failure> 
try_recv_states			    fn try_recv_states() 
try_send			    pub fn try_send(&self, t: T) -> Result<(), TrySendError<T>> 
try_send			    pub fn try_send(&self, t: T) -> Result<(), super::TrySendError<T>> 
try_send1			    fn try_send1() 
try_send2			    fn try_send2() 
try_send3			    fn try_send3() 
try_wait			    pub fn try_wait(&self) -> Option<ProcessExit> 
try_write			    pub fn try_write(&'static self)
try_write			    pub fn try_write(&self) -> TryLockResult<RwLockWriteGuard<T>> 
try_write			    pub unsafe fn try_write(&self) -> bool { self.0.try_write() }
try_write			    pub unsafe fn try_write(&self) -> bool 
try_write			    pub unsafe fn try_write(&self) -> bool 
tty			pub mod tty;
tty			pub mod tty;
tuple			mod tuple;
two_mutexes			    fn two_mutexes() 
u64_from_be_bytes			pub fn u64_from_be_bytes(data: &[u8], start: uint, size: uint) -> u64 
u64_from_be_bytes_4_aligned			    fn u64_from_be_bytes_4_aligned(b: &mut Bencher) 
u64_from_be_bytes_4_unaligned			    fn u64_from_be_bytes_4_unaligned(b: &mut Bencher) 
u64_from_be_bytes_7_aligned			    fn u64_from_be_bytes_7_aligned(b: &mut Bencher) 
u64_from_be_bytes_7_unaligned			    fn u64_from_be_bytes_7_unaligned(b: &mut Bencher) 
u64_from_be_bytes_8_aligned			    fn u64_from_be_bytes_8_aligned(b: &mut Bencher) 
u64_from_be_bytes_8_unaligned			    fn u64_from_be_bytes_8_unaligned(b: &mut Bencher) 
u64_to_be_bytes			pub fn u64_to_be_bytes<T, F>(n: u64, size: uint, f: F) -> T where
u64_to_le_bytes			pub fn u64_to_le_bytes<T, F>(n: u64, size: uint, f: F) -> T where
udp			pub mod udp;
udp			pub mod udp;
udp			pub mod udp;
udp_clone_smoke			    fn udp_clone_smoke() 
udp_clone_two_read			    fn udp_clone_two_read() 
udp_clone_two_write			    fn udp_clone_two_write() 
uid			    fn uid(&self) -> Option<uint> 
uid			    pub fn uid<'a>(&'a mut self, id: uint) -> &'a mut Command 
uid			    fn uid(&self) -> Option<uint>;
uid_fails_on_windows			    fn uid_fails_on_windows() 
uid_to_root_fails			    fn uid_to_root_fails() 
uid_works			    fn uid_works() 
uint			    mod uint 
uint_macros			mod uint_macros;
unblocks			    fn unblocks() 
unicode_path_exists			    fn unicode_path_exists() 
unicode_path_is_dir			    fn unicode_path_is_dir() 
unimpl			pub fn unimpl() -> IoError 
unimpl			pub fn unimpl() -> IoError 
union			    pub fn union<'a>(&'a self, other: &'a HashSet<T, H>) -> Union<'a, T, H> 
unit			mod unit;
unix_clone_smoke			    fn unix_clone_smoke() 
unix_clone_two_read			    fn unix_clone_two_read() 
unix_clone_two_write			    fn unix_clone_two_write() 
unix_socket			fn unix_socket(ty: libc::c_int) -> IoResult<fd_t> 
unlink			pub fn unlink(path: &Path) -> IoResult<()> 
unlink			pub fn unlink(p: &Path) -> IoResult<()> 
unlink			pub fn unlink(p: &Path) -> IoResult<()> 
unlink_readonly			    fn unlink_readonly() 
unlock			    pub unsafe fn unlock(&self) { self.0.unlock() }
unlock			    pub unsafe fn unlock(&self) 
unlock			    pub unsafe fn unlock(&self) 
unpark			    pub fn unpark(&self) 
unregister_dtor			unsafe fn unregister_dtor(key: Key) -> bool 
unsetenv			pub fn unsetenv(n: &str) 
unwind			pub mod unwind;
unwrap			    pub fn unwrap(self) -> fd_t 
unwrap			    pub fn unwrap(self) -> fd_t 
update_desc			    fn update_desc(self, desc: &'static str) -> IoResult<T> 
update_desc			    fn update_desc(self, desc: &'static str) -> Self;
update_detail			    fn update_detail<D>(self, detail: D) -> IoResult<T> where
update_detail			    fn update_detail<D>(self, detail: D) -> Self where
update_err			        fn update_err<T>(result: IoResult<T>, file: &File) -> IoResult<T> 
update_err			    fn update_err<T>(err: IoResult<T>, path: &Path) -> IoResult<T> 
update_err			    fn update_err<T>(result: IoResult<T>, from: &Path, to: &Path) -> IoResult<T> 
update_err			    fn update_err<D>(self, desc: &'static str, detail: D) -> IoResult<T> where
update_err			    fn update_err<D>(self, desc: &'static str, detail: D) -> Self where
update_normalized			    fn update_normalized(&mut self, s: &str) 
update_sepidx			    fn update_sepidx(&mut self) 
upgrade			    pub fn upgrade(&mut self, up: Receiver<T>) -> UpgradeResult 
upgrade			    pub fn upgrade(&mut self, up: Receiver<T>) -> UpgradeResult 
usable_capacity			    fn usable_capacity(&self, cap: uint) -> uint 
util			pub mod util;
util			pub mod util;
utime			    fn utime() 
utime			pub fn utime(p: &Path, atime: u64, mtime: u64) -> IoResult<()> 
utime			pub fn utime(p: &Path, atime: u64, mtime: u64) -> IoResult<()> 
utime_noexist			    fn utime_noexist() 
uw			mod uw 
v1			pub mod v1;
values			    pub fn values<'a>(&'a self) -> Values<'a, K, V> 
vectored_handler			extern "system" fn vectored_handler(ExceptionInfo: *mut EXCEPTION_POINTERS) -> LONG 
verify			    fn verify(&self, mutex: &sys_mutex::Mutex) 
wait			    pub fn wait(&mut self) -> IoResult<ProcessExit> 
wait			    pub fn wait(&self) -> BarrierWaitResult 
wait			    pub fn wait<'a, T>(&'static self, guard: MutexGuard<'a, T>)
wait			    pub fn wait<'a, T>(&self, guard: MutexGuard<'a, T>)
wait			    pub fn wait(self) 
wait			    pub fn wait(&self) -> uint 
wait			fn wait<'a, 'b, T: Send>(lock: &'a Mutex<State<T>>,
wait			    pub unsafe fn wait(&self, mutex: &Mutex) { self.0.wait(mutex::raw(mutex)) }
wait			    pub unsafe fn wait(&self, mutex: &Mutex) 
wait			    pub fn wait(&self, deadline: u64) -> IoResult<ProcessExit> 
wait			    pub unsafe fn wait(&self, mutex: &Mutex) 
wait			    pub fn wait(&self, deadline: u64) -> IoResult<ProcessExit> 
wait2			    fn wait2(&self, do_preflight_checks: bool) -> uint 
wait_timeout			    fn wait_timeout() 
wait_timeout			    fn wait_timeout() 
wait_timeout			    fn wait_timeout<'a, T>(&'static self, guard: MutexGuard<'a, T>, dur: Duration)
wait_timeout			    fn wait_timeout<'a, T>(&self, guard: MutexGuard<'a, T>, dur: Duration)
wait_timeout			    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool 
wait_timeout			    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool 
wait_timeout			    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool 
wait_timeout2			    fn wait_timeout2() 
wait_with_output			    pub fn wait_with_output(mut self) -> IoResult<ProcessOutput> 
waitpid			    pub fn waitpid(pid: libc::pid_t, status: *mut libc::c_int,
waitpid_helper			        fn waitpid_helper(input: libc::c_int,
wakeup			fn wakeup<T>(token: SignalToken, guard: MutexGuard<State<T>>) 
wakeup_senders			    fn wakeup_senders(&self, waited: bool, mut guard: MutexGuard<State<T>>) 
walk_dir			pub fn walk_dir(path: &Path) -> IoResult<Directories> 
weak_rng			pub fn weak_rng() -> XorShiftRng 
weeks			    pub fn weeks(weeks: i64) -> Duration 
windows			pub mod windows;
winsize			    pub fn winsize(&mut self) -> IoResult<(int, int)> 
with			    fn with<R, F>(f: F) -> R where F: FnOnce(&mut ThreadInfo) -> R 
with			    pub fn with<F, R>(&'static self, f: F) -> R
with			    pub fn with<R, F>(&'static self, cb: F) -> R where
with_addresses			fn with_addresses<A, T, F>(addr: A, mut action: F) -> IoResult<T> where
with_arg			    pub fn with_arg<F>(func: F) -> Thunk<A,R>
with_argv			fn with_argv<T,F>(prog: &CString, args: &[CString],
with_capacities			    pub fn with_capacities(reader_cap: uint, writer_cap: uint, inner: S)
with_capacity			    pub fn with_capacity(capacity: uint) -> HashMap<K, V, RandomSipHasher> 
with_capacity			    pub fn with_capacity(capacity: uint) -> HashSet<T, RandomSipHasher> 
with_capacity			    pub fn with_capacity(cap: uint, inner: R) -> BufferedReader<R> 
with_capacity			    pub fn with_capacity(cap: uint, inner: W) -> BufferedWriter<W> 
with_capacity			    pub fn with_capacity(n: uint) -> MemWriter 
with_capacity_and_hasher			    pub fn with_capacity_and_hasher(capacity: uint, hasher: H) -> HashMap<K, V, H> 
with_capacity_and_hasher			    pub fn with_capacity_and_hasher(capacity: uint, hasher: H) -> HashSet<T, H> 
with_dirp			fn with_dirp<T, F>(d: Option<&CString>, cb: F) -> T where
with_env_lock			fn with_env_lock<T, F>(f: F) -> T where
with_envp			fn with_envp<K,V,T,F>(env: Option<&collections::HashMap<K, V>>,
with_envp			fn with_envp<K, V, T, F>(env: Option<&collections::HashMap<K, V>>, cb: F) -> T where
with_extension			    fn with_extension<T: BytesContainer>(&self, extension: T) -> Self 
with_filename			    fn with_filename<T: BytesContainer>(&self, filename: T) -> Self 
with_hasher			    pub fn with_hasher(hasher: H) -> HashMap<K, V, H> 
with_hasher			    pub fn with_hasher(hasher: H) -> HashSet<T, H> 
with_task_stdout			fn with_task_stdout<F>(f: F) where F: FnOnce(&mut Writer) -> IoResult<()> 
wouldblock			pub fn wouldblock() -> bool 
wouldblock			pub fn wouldblock() -> bool 
write			    fn write(&mut self, bytes: &[u8]) -> IoResult<()> 
write			            fn write(&mut self, _: &[u8]) -> io::IoResult<()> { Ok(()) }
write			            fn write(&mut self, _buf: &[u8]) -> IoResult<()> { Ok(()) }
write			        fn write(&mut self, _: &[u8]) -> io::IoResult<()> { Ok(()) }
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			    fn write(&mut self, src: &[u8]) -> IoResult<()> 
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> { (**self).write(buf) }
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.inner.write(buf) }
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()>;
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			            fn write(&mut self, _buf: &[u8]) -> io::IoResult<()> 
write			    fn write(&mut self, _buf: &[u8]) -> io::IoResult<()> { Ok(()) }
write			    fn write(&mut self, buf: &[u8]) -> io::IoResult<()> 
write			    pub fn write(&'static self) -> LockResult<RwLockWriteGuard<'static, ()>> 
write			    pub fn write(&self) -> LockResult<RwLockWriteGuard<T>> 
write			    pub fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			pub fn write<T, L, W>(fd: sock_t,
write			    pub unsafe fn write(&self) { self.0.write() }
write			pub fn write(w: &mut Writer) -> IoResult<()> 
write			    pub fn write(&self, buf: &[u8]) -> IoResult<()> 
write			    pub fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			    pub unsafe fn write(&self) 
write			    pub fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			pub fn write(w: &mut Writer) -> IoResult<()> 
write			    pub fn write(&self, buf: &[u8]) -> IoResult<()> 
write			    pub fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			    pub unsafe fn write(&self) 
write			    pub fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write_be_f32			    fn write_be_f32(&mut self, f: f32) -> IoResult<()> 
write_be_f64			    fn write_be_f64(&mut self, f: f64) -> IoResult<()> 
write_be_i16			    fn write_be_i16(&mut self, n: i16) -> IoResult<()> 
write_be_i32			    fn write_be_i32(&mut self, n: i32) -> IoResult<()> 
write_be_i64			    fn write_be_i64(&mut self, n: i64) -> IoResult<()> 
write_be_int			    fn write_be_int(&mut self, n: int) -> IoResult<()> 
write_be_u16			    fn write_be_u16(&mut self, n: u16) -> IoResult<()> 
write_be_u32			    fn write_be_u32(&mut self, n: u32) -> IoResult<()> 
write_be_u64			    fn write_be_u64(&mut self, n: u64) -> IoResult<()> 
write_be_uint			    fn write_be_uint(&mut self, n: uint) -> IoResult<()> 
write_begone			    fn write_begone() 
write_bytes			    pub fn write_bytes(&mut self, data: &[u8]) 
write_char			    fn write_char(&mut self, c: char) -> IoResult<()> 
write_close_ip4			    fn write_close_ip4() 
write_close_ip6			    fn write_close_ip6() 
write_closed			    fn write_closed(&self) -> bool 
write_fmt			    fn write_fmt(&mut self, fmt: fmt::Arguments) -> IoResult<()> 
write_i8			    fn write_i8(&mut self, n: i8) -> IoResult<()> 
write_int			    fn write_int(&mut self, n: int) -> IoResult<()> 
write_le_f32			    fn write_le_f32(&mut self, f: f32) -> IoResult<()> 
write_le_f64			    fn write_le_f64(&mut self, f: f64) -> IoResult<()> 
write_le_i16			    fn write_le_i16(&mut self, n: i16) -> IoResult<()> 
write_le_i32			    fn write_le_i32(&mut self, n: i32) -> IoResult<()> 
write_le_i64			    fn write_le_i64(&mut self, n: i64) -> IoResult<()> 
write_le_int			    fn write_le_int(&mut self, n: int) -> IoResult<()> 
write_le_u16			    fn write_le_u16(&mut self, n: u16) -> IoResult<()> 
write_le_u32			    fn write_le_u32(&mut self, n: u32) -> IoResult<()> 
write_le_u64			    fn write_le_u64(&mut self, n: u64) -> IoResult<()> 
write_le_uint			    fn write_le_uint(&mut self, n: uint) -> IoResult<()> 
write_line			    fn write_line(&mut self, s: &str) -> IoResult<()> 
write_str			            fn write_str(&mut self, s: &str) -> fmt::Result 
write_str			    fn write_str(&mut self, s: &str) -> IoResult<()> 
write_str			        fn write_str(&mut self, bytes: &str) -> fmt::Result 
write_str			    fn write_str(&mut self, data: &str) -> fmt::Result 
write_timeouts			    fn write_timeouts() 
write_timeouts			    fn write_timeouts() 
write_u8			    fn write_u8(&mut self, n: u8) -> IoResult<()> 
write_uint			    fn write_uint(&mut self, n: uint) -> IoResult<()> 
write_unlock			    pub unsafe fn write_unlock(&self) { self.0.write_unlock() }
write_unlock			    pub unsafe fn write_unlock(&self) { self.read_unlock() }
write_unlock			    pub unsafe fn write_unlock(&self) 
y0			        pub fn y0(n: c_double) -> c_double;
y1			        pub fn y1(n: c_double) -> c_double;
yield_now			pub unsafe fn yield_now() { assert_eq!(sched_yield(), 0); }
yield_now			pub unsafe fn yield_now() 
yield_now			    pub fn yield_now() 
yn			        pub fn yn(i: c_int, n: c_double) -> c_double;
zero			    fn zero() -> f32 { num::Float::zero() }
zero			    fn zero() -> f64 { num::Float::zero() }
zero			    fn zero() -> Self;
zero			    pub fn zero() -> Duration 
zeroed_process_information			fn zeroed_process_information() -> libc::types::os::arch::extra::PROCESS_INFORMATION 
zeroed_startupinfo			fn zeroed_startupinfo() -> libc::types::os::arch::extra::STARTUPINFO 
