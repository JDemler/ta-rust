Nfa			    struct Nfa<'t> 
NfaGen			struct NfaGen<'a> 
Thread			    struct Thread 
Threads			    impl Threads 
Threads			    struct Threads 
add			        fn add(&mut self, pc: uint, groups: &Captures) 
add			        fn add(&self, nlist: &mut Threads, pc: uint,
add_empty			        fn add_empty(&mut self, pc: uint) 
add_insts			    fn add_insts(&self) -> Gc<ast::Expr> 
arm_inst			    fn arm_inst(&self, pc: uint, body: Gc<ast::Expr>) -> ast::Arm 
check_prefix			    fn check_prefix(&self) -> Gc<ast::Expr> 
code			    fn code(&mut self) -> Gc<ast::Expr> 
contains			        fn contains(&self, pc: uint) -> bool 
empty			        fn empty(&mut self) 
empty_block			    fn empty_block(&self) -> Gc<ast::Expr> 
exec			fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,
groups			        fn groups<'r>(&'r mut self, i: uint) -> &'r mut Captures 
match_class			    fn match_class(&self, casei: bool, ranges: &[(char, char)]) -> Gc<ast::Expr> 
match_insts			    fn match_insts(&self, mut arms: Vec<ast::Arm>) -> Gc<ast::Expr> 
native			fn native(cx: &mut ExtCtxt, sp: codemap::Span, tts: &[ast::TokenTree])
new			        fn new(which: MatchKind) -> Threads 
parse			fn parse(cx: &mut ExtCtxt, tts: &[ast::TokenTree]) -> Option<String> 
pc			        fn pc(&self, i: uint) -> uint 
plugin_registrar			pub fn plugin_registrar(reg: &mut Registry) 
run			        fn run(&mut self, start: uint, end: uint) -> Vec<Option<uint>> 
step			        fn step(&self, groups: &mut Captures, nlist: &mut Threads,
step_insts			    fn step_insts(&self) -> Gc<ast::Expr> 
vec_expr			    fn vec_expr<T, It: Iterator<T>>(&self, xs: It,
wild_arm_expr			    fn wild_arm_expr(&self, body: Gc<ast::Expr>) -> ast::Arm 
