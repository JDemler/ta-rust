Access			impl Access 
Access			pub struct Access 
Addrinfo			struct Addrinfo 
AsyncWatcher			impl AsyncWatcher 
AsyncWatcher			pub struct AsyncWatcher 
Callback			        impl Callback for MyCallback 
Callback			    impl Callback for MyCallback 
Clone			impl Clone for Access 
Clone			impl Clone for HomeHandle 
Clone			impl Clone for Queue 
Clone			impl Clone for Refcount 
Ctx			struct Ctx 
Ctx			        struct Ctx { status: c_int, task: Option<BlockedTask> }
Ctx			        struct Ctx { task: Option<BlockedTask>, result: c_int }
Ctx			        struct Ctx 
Ctx			        struct Ctx { task: Option<BlockedTask>, result: libc::c_int, }
Drop			impl Drop for Inner 
Drop			impl Drop for Addrinfo 
Drop			impl Drop for AsyncWatcher 
Drop			impl Drop for FileWatcher 
Drop			impl Drop for FsRequest 
Drop			impl Drop for HomingMissile 
Drop			impl Drop for IdleWatcher 
Drop			impl Drop for ForbidSwitch 
Drop			impl Drop for ForbidUnwind 
Drop			impl Drop for Request 
Drop			impl Drop for TcpListener 
Drop			impl Drop for TcpWatcher 
Drop			impl Drop for UdpWatcher 
Drop			impl Drop for PipeListener 
Drop			impl Drop for PipeWatcher 
Drop			impl Drop for Process 
Drop			impl Drop for Queue 
Drop			impl Drop for State 
Drop			impl Drop for SignalWatcher 
Drop			impl Drop for TimerWatcher 
Drop			impl Drop for TtyWatcher 
Drop			impl Drop for UvEventLoop 
FileWatcher			impl FileWatcher 
FileWatcher			pub struct FileWatcher 
ForbidSwitch			impl ForbidSwitch 
ForbidSwitch			pub struct ForbidSwitch 
ForbidUnwind			impl ForbidUnwind 
ForbidUnwind			pub struct ForbidUnwind 
FsRequest			impl FsRequest 
FsRequest			pub struct FsRequest 
GetAddrInfoRequest			impl GetAddrInfoRequest 
GetAddrInfoRequest			pub struct GetAddrInfoRequest;
Guard			pub struct Guard<'a> 
HomeHandle			impl HomeHandle 
HomeHandle			pub struct HomeHandle 
HomingIO			impl HomingIO for FileWatcher 
HomingIO			pub trait HomingIO 
HomingIO			impl HomingIO for TcpAcceptor 
HomingIO			impl HomingIO for TcpListener 
HomingIO			impl HomingIO for TcpWatcher 
HomingIO			impl HomingIO for UdpWatcher 
HomingIO			impl HomingIO for PipeAcceptor 
HomingIO			impl HomingIO for PipeListener 
HomingIO			impl HomingIO for PipeWatcher 
HomingIO			impl HomingIO for Process 
HomingIO			impl HomingIO for SignalWatcher 
HomingIO			impl HomingIO for TimerWatcher 
HomingIO			impl HomingIO for TtyWatcher 
HomingMissile			impl HomingMissile 
HomingMissile			pub struct HomingMissile 
IdleWatcher			impl IdleWatcher 
IdleWatcher			pub struct IdleWatcher 
Inner			struct Inner 
IoFactory			impl IoFactory for UvIoFactory 
Loop			impl Loop 
Loop			pub struct Loop 
Message			enum Message 
MyCallback			        struct MyCallback(Option<Sender<int>>);
MyCallback			    struct MyCallback(Rc<RefCell<(Option<BlockedTask>, uint)>>, uint);
NextAction			pub enum NextAction 
PausableIdleCallback			impl PausableIdleCallback for IdleWatcher 
Payload			struct Payload 
PipeAcceptor			pub struct PipeAcceptor 
PipeListener			impl PipeListener 
PipeListener			pub struct PipeListener 
PipeWatcher			impl PipeWatcher 
PipeWatcher			pub struct PipeWatcher 
Process			impl Process 
Process			pub struct Process 
Queue			impl Queue 
Queue			pub struct Queue 
QueuePool			impl QueuePool 
QueuePool			pub struct QueuePool 
ReadContext			struct ReadContext 
Refcount			impl Refcount 
Refcount			pub struct Refcount 
RemoteCallback			impl RemoteCallback for AsyncWatcher 
Request			impl Request 
Request			pub struct Request 
RtioPipe			impl RtioPipe for PipeWatcher 
RtioProcess			impl RtioProcess for Process 
RtioSignal			impl RtioSignal for SignalWatcher {}
RtioTTY			impl RtioTTY for TtyWatcher 
RtioTimer			impl RtioTimer for TimerWatcher 
RtioUnixAcceptor			impl RtioUnixAcceptor for PipeAcceptor 
RtioUnixListener			impl RtioUnixListener for PipeListener 
SignalWatcher			impl SignalWatcher 
SignalWatcher			pub struct SignalWatcher 
SocketNameKind			enum SocketNameKind 
State			struct State 
Stderr			    struct Stderr;
StreamWatcher			impl StreamWatcher 
StreamWatcher			pub struct StreamWatcher 
TcpAcceptor			pub struct TcpAcceptor 
TcpListener			impl TcpListener 
TcpListener			pub struct TcpListener 
TcpWatcher			impl TcpWatcher 
TcpWatcher			pub struct TcpWatcher 
TimerWatcher			impl TimerWatcher 
TimerWatcher			pub struct TimerWatcher 
TtyWatcher			impl TtyWatcher 
TtyWatcher			pub struct TtyWatcher
UdpWatcher			impl UdpWatcher 
UdpWatcher			pub struct UdpWatcher 
UvError			impl UvError 
UvError			pub struct UvError(c_int);
UvEventLoop			impl UvEventLoop 
UvEventLoop			pub struct UvEventLoop 
UvHandle			impl UvHandle<uvll::uv_async_t> for AsyncWatcher 
UvHandle			impl UvHandle<uvll::uv_idle_t> for IdleWatcher 
UvHandle			pub trait UvHandle<T> 
UvHandle			impl UvHandle<uvll::uv_tcp_t> for TcpListener 
UvHandle			impl UvHandle<uvll::uv_tcp_t> for TcpWatcher 
UvHandle			impl UvHandle<uvll::uv_udp_t> for UdpWatcher 
UvHandle			impl UvHandle<uvll::uv_pipe_t> for PipeListener 
UvHandle			impl UvHandle<uvll::uv_pipe_t> for PipeWatcher 
UvHandle			impl UvHandle<uvll::uv_process_t> for Process 
UvHandle			impl UvHandle<uvll::uv_signal_t> for SignalWatcher 
UvHandle			impl UvHandle<uvll::uv_timer_t> for TimerWatcher 
UvHandle			impl UvHandle<uvll::uv_tty_t> for TtyWatcher 
UvIoFactory			impl UvIoFactory 
UvIoFactory			pub struct UvIoFactory 
WriteContext			struct WriteContext 
accept			    fn accept(&mut self) -> Result<~rtio::RtioTcpStream:Send, IoError> 
accept			    fn accept(&mut self) -> Result<~RtioPipe:Send, IoError> 
accept_simultaneously			    fn accept_simultaneously(&mut self) -> Result<(), IoError> 
access			mod access;
accum_addrinfo			pub fn accum_addrinfo(addr: &Addrinfo) -> ~[ai::Info] 
addr_to_sockaddr			fn addr_to_sockaddr(addr: ip::SocketAddr) -> (libc::sockaddr_storage, uint) 
addrinfo			pub mod addrinfo;
alloc			    fn alloc(_: Option<Self>, ty: uvll::uv_handle_type) -> *T 
alloc_cb			        extern fn alloc_cb(handle: *uvll::uv_udp_t,
alloc_cb			extern fn alloc_cb(stream: *uvll::uv_stream_t, _hint: size_t, buf: *mut Buf) 
async			pub mod async;
async_cb			extern fn async_cb(handle: *uvll::uv_async_t, status: c_int) 
async_cb			extern fn async_cb(handle: *uvll::uv_async_t, status: c_int) 
base_read			    fn base_read(&mut self, buf: &mut [u8], offset: i64) -> Result<int, IoError> 
base_write			    fn base_write(&mut self, buf: &[u8], offset: i64) -> Result<(), IoError> 
bind			    pub fn bind(io: &mut UvIoFactory, address: ip::SocketAddr)
bind			    fn bind() 
bind			    pub fn bind(io: &mut UvIoFactory, name: &CString)
bind_err			    fn bind_err() 
bind_fail			    fn bind_fail() 
call			            fn call(&mut self) 
call			        fn call(&mut self) 
callback			    fn callback(&mut self, f: proc()) 
check			    pub fn check(&self, msg: &'static str) 
chmod			    pub fn chmod(loop_: &Loop, path: &CString, mode: c_int)
chown			    pub fn chown(loop_: &Loop, path: &CString, uid: int, gid: int)
clone			    fn clone(&self) -> Access 
clone			    fn clone(&self) -> HomeHandle 
clone			    fn clone(&self) -> ~rtio::RtioTcpStream:Send 
clone			    fn clone(&self) -> ~rtio::RtioUdpSocket:Send 
clone			    fn clone(&self) -> ~RtioPipe:Send 
clone			    fn clone(&self) -> Queue 
clone			    fn clone(&self) -> Refcount 
close			    fn close(&mut self) 
close			    pub fn close(&mut self) 
close_async_			    fn close_async_(&mut self) 
close_cb			extern fn close_cb(handle: *uvll::uv_handle_t) 
close_cb			                extern fn close_cb(req: *uvll::uv_fs_t) 
close_cb			        extern fn close_cb(handle: *uvll::uv_handle_t) 
close_cb			        extern fn close_cb(handle: *uvll::uv_handle_t) 
close_write			    fn close_write(&mut self) -> Result<(), IoError> 
closing_channel_during_drop_doesnt_kill_everything			    fn closing_channel_during_drop_doesnt_kill_everything() 
closing_channel_during_drop_doesnt_kill_everything			    fn closing_channel_during_drop_doesnt_kill_everything() 
connect			    pub fn connect(io: &mut UvIoFactory, address: ip::SocketAddr)
connect			    fn connect() 
connect			    pub fn connect(io: &mut UvIoFactory, name: &CString)
connect_cb			        extern fn connect_cb(req: *uvll::uv_connect_t, status: c_int) 
connect_cb			        extern fn connect_cb(req: *uvll::uv_connect_t, status: libc::c_int) {;
connect_close_ip4			    fn connect_close_ip4() 
connect_close_ip6			    fn connect_close_ip6() 
connect_err			    fn connect_err() 
connect_fail			    fn connect_fail() 
control_congestion			    fn control_congestion(&mut self) -> Result<(), IoError> 
datasync			    fn datasync(&mut self) -> Result<(), IoError> 
datasync			    pub fn datasync(loop_: &Loop, fd: c_int) -> Result<(), UvError> 
decrement			    pub fn decrement(&self) -> bool 
defuse			    pub fn defuse(&mut self) 
desc			    pub fn desc(&self) -> ~str 
dont_accept_simultaneously			    fn dont_accept_simultaneously(&mut self) -> Result<(), IoError> 
dont_loop_multicast_locally			    fn dont_loop_multicast_locally(&mut self) -> Result<(), IoError> 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
dumb_println			pub fn dumb_println(args: &fmt::Arguments) 
each_ai_flag			fn each_ai_flag(_f: |c_int, ai::Flag|) 
empty_buf			pub fn empty_buf() -> Buf 
error_smoke_test			fn error_smoke_test() 
errors			pub mod errors 
event_loop			pub fn event_loop() -> ~rtio::EventLoop:Send 
execute			fn execute(f: |*uvll::uv_fs_t, uvll::uv_fs_cb| -> c_int)
execute_nop			fn execute_nop(f: |*uvll::uv_fs_t, uvll::uv_fs_cb| -> c_int)
file			pub mod file;
file_test_full_simple_sync			    fn file_test_full_simple_sync() 
file_test_mk_rm_dir			    fn file_test_mk_rm_dir() 
file_test_mkdir_chokes_on_double_create			    fn file_test_mkdir_chokes_on_double_create() 
file_test_rmdir_chokes_on_nonexistant_path			    fn file_test_rmdir_chokes_on_nonexistant_path() 
file_test_stat			    fn file_test_stat() 
fire			    fn fire(&mut self) 
fire_homing_missile			    fn fire_homing_missile(&mut self) -> HomingMissile 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			impl fmt::Show for UvError 
free			        fn free<T>(_: T) {}
free_handle			pub unsafe fn free_handle(v: *c_void) 
free_req			pub unsafe fn free_req(v: *c_void) 
from_uv_handle			    unsafe fn from_uv_handle<'a>(_: &'a *uvll::uv_async_t) -> &'a mut AsyncWatcher 
from_uv_handle			    unsafe fn from_uv_handle<'a>(h: &'a *T) -> &'a mut Self 
fs_cb			    extern fn fs_cb(req: *uvll::uv_fs_t) 
fs_chmod			    fn fs_chmod(&mut self, path: &CString,
fs_chown			    fn fs_chown(&mut self, path: &CString, uid: int, gid: int) -> Result<(), IoError> 
fs_from_raw_fd			    fn fs_from_raw_fd(&mut self, fd: c_int,
fs_link			    fn fs_link(&mut self, src: &CString, dst: &CString) -> Result<(), IoError> 
fs_lstat			    fn fs_lstat(&mut self, path: &CString) -> Result<FileStat, IoError> 
fs_mkdir			    fn fs_mkdir(&mut self, path: &CString,
fs_open			    fn fs_open(&mut self, path: &CString, fm: FileMode, fa: FileAccess)
fs_readdir			    fn fs_readdir(&mut self, path: &CString, flags: c_int)
fs_readlink			    fn fs_readlink(&mut self, path: &CString) -> Result<Path, IoError> 
fs_rename			    fn fs_rename(&mut self, path: &CString, to: &CString) -> Result<(), IoError> 
fs_rmdir			    fn fs_rmdir(&mut self, path: &CString) -> Result<(), IoError> 
fs_stat			    fn fs_stat(&mut self, path: &CString) -> Result<FileStat, IoError> 
fs_symlink			    fn fs_symlink(&mut self, src: &CString, dst: &CString) -> Result<(), IoError> 
fs_unlink			    fn fs_unlink(&mut self, path: &CString) -> Result<(), IoError> 
fs_utime			    fn fs_utime(&mut self, path: &CString, atime: u64, mtime: u64)
fsync			    fn fsync(&mut self) -> Result<(), IoError> 
fsync			    pub fn fsync(loop_: &Loop, fd: c_int) -> Result<(), UvError> 
fun_combinations_of_methods			    fn fun_combinations_of_methods() 
get_blockers			    fn get_blockers(&self) -> uint 
get_data			    pub unsafe fn get_data<T>(&self) -> &'static mut T 
get_data_for_req			pub unsafe fn get_data_for_req<T>(req: *T) -> *c_void 
get_data_for_uv_handle			pub unsafe fn get_data_for_uv_handle<T>(handle: *T) -> *c_void 
get_data_for_uv_loop			pub unsafe fn get_data_for_uv_loop(loop_ptr: *c_void) -> *c_void 
get_host_addresses			    fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,
get_loop_for_uv_handle			pub unsafe fn get_loop_for_uv_handle<T>(handle: *T) -> *c_void 
get_loop_from_fs_req			pub unsafe fn get_loop_from_fs_req(req: *uv_fs_t) -> *uv_loop_t 
get_loop_from_getaddrinfo_req			pub unsafe fn get_loop_from_getaddrinfo_req(req: *uv_getaddrinfo_t) -> *uv_loop_t 
get_path_from_fs_req			pub unsafe fn get_path_from_fs_req(req: *uv_fs_t) -> *c_char 
get_ptr			    pub fn get_ptr(&self) -> *libc::c_void 
get_ptr_from_fs_req			pub unsafe fn get_ptr_from_fs_req(req: *uv_fs_t) -> *libc::c_void 
get_result			    pub fn get_result(&self) -> ssize_t 
get_result_from_fs_req			pub unsafe fn get_result_from_fs_req(req: *uv_fs_t) -> ssize_t 
get_stat			    pub fn get_stat(&self) -> uvll::uv_stat_t 
get_stream_handle_from_connect_req			pub unsafe fn get_stream_handle_from_connect_req(connect: *uv_connect_t) -> *uv_stream_t 
get_stream_handle_from_write_req			pub unsafe fn get_stream_handle_from_write_req(write_req: *uv_write_t) -> *uv_stream_t 
get_udp_handle_from_send_req			pub unsafe fn get_udp_handle_from_send_req(send_req: *uv_udp_send_t) -> *uv_udp_t 
get_winsize			    fn get_winsize(&mut self) -> Result<(int, int), IoError> 
getaddrinfo_cb			        extern fn getaddrinfo_cb(req: *uvll::uv_getaddrinfo_t,
go_to_IO_home			    fn go_to_IO_home(&mut self) -> uint 
grant			    pub fn grant<'a>(&'a mut self, missile: HomingMissile) -> Guard<'a> 
guess_handle			pub unsafe fn guess_handle(handle: c_int) -> c_int 
handle			    pub fn handle(&self) -> *uvll::uv_pipe_t { self.stream.handle }
handle			    pub fn handle(&self) -> *uvll::uv_async_t 
handle_sanity_check			fn handle_sanity_check() 
has_active_io			    fn has_active_io(&self) -> bool 
hear_broadcasts			    fn hear_broadcasts(&mut self) -> Result<(), IoError> 
home			    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }
home			    fn home<'r>(&'r mut self) -> &'r mut HomeHandle;
home			    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }
home			    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { self.listener.home() }
home			    fn home<'a>(&'a mut self) -> &'a mut HomeHandle { &mut self.home }
home			    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }
home			    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.listener.home }
home			    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }
home			    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }
home			    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }
home			    fn home<'a>(&'a mut self) -> &'a mut HomeHandle { &mut self.home }
homing			mod homing;
htons			pub fn htons(u: u16) -> u16 { mem::to_be16(u as i16) as u16 }
id			    fn id(&self) -> libc::pid_t 
idle			pub mod idle;
idle_cb			extern fn idle_cb(handle: *uvll::uv_idle_t, status: c_int) 
ignore_broadcasts			    fn ignore_broadcasts(&mut self) -> Result<(), IoError> 
increment			    fn increment(&self) 
install			    fn install(~self) -> ~Self 
io			    impl io::Writer for Stderr 
io			    fn io<'a>(&'a mut self) -> Option<&'a mut rtio::IoFactory> 
is_dir			    pub fn is_dir(&self) -> bool 
is_eof			    pub fn is_eof(&self) -> bool 
is_file			    pub fn is_file(&self) -> bool 
isatty			    fn isatty(&self) -> bool 
join_multicast			    fn join_multicast(&mut self, multi: ip::IpAddr) -> Result<(), IoError> 
keepalive			    fn keepalive(&mut self, delay_in_seconds: uint) -> Result<(), IoError> 
kill			    fn kill(&mut self, signal: int) -> Result<(), IoError> 
kill			    pub fn kill(pid: libc::pid_t, signum: int) -> Result<(), UvError> 
kill			    fn kill(&mut self, pid: libc::pid_t, signum: int) -> Result<(), IoError> 
l			    fn l() -> &mut Loop { &mut local_loop().loop_ }
leave_multicast			    fn leave_multicast(&mut self, multi: ip::IpAddr) -> Result<(), IoError> 
letdie			    fn letdie(&mut self) -> Result<(), IoError> 
link			    pub fn link(loop_: &Loop, src: &CString, dst: &CString)
listen			    fn listen(~self) -> Result<~rtio::RtioTcpAcceptor:Send, IoError> 
listen			    fn listen(~self) -> Result<~RtioUnixAcceptor:Send, IoError> 
listen_cb			extern fn listen_cb(server: *uvll::uv_stream_t, status: c_int) 
listen_cb			extern fn listen_cb(server: *uvll::uv_stream_t, status: libc::c_int) 
listen_ip4			    fn listen_ip4() 
listen_ip6			    fn listen_ip6() 
local_id			pub fn local_id() -> uint 
local_loop			fn local_loop() -> &'static mut uvio::UvIoFactory 
loop_multicast_locally			    fn loop_multicast_locally(&mut self) -> Result<(), IoError> 
loop_new			pub unsafe fn loop_new() -> *c_void 
loop_smoke_test			    fn loop_smoke_test() 
lstat			    pub fn lstat(loop_: &Loop, path: &CString) -> Result<FileStat, UvError> 
macros			mod macros;
make_handle			    pub fn make_handle(&mut self) -> HomeHandle 
malloc_handle			pub unsafe fn malloc_handle(handle: uv_handle_type) -> *c_void 
malloc_req			pub unsafe fn malloc_req(req: uv_req_type) -> *c_void 
mk			    fn mk(v: uint) -> (~IdleWatcher, Chan) 
mkdir			    pub fn mkdir(loop_: &Loop, path: &CString, mode: c_int)
mkstat			    pub fn mkstat(&self) -> FileStat 
modify_blockers			    fn modify_blockers(&self, amt: uint) 
multicast_time_to_live			    fn multicast_time_to_live(&mut self, ttl: int) -> Result<(), IoError> 
name			    pub fn name(&self) -> ~str 
net			pub mod net;
new			    pub fn new() -> Access 
new			    pub fn new(loop_: &mut Loop, cb: ~Callback:Send) -> AsyncWatcher 
new			    pub fn new(io: &mut UvIoFactory, fd: c_int,
new			    pub fn new(id: uint, pool: &mut QueuePool) -> HomeHandle 
new			    pub fn new(loop_: &mut Loop, cb: ~Callback:Send) -> ~IdleWatcher 
new			    fn new(s: &'static str) -> ForbidSwitch 
new			    fn new(s: &'static str) -> ForbidUnwind 
new			    pub fn new() -> Loop 
new			    pub fn new(ty: uvll::uv_req_type) -> Request 
new			    pub fn new(io: &mut UvIoFactory) -> TcpWatcher 
new			    pub fn new(io: &mut UvIoFactory, ipc: bool) -> PipeWatcher 
new			    pub fn new(loop_: &mut Loop) -> ~QueuePool 
new			    pub fn new() -> Refcount 
new			    pub fn new(io: &mut UvIoFactory, signum: Signum,
new			    pub fn new(stream: *uvll::uv_stream_t) -> StreamWatcher 
new			    pub fn new(io: &mut UvIoFactory) -> ~TimerWatcher 
new			    pub fn new(io: &mut UvIoFactory, fd: libc::c_int, readable: bool)
new			    pub fn new() -> UvEventLoop 
new			    pub fn new() -> uv_stat_t 
new_home			    fn new_home(loop_: &Loop, home: HomeHandle) -> TcpWatcher 
new_home			    pub fn new_home(loop_: &Loop, home: HomeHandle, ipc: bool) -> PipeWatcher 
nodelay			    fn nodelay(&mut self) -> Result<(), IoError> 
normal_fail			    fn normal_fail() 
not_used			    fn not_used() 
ntohs			pub fn ntohs(u: u16) -> u16 { mem::from_be16(u as i16) as u16 }
on_exit			extern fn on_exit(handle: *uvll::uv_process_t,
oneshot			    fn oneshot(&mut self, msecs: u64) -> Receiver<()> 
oneshot			    fn oneshot() 
oneshot_fail			    fn oneshot_fail() 
onetime			    pub fn onetime(loop_: &mut Loop, f: proc()) 
onetime_cb			        extern fn onetime_cb(handle: *uvll::uv_idle_t, status: c_int) 
open			    pub fn open(io: &mut UvIoFactory, path: &CString, flags: int, mode: int)
open			    pub fn open(io: &mut UvIoFactory, file: libc::c_int)
override			    fn override() 
pausable_idle_callback			    fn pausable_idle_callback(&mut self, cb: ~rtio::Callback:Send)
pause			    fn pause(&mut self) 
pause_pauses			    fn pause_pauses() 
peer_name			    fn peer_name(&mut self) -> Result<ip::SocketAddr, IoError> 
period			    fn period(&mut self, msecs: u64) -> Receiver<()> 
period			    fn period() 
period_fail			    fn period_fail() 
pipe			pub mod pipe;
pipe_open			    fn pipe_open(&mut self, fd: c_int) -> Result<~rtio::RtioPipe:Send, IoError> 
populate_stat			pub unsafe fn populate_stat(req_in: *uv_fs_t, stat_out: *uv_stat_t) 
pread			    fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError> 
process			pub mod process;
process_pid			pub unsafe fn process_pid(p: *uv_process_t) -> c_int 
push			    pub fn push(&mut self, task: BlockedTask) 
pwrite			    fn pwrite(&mut self, buf: &[u8], offset: u64) -> Result<(), IoError> 
queue			mod queue;
queue			    pub fn queue(&mut self) -> Queue 
rc			mod rc;
read			    fn read(&mut self, buf: &mut [u8]) -> Result<int, IoError> 
read			    pub fn read(loop_: &Loop, fd: c_int, buf: &mut [u8], offset: i64)
read			    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> 
read			    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> 
read			    pub fn read(&mut self, buf: &mut [u8]) -> Result<uint, UvError> 
read			    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> 
read_cb			extern fn read_cb(handle: *uvll::uv_stream_t, nread: ssize_t, _buf: *Buf) 
readdir			    pub fn readdir(loop_: &Loop, path: &CString, flags: c_int)
readlink			    pub fn readlink(loop_: &Loop, path: &CString) -> Result<Path, UvError> 
receiver_goes_away_oneshot			    fn receiver_goes_away_oneshot() 
receiver_goes_away_period			    fn receiver_goes_away_period() 
recv_cb			        extern fn recv_cb(handle: *uvll::uv_udp_t, nread: ssize_t, buf: *Buf,
recvfrom			    fn recvfrom(&mut self, buf: &mut [u8])
remote_callback			    fn remote_callback(&mut self, f: ~rtio::Callback:Send)
rename			    pub fn rename(loop_: &Loop, path: &CString, to: &CString)
request_sanity_check			fn request_sanity_check() 
reset_doesnt_switch_tasks			    fn reset_doesnt_switch_tasks() 
reset_doesnt_switch_tasks2			    fn reset_doesnt_switch_tasks2() 
resume			    fn resume(&mut self) 
rmdir			    pub fn rmdir(loop_: &Loop, path: &CString) -> Result<(), UvError> 
rtio			impl rtio::RtioFileStream for FileWatcher 
rtio			impl rtio::RtioSocket for TcpAcceptor 
rtio			impl rtio::RtioSocket for TcpListener 
rtio			impl rtio::RtioSocket for TcpWatcher 
rtio			impl rtio::RtioSocket for UdpWatcher 
rtio			impl rtio::RtioTcpAcceptor for TcpAcceptor 
rtio			impl rtio::RtioTcpListener for TcpListener 
rtio			impl rtio::RtioTcpStream for TcpWatcher 
rtio			impl rtio::RtioUdpSocket for UdpWatcher 
rtio			impl rtio::EventLoop for UvEventLoop 
run			    pub fn run(loop_: &Loop, node: Option<&str>, service: Option<&str>,
run			    pub fn run(&mut self) 
run			    fn run(&mut self) 
rust_set_stdio_container_fd			    fn rust_set_stdio_container_fd(c: *uv_stdio_container_t, fd: c_int);
rust_set_stdio_container_flags			    fn rust_set_stdio_container_flags(c: *uv_stdio_container_t, flags: c_int);
rust_set_stdio_container_stream			    fn rust_set_stdio_container_stream(c: *uv_stdio_container_t,
rust_uv_get_data_for_req			    fn rust_uv_get_data_for_req(req: *c_void) -> *c_void;
rust_uv_get_data_for_uv_handle			    fn rust_uv_get_data_for_uv_handle(handle: *c_void) -> *c_void;
rust_uv_get_data_for_uv_loop			    fn rust_uv_get_data_for_uv_loop(loop_ptr: *c_void) -> *c_void;
rust_uv_get_loop_for_uv_handle			    fn rust_uv_get_loop_for_uv_handle(handle: *c_void) -> *c_void;
rust_uv_get_loop_from_fs_req			    fn rust_uv_get_loop_from_fs_req(req: *uv_fs_t) -> *uv_loop_t;
rust_uv_get_loop_from_getaddrinfo_req			    fn rust_uv_get_loop_from_getaddrinfo_req(req: *uv_fs_t) -> *uv_loop_t;
rust_uv_get_path_from_fs_req			    fn rust_uv_get_path_from_fs_req(req: *uv_fs_t) -> *c_char;
rust_uv_get_ptr_from_fs_req			    fn rust_uv_get_ptr_from_fs_req(req: *uv_fs_t) -> *libc::c_void;
rust_uv_get_result_from_fs_req			    fn rust_uv_get_result_from_fs_req(req: *uv_fs_t) -> ssize_t;
rust_uv_get_stream_handle_from_connect_req			    fn rust_uv_get_stream_handle_from_connect_req(req: *uv_connect_t) -> *uv_stream_t;
rust_uv_get_stream_handle_from_write_req			    fn rust_uv_get_stream_handle_from_write_req(req: *uv_write_t) -> *uv_stream_t;
rust_uv_get_udp_handle_from_send_req			    fn rust_uv_get_udp_handle_from_send_req(req: *uv_udp_send_t) -> *uv_udp_t;
rust_uv_guess_handle			    fn rust_uv_guess_handle(fd: c_int) -> c_int;
rust_uv_handle_type_max			    fn rust_uv_handle_type_max() -> uintptr_t;
rust_uv_loop_new			    fn rust_uv_loop_new() -> *c_void;
rust_uv_populate_uv_stat			    fn rust_uv_populate_uv_stat(req_in: *uv_fs_t, stat_out: *uv_stat_t);
rust_uv_process_pid			    fn rust_uv_process_pid(p: *uv_process_t) -> c_int;
rust_uv_req_type_max			    fn rust_uv_req_type_max() -> uintptr_t;
rust_uv_set_data_for_req			    fn rust_uv_set_data_for_req(req: *c_void, data: *c_void);
rust_uv_set_data_for_uv_handle			    fn rust_uv_set_data_for_uv_handle(handle: *c_void, data: *c_void);
rust_uv_set_data_for_uv_loop			    fn rust_uv_set_data_for_uv_loop(loop_ptr: *c_void, data: *c_void);
seek			    fn seek(&mut self, pos: i64, whence: io::SeekStyle) -> Result<u64, IoError> 
seek_common			    fn seek_common(&mut self, pos: i64, whence: c_int) ->
send			    fn send(&mut self, task: BlockedTask) 
send_cb			        extern fn send_cb(req: *uvll::uv_udp_send_t, status: c_int) 
sender_goes_away_oneshot			    fn sender_goes_away_oneshot() 
sender_goes_away_period			    fn sender_goes_away_period() 
sendto			    fn sendto(&mut self, buf: &[u8], dst: ip::SocketAddr) -> Result<(), IoError> 
set_data			    pub fn set_data<T>(&self, t: *T) 
set_data_for_req			pub unsafe fn set_data_for_req<T, U>(req: *T, data: *U) 
set_data_for_uv_handle			pub unsafe fn set_data_for_uv_handle<T, U>(handle: *T, data: *U) 
set_data_for_uv_loop			pub unsafe fn set_data_for_uv_loop(loop_ptr: *c_void, data: *c_void) 
set_raw			    fn set_raw(&mut self, raw: bool) -> Result<(), IoError> 
set_stdio			unsafe fn set_stdio(dst: *uvll::uv_stdio_container_t,
set_stdio_container_fd			pub unsafe fn set_stdio_container_fd(c: *uv_stdio_container_t,
set_stdio_container_flags			pub unsafe fn set_stdio_container_flags(c: *uv_stdio_container_t,
set_stdio_container_stream			pub unsafe fn set_stdio_container_stream(c: *uv_stdio_container_t,
shutdown_cb			        extern fn shutdown_cb(req: *uvll::uv_shutdown_t, status: libc::c_int) 
signal			pub mod signal;
signal			    fn signal(&mut self, signum: Signum, channel: Sender<Signum>)
signal_cb			extern fn signal_cb(handle: *uvll::uv_signal_t, signum: c_int) 
sleep			    fn sleep(chan: &Chan) -> uint 
sleep			    fn sleep(&mut self, msecs: u64) 
sleep			    fn sleep() 
slice_to_uv_buf			pub fn slice_to_uv_buf(v: &[u8]) -> Buf 
smoke_fail			    fn smoke_fail() 
smoke_test			    fn smoke_test() 
smoke_test			    fn smoke_test() 
sockaddr_to_addr			pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,
socket_name			    fn socket_name(&mut self) -> Result<ip::SocketAddr, IoError> 
socket_name			fn socket_name(sk: SocketNameKind,
spawn			    pub fn spawn(io_loop: &mut UvIoFactory, config: process::ProcessConfig)
spawn			    fn spawn(&mut self, config: ProcessConfig)
start			fn start(argc: int, argv: **u8) -> int 
start			    fn start(&mut self, msecs: u64, period: u64) 
stat			    pub fn stat(loop_: &Loop, path: &CString) -> Result<FileStat, UvError> 
status_to_io_result			pub fn status_to_io_result(status: c_int) -> Result<(), IoError> 
status_to_maybe_uv_error			pub fn status_to_maybe_uv_error(status: c_int) -> Option<UvError> 
stop			    fn stop(&mut self) 
stream			pub mod stream;
symlink			    pub fn symlink(loop_: &Loop, src: &CString, dst: &CString)
tcp_bind			    fn tcp_bind(&mut self, addr: SocketAddr) -> Result<~rtio::RtioTcpListener:Send, IoError> 
tcp_connect			    fn tcp_connect(&mut self, addr: SocketAddr)
tcp_listener_fail_cleanup			    fn tcp_listener_fail_cleanup() 
tcp_stream_fail_cleanup			    fn tcp_stream_fail_cleanup() 
tell			    fn tell(&self) -> Result<u64, IoError> 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test_callback_run_once			fn test_callback_run_once() 
test_homing_closes_correctly			    fn test_homing_closes_correctly() 
test_homing_read			    fn test_homing_read() 
test_read_and_block			    fn test_read_and_block() 
test_read_read_read			    fn test_read_read_read() 
test_remote			mod test_remote 
test_simple_tcp_server_and_client_on_diff_threads			    fn test_simple_tcp_server_and_client_on_diff_threads() 
test_slice_to_uv_buf			    fn test_slice_to_uv_buf() 
test_udp_many_read			    fn test_udp_many_read() 
test_udp_twice			    fn test_udp_twice() 
tests			mod tests 
time_to_live			    fn time_to_live(&mut self, ttl: int) -> Result<(), IoError> 
timer			pub mod timer;
timer_cb			extern fn timer_cb(handle: *uvll::uv_timer_t, status: c_int) 
timer_init			    fn timer_init(&mut self) -> Result<~rtio::RtioTimer:Send, IoError> 
to_msec			        fn to_msec(stat: uvll::uv_timespec_t) -> u64 
truncate			    fn truncate(&mut self, offset: i64) -> Result<(), IoError> 
truncate			    pub fn truncate(loop_: &Loop, file: c_int, offset: i64)
tty			pub mod tty;
tty_open			    fn tty_open(&mut self, fd: c_int, readable: bool)
udp_bind			    fn udp_bind(&mut self, addr: SocketAddr) -> Result<~rtio::RtioUdpSocket:Send, IoError> 
udp_bind_close_ip4			    fn udp_bind_close_ip4() 
udp_bind_close_ip6			    fn udp_bind_close_ip6() 
udp_fail_other_task			    fn udp_fail_other_task() 
udp_listener_fail_cleanup			    fn udp_listener_fail_cleanup() 
udp_recv_ip4			    fn udp_recv_ip4() 
udp_recv_ip6			    fn udp_recv_ip6() 
unix_bind			    fn unix_bind(&mut self, path: &CString) -> Result<~rtio::RtioUnixListener:Send, IoError>
unix_connect			    fn unix_connect(&mut self, path: &CString) -> Result<~rtio::RtioPipe:Send, IoError> 
unlink			    pub fn unlink(loop_: &Loop, path: &CString) -> Result<(), UvError> 
unwrap			    fn unwrap(mut self) -> *uvll::uv_pipe_t 
utime			    pub fn utime(loop_: &Loop, path: &CString, atime: u64, mtime: u64)
uv_accept			    pub fn uv_accept(server: *uv_stream_t, client: *uv_stream_t) -> c_int;
uv_async_init			    pub fn uv_async_init(l: *uv_loop_t, a: *uv_async_t,
uv_async_send			    pub fn uv_async_send(a: *uv_async_t);
uv_buf_init			    pub fn uv_buf_init(base: *c_char, len: c_uint) -> uv_buf_t;
uv_buf_t			pub struct uv_buf_t 
uv_close			    pub fn uv_close(h: *uv_handle_t, cb: uv_close_cb);
uv_err_name			    pub fn uv_err_name(err: c_int) -> *c_char;
uv_error_to_io_error			pub fn uv_error_to_io_error(uverr: UvError) -> IoError 
uv_freeaddrinfo			    pub fn uv_freeaddrinfo(ai: *addrinfo);
uv_fs_chmod			    pub fn uv_fs_chmod(handle: *uv_loop_t, req: *uv_fs_t, path: *c_char,
uv_fs_chown			    pub fn uv_fs_chown(handle: *uv_loop_t, req: *uv_fs_t, src: *c_char,
uv_fs_close			    pub fn uv_fs_close(l: *uv_loop_t, req: *uv_fs_t, fd: c_int,
uv_fs_fdatasync			    pub fn uv_fs_fdatasync(handle: *uv_loop_t, req: *uv_fs_t, file: c_int,
uv_fs_fstat			    pub fn uv_fs_fstat(l: *uv_loop_t, req: *uv_fs_t, fd: c_int,
uv_fs_fsync			    pub fn uv_fs_fsync(handle: *uv_loop_t, req: *uv_fs_t, file: c_int,
uv_fs_ftruncate			    pub fn uv_fs_ftruncate(handle: *uv_loop_t, req: *uv_fs_t, file: c_int,
uv_fs_link			    pub fn uv_fs_link(handle: *uv_loop_t, req: *uv_fs_t, src: *c_char,
uv_fs_lstat			    pub fn uv_fs_lstat(handle: *uv_loop_t, req: *uv_fs_t, file: *c_char,
uv_fs_mkdir			    pub fn uv_fs_mkdir(l: *uv_loop_t, req: *uv_fs_t, path: *c_char,
uv_fs_open			    pub fn uv_fs_open(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,
uv_fs_read			    pub fn uv_fs_read(l: *uv_loop_t, req: *uv_fs_t, fd: c_int, buf: *c_void,
uv_fs_readdir			    pub fn uv_fs_readdir(l: *uv_loop_t, req: *uv_fs_t, path: *c_char,
uv_fs_readlink			    pub fn uv_fs_readlink(handle: *uv_loop_t, req: *uv_fs_t, file: *c_char,
uv_fs_rename			    pub fn uv_fs_rename(handle: *uv_loop_t, req: *uv_fs_t, src: *c_char,
uv_fs_req_cleanup			    pub fn uv_fs_req_cleanup(req: *uv_fs_t);
uv_fs_rmdir			    pub fn uv_fs_rmdir(l: *uv_loop_t, req: *uv_fs_t, path: *c_char,
uv_fs_stat			    pub fn uv_fs_stat(l: *uv_loop_t, req: *uv_fs_t, path: *c_char,
uv_fs_symlink			    pub fn uv_fs_symlink(handle: *uv_loop_t, req: *uv_fs_t, src: *c_char,
uv_fs_unlink			    pub fn uv_fs_unlink(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,
uv_fs_utime			    pub fn uv_fs_utime(handle: *uv_loop_t, req: *uv_fs_t, path: *c_char,
uv_fs_write			    pub fn uv_fs_write(l: *uv_loop_t, req: *uv_fs_t, fd: c_int, buf: *c_void,
uv_getaddrinfo			    pub fn uv_getaddrinfo(loop_: *uv_loop_t, req: *uv_getaddrinfo_t,
uv_handle			    fn uv_handle(&self) -> *uvll::uv_async_t { self.handle }
uv_handle			    fn uv_handle(&self) -> *uvll::uv_idle_t { self.handle }
uv_handle			    fn uv_handle(&self) -> *T;
uv_handle			    fn uv_handle(&self) -> *uvll::uv_tcp_t { self.handle }
uv_handle			    fn uv_handle(&self) -> *uvll::uv_tcp_t { self.stream.handle }
uv_handle			    fn uv_handle(&self) -> *uvll::uv_udp_t { self.handle }
uv_handle			    fn uv_handle(&self) -> *uvll::uv_pipe_t { self.pipe }
uv_handle			    fn uv_handle(&self) -> *uvll::uv_pipe_t { self.stream.handle }
uv_handle			    fn uv_handle(&self) -> *uvll::uv_process_t { self.handle }
uv_handle			    fn uv_handle(&self) -> *uvll::uv_signal_t { self.handle }
uv_handle			    fn uv_handle(&self) -> *uvll::uv_timer_t { self.handle }
uv_handle			    fn uv_handle(&self) -> *uvll::uv_tty_t { self.tty }
uv_handle_size			    pub fn uv_handle_size(ty: uv_handle_type) -> size_t;
uv_handle_type			pub enum uv_handle_type 
uv_idle_init			    pub fn uv_idle_init(l: *uv_loop_t, i: *uv_idle_t) -> c_int;
uv_idle_start			    pub fn uv_idle_start(i: *uv_idle_t, cb: uv_idle_cb) -> c_int;
uv_idle_stop			    pub fn uv_idle_stop(i: *uv_idle_t) -> c_int;
uv_kill			    pub fn uv_kill(pid: c_int, signum: c_int) -> c_int;
uv_listen			    pub fn uv_listen(s: *uv_stream_t, backlog: c_int,
uv_loop			    fn uv_loop(&self) -> Loop 
uv_loop			    pub fn uv_loop<'a>(&mut self) -> *uvll::uv_loop_t { self.loop_.handle }
uv_loop_delete			    pub fn uv_loop_delete(l: *uv_loop_t);
uv_membership			pub enum uv_membership 
uv_pipe_bind			    pub fn uv_pipe_bind(pipe: *uv_pipe_t, name: *c_char) -> c_int;
uv_pipe_connect			    pub fn uv_pipe_connect(req: *uv_connect_t, handle: *uv_pipe_t,
uv_pipe_init			    pub fn uv_pipe_init(l: *uv_loop_t, p: *uv_pipe_t, ipc: c_int) -> c_int;
uv_pipe_open			    pub fn uv_pipe_open(pipe: *uv_pipe_t, file: c_int) -> c_int;
uv_process_kill			    pub fn uv_process_kill(p: *uv_process_t, signum: c_int) -> c_int;
uv_process_options_t			pub struct uv_process_options_t 
uv_read_start			    pub fn uv_read_start(stream: *uv_stream_t,
uv_read_stop			    pub fn uv_read_stop(stream: *uv_stream_t) -> c_int;
uv_ref			    pub fn uv_ref(t: *uv_handle_t);
uv_req_size			    pub fn uv_req_size(ty: uv_req_type) -> size_t;
uv_req_type			pub enum uv_req_type 
uv_run			    pub fn uv_run(l: *uv_loop_t, mode: uv_run_mode) -> c_int;
uv_run_mode			pub enum uv_run_mode 
uv_shutdown			    pub fn uv_shutdown(req: *uv_shutdown_t, handle: *uv_stream_t,
uv_signal_init			    pub fn uv_signal_init(loop_: *uv_loop_t, handle: *uv_signal_t) -> c_int;
uv_signal_start			    pub fn uv_signal_start(h: *uv_signal_t, cb: uv_signal_cb,
uv_signal_stop			    pub fn uv_signal_stop(handle: *uv_signal_t) -> c_int;
uv_spawn			    pub fn uv_spawn(loop_ptr: *uv_loop_t, outptr: *uv_process_t,
uv_stat_t			impl uv_stat_t 
uv_stat_t			pub struct uv_stat_t 
uv_stdio_container_t			pub struct uv_stdio_container_t 
uv_strerror			    pub fn uv_strerror(err: c_int) -> *c_char;
uv_tcp_bind			    pub fn uv_tcp_bind(t: *uv_tcp_t, addr: *sockaddr) -> c_int;
uv_tcp_connect			    pub fn uv_tcp_connect(c: *uv_connect_t, h: *uv_tcp_t,
uv_tcp_getpeername			    pub fn uv_tcp_getpeername(h: *uv_tcp_t, name: *mut sockaddr,
uv_tcp_getsockname			    pub fn uv_tcp_getsockname(h: *uv_tcp_t, name: *mut sockaddr,
uv_tcp_init			    pub fn uv_tcp_init(l: *uv_loop_t, h: *uv_tcp_t) -> c_int;
uv_tcp_keepalive			    pub fn uv_tcp_keepalive(h: *uv_tcp_t, enable: c_int,
uv_tcp_nodelay			    pub fn uv_tcp_nodelay(h: *uv_tcp_t, enable: c_int) -> c_int;
uv_tcp_simultaneous_accepts			    pub fn uv_tcp_simultaneous_accepts(h: *uv_tcp_t, enable: c_int) -> c_int;
uv_timer_init			    pub fn uv_timer_init(l: *uv_loop_t, t: *uv_timer_t) -> c_int;
uv_timer_start			    pub fn uv_timer_start(t: *uv_timer_t, cb: uv_timer_cb,
uv_timer_stop			    pub fn uv_timer_stop(handle: *uv_timer_t) -> c_int;
uv_timespec_t			pub struct uv_timespec_t 
uv_tty_get_winsize			    pub fn uv_tty_get_winsize(tty: *uv_tty_t, width: *c_int,
uv_tty_init			    pub fn uv_tty_init(l: *uv_loop_t, tty: *uv_tty_t, fd: c_int,
uv_tty_set_mode			    pub fn uv_tty_set_mode(tty: *uv_tty_t, mode: c_int) -> c_int;
uv_udp_bind			    pub fn uv_udp_bind(h: *uv_udp_t, addr: *sockaddr, flags: c_uint) -> c_int;
uv_udp_getsockname			    pub fn uv_udp_getsockname(h: *uv_udp_t, name: *mut sockaddr,
uv_udp_init			    pub fn uv_udp_init(l: *uv_loop_t, h: *uv_udp_t) -> c_int;
uv_udp_recv_start			    pub fn uv_udp_recv_start(server: *uv_udp_t,
uv_udp_recv_stop			    pub fn uv_udp_recv_stop(server: *uv_udp_t) -> c_int;
uv_udp_send			        fn uv_udp_send(req: *uv_write_t, stream: *uv_stream_t,
uv_udp_send			pub unsafe fn uv_udp_send(req: *uv_udp_send_t,
uv_udp_set_broadcast			    pub fn uv_udp_set_broadcast(handle: *uv_udp_t, on: c_int) -> c_int;
uv_udp_set_membership			    pub fn uv_udp_set_membership(handle: *uv_udp_t, multicast_addr: *c_char,
uv_udp_set_multicast_loop			    pub fn uv_udp_set_multicast_loop(handle: *uv_udp_t, on: c_int) -> c_int;
uv_udp_set_multicast_ttl			    pub fn uv_udp_set_multicast_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int;
uv_udp_set_ttl			    pub fn uv_udp_set_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int;
uv_unref			    pub fn uv_unref(t: *uv_handle_t);
uv_walk			    pub fn uv_walk(l: *uv_loop_t, cb: uv_walk_cb, arg: *c_void);
uv_write			        fn uv_write(req: *uv_write_t, stream: *uv_stream_t,
uv_write			pub unsafe fn uv_write(req: *uv_write_t,
uvio			pub mod uvio;
uvll			pub mod uvll;
wait			    fn wait(&mut self) -> process::ProcessExit 
wait_until_woken_after			fn wait_until_woken_after(slot: *mut Option<BlockedTask>,
wakeup			fn wakeup(slot: &mut Option<BlockedTask>) 
with_argv			fn with_argv<T>(prog: &str, args: &[~str], f: |**libc::c_char| -> T) -> T 
with_env			fn with_env<T>(env: Option<&[(~str, ~str)]>, f: |**libc::c_char| -> T) -> T 
wrap			    pub fn wrap(handle: *uvll::uv_loop_t) -> Loop { Loop { handle: handle } }
wrap			    pub fn wrap(handle: *uvll::uv_req_t) -> Request 
write			    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> 
write			    pub fn write(loop_: &Loop, fd: c_int, buf: &[u8], offset: i64)
write			        fn write(&mut self, data: &[u8]) -> io::IoResult<()> 
write			    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> 
write			    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> 
write			    pub fn write(&mut self, buf: &[u8]) -> Result<(), UvError> 
write			    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> 
write_cb			extern fn write_cb(req: *uvll::uv_write_t, status: c_int) 
