AcceptTimeout			impl AcceptTimeout 
AcceptTimeout			pub struct AcceptTimeout 
Access			impl Access 
Access			pub struct Access 
AccessTimeout			impl AccessTimeout 
AccessTimeout			pub struct AccessTimeout 
Addrinfo			struct Addrinfo 
AsyncWatcher			impl AsyncWatcher 
AsyncWatcher			pub struct AsyncWatcher 
Callback			        impl Callback for MyCallback 
Callback			    impl Callback for MyCallback 
ClientState			enum ClientState 
Clone			impl Clone for Access 
Clone			impl Clone for HomeHandle 
Clone			impl Clone for Queue 
Clone			impl Clone for Refcount 
Clone			impl Clone for AccessTimeout 
ConnectCtx			impl ConnectCtx 
ConnectCtx			pub struct ConnectCtx 
Ctx			struct Ctx 
Ctx			    struct Ctx 
Drop			impl Drop for Inner 
Drop			impl Drop for Addrinfo 
Drop			impl Drop for AsyncWatcher 
Drop			impl Drop for FileWatcher 
Drop			impl Drop for FsRequest 
Drop			impl Drop for HomingMissile 
Drop			impl Drop for IdleWatcher 
Drop			impl Drop for ForbidSwitch 
Drop			impl Drop for ForbidUnwind 
Drop			impl Drop for Request 
Drop			impl Drop for TcpListener 
Drop			impl Drop for TcpWatcher 
Drop			impl Drop for UdpWatcher 
Drop			impl Drop for PipeListener 
Drop			impl Drop for PipeWatcher 
Drop			impl Drop for Process 
Drop			impl Drop for Queue 
Drop			impl Drop for State 
Drop			impl Drop for SignalWatcher 
Drop			impl Drop for AccessTimeout 
Drop			impl Drop for TimerWatcher 
Drop			impl Drop for TtyWatcher 
Drop			impl Drop for UvEventLoop 
EventLoop			impl EventLoop for UvEventLoop 
FileWatcher			impl FileWatcher 
FileWatcher			pub struct FileWatcher 
ForbidSwitch			impl ForbidSwitch 
ForbidSwitch			pub struct ForbidSwitch 
ForbidUnwind			impl ForbidUnwind 
ForbidUnwind			pub struct ForbidUnwind 
FsRequest			impl FsRequest 
FsRequest			pub struct FsRequest 
GetAddrInfoRequest			impl GetAddrInfoRequest 
GetAddrInfoRequest			pub struct GetAddrInfoRequest;
Guard			pub struct Guard<'a> 
Guard			pub struct Guard<'a> 
HomeHandle			impl HomeHandle 
HomeHandle			pub struct HomeHandle 
HomingIO			impl HomingIO for FileWatcher 
HomingIO			pub trait HomingIO 
HomingIO			impl HomingIO for TcpAcceptor 
HomingIO			impl HomingIO for TcpListener 
HomingIO			impl HomingIO for TcpWatcher 
HomingIO			impl HomingIO for UdpWatcher 
HomingIO			impl HomingIO for PipeAcceptor 
HomingIO			impl HomingIO for PipeListener 
HomingIO			impl HomingIO for PipeWatcher 
HomingIO			impl HomingIO for Process 
HomingIO			impl HomingIO for SignalWatcher 
HomingIO			impl HomingIO for TimerWatcher 
HomingIO			impl HomingIO for TtyWatcher 
HomingMissile			impl HomingMissile 
HomingMissile			pub struct HomingMissile 
IdleWatcher			impl IdleWatcher 
IdleWatcher			pub struct IdleWatcher 
Inner			struct Inner 
IoFactory			impl IoFactory for UvIoFactory 
Loop			impl Loop 
Loop			pub struct Loop 
Message			enum Message 
MyCallback			        struct MyCallback(Option<Sender<int>>);
MyCallback			    struct MyCallback(Rc<RefCell<(Option<BlockedTask>, uint)>>, uint);
NextAction			pub enum NextAction 
PausableIdleCallback			impl PausableIdleCallback for IdleWatcher 
Payload			struct Payload 
PipeAcceptor			pub struct PipeAcceptor 
PipeListener			impl PipeListener 
PipeListener			pub struct PipeListener 
PipeWatcher			impl PipeWatcher 
PipeWatcher			pub struct PipeWatcher 
Process			impl Process 
Process			pub struct Process 
Queue			impl Queue 
Queue			pub struct Queue 
QueuePool			impl QueuePool 
QueuePool			pub struct QueuePool 
ReadContext			struct ReadContext 
Refcount			impl Refcount 
Refcount			pub struct Refcount 
RemoteCallback			impl RemoteCallback for AsyncWatcher 
Request			impl Request 
Request			pub struct Request 
RtioSignal			impl RtioSignal for SignalWatcher {}
RtioTTY			impl RtioTTY for TtyWatcher 
RtioTimer			impl RtioTimer for TimerWatcher 
SignalWatcher			impl SignalWatcher 
SignalWatcher			pub struct SignalWatcher 
SocketNameKind			enum SocketNameKind 
State			struct State 
StreamWatcher			impl StreamWatcher 
StreamWatcher			pub struct StreamWatcher 
TcpAcceptor			pub struct TcpAcceptor 
TcpListener			impl TcpListener 
TcpListener			pub struct TcpListener 
TcpWatcher			impl TcpWatcher 
TcpWatcher			pub struct TcpWatcher 
TimeoutState			enum TimeoutState 
TimeoutState			enum TimeoutState 
TimerContext			struct TimerContext 
TimerWatcher			impl TimerWatcher 
TimerWatcher			pub struct TimerWatcher 
TtyWatcher			impl TtyWatcher 
TtyWatcher			pub struct TtyWatcher
UdpRecvCtx			struct UdpRecvCtx 
UdpSendCtx			struct UdpSendCtx 
UdpWatcher			impl UdpWatcher 
UdpWatcher			pub struct UdpWatcher 
UvError			impl UvError 
UvError			pub struct UvError(c_int);
UvEventLoop			impl UvEventLoop 
UvEventLoop			pub struct UvEventLoop 
UvHandle			impl UvHandle<uvll::uv_async_t> for AsyncWatcher 
UvHandle			impl UvHandle<uvll::uv_idle_t> for IdleWatcher 
UvHandle			pub trait UvHandle<T> 
UvHandle			impl UvHandle<uvll::uv_tcp_t> for TcpListener 
UvHandle			impl UvHandle<uvll::uv_tcp_t> for TcpWatcher 
UvHandle			impl UvHandle<uvll::uv_udp_t> for UdpWatcher 
UvHandle			impl UvHandle<uvll::uv_pipe_t> for PipeListener 
UvHandle			impl UvHandle<uvll::uv_pipe_t> for PipeWatcher 
UvHandle			impl UvHandle<uvll::uv_process_t> for Process 
UvHandle			impl UvHandle<uvll::uv_signal_t> for SignalWatcher 
UvHandle			impl UvHandle<uvll::uv_timer_t> for TimerWatcher 
UvHandle			impl UvHandle<uvll::uv_tty_t> for TtyWatcher 
UvIoFactory			impl UvIoFactory 
UvIoFactory			pub struct UvIoFactory 
WriteContext			struct WriteContext 
accept			    fn accept(&mut self) -> Result<Box<rtio::RtioTcpStream + Send>, IoError> 
accept			    fn accept(&mut self) -> IoResult<Box<rtio::RtioPipe + Send>> 
accept			    pub fn accept<T: Send>(&mut self, c: &Receiver<IoResult<T>>) -> IoResult<T> 
accept_simultaneously			    fn accept_simultaneously(&mut self) -> Result<(), IoError> 
access			mod access;
accum_addrinfo			pub fn accum_addrinfo(addr: &Addrinfo) -> Vec<rtio::AddrinfoInfo> 
addr_to_sockaddr			fn addr_to_sockaddr(addr: rtio::SocketAddr) -> (libc::sockaddr_storage, uint) 
addrinfo			pub mod addrinfo;
alloc			    fn alloc(_: Option<Self>, ty: uvll::uv_handle_type) -> *mut T 
alloc_cb			        extern fn alloc_cb(handle: *mut uvll::uv_udp_t,
alloc_cb			extern fn alloc_cb(stream: *mut uvll::uv_stream_t, _hint: size_t, buf: *mut Buf) 
async			pub mod async;
async_cb			extern fn async_cb(handle: *mut uvll::uv_async_t) 
async_cb			extern fn async_cb(handle: *mut uvll::uv_async_t) 
base_read			    fn base_read(&mut self, buf: &mut [u8], offset: i64) -> IoResult<int> 
base_write			    fn base_write(&mut self, buf: &[u8], offset: i64) -> IoResult<()> 
bind			    pub fn bind(io: &mut UvIoFactory, address: rtio::SocketAddr)
bind			    fn bind() 
bind			    pub fn bind(io: &mut UvIoFactory, name: &CString)
bind_err			    fn bind_err() 
bind_fail			    fn bind_fail() 
call			            fn call(&mut self) 
call			        fn call(&mut self) 
callback			    fn callback(&mut self, f: proc()) 
cancel_read			        fn cancel_read(stream: uint) -> Option<BlockedTask> 
cancel_read			        fn cancel_read(stream: uint) -> Option<BlockedTask> 
cancel_read			    pub fn cancel_read(&mut self, reason: ssize_t) -> Option<BlockedTask> 
cancel_write			        fn cancel_write(stream: uint) -> Option<BlockedTask> 
cancel_write			        fn cancel_write(stream: uint) -> Option<BlockedTask> 
cancel_write			    pub fn cancel_write(&mut self) -> Option<BlockedTask> 
check			    pub fn check(&self, msg: &'static str) 
chmod			    pub fn chmod(loop_: &Loop, path: &CString, mode: c_int)
chown			    pub fn chown(loop_: &Loop, path: &CString, uid: int, gid: int)
clear			    pub fn clear(&mut self) 
clone			    fn clone(&self) -> Access 
clone			    fn clone(&self) -> HomeHandle 
clone			    fn clone(&self) -> Box<rtio::RtioTcpStream + Send> 
clone			    fn clone(&self) -> Box<rtio::RtioUdpSocket + Send> 
clone			    fn clone(&self) -> Box<rtio::RtioPipe + Send> 
clone			    fn clone(&self) -> Queue 
clone			    fn clone(&self) -> Refcount 
clone			    fn clone(&self) -> AccessTimeout 
close			    pub fn close(&self, _missile: &HomingMissile) 
close			    fn close(&mut self) 
close			    pub fn close(&mut self) 
close_async_			    fn close_async_(&mut self) 
close_cb			extern fn close_cb(handle: *mut uvll::uv_handle_t) 
close_cb			                extern fn close_cb(req: *mut uvll::uv_fs_t) 
close_cb			        extern fn close_cb(handle: *mut uvll::uv_handle_t) 
close_cb			        extern fn close_cb(handle: *mut uvll::uv_handle_t) 
close_read			    fn close_read(&mut self) -> Result<(), IoError> 
close_read			    fn close_read(&mut self) -> IoResult<()> 
close_write			    fn close_write(&mut self) -> Result<(), IoError> 
close_write			    fn close_write(&mut self) -> IoResult<()> 
connect			    pub fn connect(io: &mut UvIoFactory,
connect			    fn connect() 
connect			    pub fn connect(io: &mut UvIoFactory, name: &CString, timeout: Option<u64>)
connect			    pub fn connect<T>(
connect_cb			        extern fn connect_cb(req: *mut uvll::uv_connect_t, status: c_int) 
connect_close_ip4			    fn connect_close_ip4() 
connect_close_ip6			    fn connect_close_ip6() 
connect_err			    fn connect_err() 
connect_fail			    fn connect_fail() 
control_congestion			    fn control_congestion(&mut self) -> Result<(), IoError> 
datasync			    fn datasync(&mut self) -> IoResult<()> 
datasync			    pub fn datasync(loop_: &Loop, fd: c_int) -> Result<(), UvError> 
decrement			    pub fn decrement(&self) -> bool 
defuse			    pub fn defuse(&mut self) 
dequeue			    pub unsafe fn dequeue(&mut self, token: uint) -> Option<BlockedTask> 
desc			    pub fn desc(&self) -> String 
dont_accept_simultaneously			    fn dont_accept_simultaneously(&mut self) -> Result<(), IoError> 
dont_loop_multicast_locally			    fn dont_loop_multicast_locally(&mut self) -> Result<(), IoError> 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
dumb_println			pub fn dumb_println(args: &fmt::Arguments) 
empty_buf			pub fn empty_buf() -> Buf 
error_smoke_test			fn error_smoke_test() 
errors			pub mod errors 
event_loop			pub fn event_loop() -> Box<rtio::EventLoop + Send> 
execute			fn execute(f: |*mut uvll::uv_fs_t, uvll::uv_fs_cb| -> c_int)
execute_nop			fn execute_nop(f: |*mut uvll::uv_fs_t, uvll::uv_fs_cb| -> c_int)
file			pub mod file;
file_test_full_simple_sync			    fn file_test_full_simple_sync() 
file_test_mk_rm_dir			    fn file_test_mk_rm_dir() 
file_test_mkdir_chokes_on_double_create			    fn file_test_mkdir_chokes_on_double_create() 
file_test_rmdir_chokes_on_nonexistant_path			    fn file_test_rmdir_chokes_on_nonexistant_path() 
file_test_stat			    fn file_test_stat() 
fire			    fn fire(&mut self) 
fire_homing_missile			    fn fire_homing_missile(&mut self) -> HomingMissile 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			impl fmt::Show for UvError 
free			        fn free<T>(_: T) {}
free_handle			pub unsafe fn free_handle(v: *mut c_void) 
free_req			pub unsafe fn free_req(v: *mut c_void) 
from_uv_handle			    unsafe fn from_uv_handle<'a>(_: &'a *mut uvll::uv_async_t) -> &'a mut AsyncWatcher 
from_uv_handle			    unsafe fn from_uv_handle<'a>(h: &'a *mut T) -> &'a mut Self 
fs_cb			    extern fn fs_cb(req: *mut uvll::uv_fs_t) 
fs_chmod			    fn fs_chmod(&mut self, path: &CString, perm: uint) -> IoResult<()> 
fs_chown			    fn fs_chown(&mut self, path: &CString, uid: int, gid: int) -> IoResult<()> 
fs_from_raw_fd			    fn fs_from_raw_fd(&mut self, fd: c_int, close: rtio::CloseBehavior)
fs_link			    fn fs_link(&mut self, src: &CString, dst: &CString) -> IoResult<()> 
fs_lstat			    fn fs_lstat(&mut self, path: &CString) -> IoResult<rtio::FileStat> 
fs_mkdir			    fn fs_mkdir(&mut self, path: &CString, perm: uint) -> IoResult<()> 
fs_open			    fn fs_open(&mut self, path: &CString, fm: rtio::FileMode,
fs_readdir			    fn fs_readdir(&mut self, path: &CString, flags: c_int)
fs_readlink			    fn fs_readlink(&mut self, path: &CString) -> IoResult<CString> 
fs_rename			    fn fs_rename(&mut self, path: &CString, to: &CString) -> IoResult<()> 
fs_rmdir			    fn fs_rmdir(&mut self, path: &CString) -> IoResult<()> 
fs_stat			    fn fs_stat(&mut self, path: &CString) -> IoResult<rtio::FileStat> 
fs_symlink			    fn fs_symlink(&mut self, src: &CString, dst: &CString) -> IoResult<()> 
fs_unlink			    fn fs_unlink(&mut self, path: &CString) -> IoResult<()> 
fs_utime			    fn fs_utime(&mut self, path: &CString, atime: u64, mtime: u64)
fstat			    fn fstat(&mut self) -> IoResult<rtio::FileStat> 
fstat			    pub fn fstat(loop_: &Loop, fd: c_int) -> Result<rtio::FileStat, UvError> 
fsync			    fn fsync(&mut self) -> IoResult<()> 
fsync			    pub fn fsync(loop_: &Loop, fd: c_int) -> Result<(), UvError> 
fun_combinations_of_methods			    fn fun_combinations_of_methods() 
get_blockers			    fn get_blockers(&self) -> uint 
get_data			    pub unsafe fn get_data<T>(&self) -> &'static mut T 
get_data_for_req			pub unsafe fn get_data_for_req<T>(req: *mut T) -> *mut c_void 
get_data_for_uv_handle			pub unsafe fn get_data_for_uv_handle<T>(handle: *mut T) -> *mut c_void 
get_data_for_uv_loop			pub unsafe fn get_data_for_uv_loop(loop_ptr: *mut c_void) -> *mut c_void 
get_host_addresses			    fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,
get_loop_for_uv_handle			pub unsafe fn get_loop_for_uv_handle<T>(handle: *mut T) -> *mut c_void 
get_loop_from_fs_req			pub unsafe fn get_loop_from_fs_req(req: *mut uv_fs_t) -> *mut uv_loop_t 
get_loop_from_getaddrinfo_req			pub unsafe fn get_loop_from_getaddrinfo_req(req: *mut uv_getaddrinfo_t) -> *mut uv_loop_t 
get_path_from_fs_req			pub unsafe fn get_path_from_fs_req(req: *mut uv_fs_t) -> *mut c_char 
get_ptr			    pub fn get_ptr(&self) -> *mut libc::c_void 
get_ptr_from_fs_req			pub unsafe fn get_ptr_from_fs_req(req: *mut uv_fs_t) -> *mut libc::c_void 
get_result			    pub fn get_result(&self) -> ssize_t 
get_result_from_fs_req			pub unsafe fn get_result_from_fs_req(req: *mut uv_fs_t) -> ssize_t 
get_stat			    pub fn get_stat(&self) -> uvll::uv_stat_t 
get_stream_handle_from_connect_req			pub unsafe fn get_stream_handle_from_connect_req(connect: *mut uv_connect_t) -> *mut uv_stream_t 
get_stream_handle_from_write_req			pub unsafe fn get_stream_handle_from_write_req(write_req: *mut uv_write_t) -> *mut uv_stream_t 
get_udp_handle_from_send_req			pub unsafe fn get_udp_handle_from_send_req(send_req: *mut uv_udp_send_t) -> *mut uv_udp_t 
get_winsize			    fn get_winsize(&mut self) -> IoResult<(int, int)> 
getaddrinfo_cb			        extern fn getaddrinfo_cb(req: *mut uvll::uv_getaddrinfo_t,
go_to_io_home			    fn go_to_io_home(&mut self) -> uint 
grant			    pub fn grant<'a>(&'a mut self, token: uint,
grant			    pub fn grant<'a>(&'a mut self, m: HomingMissile) -> IoResult<Guard<'a>> 
guess_handle			pub unsafe fn guess_handle(handle: c_int) -> c_int 
handle			    pub fn handle(&self) -> *mut uvll::uv_pipe_t { self.stream.handle }
handle			    pub fn handle(&self) -> *mut uvll::uv_async_t { self.queue.handle }
handle_sanity_check			fn handle_sanity_check() 
has_active_io			    fn has_active_io(&self) -> bool 
hear_broadcasts			    fn hear_broadcasts(&mut self) -> Result<(), IoError> 
home			    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }
home			    fn home<'r>(&'r mut self) -> &'r mut HomeHandle;
home			    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }
home			    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { self.listener.home() }
home			    fn home<'a>(&'a mut self) -> &'a mut HomeHandle { &mut self.home }
home			    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }
home			    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.listener.home }
home			    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }
home			    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }
home			    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }
home			    fn home<'a>(&'a mut self) -> &'a mut HomeHandle { &mut self.home }
homing			mod homing;
htons			pub fn htons(u: u16) -> u16 { u.to_be() }
id			    fn id(&self) -> libc::pid_t 
idle			pub mod idle;
idle_cb			extern fn idle_cb(handle: *mut uvll::uv_idle_t) 
ignore_broadcasts			    fn ignore_broadcasts(&mut self) -> Result<(), IoError> 
increment			    fn increment(&self) 
install			    fn install(~self) -> Box<Self> 
io			    fn io<'a>(&'a mut self) -> Option<&'a mut rtio::IoFactory> 
is_closed			    pub fn is_closed(&self) -> bool 
is_dir			    pub fn is_dir(&self) -> bool 
is_eof			    pub fn is_eof(&self) -> bool 
is_file			    pub fn is_file(&self) -> bool 
isatty			    fn isatty(&self) -> bool 
join_multicast			    fn join_multicast(&mut self, multi: rtio::IpAddr) -> Result<(), IoError> 
keepalive			    fn keepalive(&mut self, delay_in_seconds: uint) -> Result<(), IoError> 
kill			    fn kill(&mut self, signal: int) -> IoResult<()> 
kill			    pub fn kill(pid: libc::pid_t, signum: int) -> Result<(), UvError> 
kill			    fn kill(&mut self, pid: libc::pid_t, signum: int) -> IoResult<()> 
l			    fn l() -> &mut Loop { &mut local_loop().loop_ }
leave_multicast			    fn leave_multicast(&mut self, multi: rtio::IpAddr) -> Result<(), IoError> 
letdie			    fn letdie(&mut self) -> Result<(), IoError> 
link			    pub fn link(loop_: &Loop, src: &CString, dst: &CString)
listen			    fn listen(~self) -> Result<Box<rtio::RtioTcpAcceptor + Send>, IoError> 
listen			    fn listen(~self) -> IoResult<Box<rtio::RtioUnixAcceptor + Send>> 
listen_cb			extern fn listen_cb(server: *mut uvll::uv_stream_t, status: c_int) 
listen_cb			extern fn listen_cb(server: *mut uvll::uv_stream_t, status: libc::c_int) 
listen_ip4			    fn listen_ip4() 
listen_ip6			    fn listen_ip6() 
local_id			pub fn local_id() -> uint 
local_loop			fn local_loop() -> &'static mut uvio::UvIoFactory 
loop_multicast_locally			    fn loop_multicast_locally(&mut self) -> Result<(), IoError> 
loop_new			pub unsafe fn loop_new() -> *mut c_void 
loop_smoke_test			    fn loop_smoke_test() 
lstat			    pub fn lstat(loop_: &Loop, path: &CString)
macros			mod macros;
make_handle			    pub fn make_handle(&mut self) -> HomeHandle 
malloc_handle			pub unsafe fn malloc_handle(handle: uv_handle_type) -> *mut c_void 
malloc_req			pub unsafe fn malloc_req(req: uv_req_type) -> *mut c_void 
mk			    fn mk(v: uint) -> (Box<IdleWatcher>, Chan) 
mkdir			    pub fn mkdir(loop_: &Loop, path: &CString, mode: c_int)
mkstat			    pub fn mkstat(&self) -> rtio::FileStat 
modify_blockers			    fn modify_blockers(&self, amt: uint) 
multicast_time_to_live			    fn multicast_time_to_live(&mut self, ttl: int) -> Result<(), IoError> 
name			    pub fn name(&self) -> String 
net			pub mod net;
new			    pub fn new() -> Access 
new			    pub fn new(loop_: &mut Loop, cb: Box<Callback + Send>) -> AsyncWatcher 
new			    pub fn new(io: &mut UvIoFactory, fd: c_int,
new			    pub fn new(id: uint, pool: &mut QueuePool) -> HomeHandle 
new			    pub fn new(loop_: &mut Loop, cb: Box<Callback + Send>) -> Box<IdleWatcher> 
new			    fn new(s: &'static str) -> ForbidSwitch 
new			    fn new(s: &'static str) -> ForbidUnwind 
new			    pub fn new() -> Loop 
new			    pub fn new(ty: uvll::uv_req_type) -> Request 
new			    pub fn new(io: &mut UvIoFactory) -> TcpWatcher 
new			    pub fn new(io: &mut UvIoFactory, ipc: bool) -> PipeWatcher 
new			    pub fn new(loop_: &mut Loop) -> Box<QueuePool> 
new			    pub fn new() -> Refcount 
new			    pub fn new(io: &mut UvIoFactory, signum: int, cb: Box<Callback + Send>)
new			    pub fn new(stream: *mut uvll::uv_stream_t,
new			    pub fn new() -> AcceptTimeout 
new			    pub fn new() -> AccessTimeout 
new			    pub fn new(io: &mut UvIoFactory) -> Box<TimerWatcher> 
new			    pub fn new(io: &mut UvIoFactory, fd: libc::c_int, readable: bool)
new			    pub fn new() -> UvEventLoop 
new			    pub fn new() -> uv_stat_t 
new_home			    fn new_home(loop_: &Loop, home: HomeHandle) -> TcpWatcher 
new_home			    pub fn new_home(loop_: &Loop, home: HomeHandle, ipc: bool) -> PipeWatcher 
new_home			    pub fn new_home(loop_: &Loop, home: HomeHandle) -> TimerWatcher 
next_test_ip4			fn next_test_ip4() -> std::rt::rtio::SocketAddr 
next_test_ip6			fn next_test_ip6() -> std::rt::rtio::SocketAddr 
nodelay			    fn nodelay(&mut self) -> Result<(), IoError> 
not_used			    fn not_used() 
ntohs			pub fn ntohs(u: u16) -> u16 { Int::from_be(u) }
on_exit			extern fn on_exit(handle: *mut uvll::uv_process_t,
oneshot			    fn oneshot(&mut self, msecs: u64, cb: Box<Callback + Send>) 
onetime			    pub fn onetime(loop_: &mut Loop, f: proc()) 
onetime_cb			        extern fn onetime_cb(handle: *mut uvll::uv_idle_t) 
open			    pub fn open(io: &mut UvIoFactory, path: &CString, flags: int, mode: int)
open			    pub fn open(io: &mut UvIoFactory, file: libc::c_int)
pausable_idle_callback			    fn pausable_idle_callback(&mut self, cb: Box<rtio::Callback + Send>)
pause			    fn pause(&mut self) 
pause_pauses			    fn pause_pauses() 
peer_name			    fn peer_name(&mut self) -> Result<rtio::SocketAddr, IoError> 
period			    fn period(&mut self, msecs: u64, cb: Box<Callback + Send>) 
pipe			pub mod pipe;
pipe_open			    fn pipe_open(&mut self, fd: c_int)
populate_stat			pub unsafe fn populate_stat(req_in: *mut uv_fs_t, stat_out: *mut uv_stat_t) 
pread			    fn pread(&mut self, buf: &mut [u8], offset: u64) -> IoResult<int> 
process			pub mod process;
process_pid			pub unsafe fn process_pid(p: *mut uv_process_t) -> c_int 
push			    pub fn push(&mut self, task: BlockedTask) 
pwrite			    fn pwrite(&mut self, buf: &[u8], offset: u64) -> IoResult<()> 
queue			mod queue;
queue			    pub fn queue(&mut self) -> Queue 
rc			mod rc;
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<int> 
read			    pub fn read(loop_: &Loop, fd: c_int, buf: &mut [u8], offset: i64)
read			    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    pub fn read(&mut self, buf: &mut [u8]) -> Result<uint, UvError> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read_cb			extern fn read_cb(handle: *mut uvll::uv_stream_t, nread: ssize_t,
readdir			    pub fn readdir(loop_: &Loop, path: &CString, flags: c_int)
readlink			    pub fn readlink(loop_: &Loop, path: &CString) -> Result<CString, UvError> 
recv_cb			        extern fn recv_cb(handle: *mut uvll::uv_udp_t, nread: ssize_t,
recv_from			    fn recv_from(&mut self, buf: &mut [u8])
remote_callback			    fn remote_callback(&mut self, f: Box<rtio::Callback + Send>)
rename			    pub fn rename(loop_: &Loop, path: &CString, to: &CString)
request_sanity_check			fn request_sanity_check() 
resume			    fn resume(&mut self) 
rmdir			    pub fn rmdir(loop_: &Loop, path: &CString) -> Result<(), UvError> 
rtio			impl rtio::RtioFileStream for FileWatcher 
rtio			impl rtio::RtioSocket for TcpAcceptor 
rtio			impl rtio::RtioSocket for TcpListener 
rtio			impl rtio::RtioSocket for TcpWatcher 
rtio			impl rtio::RtioSocket for UdpWatcher 
rtio			impl rtio::RtioTcpAcceptor for TcpAcceptor 
rtio			impl rtio::RtioTcpListener for TcpListener 
rtio			impl rtio::RtioTcpStream for TcpWatcher 
rtio			impl rtio::RtioUdpSocket for UdpWatcher 
rtio			impl rtio::RtioPipe for PipeWatcher 
rtio			impl rtio::RtioUnixAcceptor for PipeAcceptor 
rtio			impl rtio::RtioUnixListener for PipeListener 
rtio			impl rtio::RtioProcess for Process 
run			    pub fn run(loop_: &Loop, node: Option<&str>, service: Option<&str>,
run			    pub fn run(&mut self) 
run			    fn run(&mut self) 
rust_set_stdio_container_fd			    fn rust_set_stdio_container_fd(c: *mut uv_stdio_container_t, fd: c_int);
rust_set_stdio_container_flags			    fn rust_set_stdio_container_flags(c: *mut uv_stdio_container_t, flags: c_int);
rust_set_stdio_container_stream			    fn rust_set_stdio_container_stream(c: *mut uv_stdio_container_t,
rust_uv_get_data_for_req			    fn rust_uv_get_data_for_req(req: *mut c_void) -> *mut c_void;
rust_uv_get_data_for_uv_handle			    fn rust_uv_get_data_for_uv_handle(handle: *mut c_void) -> *mut c_void;
rust_uv_get_data_for_uv_loop			    fn rust_uv_get_data_for_uv_loop(loop_ptr: *mut c_void) -> *mut c_void;
rust_uv_get_loop_for_uv_handle			    fn rust_uv_get_loop_for_uv_handle(handle: *mut c_void) -> *mut c_void;
rust_uv_get_loop_from_fs_req			    fn rust_uv_get_loop_from_fs_req(req: *mut uv_fs_t) -> *mut uv_loop_t;
rust_uv_get_loop_from_getaddrinfo_req			    fn rust_uv_get_loop_from_getaddrinfo_req(req: *mut uv_fs_t) -> *mut uv_loop_t;
rust_uv_get_path_from_fs_req			    fn rust_uv_get_path_from_fs_req(req: *mut uv_fs_t) -> *mut c_char;
rust_uv_get_ptr_from_fs_req			    fn rust_uv_get_ptr_from_fs_req(req: *mut uv_fs_t) -> *mut libc::c_void;
rust_uv_get_result_from_fs_req			    fn rust_uv_get_result_from_fs_req(req: *mut uv_fs_t) -> ssize_t;
rust_uv_get_stream_handle_from_connect_req			    fn rust_uv_get_stream_handle_from_connect_req(req: *mut uv_connect_t) -> *mut uv_stream_t;
rust_uv_get_stream_handle_from_write_req			    fn rust_uv_get_stream_handle_from_write_req(req: *mut uv_write_t) -> *mut uv_stream_t;
rust_uv_get_udp_handle_from_send_req			    fn rust_uv_get_udp_handle_from_send_req(req: *mut uv_udp_send_t) -> *mut uv_udp_t;
rust_uv_guess_handle			    fn rust_uv_guess_handle(fd: c_int) -> c_int;
rust_uv_handle_type_max			    fn rust_uv_handle_type_max() -> uintptr_t;
rust_uv_loop_new			    fn rust_uv_loop_new() -> *mut c_void;
rust_uv_populate_uv_stat			    fn rust_uv_populate_uv_stat(req_in: *mut uv_fs_t, stat_out: *mut uv_stat_t);
rust_uv_process_pid			    fn rust_uv_process_pid(p: *mut uv_process_t) -> c_int;
rust_uv_req_type_max			    fn rust_uv_req_type_max() -> uintptr_t;
rust_uv_set_data_for_req			    fn rust_uv_set_data_for_req(req: *mut c_void, data: *mut c_void);
rust_uv_set_data_for_uv_handle			    fn rust_uv_set_data_for_uv_handle(handle: *mut c_void, data: *mut c_void);
rust_uv_set_data_for_uv_loop			    fn rust_uv_set_data_for_uv_loop(loop_ptr: *mut c_void, data: *mut c_void);
seek			    fn seek(&mut self, pos: i64, whence: rtio::SeekStyle) -> IoResult<u64> 
seek_common			    fn seek_common(&self, pos: i64, whence: c_int) -> IoResult<u64>
send			    fn send(&mut self, task: BlockedTask) 
send_cb			        extern fn send_cb(req: *mut uvll::uv_udp_send_t, status: c_int) 
send_to			    fn send_to(&mut self, buf: &[u8], dst: rtio::SocketAddr) -> Result<(), IoError> 
set_data			    pub fn set_data<T>(&self, t: *mut T) 
set_data			    pub unsafe fn set_data<T>(&mut self, data: *mut T) 
set_data_for_req			pub unsafe fn set_data_for_req<T, U>(req: *mut T, data: *mut U) 
set_data_for_uv_handle			pub unsafe fn set_data_for_uv_handle<T, U>(handle: *mut T, data: *mut U) 
set_data_for_uv_loop			pub unsafe fn set_data_for_uv_loop(loop_ptr: *mut c_void, data: *mut c_void) 
set_raw			    fn set_raw(&mut self, raw: bool) -> IoResult<()> 
set_read_timeout			    fn set_read_timeout(&mut self, ms: Option<u64>) 
set_read_timeout			    fn set_read_timeout(&mut self, ms: Option<u64>) 
set_stdio			unsafe fn set_stdio(dst: *mut uvll::uv_stdio_container_t,
set_stdio_container_fd			pub unsafe fn set_stdio_container_fd(c: *mut uv_stdio_container_t,
set_stdio_container_flags			pub unsafe fn set_stdio_container_flags(c: *mut uv_stdio_container_t,
set_stdio_container_stream			pub unsafe fn set_stdio_container_stream(c: *mut uv_stdio_container_t,
set_timeout			    fn set_timeout(&mut self, ms: Option<u64>) 
set_timeout			    fn set_timeout(&mut self, timeout: Option<u64>) 
set_timeout			    fn set_timeout(&mut self, timeout: Option<u64>) 
set_timeout			    fn set_timeout(&mut self, timeout_ms: Option<u64>) 
set_timeout			    fn set_timeout(&mut self, timeout: Option<u64>) 
set_timeout			    pub fn set_timeout(&mut self, ms: Option<u64>,
set_timeout			    pub fn set_timeout<U, T: UvHandle<U> + HomingIO>(
set_write_timeout			    fn set_write_timeout(&mut self, ms: Option<u64>) 
set_write_timeout			    fn set_write_timeout(&mut self, ms: Option<u64>) 
shutdown			pub fn shutdown(handle: *mut uvll::uv_stream_t, loop_: &Loop) -> Result<(), IoError> 
shutdown_cb			    extern fn shutdown_cb(req: *mut uvll::uv_shutdown_t, status: libc::c_int) 
signal			pub mod signal;
signal			    fn signal(&mut self, signum: int, cb: Box<rtio::Callback + Send>)
signal_cb			extern fn signal_cb(handle: *mut uvll::uv_signal_t, _signum: c_int) 
sleep			    fn sleep(chan: &Chan) -> uint 
sleep			    fn sleep(&mut self, msecs: u64) 
slice_to_uv_buf			pub fn slice_to_uv_buf(v: &[u8]) -> Buf 
smoke_fail			    fn smoke_fail() 
smoke_test			    fn smoke_test() 
smoke_test			    fn smoke_test() 
sockaddr_to_addr			pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,
socket_name			    fn socket_name(&mut self) -> Result<rtio::SocketAddr, IoError> 
socket_name			fn socket_name(sk: SocketNameKind,
spawn			    pub fn spawn(io_loop: &mut UvIoFactory, cfg: rtio::ProcessConfig)
spawn			    fn spawn(&mut self, cfg: ProcessConfig)
start			fn start(argc: int, argv: *const *const u8) -> int 
start			    pub fn start(&mut self, f: uvll::uv_timer_cb, msecs: u64, period: u64) 
stat			    pub fn stat(loop_: &Loop, path: &CString) -> Result<rtio::FileStat, UvError> 
status_to_io_result			pub fn status_to_io_result(status: c_int) -> IoResult<()> 
status_to_maybe_uv_error			pub fn status_to_maybe_uv_error(status: c_int) -> Option<UvError> 
stop			    pub fn stop(&mut self) 
stream			pub mod stream;
symlink			    pub fn symlink(loop_: &Loop, src: &CString, dst: &CString)
tcp_bind			    fn tcp_bind(&mut self, addr: rtio::SocketAddr)
tcp_connect			    fn tcp_connect(&mut self, addr: rtio::SocketAddr, timeout: Option<u64>)
tcp_listener_fail_cleanup			    fn tcp_listener_fail_cleanup() 
tcp_stream_fail_cleanup			    fn tcp_stream_fail_cleanup() 
tell			    fn tell(&self) -> IoResult<u64> 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
test			mod test 
tests			mod tests 
time_to_live			    fn time_to_live(&mut self, ttl: int) -> Result<(), IoError> 
timeout			mod timeout;
timer			pub mod timer;
timer_cb			        extern fn timer_cb(timer: *mut uvll::uv_timer_t) 
timer_cb			        extern fn timer_cb(handle: *mut uvll::uv_timer_t) 
timer_cb			        extern fn timer_cb(timer: *mut uvll::uv_timer_t) 
timer_cb			extern fn timer_cb(handle: *mut uvll::uv_timer_t) 
timer_init			    fn timer_init(&mut self) -> IoResult<Box<rtio::RtioTimer + Send>> 
to_msec			        fn to_msec(stat: uvll::uv_timespec_t) -> u64 
truncate			    fn truncate(&mut self, offset: i64) -> IoResult<()> 
truncate			    pub fn truncate(loop_: &Loop, file: c_int, offset: i64)
tty			pub mod tty;
tty_open			    fn tty_open(&mut self, fd: c_int, readable: bool)
udp_bind			    fn udp_bind(&mut self, addr: rtio::SocketAddr)
udp_bind_close_ip4			    fn udp_bind_close_ip4() 
udp_bind_close_ip6			    fn udp_bind_close_ip6() 
udp_fail_other_task			    fn udp_fail_other_task() 
udp_listener_fail_cleanup			    fn udp_listener_fail_cleanup() 
udp_recv_ip4			    fn udp_recv_ip4() 
udp_recv_ip6			    fn udp_recv_ip6() 
unix_bind			    fn unix_bind(&mut self, path: &CString)
unix_connect			    fn unix_connect(&mut self, path: &CString, timeout: Option<u64>)
unlink			    pub fn unlink(loop_: &Loop, path: &CString) -> Result<(), UvError> 
unwrap			    fn unwrap(mut self) -> *mut uvll::uv_pipe_t 
utime			    pub fn utime(loop_: &Loop, path: &CString, atime: u64, mtime: u64)
uv_accept			    pub fn uv_accept(server: *mut uv_stream_t, client: *mut uv_stream_t) -> c_int;
uv_async_init			    pub fn uv_async_init(l: *mut uv_loop_t, a: *mut uv_async_t,
uv_async_send			    pub fn uv_async_send(a: *mut uv_async_t);
uv_buf_init			    pub fn uv_buf_init(base: *mut c_char, len: c_uint) -> uv_buf_t;
uv_buf_t			pub struct uv_buf_t 
uv_close			    pub fn uv_close(h: *mut uv_handle_t, cb: uv_close_cb);
uv_err_name			    pub fn uv_err_name(err: c_int) -> *const c_char;
uv_error_to_io_error			pub fn uv_error_to_io_error(uverr: UvError) -> IoError 
uv_freeaddrinfo			    pub fn uv_freeaddrinfo(ai: *mut addrinfo);
uv_fs_chmod			    pub fn uv_fs_chmod(handle: *mut uv_loop_t, req: *mut uv_fs_t,
uv_fs_chown			    pub fn uv_fs_chown(handle: *mut uv_loop_t, req: *mut uv_fs_t, src: *const c_char,
uv_fs_close			    pub fn uv_fs_close(l: *mut uv_loop_t, req: *mut uv_fs_t, fd: c_int,
uv_fs_fdatasync			    pub fn uv_fs_fdatasync(handle: *mut uv_loop_t, req: *mut uv_fs_t, file: c_int,
uv_fs_fstat			    pub fn uv_fs_fstat(l: *mut uv_loop_t, req: *mut uv_fs_t, fd: c_int,
uv_fs_fsync			    pub fn uv_fs_fsync(handle: *mut uv_loop_t, req: *mut uv_fs_t, file: c_int,
uv_fs_ftruncate			    pub fn uv_fs_ftruncate(handle: *mut uv_loop_t, req: *mut uv_fs_t, file: c_int,
uv_fs_link			    pub fn uv_fs_link(handle: *mut uv_loop_t, req: *mut uv_fs_t,
uv_fs_lstat			    pub fn uv_fs_lstat(handle: *mut uv_loop_t, req: *mut uv_fs_t,
uv_fs_mkdir			    pub fn uv_fs_mkdir(l: *mut uv_loop_t, req: *mut uv_fs_t, path: *const c_char,
uv_fs_open			    pub fn uv_fs_open(loop_ptr: *mut uv_loop_t, req: *mut uv_fs_t,
uv_fs_read			    pub fn uv_fs_read(l: *mut uv_loop_t, req: *mut uv_fs_t, fd: c_int,
uv_fs_readdir			    pub fn uv_fs_readdir(l: *mut uv_loop_t, req: *mut uv_fs_t,
uv_fs_readlink			    pub fn uv_fs_readlink(handle: *mut uv_loop_t, req: *mut uv_fs_t,
uv_fs_rename			    pub fn uv_fs_rename(handle: *mut uv_loop_t, req: *mut uv_fs_t,
uv_fs_req_cleanup			    pub fn uv_fs_req_cleanup(req: *mut uv_fs_t);
uv_fs_rmdir			    pub fn uv_fs_rmdir(l: *mut uv_loop_t, req: *mut uv_fs_t, path: *const c_char,
uv_fs_stat			    pub fn uv_fs_stat(l: *mut uv_loop_t, req: *mut uv_fs_t, path: *const c_char,
uv_fs_symlink			    pub fn uv_fs_symlink(handle: *mut uv_loop_t, req: *mut uv_fs_t,
uv_fs_unlink			    pub fn uv_fs_unlink(loop_ptr: *mut uv_loop_t, req: *mut uv_fs_t,
uv_fs_utime			    pub fn uv_fs_utime(handle: *mut uv_loop_t, req: *mut uv_fs_t,
uv_fs_write			    pub fn uv_fs_write(l: *mut uv_loop_t, req: *mut uv_fs_t, fd: c_int,
uv_getaddrinfo			    pub fn uv_getaddrinfo(loop_: *mut uv_loop_t, req: *mut uv_getaddrinfo_t,
uv_handle			    fn uv_handle(&self) -> *mut uvll::uv_async_t { self.handle }
uv_handle			    fn uv_handle(&self) -> *mut uvll::uv_idle_t { self.handle }
uv_handle			    fn uv_handle(&self) -> *mut T;
uv_handle			    fn uv_handle(&self) -> *mut uvll::uv_tcp_t { self.handle }
uv_handle			    fn uv_handle(&self) -> *mut uvll::uv_tcp_t { self.stream.handle }
uv_handle			    fn uv_handle(&self) -> *mut uvll::uv_udp_t { self.handle }
uv_handle			    fn uv_handle(&self) -> *mut uvll::uv_pipe_t { self.pipe }
uv_handle			    fn uv_handle(&self) -> *mut uvll::uv_pipe_t { self.stream.handle }
uv_handle			    fn uv_handle(&self) -> *mut uvll::uv_process_t { self.handle }
uv_handle			    fn uv_handle(&self) -> *mut uvll::uv_signal_t { self.handle }
uv_handle			    fn uv_handle(&self) -> *mut uvll::uv_timer_t { self.handle }
uv_handle			    fn uv_handle(&self) -> *mut uvll::uv_tty_t { self.tty }
uv_handle_size			    pub fn uv_handle_size(ty: uv_handle_type) -> size_t;
uv_handle_type			pub enum uv_handle_type 
uv_idle_init			    pub fn uv_idle_init(l: *mut uv_loop_t, i: *mut uv_idle_t) -> c_int;
uv_idle_start			    pub fn uv_idle_start(i: *mut uv_idle_t, cb: uv_idle_cb) -> c_int;
uv_idle_stop			    pub fn uv_idle_stop(i: *mut uv_idle_t) -> c_int;
uv_kill			    pub fn uv_kill(pid: c_int, signum: c_int) -> c_int;
uv_listen			    pub fn uv_listen(s: *mut uv_stream_t, backlog: c_int,
uv_loop			    fn uv_loop(&self) -> Loop 
uv_loop			    pub fn uv_loop<'a>(&mut self) -> *mut uvll::uv_loop_t { self.loop_.handle }
uv_loop_delete			    pub fn uv_loop_delete(l: *mut uv_loop_t);
uv_membership			pub enum uv_membership 
uv_pipe_bind			    pub fn uv_pipe_bind(pipe: *mut uv_pipe_t, name: *const c_char) -> c_int;
uv_pipe_connect			    pub fn uv_pipe_connect(req: *mut uv_connect_t, handle: *mut uv_pipe_t,
uv_pipe_init			    pub fn uv_pipe_init(l: *mut uv_loop_t, p: *mut uv_pipe_t,
uv_pipe_open			    pub fn uv_pipe_open(pipe: *mut uv_pipe_t, file: c_int) -> c_int;
uv_process_kill			    pub fn uv_process_kill(p: *mut uv_process_t, signum: c_int) -> c_int;
uv_process_options_t			pub struct uv_process_options_t 
uv_read_start			    pub fn uv_read_start(stream: *mut uv_stream_t,
uv_read_stop			    pub fn uv_read_stop(stream: *mut uv_stream_t) -> c_int;
uv_ref			    pub fn uv_ref(t: *mut uv_handle_t);
uv_req_size			    pub fn uv_req_size(ty: uv_req_type) -> size_t;
uv_req_type			pub enum uv_req_type 
uv_run			    pub fn uv_run(l: *mut uv_loop_t, mode: uv_run_mode) -> c_int;
uv_run_mode			pub enum uv_run_mode 
uv_shutdown			    pub fn uv_shutdown(req: *mut uv_shutdown_t, handle: *mut uv_stream_t,
uv_signal_init			    pub fn uv_signal_init(loop_: *mut uv_loop_t,
uv_signal_start			    pub fn uv_signal_start(h: *mut uv_signal_t, cb: uv_signal_cb,
uv_signal_stop			    pub fn uv_signal_stop(handle: *mut uv_signal_t) -> c_int;
uv_spawn			    pub fn uv_spawn(loop_ptr: *mut uv_loop_t, outptr: *mut uv_process_t,
uv_stat_t			impl uv_stat_t 
uv_stat_t			pub struct uv_stat_t 
uv_stdio_container_t			pub struct uv_stdio_container_t 
uv_strerror			    pub fn uv_strerror(err: c_int) -> *const c_char;
uv_tcp_bind			    pub fn uv_tcp_bind(t: *mut uv_tcp_t, addr: *const sockaddr) -> c_int;
uv_tcp_connect			    pub fn uv_tcp_connect(c: *mut uv_connect_t, h: *mut uv_tcp_t,
uv_tcp_getpeername			    pub fn uv_tcp_getpeername(h: *mut uv_tcp_t, name: *mut sockaddr,
uv_tcp_getsockname			    pub fn uv_tcp_getsockname(h: *mut uv_tcp_t, name: *mut sockaddr,
uv_tcp_init			    pub fn uv_tcp_init(l: *mut uv_loop_t, h: *mut uv_tcp_t) -> c_int;
uv_tcp_keepalive			    pub fn uv_tcp_keepalive(h: *mut uv_tcp_t, enable: c_int,
uv_tcp_nodelay			    pub fn uv_tcp_nodelay(h: *mut uv_tcp_t, enable: c_int) -> c_int;
uv_tcp_simultaneous_accepts			    pub fn uv_tcp_simultaneous_accepts(h: *mut uv_tcp_t, enable: c_int) -> c_int;
uv_timer_init			    pub fn uv_timer_init(l: *mut uv_loop_t, t: *mut uv_timer_t) -> c_int;
uv_timer_start			    pub fn uv_timer_start(t: *mut uv_timer_t, cb: uv_timer_cb,
uv_timer_stop			    pub fn uv_timer_stop(handle: *mut uv_timer_t) -> c_int;
uv_timespec_t			pub struct uv_timespec_t 
uv_tty_get_winsize			    pub fn uv_tty_get_winsize(tty: *mut uv_tty_t,
uv_tty_init			    pub fn uv_tty_init(l: *mut uv_loop_t, tty: *mut uv_tty_t, fd: c_int,
uv_tty_set_mode			    pub fn uv_tty_set_mode(tty: *mut uv_tty_t, mode: c_int) -> c_int;
uv_udp_bind			    pub fn uv_udp_bind(h: *mut uv_udp_t, addr: *const sockaddr,
uv_udp_getsockname			    pub fn uv_udp_getsockname(h: *mut uv_udp_t, name: *mut sockaddr,
uv_udp_init			    pub fn uv_udp_init(l: *mut uv_loop_t, h: *mut uv_udp_t) -> c_int;
uv_udp_recv_start			    pub fn uv_udp_recv_start(server: *mut uv_udp_t,
uv_udp_recv_stop			    pub fn uv_udp_recv_stop(server: *mut uv_udp_t) -> c_int;
uv_udp_send			        fn uv_udp_send(req: *mut uv_write_t, stream: *mut uv_stream_t,
uv_udp_send			pub unsafe fn uv_udp_send(req: *mut uv_udp_send_t,
uv_udp_set_broadcast			    pub fn uv_udp_set_broadcast(handle: *mut uv_udp_t, on: c_int) -> c_int;
uv_udp_set_membership			    pub fn uv_udp_set_membership(handle: *mut uv_udp_t,
uv_udp_set_multicast_loop			    pub fn uv_udp_set_multicast_loop(handle: *mut uv_udp_t, on: c_int) -> c_int;
uv_udp_set_multicast_ttl			    pub fn uv_udp_set_multicast_ttl(handle: *mut uv_udp_t, ttl: c_int) -> c_int;
uv_udp_set_ttl			    pub fn uv_udp_set_ttl(handle: *mut uv_udp_t, ttl: c_int) -> c_int;
uv_unref			    pub fn uv_unref(t: *mut uv_handle_t);
uv_walk			    pub fn uv_walk(l: *mut uv_loop_t, cb: uv_walk_cb, arg: *mut c_void);
uv_write			        fn uv_write(req: *mut uv_write_t, stream: *mut uv_stream_t,
uv_write			pub unsafe fn uv_write(req: *mut uv_write_t,
uvio			pub mod uvio;
uvll			pub mod uvll;
wait			    fn wait(&mut self) -> IoResult<rtio::ProcessExit> 
wait_until_woken_after			fn wait_until_woken_after(slot: *mut Option<BlockedTask>,
wakeup			fn wakeup(slot: &mut Option<BlockedTask>) 
with_argv			fn with_argv<T>(prog: &CString, args: &[CString],
with_env			fn with_env<T>(env: Option<&[(CString, CString)]>,
wrap			    pub fn wrap(handle: *mut uvll::uv_loop_t) -> Loop { Loop { handle: handle } }
wrap			    pub fn wrap(handle: *mut uvll::uv_req_t) -> Request 
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			    pub fn write(loop_: &Loop, fd: c_int, buf: &[u8], offset: i64)
write			    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> 
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			    pub fn write(&mut self, buf: &[u8], may_timeout: bool) -> Result<(), UvError> 
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write_cb			extern fn write_cb(req: *mut uvll::uv_write_t, status: c_int) 
