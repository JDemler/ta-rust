Arc			impl<T: Clone> Arc<T> 
Arc			impl<T> Arc<T> 
Arc			pub struct Arc<T> 
ArcInner			struct ArcInner<T> 
Bar			    struct Bar(u32);
Box			impl Box<Any+Send> 
Box			impl Box<Any> 
Box			impl<T : ?Sized> Box<T> 
Box			impl<T> Box<T> 
Box			pub struct Box<T>(Unique<T>);
Canary			    struct Canary(*mut atomic::AtomicUsize);
Clone for Arc			impl<T> Clone for Arc<T> 
Clone for Box			impl<T: Clone> Clone for Box<T> 
Clone for Rc			impl<T> Clone for Rc<T> 
Clone for Weak			impl<T> Clone for Weak<T> 
Clone for Weak			impl<T> Clone for Weak<T> 
Cycle			        struct Cycle 
Cycle			        struct Cycle 
Default for Arc			impl<T: Default + Sync + Send> Default for Arc<T> 
Default for Box			impl<T: Default> Default for Box<T> 
Default for Box			impl<T> Default for Box<[T]> 
Default for Rc			impl<T: Default> Default for Rc<T> 
Deref for Arc			impl<T> Deref for Arc<T> 
Deref for Box			impl<T: ?Sized> Deref for Box<T> 
Deref for Rc			impl<T> Deref for Rc<T> 
DerefMut for Box			impl<T: ?Sized> DerefMut for Box<T> 
DoubleEndedIterator for Box			impl<I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for Box<I> 
Drop for Arc			impl<T> Drop for Arc<T> 
Drop for Canary			    impl Drop for Canary
Drop for Rc			impl<T> Drop for Rc<T> 
Drop for Weak			impl<T> Drop for Weak<T> 
Drop for Weak			impl<T> Drop for Weak<T> 
Eq for Arc			impl<T: Eq> Eq for Arc<T> {}
Eq for Box			impl<T: ?Sized + Eq> Eq for Box<T> {}
Eq for Rc			impl<T: Eq> Eq for Rc<T> {}
ExactSizeIterator for Box			impl<I: ExactSizeIterator + ?Sized> ExactSizeIterator for Box<I> {}
FnBox			pub trait FnBox<A> 
FnBox for F			impl<A,F> FnBox<A> for F
FnOnce for Box			impl<'a,A,R> FnOnce<A> for Box<FnBox<A,Output=R>+'a> 
FnOnce for Box			impl<'a,A,R> FnOnce<A> for Box<FnBox<A,Output=R>+Send+'a> 
Foo			    struct Foo { inner: Arc<i32> }
Foo			    trait Foo 
Foo for Bar			    impl Foo for Bar 
Hash for Arc			impl<T: Hash> Hash for Arc<T> 
Hash for Box			impl<T: ?Sized + Hash> Hash for Box<T> 
Hash for Rc			impl<T: Hash> Hash for Rc<T> 
Iterator for Box			impl<I: Iterator + ?Sized> Iterator for Box<I> 
Ord for Arc			impl<T: Ord> Ord for Arc<T> 
Ord for Box			impl<T: ?Sized + Ord> Ord for Box<T> 
Ord for Rc			impl<T: Ord> Ord for Rc<T> 
PartialEq for Arc			impl<T: PartialEq> PartialEq for Arc<T> 
PartialEq for Box			impl<T: ?Sized + PartialEq> PartialEq for Box<T> 
PartialEq for Rc			impl<T: PartialEq> PartialEq for Rc<T> 
PartialOrd for Arc			impl<T: PartialOrd> PartialOrd for Arc<T> 
PartialOrd for Box			impl<T: ?Sized + PartialOrd> PartialOrd for Box<T> 
PartialOrd for Rc			impl<T: PartialOrd> PartialOrd for Rc<T> 
Rc			impl<T: Clone> Rc<T> 
Rc			impl<T> Rc<T> 
Rc			pub struct Rc<T> 
RcBox			struct RcBox<T> 
RcBoxPtr			trait RcBoxPtr<T> 
RcBoxPtr for Rc			impl<T> RcBoxPtr<T> for Rc<T> 
RcBoxPtr for Weak			impl<T> RcBoxPtr<T> for Weak<T> 
Test			struct Test;
Weak			impl<T> Weak<T> 
Weak			pub struct Weak<T> 
Weak			impl<T> Weak<T> 
Weak			pub struct Weak<T> 
_aligned_free			        fn _aligned_free(ptr: *mut c_void);
_aligned_malloc			        fn _aligned_malloc(size: size_t, align: size_t) -> *mut c_void;
_aligned_realloc			        fn _aligned_realloc(block: *mut c_void, size: size_t,
align_to_flags			    fn align_to_flags(align: usize) -> c_int 
alloc_owned_small			    fn alloc_owned_small(b: &mut Bencher) 
allocate			    pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 
allocate			pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 
any_move			fn any_move() 
arc			pub mod arc;
basic_reallocate_inplace_noop			    fn basic_reallocate_inplace_noop() 
boxed			mod boxed { pub use std::boxed::{Box, HEAP}; }
boxed			pub mod boxed;
boxed_test			mod boxed_test;
call_box			    fn call_box(self: Box<F>, args: A) -> F::Output 
call_box			    fn call_box(self: Box<Self>, args: A) -> Self::Output;
call_once			    extern "rust-call" fn call_once(self, args: A) -> R 
clone			    fn clone(&self) -> Arc<T> 
clone			    fn clone(&self) -> Weak<T> 
clone			    fn clone(&self) -> Box<T> { box {(**self).clone()} }
clone			    fn clone(&self) -> Rc<T> 
clone			    fn clone(&self) -> Weak<T> 
clone_from			    fn clone_from(&mut self, source: &Box<T>) 
cmp			    fn cmp(&self, other: &Arc<T>) -> Ordering { (**self).cmp(&**other) }
cmp			    fn cmp(&self, other: &Box<T>) -> Ordering 
cmp			    fn cmp(&self, other: &Rc<T>) -> Ordering { (**self).cmp(&**other) }
deallocate			    pub unsafe fn deallocate(ptr: *mut u8, _old_size: usize, _align: usize) 
deallocate			    pub unsafe fn deallocate(ptr: *mut u8, _old_size: usize, align: usize) 
deallocate			    pub unsafe fn deallocate(ptr: *mut u8, old_size: usize, align: usize) 
deallocate			pub unsafe fn deallocate(ptr: *mut u8, old_size: usize, align: usize) 
dec_strong			    fn dec_strong(&self) { self.inner().strong.set(self.strong() - 1); }
dec_weak			    fn dec_weak(&self) { self.inner().weak.set(self.weak() - 1); }
default			    fn default() -> Arc<T> { Arc::new(Default::default()) }
default			    fn default() -> Box<T> { box Default::default() }
default			    fn default() -> Box<[T]> { Box::<[T; 0]>::new([]) }
default			    fn default() -> Rc<T> 
deref			    fn deref(&self) -> &T 
deref			    fn deref(&self) -> &T { &**self }
deref			fn deref() 
deref			    fn deref(&self) -> &T 
deref_mut			    fn deref_mut(&mut self) -> &mut T { &mut **self }
downcast			    pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<Any>> 
downgrade			    pub fn downgrade(&self) -> Weak<T> 
downgrade			    pub fn downgrade(&self) -> Weak<T> 
drop			        fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop_arc			    fn drop_arc() 
drop_arc_weak			    fn drop_arc_weak() 
drop_slow			    unsafe fn drop_slow(&mut self) 
eq			    fn eq(&self, other: &Arc<T>) -> bool { *(*self) == *(*other) }
eq			    fn eq(&self, other: &Box<T>) -> bool { PartialEq::eq(&**self, &**other) }
eq			    fn eq(&self, other: &Rc<T>) -> bool { **self == **other }
exchange_free			unsafe fn exchange_free(ptr: *mut u8, old_size: usize, align: usize) 
exchange_malloc			unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 
fixme_14344_be_sure_to_link_to_collections			pub fn fixme_14344_be_sure_to_link_to_collections() {}
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt::Debug for Arc			impl<T: fmt::Debug> fmt::Debug for Arc<T> 
fmt::Debug for Box			impl<T: fmt::Debug + ?Sized> fmt::Debug for Box<T> 
fmt::Debug for Rc			impl<T: fmt::Debug> fmt::Debug for Rc<T> 
fmt::Debug for Weak			impl<T: fmt::Debug> fmt::Debug for Weak<T> 
fmt::Debug for Weak			impl<T: fmt::Debug> fmt::Debug for Weak<T> 
fmt::Display for Arc			impl<T: fmt::Display> fmt::Display for Arc<T> 
fmt::Display for Box			impl<T: fmt::Display + ?Sized> fmt::Display for Box<T> 
fmt::Display for Rc			impl<T: fmt::Display> fmt::Display for Rc<T> 
fmt::Pointer for Arc			impl<T> fmt::Pointer for Arc<T> 
fmt::Pointer for Box			impl<T> fmt::Pointer for Box<T> 
fmt::Pointer for Rc			impl<T> fmt::Pointer for Rc<T> 
from_raw			    pub unsafe fn from_raw(raw: *mut T) -> Self 
ge			    fn ge(&self, other: &Arc<T>) -> bool { *(*self) >= *(*other) }
ge			    fn ge(&self, other: &Box<T>) -> bool { PartialOrd::ge(&**self, &**other) }
ge			    fn ge(&self, other: &Rc<T>) -> bool { **self >= **other }
get			        fn get(&self) -> u32 
get			        fn get(&self) -> u32;
get_mut			pub fn get_mut<T>(this: &mut Arc<T>) -> Option<&mut T> 
get_mut			    fn get_mut() 
get_mut			pub fn get_mut<T>(rc: &mut Rc<T>) -> Option<&mut T> 
gt			    fn gt(&self, other: &Arc<T>) -> bool { *(*self) > *(*other) }
gt			    fn gt(&self, other: &Box<T>) -> bool { PartialOrd::gt(&**self, &**other) }
gt			    fn gt(&self, other: &Rc<T>) -> bool { **self > **other }
hash			    fn hash<H: Hasher>(&self, state: &mut H) 
hash			    fn hash<H: hash::Hasher>(&self, state: &mut H) 
hash			    fn hash<H: Hasher>(&self, state: &mut H) 
heap			pub mod heap;
homura			    fn homura<T: Deref<Target=i32>>(_: T) { }
imp			mod imp 
inc_strong			    fn inc_strong(&self) { self.inner().strong.set(self.strong() + 1); }
inc_weak			    fn inc_weak(&self) { self.inner().weak.set(self.weak() + 1); }
inner			    fn inner(&self) -> &ArcInner<T> 
inner			    fn inner(&self) -> &RcBox<T> 
inner			    fn inner(&self) -> &RcBox<T>;
into_raw			pub unsafe fn into_raw<T : ?Sized>(b: Box<T>) -> *mut T 
is_unique			    fn is_unique() 
is_unique			pub fn is_unique<T>(rc: &Rc<T>) -> bool 
je_malloc_stats_print			        fn je_malloc_stats_print(write_cb: Option<extern "C" fn(cbopaque: *mut c_void,
je_mallocx			        fn je_mallocx(size: size_t, flags: c_int) -> *mut c_void;
je_nallocx			        fn je_nallocx(size: size_t, flags: c_int) -> size_t;
je_rallocx			        fn je_rallocx(ptr: *mut c_void, size: size_t, flags: c_int) -> *mut c_void;
je_sdallocx			        fn je_sdallocx(ptr: *mut c_void, size: size_t, flags: c_int);
je_xallocx			        fn je_xallocx(ptr: *mut c_void, size: size_t, extra: size_t, flags: c_int) -> size_t;
le			    fn le(&self, other: &Arc<T>) -> bool { *(*self) <= *(*other) }
le			    fn le(&self, other: &Box<T>) -> bool { PartialOrd::le(&**self, &**other) }
le			    fn le(&self, other: &Rc<T>) -> bool { **self <= **other }
lt			    fn lt(&self, other: &Arc<T>) -> bool { *(*self) < *(*other) }
lt			    fn lt(&self, other: &Box<T>) -> bool { PartialOrd::lt(&**self, &**other) }
lt			    fn lt(&self, other: &Rc<T>) -> bool { **self < **other }
make_unique			    pub fn make_unique(&mut self) -> &mut T 
make_unique			    pub fn make_unique(&mut self) -> &mut T 
mallocx_align			    fn mallocx_align(a: usize) -> c_int { a.trailing_zeros() as c_int }
manually_share_arc			    fn manually_share_arc() 
ne			    fn ne(&self, other: &Arc<T>) -> bool { *(*self) != *(*other) }
ne			    fn ne(&self, other: &Box<T>) -> bool { PartialEq::ne(&**self, &**other) }
ne			    fn ne(&self, other: &Rc<T>) -> bool { **self != **other }
new			    pub fn new(data: T) -> Arc<T> 
new			    pub fn new(x: T) -> Box<T> 
new			    pub fn new(value: T) -> Rc<T> 
next			    fn next(&mut self) -> Option<I::Item> { (**self).next() }
next_back			    fn next_back(&mut self) -> Option<I::Item> { (**self).next_back() }
oom			pub fn oom() -> ! 
partial_cmp			    fn partial_cmp(&self, other: &Arc<T>) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &Box<T>) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &Rc<T>) -> Option<Ordering> 
posix_memalign			        fn posix_memalign(memptr: *mut *mut libc::c_void,
raw_sized			fn raw_sized() 
raw_trait			fn raw_trait() 
rc			pub mod rc;
reallocate			    pub unsafe fn reallocate(ptr: *mut u8, _old_size: usize, size: usize, align: usize) -> *mut u8 
reallocate			    pub unsafe fn reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8 
reallocate			pub unsafe fn reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8 
reallocate_inplace			    pub unsafe fn reallocate_inplace(_ptr: *mut u8, old_size: usize, _size: usize,
reallocate_inplace			    pub unsafe fn reallocate_inplace(ptr: *mut u8, _old_size: usize, size: usize,
reallocate_inplace			    pub unsafe fn reallocate_inplace(ptr: *mut u8, old_size: usize, size: usize,
reallocate_inplace			pub unsafe fn reallocate_inplace(ptr: *mut u8, old_size: usize, size: usize,
rust_allocate			        fn rust_allocate(size: usize, align: usize) -> *mut u8;
rust_deallocate			        fn rust_deallocate(ptr: *mut u8, old_size: usize, align: usize);
rust_reallocate			        fn rust_reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8;
rust_reallocate_inplace			        fn rust_reallocate_inplace(ptr: *mut u8, old_size: usize, size: usize,
rust_stats_print			        fn rust_stats_print();
rust_usable_size			        fn rust_usable_size(size: usize, align: usize) -> usize;
set			        fn set(&mut self, value: u32) 
set			        fn set(&mut self, value: u32);
show_arc			    fn show_arc() 
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) { (**self).size_hint() }
stats_print			    pub fn stats_print() 
stats_print			    pub fn stats_print() {}
stats_print			pub fn stats_print() 
strong			    fn strong(&self) -> usize { self.inner().strong.get() }
strong_count			pub fn strong_count<T>(this: &Arc<T>) -> usize { this.inner().strong.load(SeqCst) }
strong_count			pub fn strong_count<T>(this: &Rc<T>) -> usize { this.strong() }
test			mod test 
tests			mod tests 
tests			mod tests 
try_unwrap			    fn try_unwrap() 
try_unwrap			pub fn try_unwrap<T>(rc: Rc<T>) -> Result<T, Rc<T>> 
upgrade			    pub fn upgrade(&self) -> Option<Arc<T>> 
upgrade			    pub fn upgrade(&self) -> Option<Rc<T>> 
usable_size			    pub fn usable_size(size: usize, _align: usize) -> usize 
usable_size			    pub fn usable_size(size: usize, align: usize) -> usize 
usable_size			pub fn usable_size(size: usize, align: usize) -> usize 
weak			    fn weak(&self) -> usize { self.inner().weak.get() }
weak_count			pub fn weak_count<T>(this: &Arc<T>) -> usize { this.inner().weak.load(SeqCst) - 1 }
weak_count			pub fn weak_count<T>(this: &Rc<T>) -> usize { this.weak() - 1 }
weak_self_cyclic			    fn weak_self_cyclic() 
weak_self_cyclic			    fn weak_self_cyclic() 
