Arc			impl<T: ?Sized> Arc<T> 
Arc			impl<T: Clone> Arc<T> 
Arc			impl<T> Arc<T> 
Arc			pub struct Arc<T: ?Sized> 
ArcInner			struct ArcInner<T: ?Sized> 
Bar			    struct Bar(u32);
Box			impl Box<Any + Send> 
Box			impl Box<Any> 
Box			impl<T : ?Sized> Box<T> 
Box			impl<T> Box<T> 
Box			pub struct Box<T: ?Sized>(Unique<T>);
BoxBuilder			        impl<T> BoxBuilder<T> 
BoxBuilder			        struct BoxBuilder<T> 
BoxPlace for IntermediateBox			impl<T> BoxPlace<T> for IntermediateBox<T> 
Boxed for Box			impl<T> Boxed for Box<T> 
Canary			    struct Canary(*mut atomic::AtomicUsize);
Clone for Arc			impl<T: ?Sized> Clone for Arc<T> 
Clone for Box			impl Clone for Box<str> 
Clone for Box			impl<T: Clone> Clone for Box<T> 
Clone for Box			impl<T: Clone> Clone for Box<[T]> 
Clone for Rc			impl<T: ?Sized> Clone for Rc<T> 
Clone for Weak			impl<T: ?Sized> Clone for Weak<T> 
Clone for Weak			impl<T: ?Sized> Clone for Weak<T> 
Console			        struct Console(HANDLE);
Cycle			        struct Cycle 
Cycle			        struct Cycle 
Default for Arc			impl<T: Default> Default for Arc<T> 
Default for Box			impl<T: Default> Default for Box<T> 
Default for Box			impl<T> Default for Box<[T]> 
Default for Rc			impl<T: Default> Default for Rc<T> 
Deref for Arc			impl<T: ?Sized> Deref for Arc<T> 
Deref for Box			impl<T: ?Sized> Deref for Box<T> 
Deref for Rc			impl<T: ?Sized> Deref for Rc<T> 
DerefMut for Box			impl<T: ?Sized> DerefMut for Box<T> 
DoubleEndedIterator for Box			impl<I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for Box<I> 
Drop for Arc			impl<T: ?Sized> Drop for Arc<T> 
Drop for BoxBuilder			        impl<T> Drop for BoxBuilder<T> 
Drop for Canary			    impl Drop for Canary
Drop for IntermediateBox			impl<T: ?Sized> Drop for IntermediateBox<T> 
Drop for RawVec			impl<T> Drop for RawVec<T> 
Drop for Rc			impl<T: ?Sized> Drop for Rc<T> 
Drop for Weak			impl<T: ?Sized> Drop for Weak<T> 
Drop for Weak			impl<T: ?Sized> Drop for Weak<T> 
Eq for Arc			impl<T: ?Sized + Eq> Eq for Arc<T> {}
Eq for Box			impl<T: ?Sized + Eq> Eq for Box<T> {}
Eq for Rc			impl<T: ?Sized + Eq> Eq for Rc<T> {}
ExactSizeIterator for Box			impl<I: ExactSizeIterator + ?Sized> ExactSizeIterator for Box<I> {}
ExchangeHeapSingleton			pub struct ExchangeHeapSingleton { _force_singleton: () }
FnBox			pub trait FnBox<A> 
FnBox for F			impl<A,F> FnBox<A> for F
FnOnce for Box			impl<'a,A,R> FnOnce<A> for Box<FnBox<A,Output=R>+'a> 
FnOnce for Box			impl<'a,A,R> FnOnce<A> for Box<FnBox<A,Output=R>+Send+'a> 
Foo			    struct Foo { inner: Arc<i32> }
Foo			    trait Foo 
Foo for Bar			    impl Foo for Bar 
GetProcessHeap			        fn GetProcessHeap() -> HANDLE;
GetStdHandle			        fn GetStdHandle(nStdHandle: DWORD) -> HANDLE;
HEAP_SUMMARY			    struct HEAP_SUMMARY 
Hash for Arc			impl<T: ?Sized + Hash> Hash for Arc<T> 
Hash for Box			impl<T: ?Sized + Hash> Hash for Box<T> 
Hash for Rc			impl<T: ?Sized+Hash> Hash for Rc<T> 
Header			    struct Header(*mut u8);
HeapAlloc			        fn HeapAlloc(hHeap: HANDLE, dwFlags: DWORD, dwBytes: SIZE_T) -> LPVOID;
HeapFree			        fn HeapFree(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID) -> BOOL;
HeapReAlloc			        fn HeapReAlloc(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID, dwBytes: SIZE_T) -> LPVOID;
HeapSummary			        fn HeapSummary(hHeap: HANDLE, dwFlags: DWORD, lpSummary: LPHEAP_SUMMARY) -> BOOL;
InPlace for IntermediateBox			impl<T> InPlace<T> for IntermediateBox<T> 
IntermediateBox			pub struct IntermediateBox<T: ?Sized>
Iterator for Box			impl<I: Iterator + ?Sized> Iterator for Box<I> 
Ord for Arc			impl<T: ?Sized + Ord> Ord for Arc<T> 
Ord for Box			impl<T: ?Sized + Ord> Ord for Box<T> 
Ord for Rc			impl<T: ?Sized + Ord> Ord for Rc<T> 
PartialEq for Arc			impl<T: ?Sized + PartialEq> PartialEq for Arc<T> 
PartialEq for Box			impl<T: ?Sized + PartialEq> PartialEq for Box<T> 
PartialEq for Rc			impl<T: ?Sized + PartialEq> PartialEq for Rc<T> 
PartialOrd for Arc			impl<T: ?Sized + PartialOrd> PartialOrd for Arc<T> 
PartialOrd for Box			impl<T: ?Sized + PartialOrd> PartialOrd for Box<T> 
PartialOrd for Rc			impl<T: ?Sized + PartialOrd> PartialOrd for Rc<T> 
Place for IntermediateBox			impl<T> Place<T> for IntermediateBox<T> 
Placer for ExchangeHeapSingleton			impl<T> Placer<T> for ExchangeHeapSingleton 
RawVec			impl<T> RawVec<T> 
RawVec			pub struct RawVec<T> 
Rc			impl<T: ?Sized> Rc<T> 
Rc			impl<T: Clone> Rc<T> 
Rc			impl<T> Rc<T> 
Rc			pub struct Rc<T: ?Sized> 
RcBox			struct RcBox<T: ?Sized> 
RcBoxPtr			trait RcBoxPtr<T: ?Sized> 
RcBoxPtr for Rc			impl<T: ?Sized> RcBoxPtr<T> for Rc<T> 
RcBoxPtr for Weak			impl<T: ?Sized> RcBoxPtr<T> for Weak<T> 
Test			struct Test;
Weak			impl<T: ?Sized> Weak<T> 
Weak			pub struct Weak<T: ?Sized> 
Weak			impl<T: ?Sized> Weak<T> 
Weak			pub struct Weak<T: ?Sized> 
Write for Console			        impl Write for Console 
align_ptr			    unsafe fn align_ptr(ptr: *mut u8, align: usize) -> *mut u8 
align_to_flags			    fn align_to_flags(align: usize) -> c_int 
alignment_header_size			    fn alignment_header_size() 
alloc_guard			fn alloc_guard(_alloc_size: usize) { }
alloc_guard			fn alloc_guard(alloc_size: usize) 
alloc_owned_small			    fn alloc_owned_small(b: &mut Bencher) 
allocate			    pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 
allocate			pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 
any_move			fn any_move() 
arc			pub mod arc;
basic_reallocate_inplace_noop			    fn basic_reallocate_inplace_noop() 
boxed			mod boxed { pub use std::boxed::{Box, HEAP}; }
boxed			pub mod boxed;
boxed_test			mod boxed_test;
call_box			    fn call_box(self: Box<F>, args: A) -> F::Output 
call_box			    fn call_box(self: Box<Self>, args: A) -> Self::Output;
call_once			    extern "rust-call" fn call_once(self, args: A) -> R 
cap			    pub fn cap(&self) -> usize 
check_size_and_alignment			fn check_size_and_alignment(size: usize, align: usize) 
clone			    fn clone(&self) -> Arc<T> 
clone			    fn clone(&self) -> Weak<T> 
clone			    fn clone(&self) -> Box<T> { box {(**self).clone()} }
clone			    fn clone(&self) -> Self 
clone			    fn clone(&self) -> Rc<T> 
clone			    fn clone(&self) -> Weak<T> 
clone_from			    fn clone_from(&mut self, source: &Box<T>) 
cmp			    fn cmp(&self, other: &Arc<T>) -> Ordering { (**self).cmp(&**other) }
cmp			    fn cmp(&self, other: &Box<T>) -> Ordering 
cmp			    fn cmp(&self, other: &Rc<T>) -> Ordering { (**self).cmp(&**other) }
deallocate			    pub unsafe fn deallocate(ptr: *mut u8, _old_size: usize, _align: usize) 
deallocate			    pub unsafe fn deallocate(ptr: *mut u8, _old_size: usize, align: usize) 
deallocate			    pub unsafe fn deallocate(ptr: *mut u8, old_size: usize, align: usize) 
deallocate			pub unsafe fn deallocate(ptr: *mut u8, old_size: usize, align: usize) 
dec_strong			    fn dec_strong(&self) { self.inner().strong.set(self.strong() - 1); }
dec_weak			    fn dec_weak(&self) { self.inner().weak.set(self.weak() - 1); }
default			    fn default() -> Arc<T> { Arc::new(Default::default()) }
default			    fn default() -> Box<T> { box Default::default() }
default			    fn default() -> Box<[T]> { Box::<[T; 0]>::new([]) }
default			    fn default() -> Rc<T> 
deref			    fn deref(&self) -> &T 
deref			    fn deref(&self) -> &T { &**self }
deref			fn deref() 
deref			    fn deref(&self) -> &T 
deref_mut			    fn deref_mut(&mut self) -> &mut T { &mut **self }
double			    pub fn double(&mut self) 
downcast			    pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<Any + Send>> 
downcast			    pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<Any>> 
downgrade			    pub fn downgrade(&self) -> Weak<T> 
downgrade			    pub fn downgrade(&self) -> Weak<T> 
drop			        fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			            fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop_arc			    fn drop_arc() 
drop_arc_weak			    fn drop_arc_weak() 
drop_slow			    unsafe fn drop_slow(&mut self) 
eq			    fn eq(&self, other: &Arc<T>) -> bool { *(*self) == *(*other) }
eq			    fn eq(&self, other: &Box<T>) -> bool { PartialEq::eq(&**self, &**other) }
eq			    fn eq(&self, other: &Rc<T>) -> bool { **self == **other }
exchange_free			unsafe fn exchange_free(ptr: *mut u8, old_size: usize, align: usize) 
exchange_malloc			unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 
finalize			    unsafe fn finalize(b: IntermediateBox<T>) -> Box<T> { finalize(b) }
finalize			    unsafe fn finalize(self) -> Box<T> { finalize(self) }
finalize			unsafe fn finalize<T>(b: IntermediateBox<T>) -> Box<T> 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt::Debug for Arc			impl<T: ?Sized + fmt::Debug> fmt::Debug for Arc<T> 
fmt::Debug for Box			impl<T: fmt::Debug + ?Sized> fmt::Debug for Box<T> 
fmt::Debug for Rc			impl<T: ?Sized+fmt::Debug> fmt::Debug for Rc<T> 
fmt::Debug for Weak			impl<T: ?Sized + fmt::Debug> fmt::Debug for Weak<T> 
fmt::Debug for Weak			impl<T: ?Sized+fmt::Debug> fmt::Debug for Weak<T> 
fmt::Display for Arc			impl<T: ?Sized + fmt::Display> fmt::Display for Arc<T> 
fmt::Display for Box			impl<T: fmt::Display + ?Sized> fmt::Display for Box<T> 
fmt::Display for Rc			impl<T: ?Sized+fmt::Display> fmt::Display for Rc<T> 
fmt::Pointer for Arc			impl<T> fmt::Pointer for Arc<T> 
fmt::Pointer for Box			impl<T> fmt::Pointer for Box<T> 
fmt::Pointer for Rc			impl<T> fmt::Pointer for Rc<T> 
from_box			    pub fn from_box(mut slice: Box<[T]>) -> Self 
from_raw			    pub unsafe fn from_raw(raw: *mut T) -> Self 
from_raw_parts			    pub unsafe fn from_raw_parts(ptr: *mut T, cap: usize) -> Self 
ge			    fn ge(&self, other: &Arc<T>) -> bool { *(*self) >= *(*other) }
ge			    fn ge(&self, other: &Box<T>) -> bool { PartialOrd::ge(&**self, &**other) }
ge			    fn ge(&self, other: &Rc<T>) -> bool { **self >= **other }
get			        fn get(&self) -> u32 
get			        fn get(&self) -> u32;
get_header			    unsafe fn get_header<'a>(ptr: *mut u8) -> &'a mut Header 
get_mut			    pub fn get_mut(this: &mut Arc<T>) -> Option<&mut T> 
get_mut			pub fn get_mut<T: ?Sized>(this: &mut Arc<T>) -> Option<&mut T> 
get_mut			    fn get_mut() 
get_mut			    pub fn get_mut(rc: &mut Rc<T>) -> Option<&mut T> 
get_mut			pub fn get_mut<T>(rc: &mut Rc<T>) -> Option<&mut T> { Rc::get_mut(rc) }
gt			    fn gt(&self, other: &Arc<T>) -> bool { *(*self) > *(*other) }
gt			    fn gt(&self, other: &Box<T>) -> bool { PartialOrd::gt(&**self, &**other) }
gt			    fn gt(&self, other: &Rc<T>) -> bool { **self > **other }
hash			    fn hash<H: Hasher>(&self, state: &mut H) 
hash			    fn hash<H: hash::Hasher>(&self, state: &mut H) 
hash			    fn hash<H: Hasher>(&self, state: &mut H) 
heap			pub mod heap;
homura			    fn homura<T: Deref<Target=i32>>(_: T) { }
imp			mod imp 
inc_strong			    fn inc_strong(&self) 
inc_weak			    fn inc_weak(&self) 
inner			    fn inner(&self) -> &ArcInner<T> 
inner			    fn inner(&self) -> &RcBox<T> 
inner			    fn inner(&self) -> &RcBox<T>;
into_box			            unsafe fn into_box(self) -> Box<[T]> 
into_box			    pub unsafe fn into_box(self) -> Box<[T]> 
into_raw			    pub fn into_raw(b: Box<T>) -> *mut T 
into_raw			pub fn into_raw<T : ?Sized>(b: Box<T>) -> *mut T 
is_unique			    fn is_unique(&mut self) -> bool 
is_unique			    fn is_unique() 
is_unique			    pub fn is_unique(rc: &Rc<T>) -> bool 
is_unique			pub fn is_unique<T>(rc: &Rc<T>) -> bool { Rc::is_unique(rc) }
je_malloc_stats_print			        fn je_malloc_stats_print(write_cb: Option<extern "C" fn(cbopaque: *mut c_void,
je_mallocx			        fn je_mallocx(size: size_t, flags: c_int) -> *mut c_void;
je_nallocx			        fn je_nallocx(size: size_t, flags: c_int) -> size_t;
je_rallocx			        fn je_rallocx(ptr: *mut c_void, size: size_t, flags: c_int) -> *mut c_void;
je_sdallocx			        fn je_sdallocx(ptr: *mut c_void, size: size_t, flags: c_int);
je_xallocx			        fn je_xallocx(ptr: *mut c_void, size: size_t, extra: size_t, flags: c_int) -> size_t;
le			    fn le(&self, other: &Arc<T>) -> bool { *(*self) <= *(*other) }
le			    fn le(&self, other: &Box<T>) -> bool { PartialOrd::le(&**self, &**other) }
le			    fn le(&self, other: &Rc<T>) -> bool { **self <= **other }
lt			    fn lt(&self, other: &Arc<T>) -> bool { *(*self) < *(*other) }
lt			    fn lt(&self, other: &Box<T>) -> bool { PartialOrd::lt(&**self, &**other) }
lt			    fn lt(&self, other: &Rc<T>) -> bool { **self < **other }
make_place			    fn make_place() -> IntermediateBox<T> { make_place() }
make_place			    fn make_place(self) -> IntermediateBox<T> 
make_place			fn make_place<T>() -> IntermediateBox<T> 
make_unique			    pub fn make_unique(this: &mut Arc<T>) -> &mut T 
make_unique			    pub fn make_unique(&mut self) -> &mut T 
mallocx_align			    fn mallocx_align(a: usize) -> c_int { a.trailing_zeros() as c_int }
manually_share_arc			    fn manually_share_arc() 
ne			    fn ne(&self, other: &Arc<T>) -> bool { *(*self) != *(*other) }
ne			    fn ne(&self, other: &Box<T>) -> bool { PartialEq::ne(&**self, &**other) }
ne			    fn ne(&self, other: &Rc<T>) -> bool { **self != **other }
new			    pub fn new(data: T) -> Arc<T> 
new			    pub fn new(x: T) -> Box<T> 
new			    pub fn new() -> Self 
new			    pub fn new(value: T) -> Rc<T> 
next			    fn next(&mut self) -> Option<I::Item> { (**self).next() }
next_back			    fn next_back(&mut self) -> Option<I::Item> { (**self).next_back() }
oom			pub fn oom() -> ! 
partial_cmp			    fn partial_cmp(&self, other: &Arc<T>) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &Box<T>) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &Rc<T>) -> Option<Ordering> 
pointer			    fn pointer(&mut self) -> *mut T 
posix_memalign			        fn posix_memalign(memptr: *mut *mut libc::c_void,
ptr			    pub fn ptr(&self) -> *mut T 
raw_sized			fn raw_sized() 
raw_trait			fn raw_trait() 
raw_vec			pub mod raw_vec;
rc			pub mod rc;
reallocate			    pub unsafe fn reallocate(ptr: *mut u8, _old_size: usize, size: usize, align: usize) -> *mut u8 
reallocate			    pub unsafe fn reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8 
reallocate			pub unsafe fn reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8 
reallocate_inplace			    pub unsafe fn reallocate_inplace(_ptr: *mut u8, old_size: usize, _size: usize,
reallocate_inplace			    pub unsafe fn reallocate_inplace(ptr: *mut u8, _old_size: usize, size: usize,
reallocate_inplace			    pub unsafe fn reallocate_inplace(ptr: *mut u8, old_size: usize, size: usize,
reallocate_inplace			pub unsafe fn reallocate_inplace(ptr: *mut u8, old_size: usize, size: usize,
reserve			    pub fn reserve(&mut self, used_cap: usize, needed_extra_cap: usize) 
reserve_exact			    pub fn reserve_exact(&mut self, used_cap: usize, needed_extra_cap: usize) 
rust_allocate			        fn rust_allocate(size: usize, align: usize) -> *mut u8;
rust_deallocate			        fn rust_deallocate(ptr: *mut u8, old_size: usize, align: usize);
rust_reallocate			        fn rust_reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8;
rust_reallocate_inplace			        fn rust_reallocate_inplace(ptr: *mut u8, old_size: usize, size: usize,
rust_stats_print			        fn rust_stats_print();
rust_usable_size			        fn rust_usable_size(size: usize, align: usize) -> usize;
set			        fn set(&mut self, value: u32) 
set			        fn set(&mut self, value: u32);
show_arc			    fn show_arc() 
shrink_to_fit			    pub fn shrink_to_fit(&mut self, amount: usize) 
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) { (**self).size_hint() }
stats_print			    pub fn stats_print() 
stats_print			    pub fn stats_print() {}
stats_print			pub fn stats_print() 
strong			    fn strong(&self) -> usize { self.inner().strong.get() }
strong_count			    pub fn strong_count(this: &Arc<T>) -> usize 
strong_count			pub fn strong_count<T: ?Sized>(this: &Arc<T>) -> usize { Arc::strong_count(this) }
strong_count			    pub fn strong_count(this: &Rc<T>) -> usize { this.strong() }
strong_count			pub fn strong_count<T: ?Sized>(this: &Rc<T>) -> usize { Rc::strong_count(this) }
tests			mod tests 
tests			mod tests 
tests			mod tests 
try_unwrap			    fn try_unwrap() 
try_unwrap			    pub fn try_unwrap(rc: Rc<T>) -> Result<T, Rc<T>> 
try_unwrap			pub fn try_unwrap<T>(rc: Rc<T>) -> Result<T, Rc<T>> { Rc::try_unwrap(rc) }
unsafe_no_drop_flag_needs_drop			    pub fn unsafe_no_drop_flag_needs_drop(&self) -> bool 
upgrade			    pub fn upgrade(&self) -> Option<Arc<T>> 
upgrade			    pub fn upgrade(&self) -> Option<Rc<T>> 
usable_size			    pub fn usable_size(size: usize, _align: usize) -> usize 
usable_size			    pub fn usable_size(size: usize, align: usize) -> usize 
usable_size			pub fn usable_size(size: usize, align: usize) -> usize 
weak			    fn weak(&self) -> usize { self.inner().weak.get() }
weak_count			    pub fn weak_count(this: &Arc<T>) -> usize 
weak_count			pub fn weak_count<T: ?Sized>(this: &Arc<T>) -> usize { Arc::weak_count(this) }
weak_count			    pub fn weak_count(this: &Rc<T>) -> usize { this.weak() - 1 }
weak_count			pub fn weak_count<T: ?Sized>(this: &Rc<T>) -> usize { Rc::weak_count(this) }
weak_self_cyclic			    fn weak_self_cyclic() 
weak_self_cyclic			    fn weak_self_cyclic() 
with_capacity			    pub fn with_capacity(cap: usize) -> Self 
write_str			            fn write_str(&mut self, s: &str) -> Result 
