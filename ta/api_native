CFile			impl CFile 
CFile			pub struct CFile 
CreateEventA			        fn CreateEventA(lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
CreateWaitableTimerA			        pub fn CreateWaitableTimerA(lpTimerAttributes: LPSECURITY_ATTRIBUTES,
Drop			impl Drop for CFile 
Drop			impl Drop for Inner 
Drop			impl Drop for Inner 
Drop			impl Drop for Inner 
Drop			impl Drop for Inner 
Drop			impl Drop for Event 
Drop			impl Drop for Inner 
Drop			impl Drop for UnixListener 
Drop			impl Drop for Process 
Drop			impl Drop for Timer 
Drop			impl Drop for Timer 
Drop			impl Drop for Timer 
Event			impl Event 
Event			struct Event(libc::HANDLE);
FileDesc			impl FileDesc 
FileDesc			pub struct FileDesc 
FileDesc			impl FileDesc 
FileDesc			pub struct FileDesc 
GetAddrInfoRequest			impl GetAddrInfoRequest 
GetAddrInfoRequest			pub struct GetAddrInfoRequest;
InAddr			enum InAddr 
Inner			struct Inner 
Inner			struct Inner 
Inner			struct Inner 
Inner			struct Inner 
Inner			struct Inner 
Inner			struct Inner 
IoFactory			impl IoFactory 
IoFactory			pub struct IoFactory 
Ops			struct Ops 
Process			impl Process 
Process			pub struct Process 
Req			pub enum Req 
Req			pub enum Req 
Req			pub enum Req 
SetEvent			        fn SetEvent(hEvent: HANDLE) -> BOOL;
SetWaitableTimer			        pub fn SetWaitableTimer(hTimer: HANDLE,
SpawnProcessResult			struct SpawnProcessResult 
TcpAcceptor			impl TcpAcceptor 
TcpAcceptor			pub struct TcpAcceptor 
TcpListener			impl TcpListener 
TcpListener			pub struct TcpListener 
TcpStream			impl TcpStream 
TcpStream			pub struct TcpStream 
Timer			impl Timer 
Timer			pub struct Timer 
Timer			impl Timer 
Timer			pub struct Timer 
Timer			impl Timer 
Timer			pub struct Timer 
UdpSocket			impl UdpSocket 
UdpSocket			pub struct UdpSocket 
UnixAcceptor			impl UnixAcceptor 
UnixAcceptor			pub struct UnixAcceptor 
UnixAcceptor			impl UnixAcceptor 
UnixAcceptor			pub struct UnixAcceptor 
UnixDatagram			impl UnixDatagram 
UnixDatagram			pub struct UnixDatagram 
UnixListener			impl UnixListener 
UnixListener			pub struct UnixListener 
UnixListener			impl UnixListener 
UnixListener			pub struct UnixListener 
UnixStream			impl UnixStream 
UnixStream			pub struct UnixStream 
UnixStream			impl UnixStream 
UnixStream			pub struct UnixStream 
WEXITSTATUS			        pub fn WEXITSTATUS(status: i32) -> i32 { (status >> 8) & 0xff }
WEXITSTATUS			        pub fn WEXITSTATUS(status: i32) -> i32 { status >> 8 }
WIFEXITED			        pub fn WIFEXITED(status: i32) -> bool { (status & 0x7f) == 0 }
WIFEXITED			        pub fn WIFEXITED(status: i32) -> bool { (status & 0xff) == 0 }
WSADATA			    struct WSADATA 
WSAGetLastError			    fn WSAGetLastError() -> c_int;
WSAGetLastError			        fn WSAGetLastError() -> libc::c_int;
WSAStartup			        fn WSAStartup(wVersionRequested: libc::WORD,
WTERMSIG			        pub fn WTERMSIG(status: i32) -> i32 { status & 0o177 }
WTERMSIG			        pub fn WTERMSIG(status: i32) -> i32 { status & 0x7f }
WaitForMultipleObjects			        pub fn WaitForMultipleObjects(nCount: DWORD,
WaitForSingleObject			        pub fn WaitForSingleObject(hHandle: HANDLE,
accept			    fn accept(&mut self) -> IoResult<~rtio::RtioTcpStream:Send> 
accept			    fn accept(&mut self) -> IoResult<~rtio::RtioPipe:Send> 
accept			    fn accept(&mut self) -> IoResult<~rtio::RtioPipe:Send> 
accept_simultaneously			    fn accept_simultaneously(&mut self) -> IoResult<()> { Ok(()) }
add			    fn add(efd: libc::c_int, fd: libc::c_int) 
addr_to_sockaddr			fn addr_to_sockaddr(addr: ip::SocketAddr) -> (libc::sockaddr_storage, uint) 
addr_to_sockaddr_un			fn addr_to_sockaddr_un(addr: &CString) -> IoResult<(libc::sockaddr_storage, uint)> 
addrinfo			pub mod addrinfo;
append_arg			    fn append_arg(cmd: &mut ~str, arg: &str) 
append_char_at			    fn append_char_at(cmd: &mut ~str, arg: &str, i: uint) 
backslash_run_ends_in_quote			    fn backslash_run_ends_in_quote(s: &str, mut i: uint) -> bool 
bind			    pub fn bind(addr: ip::SocketAddr) -> IoResult<TcpListener> 
bind			    pub fn bind(addr: ip::SocketAddr) -> IoResult<UdpSocket> 
bind			    pub fn bind(addr: &CString) -> IoResult<UnixDatagram> 
bind			    pub fn bind(addr: &CString) -> IoResult<UnixListener> 
bind			fn bind(addr: &CString, ty: libc::c_int) -> IoResult<Inner> 
bind			    pub fn bind(addr: &CString) -> IoResult<UnixListener> 
boot			pub fn boot(helper: fn(imp::signal, Receiver<Req>)) 
can_block			    fn can_block(&self) -> bool { true }
chmod			pub fn chmod(p: &CString, mode: io::FilePermission) -> IoResult<()> 
chmod			pub fn chmod(p: &CString, mode: io::FilePermission) -> IoResult<()> 
chown			pub fn chown(p: &CString, uid: int, gid: int) -> IoResult<()> 
chown			pub fn chown(_p: &CString, _uid: int, _gid: int) -> IoResult<()> 
clone			    fn clone(&self) -> ~rtio::RtioPipe:Send 
clone			    fn clone(&self) -> ~rtio::RtioPipe:Send 
clone			    fn clone(&self) -> ~rtio::RtioTcpStream:Send 
clone			    fn clone(&self) -> ~rtio::RtioUdpSocket:Send 
clone			    fn clone(&self) -> ~rtio::RtioPipe:Send 
clone			    pub fn clone(&mut self) -> UnixDatagram 
clone			    fn clone(&self) -> ~rtio::RtioPipe:Send 
close			    pub fn close(fd: libc::c_int) 
close			    pub fn close(handle: HANDLE) 
close_write			    fn close_write(&mut self) -> IoResult<()> 
connect			    pub fn connect(addr: ip::SocketAddr) -> IoResult<TcpStream> 
connect			    pub fn connect(addr: &CString) -> IoResult<UnixDatagram> 
connect			    pub fn connect(addr: &CString) -> IoResult<UnixStream> 
connect			fn connect(addr: &CString, ty: libc::c_int) -> IoResult<Inner> 
connect			    pub fn connect(addr: &CString) -> IoResult<UnixStream> 
control_congestion			    fn control_congestion(&mut self) -> IoResult<()> 
datasync			    fn datasync(&mut self) -> Result<(), IoError> 
datasync			    fn datasync(&mut self) -> Result<(), IoError> { return self.fsync(); }
del			    fn del(efd: libc::c_int, fd: libc::c_int) 
deschedule			    fn deschedule(mut ~self, times: uint, mut cur_task: ~Task,
dont_accept_simultaneously			    fn dont_accept_simultaneously(&mut self) -> IoResult<()> { Ok(()) }
dont_loop_multicast_locally			    fn dont_loop_multicast_locally(&mut self) -> IoResult<()> 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) { unsafe { close(self.fd); } }
drop			    fn drop(&mut self) { unsafe { let _ = libc::close(self.fd); } }
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
epoll_create			        pub fn epoll_create(size: libc::c_int) -> libc::c_int;
epoll_ctl			        pub fn epoll_ctl(epfd: libc::c_int,
epoll_event			    pub struct epoll_event 
epoll_wait			        pub fn epoll_wait(epfd: libc::c_int,
fail			            fn fail(output: &mut file::FileDesc) -> ! 
fd			    pub fn fd(&self) -> fd_t 
fd			    pub fn fd(&self) -> fd_t 
fd			    pub fn fd(&self) -> sock_t { self.listener.fd() }
fd			    pub fn fd(&self) -> sock_t 
fd			    fn fd(&self) -> fd_t { self.inner.fd }
fd			    fn fd(&self) -> fd_t { self.listener.fd() }
fd			    fn fd(&self) -> fd_t { unsafe { (*self.inner.get()).fd } }
fd_set			    pub fn fd_set(set: &mut fd_set, fd: i32) 
fd_set			    pub struct fd_set 
file			pub mod file;
flags			    fn flags(_stat: &libc::stat) -> u64 { 0 }
flags			    fn flags(stat: &libc::stat) -> u64 { stat.st_flags as u64 }
flush			    pub fn flush(&mut self) -> Result<(), IoError> 
free_handle			fn free_handle(_handle: *()) 
free_handle			fn free_handle(handle: *()) 
freeaddrinfo			    fn freeaddrinfo(res: *mut libc::addrinfo);
fs_chmod			    fn fs_chmod(&mut self, path: &CString,
fs_chown			    fn fs_chown(&mut self, path: &CString, uid: int, gid: int) -> IoResult<()> 
fs_from_raw_fd			    fn fs_from_raw_fd(&mut self, fd: c_int,
fs_link			    fn fs_link(&mut self, src: &CString, dst: &CString) -> IoResult<()> 
fs_lstat			    fn fs_lstat(&mut self, path: &CString) -> IoResult<io::FileStat> 
fs_mkdir			    fn fs_mkdir(&mut self, path: &CString,
fs_open			    fn fs_open(&mut self, path: &CString, fm: io::FileMode, fa: io::FileAccess)
fs_readdir			    fn fs_readdir(&mut self, path: &CString, _flags: c_int) -> IoResult<~[Path]> 
fs_readlink			    fn fs_readlink(&mut self, path: &CString) -> IoResult<Path> 
fs_rename			    fn fs_rename(&mut self, path: &CString, to: &CString) -> IoResult<()> 
fs_rmdir			    fn fs_rmdir(&mut self, path: &CString) -> IoResult<()> 
fs_stat			    fn fs_stat(&mut self, path: &CString) -> IoResult<io::FileStat> 
fs_symlink			    fn fs_symlink(&mut self, src: &CString, dst: &CString) -> IoResult<()> 
fs_unlink			    fn fs_unlink(&mut self, path: &CString) -> IoResult<()> 
fs_utime			    fn fs_utime(&mut self, src: &CString, atime: u64,
fsync			    fn fsync(&mut self) -> Result<(), IoError> 
fsync			    fn fsync(&mut self) -> Result<(), IoError> 
gai_strerror			    fn gai_strerror(errcode: c_int) -> *c_char;
gen			    fn gen(_stat: &libc::stat) -> u64 { 0 }
gen			    fn gen(stat: &libc::stat) -> u64 { stat.st_gen as u64 }
get_error			fn get_error(_: c_int) -> IoError 
get_error			fn get_error(s: c_int) -> IoError 
get_host_addresses			    fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,
get_io			        fn get_io(io: p::StdioContainer, ret: &mut ~[Option<file::FileDesc>])
get_winsize			    fn get_winsize(&mut self) -> Result<(int, int), IoError> 
get_winsize			    fn get_winsize(&mut self) -> Result<(int, int), IoError> 
getaddrinfo			    fn getaddrinfo(node: *c_char, service: *c_char,
gettimeofday			        pub fn gettimeofday(timeval: *mut libc::timeval,
handle			    pub fn handle(&self) -> libc::HANDLE 
handle			    fn handle(&self) -> libc::HANDLE { let Event(handle) = *self; handle }
handle			    fn handle(&self) -> libc::HANDLE { unsafe { (*self.inner.get()).handle } }
hear_broadcasts			    fn hear_broadcasts(&mut self) -> IoResult<()> 
helper			fn helper(input: libc::c_int, messages: Receiver<Req>) 
helper			fn helper(input: libc::c_int, messages: Receiver<Req>) 
helper			fn helper(input: libc::HANDLE, messages: Receiver<Req>) 
htons			pub fn htons(u: u16) -> u16 
id			    fn id(&self) -> pid_t { self.pid }
ignore_broadcasts			    fn ignore_broadcasts(&mut self) -> IoResult<()> 
imp			    mod imp 
imp			mod imp 
imp			mod imp 
imp			mod imp 
imp			mod imp 
init			pub fn init() 
init			pub fn init() {}
inner			    fn inner(&mut self) -> ~Inner 
inner_read			    pub fn inner_read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> 
inner_read			    pub fn inner_read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> 
inner_write			    pub fn inner_write(&mut self, buf: &[u8]) -> Result<(), IoError> 
inner_write			    pub fn inner_write(&mut self, buf: &[u8]) -> Result<(), IoError> 
insert			    fn insert(t: ~Inner, active: &mut ~[~Inner]) 
io			impl io::Reader for FileDesc 
io			impl io::Writer for FileDesc 
io			impl io::Reader for FileDesc 
io			impl io::Writer for FileDesc 
io			pub mod io;
ip_to_inaddr			fn ip_to_inaddr(ip: ip::IpAddr) -> InAddr 
isatty			    fn isatty(&self) -> bool { false }
isatty			    fn isatty(&self) -> bool { false }
itimerspec			    pub struct itimerspec 
join_multicast			    fn join_multicast(&mut self, multi: ip::IpAddr) -> IoResult<()> 
keep_going			fn keep_going(data: &[u8], f: |*u8, uint| -> i64) -> i64 
keepalive			    fn keepalive(&mut self, delay_in_seconds: uint) -> IoResult<()> 
kill			    fn kill(&mut self, pid: libc::pid_t, signum: int) -> IoResult<()> 
kill			    fn kill(&mut self, signum: int) -> Result<(), io::IoError> 
kill			    pub fn kill(pid: libc::pid_t, signum: int) -> IoResult<()> 
killpid			unsafe fn killpid(pid: pid_t, signal: int) -> Result<(), io::IoError> 
lang_start			pub fn lang_start(main: *u8, argc: int, argv: **u8) -> int 
last_error			fn last_error() -> IoError 
last_error			fn last_error() -> io::IoError 
leave_multicast			    fn leave_multicast(&mut self, multi: ip::IpAddr) -> IoResult<()> 
letdie			    fn letdie(&mut self) -> IoResult<()> 
link			pub fn link(src: &CString, dst: &CString) -> IoResult<()> 
link			pub fn link(src: &CString, dst: &CString) -> IoResult<()> 
listen			    fn listen(~self) -> IoResult<~rtio::RtioTcpAcceptor:Send> 
listen			    fn listen(~self) -> IoResult<~rtio::RtioUnixAcceptor:Send> 
listen			    fn listen(~self) -> IoResult<~rtio::RtioUnixAcceptor:Send> 
local_io			    fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>> 
loop_multicast_locally			    fn loop_multicast_locally(&mut self) -> IoResult<()> 
lstat			pub fn lstat(p: &CString) -> IoResult<io::FileStat> 
lstat			pub fn lstat(_p: &CString) -> IoResult<io::FileStat> 
make_command_line			fn make_command_line(prog: &str, args: &[~str]) -> ~str 
maybe_yield			    fn maybe_yield(~self, mut cur_task: ~Task) 
mkdir			pub fn mkdir(p: &CString, mode: io::FilePermission) -> IoResult<()> 
mkdir			pub fn mkdir(p: &CString, _mode: io::FilePermission) -> IoResult<()> 
mkerr_libc			fn mkerr_libc(ret: libc::c_int) -> IoResult<()> 
mkerr_winbool			fn mkerr_winbool(ret: libc::c_int) -> IoResult<()> 
mkstat			fn mkstat(stat: &libc::stat, path: &CString) -> io::FileStat 
mkstat			fn mkstat(stat: &libc::stat, path: &CString) -> io::FileStat 
mktime			    fn mktime(secs: u64, nsecs: u64) -> u64 { secs * 1000 + nsecs \/ 1000000 }
multicast_time_to_live			    fn multicast_time_to_live(&mut self, ttl: int) -> IoResult<()> 
native_accept			    pub fn native_accept(&mut self) -> IoResult<TcpStream> 
native_accept			    pub fn native_accept(&mut self) -> IoResult<UnixStream> 
native_accept			    pub fn native_accept(&mut self) -> IoResult<UnixStream> 
native_listen			    pub fn native_listen(self, backlog: int) -> IoResult<TcpAcceptor> 
native_listen			    pub fn native_listen(self, backlog: int) -> IoResult<UnixAcceptor> 
native_listen			    pub fn native_listen(self) -> IoResult<UnixAcceptor> 
net			pub mod net;
new			    pub fn new(fd: fd_t, close_on_drop: bool) -> FileDesc 
new			    pub fn new(file: *libc::FILE) -> CFile 
new			    pub fn new(fd: fd_t, close_on_drop: bool) -> FileDesc 
new			    pub fn new() -> IoFactory 
new			    fn new(manual_reset: bool, initial_state: bool) -> IoResult<Event> 
new			    pub fn new() -> (HANDLE, HANDLE) 
new			    pub fn new() -> (signal, signal) 
new			    pub fn new() -> IoResult<Timer> 
new			    pub fn new() -> IoResult<Timer> 
new			    pub fn new() -> IoResult<Timer> 
new			pub fn new(stack_bounds: (uint, uint)) -> ~Task 
nodelay			    fn nodelay(&mut self) -> IoResult<()> 
now			fn now() -> u64 
ntohs			pub fn ntohs(u: u16) -> u16 
oneshot			    fn oneshot(&mut self, msecs: u64) -> Receiver<()> 
oneshot			    fn oneshot(&mut self, msecs: u64) -> Receiver<()> 
oneshot			    fn oneshot(&mut self, msecs: u64) -> Receiver<()> 
open			pub fn open(path: &CString, fm: io::FileMode, fa: io::FileAccess)
open			pub fn open(path: &CString, fm: io::FileMode, fa: io::FileAccess)
ops			fn ops() -> ~Ops 
os_datasync			        fn os_datasync(fd: c_int) -> c_int 
peer_name			    fn peer_name(&mut self) -> IoResult<ip::SocketAddr> 
period			    fn period(&mut self, msecs: u64) -> Receiver<()> 
period			    fn period(&mut self, msecs: u64) -> Receiver<()> 
period			    fn period(&mut self, msecs: u64) -> Receiver<()> 
pipe			pub mod pipe;
pipe			unsafe fn pipe(name: *u16, init: bool) -> libc::HANDLE 
pipe_open			    fn pipe_open(&mut self, fd: c_int) -> IoResult<~RtioPipe:Send> 
pread			    fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError> 
pread			    fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError> 
process			pub mod process;
prune			    fn prune(root: &CString, dirs: ~[Path]) -> ~[Path] 
prune			    fn prune(root: &CString, dirs: ~[Path]) -> ~[Path] 
pwrite			    fn pwrite(&mut self, buf: &[u8], offset: u64) -> Result<(), IoError> 
pwrite			    fn pwrite(&mut self, buf: &[u8], mut offset: u64) -> Result<(), IoError> 
read			    fn read(&mut self, buf: &mut [u8]) -> Result<int, IoError> 
read			    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> 
read			    fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> Result<int, IoError> 
read			    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> 
read			    fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
readdir			pub fn readdir(p: &CString) -> IoResult<~[Path]> 
readdir			pub fn readdir(p: &CString) -> IoResult<~[Path]> 
readlink			pub fn readlink(p: &CString) -> IoResult<Path> 
readlink			pub fn readlink(p: &CString) -> IoResult<Path> 
reawaken			    fn reawaken(mut ~self, mut to_wake: ~Task) 
recvfrom			    fn recvfrom(&mut self, buf: &mut [u8]) -> IoResult<(uint, ip::SocketAddr)> 
recvfrom			    pub fn recvfrom(&mut self, buf: &mut [u8]) -> IoResult<(uint, CString)> 
remove			    fn remove(&mut self) 
remove			    fn remove(&mut self) 
rename			pub fn rename(old: &CString, new: &CString) -> IoResult<()> 
rename			pub fn rename(old: &CString, new: &CString) -> IoResult<()> 
retry			fn retry(f: || -> libc::c_int) -> libc::c_int 
rmdir			pub fn rmdir(p: &CString) -> IoResult<()> 
rmdir			pub fn rmdir(p: &CString) -> IoResult<()> 
rt			impl rt::Runtime for Ops 
rtio			impl rtio::RtioFileStream for CFile 
rtio			impl rtio::RtioFileStream for FileDesc 
rtio			impl rtio::RtioPipe for FileDesc 
rtio			impl rtio::RtioTTY for FileDesc 
rtio			impl rtio::RtioFileStream for FileDesc 
rtio			impl rtio::RtioPipe for FileDesc 
rtio			impl rtio::RtioTTY for FileDesc 
rtio			impl rtio::IoFactory for IoFactory 
rtio			impl rtio::RtioSocket for TcpAcceptor 
rtio			impl rtio::RtioSocket for TcpListener 
rtio			impl rtio::RtioSocket for TcpStream 
rtio			impl rtio::RtioSocket for UdpSocket 
rtio			impl rtio::RtioTcpAcceptor for TcpAcceptor 
rtio			impl rtio::RtioTcpListener for TcpListener 
rtio			impl rtio::RtioTcpStream for TcpStream 
rtio			impl rtio::RtioUdpSocket for UdpSocket 
rtio			impl rtio::RtioPipe for UnixStream 
rtio			impl rtio::RtioUnixAcceptor for UnixAcceptor 
rtio			impl rtio::RtioUnixListener for UnixListener 
rtio			impl rtio::RtioPipe for UnixStream 
rtio			impl rtio::RtioUnixAcceptor for UnixAcceptor 
rtio			impl rtio::RtioUnixListener for UnixListener 
rtio			impl rtio::RtioProcess for Process 
rtio			impl rtio::RtioTimer for Timer 
rtio			impl rtio::RtioTimer for Timer 
rtio			impl rtio::RtioTimer for Timer 
run			    pub fn run(host: Option<&str>, servname: Option<&str>,
run			pub fn run(main: proc()) -> int 
rust_dirent_t_size			        fn rust_dirent_t_size() -> libc::c_int;
rust_list_dir_val			        fn rust_list_dir_val(ptr: *mut dirent_t) -> *libc::c_char;
rust_list_dir_wfd_fp_buf			        fn rust_list_dir_wfd_fp_buf(wfd: *libc::c_void) -> *u16;
rust_list_dir_wfd_size			        fn rust_list_dir_wfd_size() -> libc::size_t;
rust_unset_sigprocmask			            pub fn rust_unset_sigprocmask();
rustrt			    mod rustrt 
seek			    fn seek(&mut self, pos: i64, style: io::SeekStyle) -> Result<u64, IoError> 
seek			    fn seek(&mut self, pos: i64, whence: io::SeekStyle) -> Result<u64, IoError> 
seek			    fn seek(&mut self, pos: i64, style: io::SeekStyle) -> Result<u64, IoError> 
select			        pub fn select(nfds: libc::c_int,
send			pub fn send(req: Req) 
sendto			    fn sendto(&mut self, buf: &[u8], dst: ip::SocketAddr) -> IoResult<()> 
sendto			    pub fn sendto(&mut self, buf: &[u8], dst: &CString) -> IoResult<()> 
set_broadcast			    pub fn set_broadcast(&mut self, on: bool) -> IoResult<()> 
set_cloexec			    unsafe fn set_cloexec(fd: c_int) 
set_environ			    unsafe fn set_environ(envp: *c_void) 
set_keepalive			    fn set_keepalive(&mut self, seconds: Option<uint>) -> IoResult<()> 
set_membership			    pub fn set_membership(&mut self, addr: ip::IpAddr,
set_multicast_loop			    pub fn set_multicast_loop(&mut self, on: bool) -> IoResult<()> 
set_nodelay			    fn set_nodelay(&mut self, nodelay: bool) -> IoResult<()> 
set_raw			    fn set_raw(&mut self, _raw: bool) -> Result<(), IoError> 
set_raw			    fn set_raw(&mut self, _raw: bool) -> Result<(), IoError> 
set_tcp_keepalive			    fn set_tcp_keepalive(&mut self, _seconds: uint) -> IoResult<()> 
set_tcp_keepalive			    fn set_tcp_keepalive(&mut self, seconds: uint) -> IoResult<()> 
setgroups			                        fn setgroups(ngroups: libc::c_int,
setsockopt			fn setsockopt<T>(fd: sock_t, opt: libc::c_int, val: libc::c_int,
shutdown			fn shutdown() 
signal			    fn signal(&mut self, _signal: Signum, _channel: Sender<Signum>)
signal			    pub fn signal(fd: libc::c_int) 
signal			    pub fn signal(handle: HANDLE) 
signal			    fn signal(active: &mut ~[~Inner], dead: &mut ~[(uint, ~Inner)]) 
sleep			    fn sleep(&mut self, msecs: u64) 
sleep			    pub fn sleep(ms: u64) 
sleep			    fn sleep(&mut self, msecs: u64) 
sleep			    pub fn sleep(ms: u64) 
sleep			    fn sleep(&mut self, msecs: u64) 
sleep			    pub fn sleep(ms: u64) 
smoke			    fn smoke() 
smoke_fail			    fn smoke_fail() 
smoke_opts			    fn smoke_opts() 
smoke_opts_fail			    fn smoke_opts_fail() 
sockaddr_to_addr			pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,
sockaddr_to_unix			fn sockaddr_to_unix(storage: &libc::sockaddr_storage,
socket			fn socket(addr: ip::SocketAddr, ty: libc::c_int) -> IoResult<sock_t> 
socket_name			    fn socket_name(&mut self) -> IoResult<ip::SocketAddr> 
sockname			fn sockname(fd: sock_t,
spawn			    fn spawn(&mut self, config: ProcessConfig)
spawn			    pub fn spawn(config: p::ProcessConfig)
spawn			pub fn spawn(f: proc:Send()) 
spawn_children			    fn spawn_children() 
spawn_inherits			    fn spawn_inherits() 
spawn_opts			pub fn spawn_opts(opts: TaskOpts, f: proc:Send()) 
spawn_process_os			fn spawn_process_os(config: p::ProcessConfig,
spawn_sibling			    fn spawn_sibling(~self, mut cur_task: ~Task, opts: TaskOpts, f: proc:Send()) 
stack_bounds			    fn stack_bounds(&self) -> (uint, uint) { self.stack_bounds }
start			pub fn start(argc: int, argv: **u8, main: proc()) -> int 
stat			pub fn stat(p: &CString) -> IoResult<io::FileStat> 
stat			pub fn stat(p: &CString) -> IoResult<io::FileStat> 
symlink			pub fn symlink(src: &CString, dst: &CString) -> IoResult<()> 
symlink			pub fn symlink(src: &CString, dst: &CString) -> IoResult<()> 
task			pub mod task;
tcp_bind			    fn tcp_bind(&mut self, addr: SocketAddr) -> IoResult<~RtioTcpListener:Send> 
tcp_connect			    fn tcp_connect(&mut self, addr: SocketAddr) -> IoResult<~RtioTcpStream:Send> 
tell			    fn tell(&self) -> Result<u64, IoError> 
tell			    fn tell(&self) -> Result<u64, IoError> 
test_cfile			    fn test_cfile() 
test_file_desc			    fn test_file_desc() 
test_make_command_line			    fn test_make_command_line() 
tests			mod tests 
tests			mod tests 
tests			mod tests 
time_to_live			    fn time_to_live(&mut self, ttl: int) -> IoResult<()> 
timer			pub mod timer;
timer_helper			mod timer_helper;
timer_init			    fn timer_init(&mut self) -> IoResult<~RtioTimer:Send> 
timerfd_create			        pub fn timerfd_create(clockid: libc::c_int,
timerfd_gettime			        pub fn timerfd_gettime(fd: libc::c_int,
timerfd_settime			        pub fn timerfd_settime(fd: libc::c_int,
timespec			    pub struct timespec 
translate_status			fn translate_status(status: c_int) -> p::ProcessExit 
truncate			    fn truncate(&mut self, offset: i64) -> Result<(), IoError> 
truncate			    fn truncate(&mut self, offset: i64) -> Result<(), IoError> 
try_connect			    fn try_connect(p: *u16) -> Option<libc::HANDLE> 
tty_open			    fn tty_open(&mut self, fd: c_int, _readable: bool)
udp_bind			    fn udp_bind(&mut self, addr: SocketAddr) -> IoResult<~RtioUdpSocket:Send> 
unimpl			fn unimpl() -> IoError 
unix_bind			    fn unix_bind(&mut self, path: &CString) -> IoResult<~RtioUnixListener:Send> 
unix_connect			    fn unix_connect(&mut self, path: &CString) -> IoResult<~RtioPipe:Send> 
unix_socket			fn unix_socket(ty: libc::c_int) -> IoResult<fd_t> 
unlink			pub fn unlink(p: &CString) -> IoResult<()> 
unlink			pub fn unlink(p: &CString) -> IoResult<()> 
utime			pub fn utime(p: &CString, atime: u64, mtime: u64) -> IoResult<()> 
utime			pub fn utime(p: &CString, atime: u64, mtime: u64) -> IoResult<()> 
wait			    fn wait(&mut self) -> p::ProcessExit 
waitpid			fn waitpid(pid: pid_t) -> p::ProcessExit 
waitpid_nowait			fn waitpid_nowait(pid: pid_t) -> Option<p::ProcessExit> 
waitpid_os			    fn waitpid_os(_pid: pid_t) -> Option<p::ProcessExit> { None }
waitpid_os			    fn waitpid_os(pid: pid_t) -> Option<p::ProcessExit> 
waitpid_os			    fn waitpid_os(pid: pid_t) -> p::ProcessExit 
with_argv			fn with_argv<T>(prog: &str, args: &[~str], cb: proc:(**libc::c_char) -> T) -> T 
with_dirp			fn with_dirp<T>(d: Option<&Path>, cb: |*libc::c_char| -> T) -> T 
with_envp			fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: proc:(*c_void) -> T) -> T 
with_envp			fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: |*mut c_void| -> T) -> T 
wrap			    fn wrap(~self) -> ~Any 
write			    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> 
write			    fn write(&mut self, buf: &[u8]) -> io::IoResult<()> 
write			    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> 
write			    fn write(&mut self, buf: &[u8]) -> io::IoResult<()> 
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
yield_now			    fn yield_now(~self, mut cur_task: ~Task) 
yield_test			    fn yield_test() 
zeroed_process_information			fn zeroed_process_information() -> libc::types::os::arch::extra::PROCESS_INFORMATION 
zeroed_startupinfo			fn zeroed_startupinfo() -> libc::types::os::arch::extra::STARTUPINFO 
