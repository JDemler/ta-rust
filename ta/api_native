CFile			impl CFile 
CFile			pub struct CFile 
CancelIo			    pub fn CancelIo(hFile: libc::HANDLE) -> libc::BOOL;
CancelIoEx			    pub fn CancelIoEx(hFile: libc::HANDLE,
Closer			    struct Closer { fd: libc::c_int }
CreateEventA			        fn CreateEventA(lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
CreateWaitableTimerA			        pub fn CreateWaitableTimerA(lpTimerAttributes: LPSECURITY_ATTRIBUTES,
Drop			impl Drop for CFile 
Drop			impl Drop for Inner 
Drop			impl Drop for Inner 
Drop			impl Drop for Inner 
Drop			impl Drop for Inner 
Drop			impl Drop for UnixListener 
Drop			impl Drop for Event 
Drop			impl Drop for Inner 
Drop			impl Drop for UnixListener 
Drop			    impl Drop for Closer 
Drop			impl Drop for Process 
Drop			impl Drop for Timer 
Drop			impl Drop for Timer 
Drop			impl Drop for WindowsTTY 
Event			impl Event 
Event			struct Event(libc::HANDLE);
FileDesc			impl FileDesc 
FileDesc			pub struct FileDesc 
FileDesc			impl FileDesc 
FileDesc			pub struct FileDesc 
GetAddrInfoRequest			impl GetAddrInfoRequest 
GetAddrInfoRequest			pub struct GetAddrInfoRequest;
GetConsoleMode			    pub fn GetConsoleMode(hConsoleHandle: libc::HANDLE,
GetModuleHandleW			        fn GetModuleHandleW(lpModuleName: LPCWSTR) -> HMODULE;
GetProcAddress			        fn GetProcAddress(hModule: HMODULE, lpProcName: LPCSTR) -> LPVOID;
Guard			pub struct Guard<'a> 
Helper			pub struct Helper<M> 
InAddr			enum InAddr 
Inner			struct Inner 
Inner			struct Inner 
Inner			impl Inner 
Inner			struct Inner 
Inner			impl Inner 
Inner			struct Inner 
Inner			impl Inner 
Inner			struct Inner 
Inner			struct Inner 
IoFactory			impl IoFactory 
IoFactory			pub struct IoFactory 
NativeSpawner			pub struct NativeSpawner;
NativeTaskBuilder			pub trait NativeTaskBuilder 
Ops			struct Ops 
Process			impl Process 
Process			pub struct Process 
ReadConsoleW			    pub fn ReadConsoleW(hConsoleInput: libc::HANDLE,
Req			enum Req 
Req			pub enum Req 
Req			pub enum Req 
RtioTTY			impl RtioTTY for WindowsTTY 
SetConsoleMode			    pub fn SetConsoleMode(hConsoleHandle: libc::HANDLE,
SetEvent			        fn SetEvent(hEvent: HANDLE) -> BOOL;
SetLastError			            fn SetLastError(dwErrCode: DWORD);
SetWaitableTimer			        pub fn SetWaitableTimer(hTimer: HANDLE,
SocketStatus			pub enum SocketStatus 
SpawnProcessResult			struct SpawnProcessResult 
Spawner			impl Spawner for NativeSpawner 
TcpAcceptor			impl TcpAcceptor 
TcpAcceptor			pub struct TcpAcceptor 
TcpListener			impl TcpListener 
TcpListener			pub struct TcpListener 
TcpStream			impl TcpStream 
TcpStream			pub struct TcpStream 
Timer			impl Timer 
Timer			pub struct Timer 
Timer			impl Timer 
Timer			pub struct Timer 
UdpSocket			impl UdpSocket 
UdpSocket			pub struct UdpSocket 
UnixAcceptor			impl UnixAcceptor 
UnixAcceptor			pub struct UnixAcceptor 
UnixAcceptor			impl UnixAcceptor 
UnixAcceptor			pub struct UnixAcceptor 
UnixListener			impl UnixListener 
UnixListener			pub struct UnixListener 
UnixListener			impl UnixListener 
UnixListener			pub struct UnixListener 
UnixStream			impl UnixStream 
UnixStream			pub struct UnixStream 
UnixStream			impl UnixStream 
UnixStream			pub struct UnixStream 
WEXITSTATUS			        pub fn WEXITSTATUS(status: i32) -> i32 { (status >> 8) & 0xff }
WEXITSTATUS			        pub fn WEXITSTATUS(status: i32) -> i32 { status >> 8 }
WIFEXITED			        pub fn WIFEXITED(status: i32) -> bool { (status & 0x7f) == 0 }
WIFEXITED			        pub fn WIFEXITED(status: i32) -> bool { (status & 0xff) == 0 }
WSADATA			pub struct WSADATA 
WSAGetLastError			    pub fn WSAGetLastError() -> libc::c_int;
WSAStartup			    pub fn WSAStartup(wVersionRequested: libc::WORD,
WTERMSIG			        pub fn WTERMSIG(status: i32) -> i32 { status & 0o177 }
WTERMSIG			        pub fn WTERMSIG(status: i32) -> i32 { status & 0x7f }
WaitForMultipleObjects			        pub fn WaitForMultipleObjects(nCount: DWORD,
WaitForSingleObject			        pub fn WaitForSingleObject(hHandle: HANDLE,
WindowsTTY			impl WindowsTTY 
WindowsTTY			pub struct WindowsTTY 
WriteConsoleW			    pub fn WriteConsoleW(hConsoleOutput: libc::HANDLE,
accept			    fn accept(&mut self) -> IoResult<Box<rtio::RtioTcpStream + Send>> 
accept			    fn accept(&mut self) -> IoResult<Box<rtio::RtioPipe + Send>> 
accept			    fn accept(&mut self) -> IoResult<Box<rtio::RtioPipe + Send>> 
accept_simultaneously			    fn accept_simultaneously(&mut self) -> IoResult<()> { Ok(()) }
addr_to_sockaddr			fn addr_to_sockaddr(addr: rtio::SocketAddr) -> (libc::sockaddr_storage, uint) 
addr_to_sockaddr_un			fn addr_to_sockaddr_un(addr: &CString) -> IoResult<(libc::sockaddr_storage, uint)> 
addrinfo			pub mod addrinfo;
append_arg			    fn append_arg(cmd: &mut String, arg: &str) 
append_char_at			    fn append_char_at(cmd: &mut String, arg: &Vec<char>, i: uint) 
await			pub fn await(handle: libc::HANDLE, deadline: u64,
await			    fn await(_fd: net::sock_t, set: &mut c::fd_set,
await			    fn await(fd: net::sock_t, set: &mut c::fd_set,
await			pub fn await(fd: net::sock_t, deadline: Option<u64>,
backslash_run_ends_in_quote			    fn backslash_run_ends_in_quote(s: &Vec<char>, mut i: uint) -> bool 
bind			    pub fn bind(addr: rtio::SocketAddr) -> IoResult<TcpListener> 
bind			    pub fn bind(addr: rtio::SocketAddr) -> IoResult<UdpSocket> 
bind			    pub fn bind(addr: &CString) -> IoResult<UnixListener> 
bind			fn bind(addr: &CString, ty: libc::c_int) -> IoResult<Inner> 
bind			    pub fn bind(addr: &CString) -> IoResult<UnixListener> 
boot			    pub fn boot<T: Send>(&'static self,
can_block			    fn can_block(&self) -> bool { true }
cancel_io			    fn cancel_io(&self) -> IoResult<()> 
chmod			pub fn chmod(p: &CString, mode: uint) -> IoResult<()> 
chmod			pub fn chmod(p: &CString, mode: uint) -> IoResult<()> 
chown			pub fn chown(p: &CString, uid: int, gid: int) -> IoResult<()> 
chown			pub fn chown(_p: &CString, _uid: int, _gid: int) -> IoResult<()> 
clone			    fn clone(&self) -> Box<rtio::RtioPipe + Send> 
clone			    fn clone(&self) -> Box<rtio::RtioPipe + Send> 
clone			    fn clone(&self) -> Box<rtio::RtioTcpStream + Send> 
clone			    fn clone(&self) -> Box<rtio::RtioUdpSocket + Send> 
clone			    fn clone(&self) -> Box<rtio::RtioPipe + Send> 
clone			    fn clone(&self) -> Box<rtio::RtioPipe + Send> 
close			    pub fn close(fd: libc::c_int) 
close			    pub fn close(handle: HANDLE) 
close_read			    fn close_read(&mut self) -> IoResult<()> 
close_read			    fn close_read(&mut self) -> IoResult<()> 
close_read			    fn close_read(&mut self) -> IoResult<()> 
close_read			    fn close_read(&mut self) -> IoResult<()> 
close_read			    fn close_read(&mut self) -> IoResult<()> 
close_write			    fn close_write(&mut self) -> IoResult<()> 
close_write			    fn close_write(&mut self) -> IoResult<()> 
close_write			    fn close_write(&mut self) -> IoResult<()> 
close_write			    fn close_write(&mut self) -> IoResult<()> 
close_write			    fn close_write(&mut self) -> IoResult<()> 
compat			pub mod compat 
connect			    pub fn connect(addr: rtio::SocketAddr,
connect			    pub fn connect(addr: &CString,
connect			fn connect(addr: &CString, ty: libc::c_int,
connect			    pub fn connect(addr: &CString, timeout: Option<u64>) -> IoResult<UnixStream> 
connect_timeout			pub fn connect_timeout(fd: net::sock_t,
control_congestion			    fn control_congestion(&mut self) -> IoResult<()> 
datasync			    fn datasync(&mut self) -> IoResult<()> 
datasync			    fn datasync(&mut self) -> IoResult<()> { return self.fsync(); }
deschedule			    fn deschedule(mut ~self, times: uint, mut cur_task: Box<Task>,
dont_accept_simultaneously			    fn dont_accept_simultaneously(&mut self) -> IoResult<()> { Ok(()) }
dont_loop_multicast_locally			    fn dont_loop_multicast_locally(&mut self) -> IoResult<()> 
drain			    fn drain(fd: libc::c_int) -> bool 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) { unsafe { close(self.fd); } }
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) { unsafe { let _ = libc::close(self.fd); } }
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			        fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
eof			pub fn eof() -> IoError 
epipe			fn epipe() -> IoError 
fail			            fn fail(output: &mut file::FileDesc) -> ! 
fallback			                extern "system" fn fallback(
fd			    pub fn fd(&self) -> fd_t { self.inner.fd }
fd			    pub fn fd(&self) -> fd_t { self.inner.fd }
fd			    pub fn fd(&self) -> sock_t { self.inner.fd }
fd			    pub fn fd(&self) -> sock_t { self.listener.fd() }
fd			    fn fd(&self) -> fd_t { self.inner.fd }
fd			    fn fd(&self) -> fd_t { self.listener.fd() }
fd_set			    pub fn fd_set(set: &mut fd_set, fd: i32) 
fd_set			    pub struct fd_set 
fd_set			pub fn fd_set(set: &mut fd_set, s: libc::SOCKET) 
fd_set			pub struct fd_set 
file			pub mod file;
flags			    fn flags(_stat: &libc::stat) -> u64 { 0 }
flags			    fn flags(stat: &libc::stat) -> u64 { stat.st_flags as u64 }
flush			    pub fn flush(&mut self) -> IoResult<()> 
free_handle			fn free_handle(_handle: *mut ()) 
free_handle			fn free_handle(handle: *mut ()) 
freeaddrinfo			    fn freeaddrinfo(res: *mut libc::addrinfo);
fs_chmod			    fn fs_chmod(&mut self, path: &CString, mode: uint) -> IoResult<()> 
fs_chown			    fn fs_chown(&mut self, path: &CString, uid: int, gid: int) -> IoResult<()> 
fs_from_raw_fd			    fn fs_from_raw_fd(&mut self, fd: c_int, close: rtio::CloseBehavior)
fs_link			    fn fs_link(&mut self, src: &CString, dst: &CString) -> IoResult<()> 
fs_lstat			    fn fs_lstat(&mut self, path: &CString) -> IoResult<rtio::FileStat> 
fs_mkdir			    fn fs_mkdir(&mut self, path: &CString, mode: uint) -> IoResult<()> 
fs_open			    fn fs_open(&mut self, path: &CString, fm: rtio::FileMode,
fs_readdir			    fn fs_readdir(&mut self, path: &CString, _flags: c_int) -> IoResult<Vec<CString>> 
fs_readlink			    fn fs_readlink(&mut self, path: &CString) -> IoResult<CString> 
fs_rename			    fn fs_rename(&mut self, path: &CString, to: &CString) -> IoResult<()> 
fs_rmdir			    fn fs_rmdir(&mut self, path: &CString) -> IoResult<()> 
fs_stat			    fn fs_stat(&mut self, path: &CString) -> IoResult<rtio::FileStat> 
fs_symlink			    fn fs_symlink(&mut self, src: &CString, dst: &CString) -> IoResult<()> 
fs_unlink			    fn fs_unlink(&mut self, path: &CString) -> IoResult<()> 
fs_utime			    fn fs_utime(&mut self, src: &CString, atime: u64,
fstat			    fn fstat(&mut self) -> IoResult<rtio::FileStat> 
fstat			    fn fstat(&mut self) -> IoResult<rtio::FileStat> 
fsync			    fn fsync(&mut self) -> IoResult<()> 
fsync			    fn fsync(&mut self) -> IoResult<()> 
gai_strerror			    fn gai_strerror(errcode: c_int) -> *const c_char;
gen			    fn gen(_stat: &libc::stat) -> u64 { 0 }
gen			    fn gen(stat: &libc::stat) -> u64 { stat.st_gen as u64 }
get_error			fn get_error(_: c_int) -> IoError 
get_error			fn get_error(s: c_int) -> IoError 
get_host_addresses			    fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,
get_io			        fn get_io(io: rtio::StdioContainer,
get_winsize			    fn get_winsize(&mut self) -> IoResult<(int, int)> 
get_winsize			    fn get_winsize(&mut self) -> IoResult<(int, int)> 
get_winsize			    fn get_winsize(&mut self) -> IoResult<(int, int)> 
getaddrinfo			    fn getaddrinfo(node: *const c_char, service: *const c_char,
getsockopt			    pub fn getsockopt(sockfd: libc::c_int,
getsockopt			    pub fn getsockopt(sockfd: libc::SOCKET,
getsockopt			pub fn getsockopt<T: Copy>(fd: sock_t, opt: libc::c_int,
gettimeofday			    pub fn gettimeofday(timeval: *mut libc::timeval,
handle			    pub fn handle(&self) -> libc::HANDLE 
handle			    fn handle(&self) -> libc::HANDLE { let Event(handle) = *self; handle }
handle			    fn handle(&self) -> libc::HANDLE { self.inner.handle }
hear_broadcasts			    fn hear_broadcasts(&mut self) -> IoResult<()> 
helper			fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) 
helper			fn helper(input: libc::HANDLE, messages: Receiver<Req>, _: ()) 
helper_thread			mod helper_thread;
htons			pub fn htons(u: u16) -> u16 
id			    fn id(&self) -> pid_t { self.pid }
ignore_broadcasts			    fn ignore_broadcasts(&mut self) -> IoResult<()> 
imp			mod imp 
imp			    mod imp 
imp			mod imp 
init			pub fn init() 
init			pub fn init() {}
inner			    fn inner(&mut self) -> Box<Inner> 
inner_read			    pub fn inner_read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
inner_read			    pub fn inner_read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
inner_write			    pub fn inner_write(&mut self, buf: &[u8]) -> IoResult<()> 
inner_write			    pub fn inner_write(&mut self, buf: &[u8]) -> IoResult<()> 
insert			    fn insert(t: Box<Inner>, active: &mut Vec<Box<Inner>>) 
invalid_encoding			fn invalid_encoding() -> IoError 
io			pub mod io;
ioctl			    pub fn ioctl(fd: libc::c_int, req: libc::c_ulong, ...) -> libc::c_int;
ioctlsocket			    pub fn ioctlsocket(s: libc::SOCKET, cmd: libc::c_long,
ip_to_inaddr			fn ip_to_inaddr(ip: rtio::IpAddr) -> InAddr 
is_tty			pub fn is_tty(fd: c_int) -> bool 
isatty			    fn isatty(&self) -> bool { false }
isatty			    fn isatty(&self) -> bool { false }
isatty			    fn isatty(&self) -> bool { true }
join_multicast			    fn join_multicast(&mut self, multi: rtio::IpAddr) -> IoResult<()> 
keep_going			fn keep_going(data: &[u8], f: |*const u8, uint| -> i64) -> i64 
keepalive			    fn keepalive(&mut self, delay_in_seconds: uint) -> IoResult<()> 
kernel32			    pub mod kernel32 
kill			    fn kill(&mut self, pid: libc::pid_t, signum: int) -> IoResult<()> 
kill			    fn kill(&mut self, signum: int) -> IoResult<()> 
kill			    pub fn kill(pid: libc::pid_t, signum: int) -> IoResult<()> 
killpid			unsafe fn killpid(pid: pid_t, signal: int) -> IoResult<()> 
lang_start			pub fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int 
last_error			fn last_error() -> IoError 
last_error			fn last_error() -> IoError 
last_error			pub fn last_error() -> IoError 
leave_multicast			    fn leave_multicast(&mut self, multi: rtio::IpAddr) -> IoResult<()> 
letdie			    fn letdie(&mut self) -> IoResult<()> 
link			pub fn link(src: &CString, dst: &CString) -> IoResult<()> 
link			pub fn link(src: &CString, dst: &CString) -> IoResult<()> 
listen			    fn listen(~self) -> IoResult<Box<rtio::RtioTcpAcceptor + Send>> 
listen			    fn listen(~self) -> IoResult<Box<rtio::RtioUnixAcceptor + Send>> 
listen			    fn listen(~self) -> IoResult<Box<rtio::RtioUnixAcceptor + Send>> 
local_io			    fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>> 
lock_nonblocking			    fn lock_nonblocking(&self) {}
lock_nonblocking			    fn lock_nonblocking<'a>(&'a self) -> Guard<'a> 
lock_nonblocking			    fn lock_nonblocking(&self) {}
lock_nonblocking			    fn lock_nonblocking<'a>(&'a self) -> net::Guard<'a> 
loop_multicast_locally			    fn loop_multicast_locally(&mut self) -> IoResult<()> 
lstat			pub fn lstat(p: &CString) -> IoResult<rtio::FileStat> 
lstat			pub fn lstat(_p: &CString) -> IoResult<rtio::FileStat> 
make_command_line			fn make_command_line(prog: &CString, args: &[CString]) -> String 
maybe_yield			    fn maybe_yield(~self, mut cur_task: Box<Task>) 
mkdir			pub fn mkdir(p: &CString, mode: uint) -> IoResult<()> 
mkdir			pub fn mkdir(p: &CString, _mode: uint) -> IoResult<()> 
mkerr_libc			fn mkerr_libc(ret: libc::c_int) -> IoResult<()> 
mkerr_winbool			fn mkerr_winbool(ret: libc::c_int) -> IoResult<()> 
mkstat			fn mkstat(stat: &libc::stat) -> rtio::FileStat 
mkstat			fn mkstat(stat: &libc::stat) -> rtio::FileStat 
mktime			    fn mktime(secs: u64, nsecs: u64) -> u64 { secs * 1000 + nsecs \/ 1000000 }
ms_to_timeval			pub fn ms_to_timeval(ms: u64) -> libc::timeval 
multicast_time_to_live			    fn multicast_time_to_live(&mut self, ttl: int) -> IoResult<()> 
native			    fn native(self) -> TaskBuilder<NativeSpawner> 
native			    fn native(self) -> TaskBuilder<NativeSpawner>;
native_accept			    pub fn native_accept(&mut self) -> IoResult<TcpStream> 
native_accept			    pub fn native_accept(&mut self) -> IoResult<UnixStream> 
native_accept			    pub fn native_accept(&mut self) -> IoResult<UnixStream> 
native_listen			    pub fn native_listen(self, backlog: int) -> IoResult<TcpAcceptor> 
native_listen			    pub fn native_listen(self, backlog: int) -> IoResult<UnixAcceptor> 
native_listen			    pub fn native_listen(self) -> IoResult<UnixAcceptor> 
net			pub mod net;
new			    pub fn new(fd: fd_t, close_on_drop: bool) -> FileDesc 
new			    pub fn new(file: *mut libc::FILE) -> CFile 
new			    pub fn new(fd: fd_t, close_on_drop: bool) -> FileDesc 
new			    pub fn new() -> (HANDLE, HANDLE) 
new			    pub fn new() -> (signal, signal) 
new			    pub fn new() -> IoFactory 
new			    fn new(fd: sock_t) -> Inner 
new			    fn new(inner: Inner) -> TcpStream 
new			    fn new(fd: fd_t) -> Inner 
new			    fn new(inner: Arc<Inner>) -> UnixStream 
new			    fn new(handle: libc::HANDLE) -> Inner 
new			    fn new(manual_reset: bool, initial_state: bool) -> IoResult<Event> 
new			    pub fn new() -> IoResult<Timer> 
new			    pub fn new() -> IoResult<Timer> 
new			    pub fn new(fd: c_int) -> WindowsTTY 
new			pub fn new(stack_bounds: (uint, uint)) -> Box<Task> 
nodelay			    fn nodelay(&mut self) -> IoResult<()> 
now			pub fn now() -> u64 
now			pub fn now() -> u64 
ntohs			pub fn ntohs(u: u16) -> u16 
oneshot			    fn oneshot(&mut self, msecs: u64, cb: Box<rtio::Callback + Send>) 
oneshot			    fn oneshot(&mut self, msecs: u64, cb: Box<Callback + Send>) 
open			pub fn open(path: &CString, fm: rtio::FileMode, fa: rtio::FileAccess)
open			pub fn open(path: &CString, fm: rtio::FileMode, fa: rtio::FileAccess)
ops			fn ops() -> Box<Ops> 
os_datasync			        fn os_datasync(fd: c_int) -> c_int 
peer_name			    fn peer_name(&mut self) -> IoResult<rtio::SocketAddr> 
period			    fn period(&mut self, msecs: u64, cb: Box<rtio::Callback + Send>) 
period			    fn period(&mut self, msecs: u64, cb: Box<Callback + Send>) 
pipe			pub mod pipe;
pipe			unsafe fn pipe(name: *const u16, init: bool) -> libc::HANDLE 
pipe			fn pipe() -> IoResult<(file::FileDesc, file::FileDesc)> 
pipe_open			    fn pipe_open(&mut self, fd: c_int) -> IoResult<Box<rtio::RtioPipe + Send>> 
pread			    fn pread(&mut self, buf: &mut [u8], offset: u64) -> IoResult<int> 
pread			    fn pread(&mut self, buf: &mut [u8], offset: u64) -> IoResult<int> 
process			pub mod process;
prune			    fn prune(root: &CString, dirs: Vec<Path>) -> Vec<CString> 
prune			    fn prune(root: &CString, dirs: Vec<Path>) -> Vec<CString> 
pwrite			    fn pwrite(&mut self, buf: &[u8], offset: u64) -> IoResult<()> 
pwrite			    fn pwrite(&mut self, buf: &[u8], mut offset: u64) -> IoResult<()> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<int> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<int> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			pub fn read<T>(fd: sock_t,
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read			    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> 
read_closed			    fn read_closed(&self) -> bool 
readdir			pub fn readdir(p: &CString) -> IoResult<Vec<CString>> 
readdir			pub fn readdir(p: &CString) -> IoResult<Vec<CString>> 
readlink			pub fn readlink(p: &CString) -> IoResult<CString> 
readlink			pub fn readlink(p: &CString) -> IoResult<CString> 
reawaken			    fn reawaken(mut ~self, mut to_wake: Box<Task>) 
recv_from			    fn recv_from(&mut self, buf: &mut [u8]) -> IoResult<(uint, rtio::SocketAddr)> 
register_sigchld			    fn register_sigchld() -> (libc::c_int, c::sigaction) 
remove			    fn remove(&mut self) 
rename			pub fn rename(old: &CString, new: &CString) -> IoResult<()> 
rename			pub fn rename(old: &CString, new: &CString) -> IoResult<()> 
retry			fn retry(f: || -> libc::c_int) -> libc::c_int 
rmdir			pub fn rmdir(p: &CString) -> IoResult<()> 
rmdir			pub fn rmdir(p: &CString) -> IoResult<()> 
rt			impl rt::Runtime for Ops 
rtio			impl rtio::RtioFileStream for CFile 
rtio			impl rtio::RtioFileStream for FileDesc 
rtio			impl rtio::RtioPipe for FileDesc 
rtio			impl rtio::RtioTTY for FileDesc 
rtio			impl rtio::RtioFileStream for FileDesc 
rtio			impl rtio::RtioPipe for FileDesc 
rtio			impl rtio::RtioTTY for FileDesc 
rtio			impl rtio::IoFactory for IoFactory 
rtio			impl rtio::RtioSocket for TcpAcceptor 
rtio			impl rtio::RtioSocket for TcpListener 
rtio			impl rtio::RtioSocket for TcpStream 
rtio			impl rtio::RtioSocket for UdpSocket 
rtio			impl rtio::RtioTcpAcceptor for TcpAcceptor 
rtio			impl rtio::RtioTcpListener for TcpListener 
rtio			impl rtio::RtioTcpStream for TcpStream 
rtio			impl rtio::RtioUdpSocket for UdpSocket 
rtio			impl rtio::RtioPipe for UnixStream 
rtio			impl rtio::RtioUnixAcceptor for UnixAcceptor 
rtio			impl rtio::RtioUnixListener for UnixListener 
rtio			impl rtio::RtioPipe for UnixStream 
rtio			impl rtio::RtioUnixAcceptor for UnixAcceptor 
rtio			impl rtio::RtioUnixListener for UnixListener 
rtio			impl rtio::RtioProcess for Process 
rtio			impl rtio::RtioTimer for Timer 
rtio			impl rtio::RtioTimer for Timer 
run			    pub fn run(host: Option<&str>, servname: Option<&str>,
run			pub fn run(main: proc()) -> int 
rust_dirent_t_size			        fn rust_dirent_t_size() -> libc::c_int;
rust_list_dir_val			        fn rust_list_dir_val(ptr: *mut dirent_t) -> *const libc::c_char;
rust_list_dir_wfd_fp_buf			        fn rust_list_dir_wfd_fp_buf(wfd: *mut libc::c_void) -> *const u16;
rust_list_dir_wfd_size			        fn rust_list_dir_wfd_size() -> libc::size_t;
rust_unset_sigprocmask			            pub fn rust_unset_sigprocmask();
rustrt			    mod rustrt 
seek			    fn seek(&mut self, pos: i64, style: rtio::SeekStyle) -> IoResult<u64> 
seek			    fn seek(&mut self, pos: i64, whence: rtio::SeekStyle) -> IoResult<u64> 
seek			    fn seek(&mut self, pos: i64, style: rtio::SeekStyle) -> IoResult<u64> 
seek_common			    fn seek_common(&self, pos: i64, style: rtio::SeekStyle) -> IoResult<u64> 
select			    pub fn select(nfds: libc::c_int,
select			mod select 
select			    pub fn select(nfds: libc::c_int,
send			    pub fn send(&'static self, msg: M) 
send_to			    fn send_to(&mut self, buf: &[u8], dst: rtio::SocketAddr) -> IoResult<()> 
set_broadcast			    pub fn set_broadcast(&mut self, on: bool) -> IoResult<()> 
set_cloexec			    unsafe fn set_cloexec(fd: c_int) 
set_environ			    unsafe fn set_environ(envp: *const c_void) 
set_keepalive			    fn set_keepalive(&mut self, seconds: Option<uint>) -> IoResult<()> 
set_membership			    pub fn set_membership(&mut self, addr: rtio::IpAddr,
set_multicast_loop			    pub fn set_multicast_loop(&mut self, on: bool) -> IoResult<()> 
set_nodelay			    fn set_nodelay(&mut self, nodelay: bool) -> IoResult<()> 
set_nonblocking			pub fn set_nonblocking(fd: net::sock_t, nb: bool) -> IoResult<()> 
set_raw			    fn set_raw(&mut self, _raw: bool) -> IoResult<()> 
set_raw			    fn set_raw(&mut self, _raw: bool) -> IoResult<()> 
set_raw			    fn set_raw(&mut self, raw: bool) -> IoResult<()> 
set_read_timeout			    fn set_read_timeout(&mut self, _t: Option<u64>) {}
set_read_timeout			    fn set_read_timeout(&mut self, _t: Option<u64>) {}
set_read_timeout			    fn set_read_timeout(&mut self, timeout: Option<u64>) 
set_read_timeout			    fn set_read_timeout(&mut self, timeout: Option<u64>) 
set_read_timeout			    fn set_read_timeout(&mut self, timeout: Option<u64>) 
set_tcp_keepalive			    fn set_tcp_keepalive(&mut self, _seconds: uint) -> IoResult<()> 
set_tcp_keepalive			    fn set_tcp_keepalive(&mut self, seconds: uint) -> IoResult<()> 
set_timeout			    fn set_timeout(&mut self, _t: Option<u64>) {}
set_timeout			    fn set_timeout(&mut self, _t: Option<u64>) {}
set_timeout			    fn set_timeout(&mut self, timeout: Option<u64>) 
set_timeout			    fn set_timeout(&mut self, timeout: Option<u64>) 
set_timeout			    fn set_timeout(&mut self, timeout: Option<u64>) 
set_timeout			    fn set_timeout(&mut self, timeout: Option<u64>) 
set_write_timeout			    fn set_write_timeout(&mut self, _t: Option<u64>) {}
set_write_timeout			    fn set_write_timeout(&mut self, _t: Option<u64>) {}
set_write_timeout			    fn set_write_timeout(&mut self, timeout: Option<u64>) 
set_write_timeout			    fn set_write_timeout(&mut self, timeout: Option<u64>) 
set_write_timeout			    fn set_write_timeout(&mut self, timeout: Option<u64>) 
setgroups			                        fn setgroups(ngroups: libc::c_int,
setsockopt			fn setsockopt<T>(fd: sock_t, opt: libc::c_int, val: libc::c_int,
short_write			pub fn short_write(n: uint, desc: &'static str) -> IoError 
shutdown			    fn shutdown(&'static self) 
sigaction			    pub fn sigaction(signum: libc::c_int,
sigaction			    pub struct sigaction 
sigaddset			    pub fn sigaddset(set: *mut sigset_t, signum: libc::c_int) -> libc::c_int;
sigchld_handler			    extern fn sigchld_handler(_signum: libc::c_int) 
sigdelset			    pub fn sigdelset(set: *mut sigset_t, signum: libc::c_int) -> libc::c_int;
sigemptyset			    pub fn sigemptyset(set: *mut sigset_t) -> libc::c_int;
siginfo			    pub struct siginfo 
signal			mod signal 
signal			    pub fn signal(fd: libc::c_int) 
signal			    pub fn signal(handle: HANDLE) 
signal			    fn signal(&mut self, _signal: int, _cb: Box<rtio::Callback>)
signal			    fn signal(active: &mut Vec<Box<Inner>>,
sigset_t			    pub struct sigset_t 
sleep			    fn sleep(&mut self, msecs: u64) 
sleep			    pub fn sleep(ms: u64) 
sleep			    fn sleep(&mut self, msecs: u64) 
sleep			    pub fn sleep(ms: u64) 
smoke			    fn smoke() 
smoke_fail			    fn smoke_fail() 
smoke_opts			    fn smoke_opts() 
smoke_opts_fail			    fn smoke_opts_fail() 
sockaddr_to_addr			pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,
socket			fn socket(addr: rtio::SocketAddr, ty: libc::c_int) -> IoResult<sock_t> 
socket_name			    fn socket_name(&mut self) -> IoResult<rtio::SocketAddr> 
sockname			fn sockname(fd: sock_t,
spawn			    fn spawn(&mut self, cfg: rtio::ProcessConfig)
spawn			    pub fn spawn(cfg: ProcessConfig)
spawn			    fn spawn(self, opts: TaskOpts, f: proc():Send) 
spawn			pub fn spawn(f: proc():Send) 
spawn_children			    fn spawn_children() 
spawn_inherits			    fn spawn_inherits() 
spawn_opts			pub fn spawn_opts(opts: TaskOpts, f: proc():Send) 
spawn_process_os			fn spawn_process_os(cfg: ProcessConfig,
spawn_sibling			    fn spawn_sibling(~self,
stack_bounds			    fn stack_bounds(&self) -> (uint, uint) { self.stack_bounds }
start			pub fn start(argc: int, argv: *const *const u8, main: proc()) -> int 
stat			pub fn stat(p: &CString) -> IoResult<rtio::FileStat> 
stat			pub fn stat(p: &CString) -> IoResult<rtio::FileStat> 
store_func			    unsafe fn store_func(ptr: *mut uint, module: &str, symbol: &str, fallback: uint) 
symlink			pub fn symlink(src: &CString, dst: &CString) -> IoResult<()> 
symlink			pub fn symlink(src: &CString, dst: &CString) -> IoResult<()> 
task			pub mod task;
tcp_bind			    fn tcp_bind(&mut self, addr: rtio::SocketAddr)
tcp_connect			    fn tcp_connect(&mut self, addr: rtio::SocketAddr,
tell			    fn tell(&self) -> IoResult<u64> 
tell			    fn tell(&self) -> IoResult<u64> 
tests			mod tests 
tests			mod tests 
tests			mod tests 
thunk			                extern "system" fn thunk(
time_to_live			    fn time_to_live(&mut self, ttl: int) -> IoResult<()> 
timeout			pub fn timeout(desc: &'static str) -> IoError 
timer			pub mod timer;
timer_init			    fn timer_init(&mut self) -> IoResult<Box<rtio::RtioTimer + Send>> 
to_utf16			pub fn to_utf16(s: &CString) -> IoResult<Vec<u16>> 
translate_status			fn translate_status(status: c_int) -> rtio::ProcessExit 
truncate			    fn truncate(&mut self, offset: i64) -> IoResult<()> 
truncate			    fn truncate(&mut self, offset: i64) -> IoResult<()> 
try_connect			    fn try_connect(p: *const u16) -> Option<libc::HANDLE> 
tty			mod tty;
tty_open			    fn tty_open(&mut self, fd: c_int, _readable: bool)
udp_bind			    fn udp_bind(&mut self, addr: rtio::SocketAddr)
unimpl			fn unimpl() -> IoError 
unix_bind			    fn unix_bind(&mut self, path: &CString)
unix_connect			    fn unix_connect(&mut self, path: &CString,
unix_socket			fn unix_socket(ty: libc::c_int) -> IoResult<fd_t> 
unlink			pub fn unlink(p: &CString) -> IoResult<()> 
unlink			pub fn unlink(p: &CString) -> IoResult<()> 
util			mod util;
utime			pub fn utime(p: &CString, atime: u64, mtime: u64) -> IoResult<()> 
utime			pub fn utime(p: &CString, atime: u64, mtime: u64) -> IoResult<()> 
wait			    fn wait(&mut self) -> IoResult<rtio::ProcessExit> 
waitpid			    pub fn waitpid(pid: libc::pid_t, status: *mut libc::c_int,
waitpid			fn waitpid(pid: pid_t, deadline: u64) -> IoResult<rtio::ProcessExit> 
waitpid_helper			    fn waitpid_helper(input: libc::c_int,
waitpid_nowait			fn waitpid_nowait(pid: pid_t) -> Option<rtio::ProcessExit> 
waitpid_os			    fn waitpid_os(_pid: pid_t) -> Option<rtio::ProcessExit> { None }
waitpid_os			    fn waitpid_os(pid: pid_t) -> Option<rtio::ProcessExit> 
with_argv			fn with_argv<T>(prog: &CString, args: &[CString],
with_dirp			fn with_dirp<T>(d: Option<&CString>, cb: |*const u16| -> T) -> T 
with_envp			fn with_envp<T>(env: Option<&[(CString, CString)]>, cb: |*mut c_void| -> T) -> T 
with_envp			fn with_envp<T>(env: Option<&[(CString, CString)]>,
wouldblock			pub fn wouldblock() -> bool 
wrap			    fn wrap(~self) -> Box<Any> 
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			pub fn write<T>(fd: sock_t,
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write			    fn write(&mut self, buf: &[u8]) -> IoResult<()> 
write_closed			    fn write_closed(&self) -> bool 
yield_now			    fn yield_now(~self, mut cur_task: Box<Task>) 
yield_test			    fn yield_test() 
zeroed_process_information			fn zeroed_process_information() -> libc::types::os::arch::extra::PROCESS_INFORMATION 
zeroed_startupinfo			fn zeroed_startupinfo() -> libc::types::os::arch::extra::STARTUPINFO 
