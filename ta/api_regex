Ast			pub enum Ast 
BuildAst			enum BuildAst 
BuildAst			impl BuildAst 
Captures			impl<'t> Captures<'t> 
Captures			pub struct Captures<'t> 
CharReader			impl<'t> CharReader<'t> 
CharReader			pub struct CharReader<'t> 
Clone for ExNative			impl Clone for ExNative 
Compiler			impl<'r> Compiler<'r> 
Compiler			struct Compiler<'r> 
Error			pub struct Error 
ExDynamic			pub struct ExDynamic 
ExNative			pub struct ExNative 
FindCaptures			pub struct FindCaptures<'r, 't> 
FindMatches			pub struct FindMatches<'r, 't> 
Greed			impl Greed 
Greed			pub enum Greed 
Inst			pub enum Inst 
Iterator for FindCaptures			impl<'r, 't> Iterator for FindCaptures<'r, 't> 
Iterator for FindMatches			impl<'r, 't> Iterator for FindMatches<'r, 't> 
Iterator for NamesIter			impl<'a> Iterator for NamesIter<'a> 
Iterator for RegexSplits			impl<'r, 't> Iterator for RegexSplits<'r, 't> 
Iterator for RegexSplitsN			impl<'r, 't> Iterator for RegexSplitsN<'r, 't> 
Iterator for SubCaptures			impl<'t> Iterator for SubCaptures<'t> 
Iterator for SubCapturesPos			impl<'t> Iterator for SubCapturesPos<'t> 
MatchKind			pub enum MatchKind 
NamesIter			pub enum NamesIter<'a> 
Nfa			impl<'r, 't> Nfa<'r, 't> 
Nfa			struct Nfa<'r, 't> 
NoExpand			pub struct NoExpand<'t>(pub &'t str);
Parser			impl<'a> Parser<'a> 
Parser			struct Parser<'a> 
Program			impl Program 
Program			pub struct Program 
Regex			impl Regex 
Regex			pub enum Regex 
RegexSplits			pub struct RegexSplits<'r, 't> 
RegexSplitsN			pub struct RegexSplitsN<'r, 't> 
Repeater			pub enum Repeater 
Replacer			impl<'t> Replacer for &'t str 
Replacer			pub trait Replacer 
Replacer for F			impl<F> Replacer for F where F: FnMut(&Captures) -> String 
Replacer for NoExpand			impl<'t> Replacer for NoExpand<'t> 
StepState			pub enum StepState 
SubCaptures			pub struct SubCaptures<'t> 
SubCapturesPos			pub struct SubCapturesPos<'t> 
Thread			struct Thread 
Threads			impl Threads 
Threads			struct Threads 
add			    fn add(&mut self, pc: uint, groups: &[Option<uint>], empty: bool) 
add			    fn add(&self, nlist: &mut Threads, pc: uint, groups: &mut [Option<uint>]) 
advance			    pub fn advance(&mut self) -> uint 
alternate			    fn alternate(&mut self, mut from: uint) -> Result<(), Error> 
anchored_literal_long_match			fn anchored_literal_long_match(b: &mut Bencher) 
anchored_literal_long_non_match			fn anchored_literal_long_non_match(b: &mut Bencher) 
anchored_literal_short_match			fn anchored_literal_short_match(b: &mut Bencher) 
anchored_literal_short_non_match			fn anchored_literal_short_non_match(b: &mut Bencher) 
as_str			    pub fn as_str<'a>(&'a self) -> &'a str 
at			    pub fn at(&self, i: uint) -> Option<&'t str> 
bar			    fn bar(&self) -> bool 
bench_assert_match			fn bench_assert_match(b: &mut Bencher, re: Regex, text: &str) 
build_from			    fn build_from<F>(&mut self, from: uint, mut mk: F) -> Result<Ast, Error> where
capture			    fn capture(&self) -> Option<uint> 
capture_name			    fn capture_name(&self) -> Option<String> 
captures			    pub fn captures<'t>(&self, text: &'t str) -> Option<Captures<'t>> 
captures_iter			    pub fn captures_iter<'r, 't>(&'r self, text: &'t str)
char_eq			    fn char_eq(&self, casei: bool, textc: Option<char>, regc: char) -> bool 
char_from_u32			    fn char_from_u32(&self, n: u32) -> Result<char, Error> 
char_is			    fn char_is(&self, textc: Option<char>, regc: char) -> bool 
class_cmp			fn class_cmp(casei: bool, mut textc: char,
clone			    fn clone(&self) -> ExNative 
combine_ranges			fn combine_ranges(unordered: Vec<(char, char)>) -> Vec<(char, char)> 
compile			    fn compile(&mut self, ast: parse::Ast) 
compile			mod compile;
concat			    fn concat(&mut self, from: uint) -> Result<(), Error> 
concat_flatten			fn concat_flatten(x: Ast, y: Ast) -> Ast 
contains			    fn contains(&self, pc: uint) -> bool 
cur			    fn cur(&self) -> char 
dynamic_bench			mod dynamic_bench;
dynamic_tests			mod dynamic_tests;
easy0			fn easy0() -> Regex { regex!("ABCDEFGHIJKLMNOPQRSTUVWXYZ
easy1			fn easy1() -> Regex { regex!("A[AB]B[BC]C[CD]D[DE]E[EF]F[FG]G[GH]H[HI]I[IJ]J
empty			    fn empty(&mut self) 
empty_jump			    fn empty_jump(&mut self) -> InstIdx 
empty_regex_empty_match			fn empty_regex_empty_match() 
empty_regex_nonempty_match			fn empty_regex_nonempty_match() 
empty_split			    fn empty_split(&mut self) -> InstIdx 
err			    fn err<T>(&self, msg: &str) -> Result<T, Error> 
exec			fn exec(re: &Regex, which: MatchKind, input: &str) -> CaptureLocs 
exec_slice			fn exec_slice(re: &Regex, which: MatchKind,
expand			    pub fn expand(&self, text: &str) -> String 
expect			    fn expect(&mut self, expected: char) -> Result<(), Error> 
find			    pub fn find(&self, text: &str) -> Option<(uint, uint)> 
find_class			fn find_class(classes: NamedClasses, name: &str) -> Option<Vec<(char, char)>> 
find_iter			    pub fn find_iter<'r, 't>(&'r self, text: &'t str) -> FindMatches<'r, 't> 
find_prefix			pub fn find_prefix(needle: &[u8], haystack: &[u8]) -> Option<uint> 
first_range_starts_with_left_bracket			fn first_range_starts_with_left_bracket() 
flags			    fn flags(&self) -> Flags 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt::Show for Error			impl fmt::Show for Error 
fmt::String for Regex			impl fmt::String for Regex 
gen_text			fn gen_text(n: uint) -> String 
get_next_greedy			    fn get_next_greedy(&mut self) -> Result<Greed, Error> 
groups			    fn groups<'r>(&'r mut self, i: uint) -> &'r mut [Option<uint>] 
hard			fn hard() -> Regex { regex!("[ -~]*ABCDEFGHIJKLMNOPQRSTUVWXYZ
has_match			fn has_match(caps: &CaptureLocs) -> bool 
is_begin			    pub fn is_begin(&self) -> bool { self.prev.is_none() }
is_empty			    pub fn is_empty(&self) -> bool { self.len() == 0 }
is_end			    pub fn is_end(&self) -> bool { self.cur.is_none() }
is_greedy			    pub fn is_greedy(&self) -> bool 
is_match			    pub fn is_match(&self, text: &str) -> bool 
is_match			pub fn is_match(regex: &str, text: &str) -> Result<bool, parse::Error> 
is_punct			pub fn is_punct(c: char) -> bool 
is_valid_cap			fn is_valid_cap(c: char) -> bool 
is_word			pub fn is_word(c: Option<char>) -> bool 
is_word_boundary			    pub fn is_word_boundary(&self) -> bool 
iter			    pub fn iter(&'t self) -> SubCaptures<'t> 
iter_pos			    pub fn iter_pos(&'t self) -> SubCapturesPos<'t> 
len			    pub fn len(&self) -> uint { self.locs.len() \/ 2 }
literal			fn literal(b: &mut Bencher) 
match_class			fn match_class(b: &mut Bencher) 
match_class_in_range			fn match_class_in_range(b: &mut Bencher) 
matches			mod matches;
medium			fn medium() -> Regex { regex!("[XYZ]ABCDEFGHIJKLMNOPQRSTUVWXYZ
name			    pub fn name(&self, name: &str) -> Option<&'t str> 
names_iter			    pub fn names_iter<'a>(&'a self) -> NamesIter<'a> 
names_len			    fn names_len(&self) -> uint 
native			pub mod native 
new			    pub fn new(ast: parse::Ast) -> (Program, Vec<Option<String>>) 
new			    fn new(re: &Regex, search: &'t str, locs: CaptureLocs)
new			    pub fn new(re: &str) -> Result<Regex, parse::Error> 
new			    fn new(which: MatchKind, num_insts: uint, ncaps: uint) -> Threads 
new			    pub fn new(input: &'t str) -> CharReader<'t> 
next			    fn next(&mut self) -> Option<&'t str> 
next			    fn next(&mut self) -> Option<(uint, uint)> 
next			    fn next(&mut self) -> Option<Captures<'t>> 
next			    fn next(&mut self) -> Option<Option<(uint, uint)>> 
next			    fn next(&mut self) -> Option<Option<String>> 
next_char			    fn next_char(&mut self) -> bool 
no_exponential			fn no_exponential(b: &mut Bencher) 
not_literal			fn not_literal(b: &mut Bencher) 
noteof			    fn noteof(&mut self, expected: &str) -> Result<(), Error> 
num_captures			    pub fn num_captures(&self) -> uint 
one_pass_long_prefix			fn one_pass_long_prefix(b: &mut Bencher) 
one_pass_long_prefix_not			fn one_pass_long_prefix_not(b: &mut Bencher) 
one_pass_short_a			fn one_pass_short_a(b: &mut Bencher) 
one_pass_short_a_not			fn one_pass_short_a_not(b: &mut Bencher) 
one_pass_short_b			fn one_pass_short_b(b: &mut Bencher) 
one_pass_short_b_not			fn one_pass_short_b_not(b: &mut Bencher) 
paren			    fn paren(&self) -> bool 
parse			mod parse;
parse			    fn parse(&mut self) -> Result<Ast, Error> 
parse			pub fn parse(s: &str) -> Result<Ast, Error> 
parse_class			    fn parse_class(&mut self) -> Result<(), Error> 
parse_counted			    fn parse_counted(&mut self) -> Result<(), Error> 
parse_escape			    fn parse_escape(&mut self) -> Result<Ast, Error> 
parse_group_opts			    fn parse_group_opts(&mut self) -> Result<(), Error> 
parse_hex			    fn parse_hex(&mut self) -> Result<Ast, Error> 
parse_hex_digits			    fn parse_hex_digits(&self, s: &str) -> Result<Ast, Error> 
parse_hex_two			    fn parse_hex_two(&mut self) -> Result<Ast, Error> 
parse_named_capture			    fn parse_named_capture(&mut self) -> Result<(), Error> 
parse_octal			    fn parse_octal(&mut self) -> Result<Ast, Error> 
parse_uint			    fn parse_uint(&self, s: &str) -> Result<uint, Error> 
parse_unicode_name			    fn parse_unicode_name(&mut self) -> Result<Ast, Error> 
pc			    fn pc(&self, i: uint) -> uint 
peek			    fn peek(&self, offset: uint) -> Option<char> 
peek_is			    fn peek_is(&self, offset: uint, is: char) -> bool 
perl_unicode_class			fn perl_unicode_class(which: char) -> Vec<(char, char)> 
pop_ast			    fn pop_ast(&mut self) -> Result<Ast, Error> 
pos			    fn pos(&self, c: char) -> Option<uint> 
pos			    pub fn pos(&self, i: uint) -> Option<(uint, uint)> 
pos_last			    fn pos_last<P>(&self, allow_start: bool, pred: P) -> Result<uint, Error> where
push			    fn push(&mut self, x: Inst) 
push			    fn push(&mut self, ast: Ast) 
push_literal			    fn push_literal(&mut self, c: char) -> Result<(), Error> 
push_repeater			    fn push_repeater(&mut self, c: char) -> Result<(), Error> 
quote			pub fn quote(text: &str) -> String 
quoted_bracket_set			fn quoted_bracket_set() 
range_ends_with_escape			fn range_ends_with_escape() 
re			mod re;
reg_replace			    fn reg_replace<'a>(&'a mut self, _: &Captures) -> CowString<'a> 
reg_replace			    fn reg_replace<'a>(&'a mut self, caps: &Captures) -> CowString<'a> 
reg_replace			    fn reg_replace<'a>(&'a mut self, caps: &Captures) -> CowString<'a>;
replace			    pub fn replace<R: Replacer>(&self, text: &str, rep: R) -> String 
replace_all			    pub fn replace_all<R: Replacer>(&self, text: &str, rep: R) -> String 
replace_all			fn replace_all(b: &mut Bencher) 
replacen			    pub fn replacen<R: Replacer>
run			    fn run(&mut self) -> CaptureLocs 
run			pub fn run<'r, 't>(which: MatchKind, prog: &'r Program, input: &'t str,
set			    pub fn set(&mut self, ic: uint) -> uint 
set_jump			    fn set_jump(&mut self, i: InstIdx, pc: InstIdx) 
set_split			    fn set_split(&mut self, i: InstIdx, pc1: InstIdx, pc2: InstIdx) 
should_merge			    fn should_merge((a, b): (char, char), (x, y): (char, char)) -> bool 
slice			    fn slice(&self, start: uint, end: uint) -> String 
split			    pub fn split<'r, 't>(&'r self, text: &'t str) -> RegexSplits<'r, 't> 
split			fn split() 
splitn			    pub fn splitn<'r, 't>(&'r self, text: &'t str, limit: uint)
splitn			fn splitn() 
static_split			fn static_split() 
static_splitn			fn static_splitn() 
step			    fn step(&self, groups: &mut [Option<uint>], nlist: &mut Threads,
swap			    fn swap(self, swapped: bool) -> Greed 
test			mod test;
try_parse_ascii			    fn try_parse_ascii(&mut self) -> Option<Ast> 
unwrap			    fn unwrap(self) -> Result<Ast, Error> 
vm			mod vm;
